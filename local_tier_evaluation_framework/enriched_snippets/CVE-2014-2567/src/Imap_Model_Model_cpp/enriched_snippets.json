[
  {
    "function_name": "isImapSubmissionSupported()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "2066-2070",
    "snippet": "ol Model::isImapSubmissionSupported() const\n{\n    QStringList caps = capabilities();\n    return caps.contains(QLatin1String(\"UIDPLUS\")) && caps.contains(QLatin1String(\"X-DRAFT-I01-SENDMAIL\"));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ps.contains",
          "args": [
            "atin1String(\"X-DRAFT-I01-SENDMAIL\"));"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "-DRAFT-I01-SENDMAIL\"))"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ps.contains",
          "args": [
            "atin1String(\"UIDPLUS\"))"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "IDPLUS\"))"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pabilities()",
          "args": [],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "capabilities()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1753-1762",
          "snippet": "tringList Model::capabilities() const\n{\n    if (m_parsers.isEmpty())\n        return QStringList();\n\n    if (m_parsers.constBegin()->capabilitiesFresh)\n        return m_parsers.constBegin()->capabilities;\n\n    return QStringList();\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::capabilities() const\n  {\n      if (m_parsers.isEmpty())\n          return QStringList();\n  \n      if (m_parsers.constBegin()->capabilitiesFresh)\n          return m_parsers.constBegin()->capabilities;\n  \n      return QStringList();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  ol Model::isImapSubmissionSupported() const\n  {\n      QStringList caps = capabilities();\n      return caps.contains(QLatin1String(\"UIDPLUS\")) && caps.contains(QLatin1String(\"X-DRAFT-I01-SENDMAIL\"));\n  }\n}"
  },
  {
    "function_name": "isGenUrlAuthSupported()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "2061-2064",
    "snippet": "ol Model::isGenUrlAuthSupported() const\n{\n    return capabilities().contains(QLatin1String(\"URLAUTH\"));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pabilities",
          "args": [
            "atin1String(\"URLAUTH\"));"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "setCapabilitiesBlacklist(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "2051-2054",
          "snippet": "id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n{\n    m_capabilitiesBlacklist = blacklist;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n  {\n      m_capabilitiesBlacklist = blacklist;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "RLAUTH\"))"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pabilities()",
          "args": [],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "capabilities()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1753-1762",
          "snippet": "tringList Model::capabilities() const\n{\n    if (m_parsers.isEmpty())\n        return QStringList();\n\n    if (m_parsers.constBegin()->capabilitiesFresh)\n        return m_parsers.constBegin()->capabilities;\n\n    return QStringList();\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::capabilities() const\n  {\n      if (m_parsers.isEmpty())\n          return QStringList();\n  \n      if (m_parsers.constBegin()->capabilitiesFresh)\n          return m_parsers.constBegin()->capabilities;\n  \n      return QStringList();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  ol Model::isGenUrlAuthSupported() const\n  {\n      return capabilities().contains(QLatin1String(\"URLAUTH\"));\n  }\n}"
  },
  {
    "function_name": "isCatenateSupported()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "2056-2059",
    "snippet": "ol Model::isCatenateSupported() const\n{\n    return capabilities().contains(QLatin1String(\"CATENATE\"));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pabilities",
          "args": [
            "atin1String(\"CATENATE\"));"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "setCapabilitiesBlacklist(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "2051-2054",
          "snippet": "id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n{\n    m_capabilitiesBlacklist = blacklist;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n  {\n      m_capabilitiesBlacklist = blacklist;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "ATENATE\"))"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pabilities()",
          "args": [],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "capabilities()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1753-1762",
          "snippet": "tringList Model::capabilities() const\n{\n    if (m_parsers.isEmpty())\n        return QStringList();\n\n    if (m_parsers.constBegin()->capabilitiesFresh)\n        return m_parsers.constBegin()->capabilities;\n\n    return QStringList();\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::capabilities() const\n  {\n      if (m_parsers.isEmpty())\n          return QStringList();\n  \n      if (m_parsers.constBegin()->capabilitiesFresh)\n          return m_parsers.constBegin()->capabilities;\n  \n      return QStringList();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  ol Model::isCatenateSupported() const\n  {\n      return capabilities().contains(QLatin1String(\"CATENATE\"));\n  }\n}"
  },
  {
    "function_name": "setCapabilitiesBlacklist(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "2051-2054",
    "snippet": "id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n{\n    m_capabilitiesBlacklist = blacklist;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCapabilitiesBlacklist(const QStringList &blacklist)\n  {\n      m_capabilitiesBlacklist = blacklist;\n  }\n}"
  },
  {
    "function_name": "checkDependentTasksConsistency(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "2023-2048",
    "snippet": "id Model::checkDependentTasksConsistency(Parser *parser, ImapTask *task, ImapTask *expectedParentTask, int depth)\n{\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n    QByteArray prefix;\n    prefix.fill(' ', depth);\n    qDebug() << prefix.constData() << \"Checking\" << task << task->debugIdentification();\n#endif\n    Q_ASSERT(parser);\n    Q_ASSERT(!task->parser || task->parser == parser);\n    Q_ASSERT(task->parentTask == expectedParentTask);\n    if (task->parentTask) {\n        Q_ASSERT(task->parentTask->dependentTasks.contains(task));\n        if (task->parentTask->parentTask) {\n            Q_ASSERT(task->parentTask->parentTask->dependentTasks.contains(task->parentTask));\n        } else {\n            Q_ASSERT(task->parentTask->parser);\n            Q_ASSERT(accessParser(task->parentTask->parser).activeTasks.contains(task->parentTask));\n        }\n    } else {\n        Q_ASSERT(accessParser(parser).activeTasks.contains(task));\n    }\n\n    Q_FOREACH(ImapTask *childTask, task->dependentTasks) {\n        checkDependentTasksConsistency(parser, childTask, task, depth + 1);\n    }\n}\n#",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eckDependentTasksConsistency(p",
          "args": [
            "rser,",
            "ildTask,",
            "sk,",
            "pth + 1);"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *childTask,",
            "sk->dependentTasks)"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(a",
          "args": [
            "cessParser(parser).activeTasks.contains(task));"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser",
          "args": [
            "sk))"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(a",
          "args": [
            "cessParser(task->parentTask->parser).activeTasks.contains(task->parentTask));"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser",
          "args": [
            "sk->parentTask))"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(t",
          "args": [
            "sk->parentTask->parser)."
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(t",
          "args": [
            "sk->parentTask->parser);"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(t",
          "args": [
            "sk->parentTask->parentTask->dependentTasks.contains(task->parentTask));"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->parentTask->parentTask->dependentTasks.contains",
          "args": [
            "sk->parentTask))"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(t",
          "args": [
            "sk->parentTask->dependentTasks.contains(task));"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->parentTask->dependentTasks.contains",
          "args": [
            "sk))"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(t",
          "args": [
            "sk->parentTask == expectedParentTask);"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(!",
          "args": [
            "ask->parser || task->parser == parser);"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(p",
          "args": [
            "rser);"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->debugIdentification",
          "args": [],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "debugIdentification(",
          "container": "umberOfMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/NumberOfMessagesTask.cpp",
          "lines": "87-95",
          "snippet": "String NumberOfMessagesTask::debugIdentification() const\n{\n    if (! mailboxIndex.isValid())\n        return QLatin1String(\"[invalid mailboxIndex]\");\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    return QString::fromUtf8(\"attached to %1\").arg(mailbox->mailbox());\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"NumberOfMessagesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"NumberOfMessagesTask.h\"\n#\n\numberOfMessagesTask {\n  String NumberOfMessagesTask::debugIdentification() const\n  {\n      if (! mailboxIndex.isValid())\n          return QLatin1String(\"[invalid mailboxIndex]\");\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      return QString::fromUtf8(\"attached to %1\").arg(mailbox->mailbox());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "efix.constData",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efix.fill",
          "args": [
            "',",
            "pth);"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::checkDependentTasksConsistency(Parser *parser, ImapTask *task, ImapTask *expectedParentTask, int depth)\n  {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n      QByteArray prefix;\n      prefix.fill(' ', depth);\n      qDebug() << prefix.constData() << \"Checking\" << task << task->debugIdentification();\n  #endif\n      Q_ASSERT(parser);\n      Q_ASSERT(!task->parser || task->parser == parser);\n      Q_ASSERT(task->parentTask == expectedParentTask);\n      if (task->parentTask) {\n          Q_ASSERT(task->parentTask->dependentTasks.contains(task));\n          if (task->parentTask->parentTask) {\n              Q_ASSERT(task->parentTask->parentTask->dependentTasks.contains(task->parentTask));\n          } else {\n              Q_ASSERT(task->parentTask->parser);\n              Q_ASSERT(accessParser(task->parentTask->parser).activeTasks.contains(task->parentTask));\n          }\n      } else {\n          Q_ASSERT(accessParser(parser).activeTasks.contains(task));\n      }\n  \n      Q_FOREACH(ImapTask *childTask, task->dependentTasks) {\n          checkDependentTasksConsistency(parser, childTask, task, depth + 1);\n      }\n  }\n  #\n}"
  },
  {
    "function_name": "checkTaskTreeConsistency()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1994-2021",
    "snippet": "id Model::checkTaskTreeConsistency()\n{\n    for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n        qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n            qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n        }\n#endif\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n            qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n#endif\n            Q_ASSERT(activeTask->parser == parserIt.key());\n            Q_ASSERT(!activeTask->parentTask);\n            checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n        }\n\n        // Make sure that no task is present twice in here\n        QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n        for (int i = 0; i < taskQueue.size(); ++i) {\n            Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                taskQueue.push_back(yetAnotherTask);\n            }\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skQueue.push_back",
          "args": [
            "tAnotherTask);"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(!",
          "args": [
            "askQueue.contains(yetAnotherTask));"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skQueue.contains",
          "args": [
            "tAnotherTask))"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *yetAnotherTask,",
            "skQueue[i]->dependentTasks)"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skQueue.size",
          "args": [],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rserIt.value",
          "args": [],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eckDependentTasksConsistency(p",
          "args": [
            "rserIt.key(),",
            "tiveTask,",
            ";"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rserIt.key",
          "args": [],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(!",
          "args": [
            "ctiveTask->parentTask);"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(a",
          "args": [
            "tiveTask->parser == parserIt.key());"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rserIt.key",
          "args": [],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tiveTask->debugIdentification",
          "args": [],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *activeTask,",
            "rserIt.value().activeTasks)"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tiveTask->debugIdentification",
          "args": [],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *activeTask,",
            "rserIt.value().activeTasks)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rserIt.key",
          "args": [],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constEnd",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constBegin",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::checkTaskTreeConsistency()\n  {\n      for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n          qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n              qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n          }\n  #endif\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n              qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n  #endif\n              Q_ASSERT(activeTask->parser == parserIt.key());\n              Q_ASSERT(!activeTask->parentTask);\n              checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n          }\n  \n          // Make sure that no task is present twice in here\n          QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n          for (int i = 0; i < taskQueue.size(); ++i) {\n              Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                  Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                  taskQueue.push_back(yetAnotherTask);\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "invalidateAllMessageCounts()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1947-1966",
    "snippet": "id Model::invalidateAllMessageCounts()\n{\n    QList<TreeItemMailbox*> queue;\n    queue.append(m_mailboxes);\n    while (!queue.isEmpty()) {\n        TreeItemMailbox *head = queue.takeFirst();\n        // ignore first child, the TreeItemMsgList\n        for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n            queue.append(static_cast<TreeItemMailbox*>(*it));\n        }\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n\n        if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n            // Ask only for data which were previously available\n            // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n            list->m_numberFetchingStatus = TreeItem::NONE;\n            emitMessageCountChanged(head);\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "itMessageCountChanged(h",
          "args": [
            "ad);"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMsgList*>",
          "args": [
            "ad->m_children[0]);"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eue.append",
          "args": [
            "atic_cast<TreeItemMailbox*>(*it));"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMailbox*>",
          "args": [
            "t))"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad->m_children.constEnd",
          "args": [],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad->m_children.constBegin",
          "args": [],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eue.takeFirst",
          "args": [],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eue.isEmpty",
          "args": [],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eue.append",
          "args": [
            "mailboxes);"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::invalidateAllMessageCounts()\n  {\n      QList<TreeItemMailbox*> queue;\n      queue.append(m_mailboxes);\n      while (!queue.isEmpty()) {\n          TreeItemMailbox *head = queue.takeFirst();\n          // ignore first child, the TreeItemMsgList\n          for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n              queue.append(static_cast<TreeItemMailbox*>(*it));\n          }\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n  \n          if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n              // Ask only for data which were previously available\n              // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n              list->m_numberFetchingStatus = TreeItem::NONE;\n              emitMessageCountChanged(head);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "messageIndexByUid(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1933-1944",
    "snippet": "odelIndex Model::messageIndexByUid(const QString &mailboxName, const uint uid)\n{\n    TreeItemMailbox *mailbox = findMailboxByName(mailboxName);\n    Q_ASSERT(mailbox);\n    QList<TreeItemMessage*> messages = findMessagesByUids(mailbox, QList<uint>() << uid);\n    if (messages.isEmpty()) {\n        return QModelIndex();\n    } else {\n        Q_ASSERT(messages.size() == 1);\n        return messages.front()->toIndex(this);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssages.front",
          "args": [
            "is);"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssages.front",
          "args": [],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ssages.size() == 1);"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssages.size",
          "args": [],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelIndex()",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssages.isEmpty",
          "args": [],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndMessagesByUids(m",
          "args": [
            "ilbox,",
            "ist<uint>() << uid);"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist<uint>",
          "args": [],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "checkTaskTreeConsistency()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1994-2021",
          "snippet": "id Model::checkTaskTreeConsistency()\n{\n    for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n        qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n            qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n        }\n#endif\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n            qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n#endif\n            Q_ASSERT(activeTask->parser == parserIt.key());\n            Q_ASSERT(!activeTask->parentTask);\n            checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n        }\n\n        // Make sure that no task is present twice in here\n        QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n        for (int i = 0; i < taskQueue.size(); ++i) {\n            Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                taskQueue.push_back(yetAnotherTask);\n            }\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::checkTaskTreeConsistency()\n  {\n      for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n          qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n              qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n          }\n  #endif\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n              qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n  #endif\n              Q_ASSERT(activeTask->parser == parserIt.key());\n              Q_ASSERT(!activeTask->parentTask);\n              checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n          }\n  \n          // Make sure that no task is present twice in here\n          QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n          for (int i = 0; i < taskQueue.size(); ++i) {\n              Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                  Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                  taskQueue.push_back(yetAnotherTask);\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ilbox);"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndMailboxByName(m",
          "args": [
            "ilboxName);"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  odelIndex Model::messageIndexByUid(const QString &mailboxName, const uint uid)\n  {\n      TreeItemMailbox *mailbox = findMailboxByName(mailboxName);\n      Q_ASSERT(mailbox);\n      QList<TreeItemMessage*> messages = findMessagesByUids(mailbox, QList<uint>() << uid);\n      if (messages.isEmpty()) {\n          return QModelIndex();\n      } else {\n          Q_ASSERT(messages.size() == 1);\n          return messages.front()->toIndex(this);\n      }\n  }\n}"
  },
  {
    "function_name": "processSslErrors(O",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1916-1931",
    "snippet": "id Model::processSslErrors(OpenConnectionTask *task)\n{\n    // Qt doesn't define either operator< or a qHash specialization for QList<QSslError> (what a surprise),\n    // so we use a plain old QList. Given that there will be at most one different QList<QSslError> sequence for\n    // each connection attempt (and more realistically, for each server at all), this O(n) complexity shall not matter\n    // at all.\n    QList<QPair<QPair<QList<QSslCertificate>, QList<QSslError> >, bool> >::const_iterator it = m_sslErrorPolicy.constBegin();\n    while (it != m_sslErrorPolicy.constEnd()) {\n        if (it->first.first == task->sslCertificateChain() && it->first.second == task->sslErrors()) {\n            task->sslConnectionPolicyDecided(it->second);\n            return;\n        }\n        ++it;\n    }\n    EMIT_LATER(this, needsSslDecision, Q_ARG(QList<QSslCertificate>, task->sslCertificateChain()), Q_ARG(QList<QSslError>, task->sslErrors()));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IT_LATER(t",
          "args": [
            "is,",
            "edsSslDecision,",
            "ARG(QList<QSslCertificate>, task->sslCertificateChain()),",
            "ARG(QList<QSslError>, task->sslErrors()));"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG(Q",
          "args": [
            "ist<QSslError>,",
            "sk->sslErrors()))"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->sslErrors",
          "args": [],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "sslErrors(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "457-460",
          "snippet": "List<QSslError> OpenConnectionTask::sslErrors() const\n{\n    return m_sslErrors;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  List<QSslError> OpenConnectionTask::sslErrors() const\n  {\n      return m_sslErrors;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG(Q",
          "args": [
            "ist<QSslCertificate>,",
            "sk->sslCertificateChain()),"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->sslCertificateChain",
          "args": [],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "sslCertificateChain(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "452-455",
          "snippet": "List<QSslCertificate> OpenConnectionTask::sslCertificateChain() const\n{\n    return m_sslChain;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  List<QSslCertificate> OpenConnectionTask::sslCertificateChain() const\n  {\n      return m_sslChain;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk->sslConnectionPolicyDecided",
          "args": [
            "->second);"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "sslConnectionPolicyDecided(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "462-485",
          "snippet": "oid OpenConnectionTask::sslConnectionPolicyDecided(bool ok)\n{\n    switch (model->accessParser(parser).connState) {\n    case CONN_STATE_SSL_VERIFYING:\n        if (ok) {\n            model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS_PRECAPS);\n        } else {\n            logout(tr(\"The security state of the SSL connection got rejected\"));\n        }\n        break;\n    case CONN_STATE_STARTTLS_VERIFYING:\n        if (ok) {\n            model->changeConnectionState(parser, CONN_STATE_ESTABLISHED_PRECAPS);\n            model->accessParser(parser).capabilitiesFresh = false;\n            capabilityCmd = parser->capability();\n        } else {\n            logout(tr(\"The security state of the connection after a STARTTLS operation got rejected\"));\n        }\n        break;\n    default:\n        Q_ASSERT(false);\n    }\n    parser->unfreezeAfterEncryption();\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::sslConnectionPolicyDecided(bool ok)\n  {\n      switch (model->accessParser(parser).connState) {\n      case CONN_STATE_SSL_VERIFYING:\n          if (ok) {\n              model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS_PRECAPS);\n          } else {\n              logout(tr(\"The security state of the SSL connection got rejected\"));\n          }\n          break;\n      case CONN_STATE_STARTTLS_VERIFYING:\n          if (ok) {\n              model->changeConnectionState(parser, CONN_STATE_ESTABLISHED_PRECAPS);\n              model->accessParser(parser).capabilitiesFresh = false;\n              capabilityCmd = parser->capability();\n          } else {\n              logout(tr(\"The security state of the connection after a STARTTLS operation got rejected\"));\n          }\n          break;\n      default:\n          Q_ASSERT(false);\n      }\n      parser->unfreezeAfterEncryption();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sslErrorPolicy.constEnd",
          "args": [],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslErrorPolicy.constBegin",
          "args": [],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::processSslErrors(OpenConnectionTask *task)\n  {\n      // Qt doesn't define either operator< or a qHash specialization for QList<QSslError> (what a surprise),\n      // so we use a plain old QList. Given that there will be at most one different QList<QSslError> sequence for\n      // each connection attempt (and more realistically, for each server at all), this O(n) complexity shall not matter\n      // at all.\n      QList<QPair<QPair<QList<QSslCertificate>, QList<QSslError> >, bool> >::const_iterator it = m_sslErrorPolicy.constBegin();\n      while (it != m_sslErrorPolicy.constEnd()) {\n          if (it->first.first == task->sslCertificateChain() && it->first.second == task->sslErrors()) {\n              task->sslConnectionPolicyDecided(it->second);\n              return;\n          }\n          ++it;\n      }\n      EMIT_LATER(this, needsSslDecision, Q_ARG(QList<QSslCertificate>, task->sslCertificateChain()), Q_ARG(QList<QSslError>, task->sslErrors()));\n  }\n}"
  },
  {
    "function_name": "setSslPolicy(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1898-1914",
    "snippet": "id Model::setSslPolicy(const QList<QSslCertificate> &sslChain, const QList<QSslError> &sslErrors, bool proceed)\n{\n    if (proceed) {\n        // Only remember positive values; there is no point in blocking any further connections until settings reload\n        m_sslErrorPolicy.prepend(qMakePair(qMakePair(sslChain, sslErrors), proceed));\n    }\n    Q_FOREACH(const ParserState &p, m_parsers) {\n        Q_FOREACH(ImapTask *task, p.activeTasks) {\n            OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n            if (!openTask)\n                continue;\n            if (openTask->sslCertificateChain() == sslChain && openTask->sslErrors() == sslErrors) {\n                openTask->sslConnectionPolicyDecided(proceed);\n            }\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enTask->sslConnectionPolicyDecided",
          "args": [
            "oceed);"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enTask->sslErrors",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enTask->sslCertificateChain",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<OpenConnectionTask *>",
          "args": [
            "sk);"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *task,",
            "activeTasks)"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslErrorPolicy.prepend",
          "args": [
            "akePair(qMakePair(sslChain, sslErrors), proceed));"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "akePair(q",
          "args": [
            "akePair(sslChain, sslErrors),",
            "oceed))"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "akePair(s",
          "args": [
            "lChain,",
            "lErrors),"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setSslPolicy(const QList<QSslCertificate> &sslChain, const QList<QSslError> &sslErrors, bool proceed)\n  {\n      if (proceed) {\n          // Only remember positive values; there is no point in blocking any further connections until settings reload\n          m_sslErrorPolicy.prepend(qMakePair(qMakePair(sslChain, sslErrors), proceed));\n      }\n      Q_FOREACH(const ParserState &p, m_parsers) {\n          Q_FOREACH(ImapTask *task, p.activeTasks) {\n              OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n              if (!openTask)\n                  continue;\n              if (openTask->sslCertificateChain() == sslChain && openTask->sslErrors() == sslErrors) {\n                  openTask->sslConnectionPolicyDecided(proceed);\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "informTasksAboutNewPassword()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1885-1895",
    "snippet": "id Model::informTasksAboutNewPassword()\n{\n    Q_FOREACH(const ParserState &p, m_parsers) {\n        Q_FOREACH(ImapTask *task, p.activeTasks) {\n            OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n            if (!openTask)\n                continue;\n            openTask->authCredentialsNowAvailable();\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enTask->authCredentialsNowAvailable",
          "args": [],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<OpenConnectionTask *>",
          "args": [
            "sk);"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *task,",
            "activeTasks)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::informTasksAboutNewPassword()\n  {\n      Q_FOREACH(const ParserState &p, m_parsers) {\n          Q_FOREACH(ImapTask *task, p.activeTasks) {\n              OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n              if (!openTask)\n                  continue;\n              openTask->authCredentialsNowAvailable();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "unsetImapPassword()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1877-1882",
    "snippet": "id Model::unsetImapPassword()\n{\n    m_imapPassword.clear();\n    m_hasImapPassword = false;\n    informTasksAboutNewPassword();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "formTasksAboutNewPassword()",
          "args": [],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "informTasksAboutNewPassword()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1885-1895",
          "snippet": "id Model::informTasksAboutNewPassword()\n{\n    Q_FOREACH(const ParserState &p, m_parsers) {\n        Q_FOREACH(ImapTask *task, p.activeTasks) {\n            OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n            if (!openTask)\n                continue;\n            openTask->authCredentialsNowAvailable();\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::informTasksAboutNewPassword()\n  {\n      Q_FOREACH(const ParserState &p, m_parsers) {\n          Q_FOREACH(ImapTask *task, p.activeTasks) {\n              OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n              if (!openTask)\n                  continue;\n              openTask->authCredentialsNowAvailable();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "imapPassword.clear",
          "args": [],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::unsetImapPassword()\n  {\n      m_imapPassword.clear();\n      m_hasImapPassword = false;\n      informTasksAboutNewPassword();\n  }\n}"
  },
  {
    "function_name": "imapPassword()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1871-1874",
    "snippet": "tring Model::imapPassword() const\n{\n    return m_imapPassword;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tring Model::imapPassword() const\n  {\n      return m_imapPassword;\n  }\n}"
  },
  {
    "function_name": "setImapPassword(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1863-1868",
    "snippet": "id Model::setImapPassword(const QString &password)\n{\n    m_imapPassword = password;\n    m_hasImapPassword = true;\n    informTasksAboutNewPassword();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "formTasksAboutNewPassword()",
          "args": [],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "informTasksAboutNewPassword()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1885-1895",
          "snippet": "id Model::informTasksAboutNewPassword()\n{\n    Q_FOREACH(const ParserState &p, m_parsers) {\n        Q_FOREACH(ImapTask *task, p.activeTasks) {\n            OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n            if (!openTask)\n                continue;\n            openTask->authCredentialsNowAvailable();\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::informTasksAboutNewPassword()\n  {\n      Q_FOREACH(const ParserState &p, m_parsers) {\n          Q_FOREACH(ImapTask *task, p.activeTasks) {\n              OpenConnectionTask *openTask = dynamic_cast<OpenConnectionTask *>(task);\n              if (!openTask)\n                  continue;\n              openTask->authCredentialsNowAvailable();\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setImapPassword(const QString &password)\n  {\n      m_imapPassword = password;\n      m_hasImapPassword = true;\n      informTasksAboutNewPassword();\n  }\n}"
  },
  {
    "function_name": "imapUser()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1857-1860",
    "snippet": "tring Model::imapUser() const\n{\n    return m_imapUser;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tring Model::imapUser() const\n  {\n      return m_imapUser;\n  }\n}"
  },
  {
    "function_name": "setImapUser(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1851-1854",
    "snippet": "id Model::setImapUser(const QString &imapUser)\n{\n    m_imapUser = imapUser;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setImapUser(const QString &imapUser)\n  {\n      m_imapUser = imapUser;\n  }\n}"
  },
  {
    "function_name": "normalizeFlags(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1813-1848",
    "snippet": "tringList Model::normalizeFlags(const QStringList &source) const\n{\n    QStringList res;\n#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\n    res.reserve(source.size());\n#endif\n    for (QStringList::const_iterator flag = source.constBegin(); flag != source.constEnd(); ++flag) {\n\n        // At first, perform a case-insensitive lookup in the (rather short) list of known special flags\n        // Only call the toLower for flags which could possibly be in that mapping. Looking at the first letter is\n        // a good approximation.\n        if (!flag->isEmpty() && ((*flag)[0] == QLatin1Char('\\\\') || (*flag)[0] == QLatin1Char('$'))) {\n            QString lowerCase = flag->toLower();\n            QHash<QString,QString>::const_iterator known = m_specialFlagNames.constFind(lowerCase);\n            if (known != m_specialFlagNames.constEnd()) {\n                res.append(*known);\n                continue;\n            }\n        }\n\n        // If it isn't a special flag, just check whether it's been encountered already\n        QSet<QString>::const_iterator it = m_flagLiterals.constFind(*flag);\n        if (it == m_flagLiterals.constEnd()) {\n            // Not in cache, so add it and return an implicitly shared copy\n            m_flagLiterals.insert(*flag);\n            res.append(*flag);\n        } else {\n            // It's in the cache already, se let's QString share the data\n            res.append(*it);\n        }\n    }\n    // Always sort the flags when performing normalization to obtain reasonable results and be ready for possible future\n    // deduplication of the actual QLists\n    res.sort();\n    return res;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.sort",
          "args": [],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.append",
          "args": [
            "t);"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.append",
          "args": [
            "lag);"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flagLiterals.insert",
          "args": [
            "lag);"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flagLiterals.constEnd",
          "args": [],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flagLiterals.constFind",
          "args": [
            "lag);"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.append",
          "args": [
            "nown);"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "specialFlagNames.constEnd",
          "args": [],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "specialFlagNames.constFind",
          "args": [
            "werCase);"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag->toLower",
          "args": [],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "'))"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "\\')"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag->isEmpty",
          "args": [],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urce.constEnd",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urce.constBegin",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.reserve",
          "args": [
            "urce.size());"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urce.size",
          "args": [],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_VERSION_CHECK(4",
          "args": [],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::normalizeFlags(const QStringList &source) const\n  {\n      QStringList res;\n  #if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\n      res.reserve(source.size());\n  #endif\n      for (QStringList::const_iterator flag = source.constBegin(); flag != source.constEnd(); ++flag) {\n  \n          // At first, perform a case-insensitive lookup in the (rather short) list of known special flags\n          // Only call the toLower for flags which could possibly be in that mapping. Looking at the first letter is\n          // a good approximation.\n          if (!flag->isEmpty() && ((*flag)[0] == QLatin1Char('\\\\') || (*flag)[0] == QLatin1Char('$'))) {\n              QString lowerCase = flag->toLower();\n              QHash<QString,QString>::const_iterator known = m_specialFlagNames.constFind(lowerCase);\n              if (known != m_specialFlagNames.constEnd()) {\n                  res.append(*known);\n                  continue;\n              }\n          }\n  \n          // If it isn't a special flag, just check whether it's been encountered already\n          QSet<QString>::const_iterator it = m_flagLiterals.constFind(*flag);\n          if (it == m_flagLiterals.constEnd()) {\n              // Not in cache, so add it and return an implicitly shared copy\n              m_flagLiterals.insert(*flag);\n              res.append(*flag);\n          } else {\n              // It's in the cache already, se let's QString share the data\n              res.append(*it);\n          }\n      }\n      // Always sort the flags when performing normalization to obtain reasonable results and be ready for possible future\n      // deduplication of the actual QLists\n      res.sort();\n      return res;\n  }\n}"
  },
  {
    "function_name": "serverId()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1801-1804",
    "snippet": "ap<QByteArray,QByteArray> Model::serverId() const\n{\n    return m_idResult;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  ap<QByteArray,QByteArray> Model::serverId() const\n  {\n      return m_idResult;\n  }\n}"
  },
  {
    "function_name": "logTrace(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1774-1794",
    "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rserId,",
            "nd,",
            "urce,",
            "ssage);"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilboxPtr->maintainingTask->parser->parserId",
          "args": [],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ilboxPtr);"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMailbox *>",
          "args": [
            "atic_cast<TreeItem *>(mailboxIndex.internalPointer()));"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItem *>",
          "args": [
            "ilboxIndex.internalPointer()))"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilboxIndex.internalPointer",
          "args": [],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ilboxIndex.isValid());"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilboxIndex.isValid",
          "args": [],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndMailboxForItems(Q",
          "args": [
            "odelIndexList() << translatedIndex);"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelIndexList()",
          "args": [],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(t",
          "args": [
            "anslatedIndex.model() == this);"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anslatedIndex.model",
          "args": [],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alTreeItem(r",
          "args": [
            "levantIndex,",
            "ranslatedIndex);"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
  },
  {
    "function_name": "logTrace(u",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1764-1768",
    "snippet": "id Model::logTrace(uint parserId, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    Common::LogMessage m(QDateTime::currentDateTime(), kind, source,  message, 0);\n    emit logged(parserId, m);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ateTime::currentDateTime()",
          "args": [],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(uint parserId, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      Common::LogMessage m(QDateTime::currentDateTime(), kind, source,  message, 0);\n      emit logged(parserId, m);\n  }\n}"
  },
  {
    "function_name": "capabilities()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1753-1762",
    "snippet": "tringList Model::capabilities() const\n{\n    if (m_parsers.isEmpty())\n        return QStringList();\n\n    if (m_parsers.constBegin()->capabilitiesFresh)\n        return m_parsers.constBegin()->capabilities;\n\n    return QStringList();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tringList()",
          "args": [],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constBegin",
          "args": [],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constBegin",
          "args": [],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tringList()",
          "args": [],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.isEmpty",
          "args": [],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::capabilities() const\n  {\n      if (m_parsers.isEmpty())\n          return QStringList();\n  \n      if (m_parsers.constBegin()->capabilitiesFresh)\n          return m_parsers.constBegin()->capabilities;\n  \n      return QStringList();\n  }\n}"
  },
  {
    "function_name": "releaseMessageData(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1709-1751",
    "snippet": "id Model::releaseMessageData(const QModelIndex &message)\n{\n    if (! message.isValid())\n        return;\n\n    const Model *whichModel = 0;\n    QModelIndex realMessage;\n    realTreeItem(message, &whichModel, &realMessage);\n    Q_ASSERT(whichModel == this);\n\n    TreeItemMessage *msg = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(realMessage.internalPointer()));\n    if (! msg)\n        return;\n\n    msg->setFetchStatus(TreeItem::NONE);\n\n#ifndef XTUPLE_CONNECT\n    beginRemoveRows(realMessage, 0, msg->m_children.size() - 1);\n#endif\n    if (msg->data()->m_partHeader) {\n        msg->data()->m_partHeader->silentlyReleaseMemoryRecursive();\n        delete msg->data()->m_partHeader;\n        msg->data()->m_partHeader = 0;\n    }\n    if (msg->data()->m_partText) {\n        msg->data()->m_partText->silentlyReleaseMemoryRecursive();\n        delete msg->data()->m_partText;\n        msg->data()->m_partText = 0;\n    }\n    delete msg->m_data;\n    msg->m_data = 0;\n    Q_FOREACH(TreeItem *item, msg->m_children) {\n        TreeItemPart *part = dynamic_cast<TreeItemPart *>(item);\n        Q_ASSERT(part);\n        part->silentlyReleaseMemoryRecursive();\n        delete part;\n    }\n    msg->m_children.clear();\n#ifndef XTUPLE_CONNECT\n    endRemoveRows();\n    emit dataChanged(realMessage, realMessage);\n#endif\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dRemoveRows()",
          "args": [],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->m_children.clear",
          "args": [],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt->silentlyReleaseMemoryRecursive",
          "args": [],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "silentlyReleaseMemoryRecursive(",
          "container": "reeItemPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1545-1566",
          "snippet": "oid TreeItemPart::silentlyReleaseMemoryRecursive()\n{\n    Q_FOREACH(TreeItem *item, m_children) {\n        TreeItemPart *part = dynamic_cast<TreeItemPart *>(item);\n        Q_ASSERT(part);\n        part->silentlyReleaseMemoryRecursive();\n    }\n    if (m_partMime) {\n        m_partMime->silentlyReleaseMemoryRecursive();\n        delete m_partMime;\n        m_partMime = 0;\n    }\n    if (m_partRaw) {\n        m_partRaw->silentlyReleaseMemoryRecursive();\n        delete m_partRaw;\n        m_partRaw = 0;\n    }\n    m_data.clear();\n    setFetchStatus(NONE);\n    qDeleteAll(m_children);\n    m_children.clear();\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemPart {\n  oid TreeItemPart::silentlyReleaseMemoryRecursive()\n  {\n      Q_FOREACH(TreeItem *item, m_children) {\n          TreeItemPart *part = dynamic_cast<TreeItemPart *>(item);\n          Q_ASSERT(part);\n          part->silentlyReleaseMemoryRecursive();\n      }\n      if (m_partMime) {\n          m_partMime->silentlyReleaseMemoryRecursive();\n          delete m_partMime;\n          m_partMime = 0;\n      }\n      if (m_partRaw) {\n          m_partRaw->silentlyReleaseMemoryRecursive();\n          delete m_partRaw;\n          m_partRaw = 0;\n      }\n      m_data.clear();\n      setFetchStatus(NONE);\n      qDeleteAll(m_children);\n      m_children.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT(p",
          "args": [
            "rt);"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemPart *>",
          "args": [
            "em);"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(T",
          "args": [
            "eeItem *item,",
            "g->m_children)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->data",
          "args": [],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ginRemoveRows(r",
          "args": [
            "alMessage,",
            "g->m_children.size() - 1);"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->m_children.size",
          "args": [],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->setFetchStatus",
          "args": [
            "eeItem::NONE);"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMessage *>",
          "args": [
            "atic_cast<TreeItem *>(realMessage.internalPointer()));"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItem *>",
          "args": [
            "alMessage.internalPointer()))"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alMessage.internalPointer",
          "args": [],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(w",
          "args": [
            "ichModel == this);"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alTreeItem(m",
          "args": [
            "ssage,",
            "hichModel,",
            "ealMessage);"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssage.isValid",
          "args": [],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::releaseMessageData(const QModelIndex &message)\n  {\n      if (! message.isValid())\n          return;\n  \n      const Model *whichModel = 0;\n      QModelIndex realMessage;\n      realTreeItem(message, &whichModel, &realMessage);\n      Q_ASSERT(whichModel == this);\n  \n      TreeItemMessage *msg = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(realMessage.internalPointer()));\n      if (! msg)\n          return;\n  \n      msg->setFetchStatus(TreeItem::NONE);\n  \n  #ifndef XTUPLE_CONNECT\n      beginRemoveRows(realMessage, 0, msg->m_children.size() - 1);\n  #endif\n      if (msg->data()->m_partHeader) {\n          msg->data()->m_partHeader->silentlyReleaseMemoryRecursive();\n          delete msg->data()->m_partHeader;\n          msg->data()->m_partHeader = 0;\n      }\n      if (msg->data()->m_partText) {\n          msg->data()->m_partText->silentlyReleaseMemoryRecursive();\n          delete msg->data()->m_partText;\n          msg->data()->m_partText = 0;\n      }\n      delete msg->m_data;\n      msg->m_data = 0;\n      Q_FOREACH(TreeItem *item, msg->m_children) {\n          TreeItemPart *part = dynamic_cast<TreeItemPart *>(item);\n          Q_ASSERT(part);\n          part->silentlyReleaseMemoryRecursive();\n          delete part;\n      }\n      msg->m_children.clear();\n  #ifndef XTUPLE_CONNECT\n      endRemoveRows();\n      emit dataChanged(realMessage, realMessage);\n  #endif\n  }\n}"
  },
  {
    "function_name": "findMessageForItem(Q",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1685-1707",
    "snippet": "odelIndex Model::findMessageForItem(QModelIndex index)\n{\n    if (! index.isValid())\n        return QModelIndex();\n\n    if (! dynamic_cast<const Model *>(index.model()))\n        return QModelIndex();\n\n    TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n    Q_ASSERT(item);\n    while (item) {\n        Q_ASSERT(index.internalPointer() == item);\n        if (dynamic_cast<TreeItemMessage *>(item)) {\n            return index;\n        } else if (dynamic_cast<TreeItemPart *>(item)) {\n            index = index.parent();\n            item = item->parent();\n        } else {\n            return QModelIndex();\n        }\n    }\n    return QModelIndex();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odelIndex()",
          "args": [],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelIndex()",
          "args": [],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->parent",
          "args": [],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemPart *>",
          "args": [
            "em))"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMessage *>",
          "args": [
            "em))"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.internalPointer() == item);"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.internalPointer",
          "args": [],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "em);"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItem *>",
          "args": [
            "dex.internalPointer());"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.internalPointer",
          "args": [],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelIndex()",
          "args": [],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<const Model *>",
          "args": [
            "dex.model()))"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.model",
          "args": [],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelIndex()",
          "args": [],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.isValid",
          "args": [],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  odelIndex Model::findMessageForItem(QModelIndex index)\n  {\n      if (! index.isValid())\n          return QModelIndex();\n  \n      if (! dynamic_cast<const Model *>(index.model()))\n          return QModelIndex();\n  \n      TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n      Q_ASSERT(item);\n      while (item) {\n          Q_ASSERT(index.internalPointer() == item);\n          if (dynamic_cast<TreeItemMessage *>(item)) {\n              return index;\n          } else if (dynamic_cast<TreeItemPart *>(item)) {\n              index = index.parent();\n              item = item->parent();\n          } else {\n              return QModelIndex();\n          }\n      }\n      return QModelIndex();\n  }\n}"
  },
  {
    "function_name": "slotTaskDying(Q",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1660-1667",
    "snippet": "id Model::slotTaskDying(QObject *obj)\n{\n    ImapTask *task = static_cast<ImapTask *>(obj);\n    for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n        it->activeTasks.removeOne(task);\n    }\n    m_taskModel->slotTaskDestroyed(task);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskModel->slotTaskDestroyed",
          "args": [
            "sk);"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->activeTasks.removeOne",
          "args": [
            "sk);"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.end",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.begin",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<ImapTask *>",
          "args": [
            "j);"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::slotTaskDying(QObject *obj)\n  {\n      ImapTask *task = static_cast<ImapTask *>(obj);\n      for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n          it->activeTasks.removeOne(task);\n      }\n      m_taskModel->slotTaskDestroyed(task);\n  }\n}"
  },
  {
    "function_name": "slotTasksChanged()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1655-1658",
    "snippet": "id Model::slotTasksChanged()\n{\n    dumpModelContents(m_taskModel);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpModelContents(m",
          "args": [
            "taskModel);"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::slotTasksChanged()\n  {\n      dumpModelContents(m_taskModel);\n  }\n}"
  },
  {
    "function_name": "findMailboxForItems(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1615-1653",
    "snippet": "odelIndex Model::findMailboxForItems(const QModelIndexList &items)\n{\n    TreeItemMailbox *mailbox = 0;\n    Q_FOREACH(const QModelIndex& index, items) {\n        TreeItemMailbox *currentMailbox = 0;\n        Q_ASSERT(index.model() == this);\n\n        TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n        Q_ASSERT(item);\n\n        if ((currentMailbox = dynamic_cast<TreeItemMailbox *>(item))) {\n            // yes, that's an assignment, not a comparison\n\n            // This case is OK\n        } else {\n            // TreeItemMessage and TreeItemPart have to walk the tree, which is why they are lumped together in this branch\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(item);\n            if (!message) {\n                if (TreeItemPart *part = dynamic_cast<TreeItemPart *>(item)) {\n                    message = part->message();\n                } else {\n                    throw CantHappen(\"findMailboxForItems() called on strange items\");\n                }\n            }\n            Q_ASSERT(message);\n            TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(message->parent());\n            Q_ASSERT(list);\n            currentMailbox = dynamic_cast<TreeItemMailbox *>(list->parent());\n        }\n\n        Q_ASSERT(currentMailbox);\n        if (!mailbox) {\n            mailbox = currentMailbox;\n        } else if (mailbox != currentMailbox) {\n            throw CantHappen(\"Messages from several mailboxes\");\n        }\n    }\n    return mailbox->toIndex(this);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilbox->toIndex",
          "args": [
            "is);"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntHappen(\"",
          "args": [
            "essages from several mailboxes\");"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(c",
          "args": [
            "rrentMailbox);"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMailbox *>",
          "args": [
            "st->parent());"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->parent",
          "args": [],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT(l",
          "args": [
            "st);"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMsgList *>",
          "args": [
            "ssage->parent());"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ssage);"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntHappen(\"",
          "args": [
            "indMailboxForItems() called on strange items\");"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt->message",
          "args": [],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemPart *>",
          "args": [
            "em))"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMessage *>",
          "args": [
            "em);"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMailbox *>",
          "args": [
            "em))"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "em);"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItem *>",
          "args": [
            "dex.internalPointer());"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.internalPointer",
          "args": [],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.model() == this);"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.model",
          "args": [],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  odelIndex Model::findMailboxForItems(const QModelIndexList &items)\n  {\n      TreeItemMailbox *mailbox = 0;\n      Q_FOREACH(const QModelIndex& index, items) {\n          TreeItemMailbox *currentMailbox = 0;\n          Q_ASSERT(index.model() == this);\n  \n          TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n          Q_ASSERT(item);\n  \n          if ((currentMailbox = dynamic_cast<TreeItemMailbox *>(item))) {\n              // yes, that's an assignment, not a comparison\n  \n              // This case is OK\n          } else {\n              // TreeItemMessage and TreeItemPart have to walk the tree, which is why they are lumped together in this branch\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(item);\n              if (!message) {\n                  if (TreeItemPart *part = dynamic_cast<TreeItemPart *>(item)) {\n                      message = part->message();\n                  } else {\n                      throw CantHappen(\"findMailboxForItems() called on strange items\");\n                  }\n              }\n              Q_ASSERT(message);\n              TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(message->parent());\n              Q_ASSERT(list);\n              currentMailbox = dynamic_cast<TreeItemMailbox *>(list->parent());\n          }\n  \n          Q_ASSERT(currentMailbox);\n          if (!mailbox) {\n              mailbox = currentMailbox;\n          } else if (mailbox != currentMailbox) {\n              throw CantHappen(\"Messages from several mailboxes\");\n          }\n      }\n      return mailbox->toIndex(this);\n  }\n}"
  },
  {
    "function_name": "genericHandleFetch(T",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1596-1613",
    "snippet": "id Model::genericHandleFetch(TreeItemMailbox *mailbox, const Imap::Responses::Fetch *const resp)\n{\n    Q_ASSERT(mailbox);\n    QList<TreeItemPart *> changedParts;\n    TreeItemMessage *changedMessage = 0;\n    mailbox->handleFetchResponse(this, *resp, changedParts, changedMessage, false);\n    if (! changedParts.isEmpty()) {\n        Q_FOREACH(TreeItemPart* part, changedParts) {\n            QModelIndex index = part->toIndex(this);\n            emit dataChanged(index, index);\n        }\n    }\n    if (changedMessage) {\n        QModelIndex index = changedMessage->toIndex(this);\n        emit dataChanged(index, index);\n        emitMessageCountChanged(mailbox);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "itMessageCountChanged(m",
          "args": [
            "ilbox);"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "angedMessage->toIndex",
          "args": [
            "is);"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt->toIndex",
          "args": [
            "is);"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "toIndex(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1652-1657",
          "snippet": "ModelIndex TreeItemModifiedPart::toIndex(Model *const model) const\n{\n    Q_ASSERT(model);\n    // see TreeItem::toIndex() for the const_cast explanation\n    return model->createIndex(row(), static_cast<int>(kind()), const_cast<TreeItemModifiedPart *>(this));\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  ModelIndex TreeItemModifiedPart::toIndex(Model *const model) const\n  {\n      Q_ASSERT(model);\n      // see TreeItem::toIndex() for the const_cast explanation\n      return model->createIndex(row(), static_cast<int>(kind()), const_cast<TreeItemModifiedPart *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "angedParts.isEmpty",
          "args": [],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilbox->handleFetchResponse",
          "args": [
            "is,",
            "esp,",
            "angedParts,",
            "angedMessage,",
            "lse);"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "handleFetchResponse(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "336-551",
          "snippet": "oid TreeItemMailbox::handleFetchResponse(Model *const model,\n        const Responses::Fetch &response,\n        QList<TreeItemPart *> &changedParts,\n        TreeItemMessage *&changedMessage, bool usingQresync)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(m_children[0]);\n\n    Responses::Fetch::dataType::const_iterator uidRecord = response.data.find(\"UID\");\n\n    // Previously, we would ignore any FETCH responses until we are fully synced. This is rather hard do to \"properly\",\n    // though.\n    // What we want to achieve is to never store data into a \"wrong\" message. Theoretically, we are prone to just this\n    // in case the server sends us unsolicited data before we are fully synced. When this happens for flags, it's a pretty\n    // harmless operation as we're going to re-fetch the flags for the concerned part of mailbox anyway (even with CONDSTORE,\n    // and this is never an issue with QRESYNC).\n    // It's worse when the data refer to some immutable piece of information like the bodystructure or body parts.\n    // If that happens, then we have to actively prevent the data from being stored because we cannot know whether we would\n    // be putting it into a correct bucket^Hmessage.\n    bool ignoreImmutableData = !list->fetched() && uidRecord == response.data.constEnd();\n\n    int number = response.number - 1;\n    if (number < 0 || number >= list->m_children.size())\n        throw UnknownMessageIndex(QString::fromUtf8(\"Got FETCH that is out of bounds -- got %1 messages\").arg(\n                                      QString::number(list->m_children.size())).toUtf8().constData(), response);\n\n    TreeItemMessage *message = static_cast<TreeItemMessage *>(list->child(number, model));\n\n    // At first, have a look at the response and check the UID of the message\n    if (uidRecord != response.data.constEnd()) {\n        uint receivedUid = static_cast<const Responses::RespData<uint>&>(*(uidRecord.value())).data;\n        if (message->uid() == receivedUid) {\n            // That's what we expect -> do nothing\n        } else if (message->uid() == 0) {\n            // This is the first time we see the UID, so let's take a note\n            message->m_uid = receivedUid;\n            changedMessage = message;\n            if (message->loading()) {\n                // The Model tried to ask for data for this message. That couldn't succeeded because the UID\n                // wasn't known at that point, so let's ask now\n                //\n                // FIXME: tweak this to keep a high watermark of \"highest UID we requested an ENVELOPE for\",\n                // issue bulk fetches in the same manner as we do the UID FETCH (FLAGS) when discovering UIDs,\n                // and at this place in code, only ask for the metadata when the UID is higher than the watermark.\n                // Optionally, simply ask for the ENVELOPE etc along with the FLAGS upon new message arrivals, maybe\n                // with some limit on the number of pending fetches. And make that dapandent on online/expensive modes.\n                message->setFetchStatus(NONE);\n                message->fetch(model);\n            }\n            if (syncState.uidNext() <= receivedUid) {\n                // Try to guess the UIDNEXT. We have to take an educated guess here, and I believe that this approach\n                // at least is not wrong. The server won't tell us the UIDNEXT (well, it could, but it doesn't have to),\n                // the only way of asking for it is via STATUS which is not allowed to reference the current mailbox and\n                // even if it was, it wouldn't be atomic. So, what could the UIDNEXT possibly be? It can't be smaller\n                // than the UID_of_highest_message, and it can't be the same, either, so it really has to be higher.\n                // Let's just increment it by one, this is our lower bound.\n                // Not guessing the UIDNEXT correctly would result at decreased performance at the next sync, and we\n                // can't really do better -> let's just set it now, along with the UID mapping.\n                syncState.setUidNext(receivedUid + 1);\n                list->setFetchStatus(LOADING);\n            }\n        } else {\n            throw MailboxException(QString::fromUtf8(\"FETCH response: UID consistency error for message #%1 -- expected UID %2, got UID %3\").arg(\n                                       QString::number(response.number), QString::number(message->uid()), QString::number(receivedUid)\n                                       ).toUtf8().constData(), response);\n        }\n    } else if (! message->uid()) {\n        qDebug() << \"FETCH: received a FETCH response for message #\" << response.number << \"whose UID is not yet known. This sucks.\";\n        QList<uint> uidsInMailbox;\n        Q_FOREACH(TreeItem *node, list->m_children) {\n            uidsInMailbox << static_cast<TreeItemMessage *>(node)->uid();\n        }\n        qDebug() << \"UIDs in the mailbox now: \" << uidsInMailbox;\n    }\n\n    bool savedBodyStructure = false;\n    bool gotEnvelope = false;\n    bool gotSize = false;\n    bool gotInternalDate = false;\n    bool updatedFlags = false;\n\n    for (Responses::Fetch::dataType::const_iterator it = response.data.begin(); it != response.data.end(); ++ it) {\n        if (it.key() == \"UID\") {\n            // established above\n            Q_ASSERT(static_cast<const Responses::RespData<uint>&>(*(it.value())).data == message->uid());\n        } else if (it.key() == \"FLAGS\") {\n            // Only emit signals when the flags have actually changed\n            QStringList newFlags = model->normalizeFlags(static_cast<const Responses::RespData<QStringList>&>(*(it.value())).data);\n            bool forceChange = (message->m_flags != newFlags);\n            message->setFlags(list, newFlags, forceChange);\n            if (forceChange) {\n                updatedFlags = true;\n                changedMessage = message;\n            }\n        } else if (it.key() == \"MODSEQ\") {\n            quint64 num = static_cast<const Responses::RespData<quint64>&>(*(it.value())).data;\n            if (num > syncState.highestModSeq()) {\n                syncState.setHighestModSeq(num);\n                if (list->accessFetchStatus() == DONE) {\n                    // This means that everything is known already, so we are by definition OK to save stuff to disk.\n                    // We can also skip rebuilding the UID map and save just the HIGHESTMODSEQ, i.e. the SyncState.\n                    model->cache()->setMailboxSyncState(mailbox(), syncState);\n                } else {\n                    // it's already marked as dirty -> nothing to do here\n                }\n            }\n        } else if (ignoreImmutableData) {\n            QByteArray buf;\n            QTextStream ss(&buf);\n            ss << response;\n            ss.flush();\n            qDebug() << \"Ignoring FETCH response to a mailbox that isn't synced yet:\" << buf;\n            continue;\n        } else if (it.key() == \"ENVELOPE\") {\n            message->data()->m_envelope = static_cast<const Responses::RespData<Message::Envelope>&>(*(it.value())).data;\n            message->setFetchStatus(DONE);\n            gotEnvelope = true;\n            changedMessage = message;\n        } else if (it.key() == \"BODYSTRUCTURE\") {\n            if (message->fetched()) {\n                // The message structure is already known, so we are free to ignore it\n            } else {\n                // We had no idea about the structure of the message\n                auto newChildren = static_cast<const Message::AbstractMessage &>(*(it.value())).createTreeItems(message);\n                if (!message->m_children.isEmpty()) {\n                    QModelIndex messageIdx = message->toIndex(model);\n                    model->beginRemoveRows(messageIdx, 0, message->m_children.size() - 1);\n                    auto oldChildren = message->setChildren(newChildren);\n                    model->endRemoveRows();\n                    qDeleteAll(oldChildren);\n                } else {\n                    auto oldChildren = message->setChildren(newChildren);\n                    Q_ASSERT(oldChildren.size() == 0);\n                }\n                savedBodyStructure = true;\n            }\n        } else if (it.key() == \"x-trojita-bodystructure\") {\n            // do nothing\n        } else if (it.key() == \"RFC822.SIZE\") {\n            message->data()->m_size = static_cast<const Responses::RespData<uint>&>(*(it.value())).data;\n            gotSize = true;\n        } else if (it.key().startsWith(\"BODY[HEADER.FIELDS (\")) {\n            // Process any headers found in any such response bit\n            const QByteArray &rawHeaders = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n            message->processAdditionalHeaders(model, rawHeaders);\n            changedMessage = message;\n        } else if (it.key().startsWith(\"BODY[\") || it.key().startsWith(\"BINARY[\")) {\n            if (it.key()[ it.key().size() - 1 ] != ']')\n                throw UnknownMessageIndex(\"Can't parse such BODY[]/BINARY[]\", response);\n            TreeItemPart *part = partIdToPtr(model, message, it.key());\n            if (! part)\n                throw UnknownMessageIndex(\"Got BODY[]/BINARY[] fetch that did not resolve to any known part\", response);\n            const QByteArray &data = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n            if (it.key().startsWith(\"BODY[\")) {\n\n                // Check whether we are supposed to be loading the raw, undecoded part as well.\n                // The check has to be done via a direct pointer access to m_partRaw to make sure that it does not\n                // get instantiated when not actually needed.\n                if (part->m_partRaw && part->m_partRaw->loading()) {\n                    part->m_partRaw->m_data = data;\n                    part->m_partRaw->setFetchStatus(DONE);\n                    changedParts.append(part->m_partRaw);\n                    if (message->uid()) {\n                        model->cache()->forgetMessagePart(mailbox(), message->uid(), part->partId());\n                        model->cache()->setMsgPart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\"), data);\n                    }\n                }\n\n                // Do not overwrite the part data if we were not asked to fetch it.\n                // One possibility is that it's already there because it was fetched before. The second option is that\n                // we were in fact asked to only fetch the raw data and the user is not itnerested in the processed data at all.\n                if (part->loading()) {\n                    // got to decode the part data by hand\n                    Imap::decodeContentTransferEncoding(data, part->encoding(), part->dataPtr());\n                    part->setFetchStatus(DONE);\n                    changedParts.append(part);\n                    if (message->uid()\n                            && model->cache()->messagePart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\")).isNull()) {\n                        // Do not store the data into cache if the raw data are already there\n                        model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                    }\n                }\n\n            } else {\n                // A BINARY FETCH item is already decoded for us, yay\n                part->m_data = data;\n                part->setFetchStatus(DONE);\n                changedParts.append(part);\n                if (message->uid()) {\n                    model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                }\n            }\n        } else if (it.key() == \"INTERNALDATE\") {\n            message->data()->m_internalDate = static_cast<const Responses::RespData<QDateTime>&>(*(it.value())).data;\n            gotInternalDate = true;\n        } else {\n            qDebug() << \"TreeItemMailbox::handleFetchResponse: unknown FETCH identifier\" << it.key();\n        }\n    }\n    if (message->uid()) {\n        if (gotEnvelope && gotSize && savedBodyStructure && gotInternalDate) {\n            Imap::Mailbox::AbstractCache::MessageDataBundle dataForCache;\n            dataForCache.envelope = message->data()->m_envelope;\n            dataForCache.serializedBodyStructure = static_cast<const Responses::RespData<QByteArray>&>(*(response.data[ \"x-trojita-bodystructure\" ])).data;\n            dataForCache.size = message->data()->m_size;\n            dataForCache.uid = message->uid();\n            dataForCache.internalDate = message->data()->m_internalDate;\n            dataForCache.hdrReferences = message->data()->m_hdrReferences;\n            dataForCache.hdrListPost = message->data()->m_hdrListPost;\n            dataForCache.hdrListPostNo = message->data()->m_hdrListPostNo;\n            model->cache()->setMessageMetadata(mailbox(), message->uid(), dataForCache);\n        }\n        if (updatedFlags) {\n            model->cache()->setMsgFlags(mailbox(), message->uid(), message->m_flags);\n        }\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleFetchResponse(Model *const model,\n          const Responses::Fetch &response,\n          QList<TreeItemPart *> &changedParts,\n          TreeItemMessage *&changedMessage, bool usingQresync)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(m_children[0]);\n  \n      Responses::Fetch::dataType::const_iterator uidRecord = response.data.find(\"UID\");\n  \n      // Previously, we would ignore any FETCH responses until we are fully synced. This is rather hard do to \"properly\",\n      // though.\n      // What we want to achieve is to never store data into a \"wrong\" message. Theoretically, we are prone to just this\n      // in case the server sends us unsolicited data before we are fully synced. When this happens for flags, it's a pretty\n      // harmless operation as we're going to re-fetch the flags for the concerned part of mailbox anyway (even with CONDSTORE,\n      // and this is never an issue with QRESYNC).\n      // It's worse when the data refer to some immutable piece of information like the bodystructure or body parts.\n      // If that happens, then we have to actively prevent the data from being stored because we cannot know whether we would\n      // be putting it into a correct bucket^Hmessage.\n      bool ignoreImmutableData = !list->fetched() && uidRecord == response.data.constEnd();\n  \n      int number = response.number - 1;\n      if (number < 0 || number >= list->m_children.size())\n          throw UnknownMessageIndex(QString::fromUtf8(\"Got FETCH that is out of bounds -- got %1 messages\").arg(\n                                        QString::number(list->m_children.size())).toUtf8().constData(), response);\n  \n      TreeItemMessage *message = static_cast<TreeItemMessage *>(list->child(number, model));\n  \n      // At first, have a look at the response and check the UID of the message\n      if (uidRecord != response.data.constEnd()) {\n          uint receivedUid = static_cast<const Responses::RespData<uint>&>(*(uidRecord.value())).data;\n          if (message->uid() == receivedUid) {\n              // That's what we expect -> do nothing\n          } else if (message->uid() == 0) {\n              // This is the first time we see the UID, so let's take a note\n              message->m_uid = receivedUid;\n              changedMessage = message;\n              if (message->loading()) {\n                  // The Model tried to ask for data for this message. That couldn't succeeded because the UID\n                  // wasn't known at that point, so let's ask now\n                  //\n                  // FIXME: tweak this to keep a high watermark of \"highest UID we requested an ENVELOPE for\",\n                  // issue bulk fetches in the same manner as we do the UID FETCH (FLAGS) when discovering UIDs,\n                  // and at this place in code, only ask for the metadata when the UID is higher than the watermark.\n                  // Optionally, simply ask for the ENVELOPE etc along with the FLAGS upon new message arrivals, maybe\n                  // with some limit on the number of pending fetches. And make that dapandent on online/expensive modes.\n                  message->setFetchStatus(NONE);\n                  message->fetch(model);\n              }\n              if (syncState.uidNext() <= receivedUid) {\n                  // Try to guess the UIDNEXT. We have to take an educated guess here, and I believe that this approach\n                  // at least is not wrong. The server won't tell us the UIDNEXT (well, it could, but it doesn't have to),\n                  // the only way of asking for it is via STATUS which is not allowed to reference the current mailbox and\n                  // even if it was, it wouldn't be atomic. So, what could the UIDNEXT possibly be? It can't be smaller\n                  // than the UID_of_highest_message, and it can't be the same, either, so it really has to be higher.\n                  // Let's just increment it by one, this is our lower bound.\n                  // Not guessing the UIDNEXT correctly would result at decreased performance at the next sync, and we\n                  // can't really do better -> let's just set it now, along with the UID mapping.\n                  syncState.setUidNext(receivedUid + 1);\n                  list->setFetchStatus(LOADING);\n              }\n          } else {\n              throw MailboxException(QString::fromUtf8(\"FETCH response: UID consistency error for message #%1 -- expected UID %2, got UID %3\").arg(\n                                         QString::number(response.number), QString::number(message->uid()), QString::number(receivedUid)\n                                         ).toUtf8().constData(), response);\n          }\n      } else if (! message->uid()) {\n          qDebug() << \"FETCH: received a FETCH response for message #\" << response.number << \"whose UID is not yet known. This sucks.\";\n          QList<uint> uidsInMailbox;\n          Q_FOREACH(TreeItem *node, list->m_children) {\n              uidsInMailbox << static_cast<TreeItemMessage *>(node)->uid();\n          }\n          qDebug() << \"UIDs in the mailbox now: \" << uidsInMailbox;\n      }\n  \n      bool savedBodyStructure = false;\n      bool gotEnvelope = false;\n      bool gotSize = false;\n      bool gotInternalDate = false;\n      bool updatedFlags = false;\n  \n      for (Responses::Fetch::dataType::const_iterator it = response.data.begin(); it != response.data.end(); ++ it) {\n          if (it.key() == \"UID\") {\n              // established above\n              Q_ASSERT(static_cast<const Responses::RespData<uint>&>(*(it.value())).data == message->uid());\n          } else if (it.key() == \"FLAGS\") {\n              // Only emit signals when the flags have actually changed\n              QStringList newFlags = model->normalizeFlags(static_cast<const Responses::RespData<QStringList>&>(*(it.value())).data);\n              bool forceChange = (message->m_flags != newFlags);\n              message->setFlags(list, newFlags, forceChange);\n              if (forceChange) {\n                  updatedFlags = true;\n                  changedMessage = message;\n              }\n          } else if (it.key() == \"MODSEQ\") {\n              quint64 num = static_cast<const Responses::RespData<quint64>&>(*(it.value())).data;\n              if (num > syncState.highestModSeq()) {\n                  syncState.setHighestModSeq(num);\n                  if (list->accessFetchStatus() == DONE) {\n                      // This means that everything is known already, so we are by definition OK to save stuff to disk.\n                      // We can also skip rebuilding the UID map and save just the HIGHESTMODSEQ, i.e. the SyncState.\n                      model->cache()->setMailboxSyncState(mailbox(), syncState);\n                  } else {\n                      // it's already marked as dirty -> nothing to do here\n                  }\n              }\n          } else if (ignoreImmutableData) {\n              QByteArray buf;\n              QTextStream ss(&buf);\n              ss << response;\n              ss.flush();\n              qDebug() << \"Ignoring FETCH response to a mailbox that isn't synced yet:\" << buf;\n              continue;\n          } else if (it.key() == \"ENVELOPE\") {\n              message->data()->m_envelope = static_cast<const Responses::RespData<Message::Envelope>&>(*(it.value())).data;\n              message->setFetchStatus(DONE);\n              gotEnvelope = true;\n              changedMessage = message;\n          } else if (it.key() == \"BODYSTRUCTURE\") {\n              if (message->fetched()) {\n                  // The message structure is already known, so we are free to ignore it\n              } else {\n                  // We had no idea about the structure of the message\n                  auto newChildren = static_cast<const Message::AbstractMessage &>(*(it.value())).createTreeItems(message);\n                  if (!message->m_children.isEmpty()) {\n                      QModelIndex messageIdx = message->toIndex(model);\n                      model->beginRemoveRows(messageIdx, 0, message->m_children.size() - 1);\n                      auto oldChildren = message->setChildren(newChildren);\n                      model->endRemoveRows();\n                      qDeleteAll(oldChildren);\n                  } else {\n                      auto oldChildren = message->setChildren(newChildren);\n                      Q_ASSERT(oldChildren.size() == 0);\n                  }\n                  savedBodyStructure = true;\n              }\n          } else if (it.key() == \"x-trojita-bodystructure\") {\n              // do nothing\n          } else if (it.key() == \"RFC822.SIZE\") {\n              message->data()->m_size = static_cast<const Responses::RespData<uint>&>(*(it.value())).data;\n              gotSize = true;\n          } else if (it.key().startsWith(\"BODY[HEADER.FIELDS (\")) {\n              // Process any headers found in any such response bit\n              const QByteArray &rawHeaders = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n              message->processAdditionalHeaders(model, rawHeaders);\n              changedMessage = message;\n          } else if (it.key().startsWith(\"BODY[\") || it.key().startsWith(\"BINARY[\")) {\n              if (it.key()[ it.key().size() - 1 ] != ']')\n                  throw UnknownMessageIndex(\"Can't parse such BODY[]/BINARY[]\", response);\n              TreeItemPart *part = partIdToPtr(model, message, it.key());\n              if (! part)\n                  throw UnknownMessageIndex(\"Got BODY[]/BINARY[] fetch that did not resolve to any known part\", response);\n              const QByteArray &data = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n              if (it.key().startsWith(\"BODY[\")) {\n  \n                  // Check whether we are supposed to be loading the raw, undecoded part as well.\n                  // The check has to be done via a direct pointer access to m_partRaw to make sure that it does not\n                  // get instantiated when not actually needed.\n                  if (part->m_partRaw && part->m_partRaw->loading()) {\n                      part->m_partRaw->m_data = data;\n                      part->m_partRaw->setFetchStatus(DONE);\n                      changedParts.append(part->m_partRaw);\n                      if (message->uid()) {\n                          model->cache()->forgetMessagePart(mailbox(), message->uid(), part->partId());\n                          model->cache()->setMsgPart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\"), data);\n                      }\n                  }\n  \n                  // Do not overwrite the part data if we were not asked to fetch it.\n                  // One possibility is that it's already there because it was fetched before. The second option is that\n                  // we were in fact asked to only fetch the raw data and the user is not itnerested in the processed data at all.\n                  if (part->loading()) {\n                      // got to decode the part data by hand\n                      Imap::decodeContentTransferEncoding(data, part->encoding(), part->dataPtr());\n                      part->setFetchStatus(DONE);\n                      changedParts.append(part);\n                      if (message->uid()\n                              && model->cache()->messagePart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\")).isNull()) {\n                          // Do not store the data into cache if the raw data are already there\n                          model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                      }\n                  }\n  \n              } else {\n                  // A BINARY FETCH item is already decoded for us, yay\n                  part->m_data = data;\n                  part->setFetchStatus(DONE);\n                  changedParts.append(part);\n                  if (message->uid()) {\n                      model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                  }\n              }\n          } else if (it.key() == \"INTERNALDATE\") {\n              message->data()->m_internalDate = static_cast<const Responses::RespData<QDateTime>&>(*(it.value())).data;\n              gotInternalDate = true;\n          } else {\n              qDebug() << \"TreeItemMailbox::handleFetchResponse: unknown FETCH identifier\" << it.key();\n          }\n      }\n      if (message->uid()) {\n          if (gotEnvelope && gotSize && savedBodyStructure && gotInternalDate) {\n              Imap::Mailbox::AbstractCache::MessageDataBundle dataForCache;\n              dataForCache.envelope = message->data()->m_envelope;\n              dataForCache.serializedBodyStructure = static_cast<const Responses::RespData<QByteArray>&>(*(response.data[ \"x-trojita-bodystructure\" ])).data;\n              dataForCache.size = message->data()->m_size;\n              dataForCache.uid = message->uid();\n              dataForCache.internalDate = message->data()->m_internalDate;\n              dataForCache.hdrReferences = message->data()->m_hdrReferences;\n              dataForCache.hdrListPost = message->data()->m_hdrListPost;\n              dataForCache.hdrListPostNo = message->data()->m_hdrListPostNo;\n              model->cache()->setMessageMetadata(mailbox(), message->uid(), dataForCache);\n          }\n          if (updatedFlags) {\n              model->cache()->setMsgFlags(mailbox(), message->uid(), message->m_flags);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT(m",
          "args": [
            "ilbox);"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::genericHandleFetch(TreeItemMailbox *mailbox, const Imap::Responses::Fetch *const resp)\n  {\n      Q_ASSERT(mailbox);\n      QList<TreeItemPart *> changedParts;\n      TreeItemMessage *changedMessage = 0;\n      mailbox->handleFetchResponse(this, *resp, changedParts, changedMessage, false);\n      if (! changedParts.isEmpty()) {\n          Q_FOREACH(TreeItemPart* part, changedParts) {\n              QModelIndex index = part->toIndex(this);\n              emit dataChanged(index, index);\n          }\n      }\n      if (changedMessage) {\n          QModelIndex index = changedMessage->toIndex(this);\n          emit dataChanged(index, index);\n          emitMessageCountChanged(mailbox);\n      }\n  }\n}"
  },
  {
    "function_name": "removeDeletedTasks(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1543-1552",
    "snippet": "id Model::removeDeletedTasks(const QList<ImapTask *> &deletedTasks, QList<ImapTask *> &activeTasks)\n{\n    // Remove the finished commands\n    for (QList<ImapTask *>::const_iterator deletedIt = deletedTasks.begin(); deletedIt != deletedTasks.end(); ++deletedIt) {\n        (*deletedIt)->deleteLater();\n        activeTasks.removeOne(*deletedIt);\n        // It isn't destroyed yet, but should be removed from the model nonetheless\n        m_taskModel->slotTaskDestroyed(*deletedIt);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskModel->slotTaskDestroyed",
          "args": [
            "eletedIt);"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tiveTasks.removeOne",
          "args": [
            "eletedIt);"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deletedIt)->deleteLater",
          "args": [],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "letedTasks.end",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "letedTasks.begin",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::removeDeletedTasks(const QList<ImapTask *> &deletedTasks, QList<ImapTask *> &activeTasks)\n  {\n      // Remove the finished commands\n      for (QList<ImapTask *>::const_iterator deletedIt = deletedTasks.begin(); deletedIt != deletedTasks.end(); ++deletedIt) {\n          (*deletedIt)->deleteLater();\n          activeTasks.removeOne(*deletedIt);\n          // It isn't destroyed yet, but should be removed from the model nonetheless\n          m_taskModel->slotTaskDestroyed(*deletedIt);\n      }\n  }\n}"
  },
  {
    "function_name": "runReadyTasks()",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1513-1541",
    "snippet": "id Model::runReadyTasks()\n{\n    for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n        bool runSomething = false;\n        do {\n            runSomething = false;\n            // See responseReceived() for more details about why we do need to iterate over a copy here.\n            // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n            QList<ImapTask *> origList = parserIt->activeTasks;\n            QList<ImapTask *> deletedList;\n            QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n            for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                ImapTask *task = *taskIt;\n                if (task->isReadyToRun()) {\n                    task->perform();\n                    runSomething = true;\n                }\n                if (task->isFinished()) {\n                    deletedList << task;\n                }\n            }\n            removeDeletedTasks(deletedList, parserIt->activeTasks);\n#ifdef TROJITA_DEBUG_TASK_TREE\n            if (!deletedList.isEmpty())\n                checkTaskTreeConsistency();\n#endif\n        } while (runSomething);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eckTaskTreeConsistency()",
          "args": [],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "checkTaskTreeConsistency()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1994-2021",
          "snippet": "id Model::checkTaskTreeConsistency()\n{\n    for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n        qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n            qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n        }\n#endif\n        Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n#ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n            qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n#endif\n            Q_ASSERT(activeTask->parser == parserIt.key());\n            Q_ASSERT(!activeTask->parentTask);\n            checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n        }\n\n        // Make sure that no task is present twice in here\n        QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n        for (int i = 0; i < taskQueue.size(); ++i) {\n            Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                taskQueue.push_back(yetAnotherTask);\n            }\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::checkTaskTreeConsistency()\n  {\n      for (QMap<Parser *,ParserState>::const_iterator parserIt = m_parsers.constBegin(); parserIt != m_parsers.constEnd(); ++parserIt) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n          qDebug() << \"\\nParser\" << parserIt.key() << \"; all active tasks:\";\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n              qDebug() << ' ' << activeTask << activeTask->debugIdentification() << activeTask->parser;\n          }\n  #endif\n          Q_FOREACH(ImapTask *activeTask, parserIt.value().activeTasks) {\n  #ifdef TROJITA_DEBUG_TASK_TREE_VERBOSE\n              qDebug() << \"Active task\" << activeTask << activeTask->debugIdentification() << activeTask->parser;\n  #endif\n              Q_ASSERT(activeTask->parser == parserIt.key());\n              Q_ASSERT(!activeTask->parentTask);\n              checkDependentTasksConsistency(parserIt.key(), activeTask, 0, 0);\n          }\n  \n          // Make sure that no task is present twice in here\n          QList<ImapTask*> taskQueue = parserIt.value().activeTasks;\n          for (int i = 0; i < taskQueue.size(); ++i) {\n              Q_FOREACH(ImapTask *yetAnotherTask, taskQueue[i]->dependentTasks) {\n                  Q_ASSERT(!taskQueue.contains(yetAnotherTask));\n                  taskQueue.push_back(yetAnotherTask);\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "letedList.isEmpty",
          "args": [],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moveDeletedTasks(d",
          "args": [
            "letedList,",
            "rserIt->activeTasks);"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->isFinished",
          "args": [],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->perform",
          "args": [],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "xpungeMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ExpungeMessagesTask.cpp",
          "lines": "46-84",
          "snippet": "oid ExpungeMessagesTask::perform()\n{\n    parser = conn->parser;\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    Sequence seq;\n    bool first = true;\n\n    Q_FOREACH(const QPersistentModelIndex& index, messages) {\n        if (! index.isValid()) {\n            // That message is gone already\n        } else {\n            TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n            Q_ASSERT(item);\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(item);\n            Q_ASSERT(message);\n            if (first) {\n                seq = Sequence(message->uid());\n                first = false;\n            } else {\n                seq.add(message->uid());\n            }\n        }\n    }\n\n    if (first) {\n        // No valid messages\n        _failed(\"All messages are gone already\");\n        return;\n    }\n\n    if (!model->accessParser(parser).capabilities.contains(\"UIDPLUS\")) {\n        _failed(\"The IMAP server doesn't support the UIDPLUS extension\");\n    }\n\n    tag = parser->uidExpunge(seq);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ExpungeMessagesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ExpungeMessagesTask.h\"\n#\n\nxpungeMessagesTask {\n  oid ExpungeMessagesTask::perform()\n  {\n      parser = conn->parser;\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      Sequence seq;\n      bool first = true;\n  \n      Q_FOREACH(const QPersistentModelIndex& index, messages) {\n          if (! index.isValid()) {\n              // That message is gone already\n          } else {\n              TreeItem *item = static_cast<TreeItem *>(index.internalPointer());\n              Q_ASSERT(item);\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(item);\n              Q_ASSERT(message);\n              if (first) {\n                  seq = Sequence(message->uid());\n                  first = false;\n              } else {\n                  seq.add(message->uid());\n              }\n          }\n      }\n  \n      if (first) {\n          // No valid messages\n          _failed(\"All messages are gone already\");\n          return;\n      }\n  \n      if (!model->accessParser(parser).capabilities.contains(\"UIDPLUS\")) {\n          _failed(\"The IMAP server doesn't support the UIDPLUS extension\");\n      }\n  \n      tag = parser->uidExpunge(seq);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk->isReadyToRun",
          "args": [],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "isReadyToRun(",
          "container": "etAnyConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/GetAnyConnectionTask.cpp",
          "lines": "101-104",
          "snippet": "ool GetAnyConnectionTask::isReadyToRun() const\n{\n    return ! isFinished() && ! newConn;\n}",
          "includes": [
            "include \"OpenConnectionTask.h\"",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include <QTimer>\n#",
            "include \"GetAnyConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"OpenConnectionTask.h\"\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude <QTimer>\n#\ninclude \"GetAnyConnectionTask.h\"\n#\n\netAnyConnectionTask {\n  ool GetAnyConnectionTask::isReadyToRun() const\n  {\n      return ! isFinished() && ! newConn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "igList.constBegin",
          "args": [],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igList.constEnd",
          "args": [],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.end",
          "args": [],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.begin",
          "args": [],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::runReadyTasks()\n  {\n      for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n          bool runSomething = false;\n          do {\n              runSomething = false;\n              // See responseReceived() for more details about why we do need to iterate over a copy here.\n              // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n              QList<ImapTask *> origList = parserIt->activeTasks;\n              QList<ImapTask *> deletedList;\n              QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n              for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                  ImapTask *task = *taskIt;\n                  if (task->isReadyToRun()) {\n                      task->perform();\n                      runSomething = true;\n                  }\n                  if (task->isFinished()) {\n                      deletedList << task;\n                  }\n              }\n              removeDeletedTasks(deletedList, parserIt->activeTasks);\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              if (!deletedList.isEmpty())\n                  checkTaskTreeConsistency();\n  #endif\n          } while (runSomething);\n      }\n  }\n}"
  },
  {
    "function_name": "setCache(A",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1505-1511",
    "snippet": "id Model::setCache(AbstractCache *cache)\n{\n    if (m_cache)\n        m_cache->deleteLater();\n    m_cache = cache;\n    m_cache->setParent(this);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache->setParent",
          "args": [
            "is);"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache->deleteLater",
          "args": [],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCache(AbstractCache *cache)\n  {\n      if (m_cache)\n          m_cache->deleteLater();\n      m_cache = cache;\n      m_cache->setParent(this);\n  }\n}"
  },
  {
    "function_name": "slotParserLineSent(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1500-1503",
    "snippet": "id Model::slotParserLineSent(Parser *parser, const QByteArray &line)\n{\n    logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), line);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_IO_WRITTEN,",
            "tring(),",
            "ne);"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->parserId",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::slotParserLineSent(Parser *parser, const QByteArray &line)\n  {\n      logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), line);\n  }\n}"
  },
  {
    "function_name": "slotParserLineReceived(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1495-1498",
    "snippet": "id Model::slotParserLineReceived(Parser *parser, const QByteArray &line)\n{\n    logTrace(parser->parserId(), Common::LOG_IO_READ, QString(), line);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_IO_READ,",
            "tring(),",
            "ne);"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->parserId",
          "args": [],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::slotParserLineReceived(Parser *parser, const QByteArray &line)\n  {\n      logTrace(parser->parserId(), Common::LOG_IO_READ, QString(), line);\n  }\n}"
  },
  {
    "function_name": "killParser(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1462-1493",
    "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT(f",
          "args": [
            "lse);"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_IO_WRITTEN,",
            "tring(),",
            "** Connection killed.\");"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->parserId",
          "args": [],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_IO_WRITTEN,",
            "tring(),",
            "** Connection closed.\");"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(a",
          "args": [
            "cessParser(parser).parser);"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->disconnect",
          "args": [],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->die",
          "args": [
            "(\"The connection is being killed for unspecified reason\"));"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "(\"",
          "args": [
            "he connection is being killed for unspecified reason\"))"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *task,",
            "cessParser(parser).activeTasks)"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->deleteLater",
          "args": [],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk->deleteLater",
          "args": [],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH(I",
          "args": [
            "apTask *task,",
            "cessParser(parser).activeTasks)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(a",
          "args": [
            "cessParser(parser).parser == 0);"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
  },
  {
    "function_name": "handleSocketStateChanged(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1454-1460",
    "snippet": "id Model::handleSocketStateChanged(Parser *parser, Imap::ConnectionState state)\n{\n    Q_ASSERT(parser);\n    if (accessParser(parser).connState < state) {\n        changeConnectionState(parser, state);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "angeConnectionState(p",
          "args": [
            "rser,",
            "ate);"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(p",
          "args": [
            "rser);"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::handleSocketStateChanged(Parser *parser, Imap::ConnectionState state)\n  {\n      Q_ASSERT(parser);\n      if (accessParser(parser).connState < state) {\n          changeConnectionState(parser, state);\n      }\n  }\n}"
  },
  {
    "function_name": "changeConnectionState(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1447-1452",
    "snippet": "id Model::changeConnectionState(Parser *parser, ConnectionState state)\n{\n    accessParser(parser).connState = state;\n    logTrace(parser->parserId(), Common::LOG_TASKS, QLatin1String(\"conn\"), connectionStateToString(state));\n    emit connectionStateChanged(parser, state);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_TASKS,",
            "atin1String(\"conn\"),",
            "nnectionStateToString(state));"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnectionStateToString(s",
          "args": [
            "ate))"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "onn\"),"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->parserId",
          "args": [],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::changeConnectionState(Parser *parser, ConnectionState state)\n  {\n      accessParser(parser).connState = state;\n      logTrace(parser->parserId(), Common::LOG_TASKS, QLatin1String(\"conn\"), connectionStateToString(state));\n      emit connectionStateChanged(parser, state);\n  }\n}"
  },
  {
    "function_name": "saveUidMap(T",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1423-1429",
    "snippet": "id Model::saveUidMap(TreeItemMsgList *list)\n{\n    QList<uint> seqToUid;\n    for (int i = 0; i < list->m_children.size(); ++i)\n        seqToUid << static_cast<TreeItemMessage *>(list->m_children[ i ])->uid();\n    cache()->setUidMapping(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), seqToUid);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "che",
          "args": [
            "atic_cast<TreeItemMailbox *>(list->parent())->mailbox(),",
            "qToUid);"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "NetworkWatcher(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "29-34",
          "snippet": "etworkWatcher::NetworkWatcher(QObject *parent, Model *model):\n    QObject(parent), m_model(model), m_desiredPolicy(NETWORK_OFFLINE)\n{\n    Q_ASSERT(m_model);\n    connect(model, SIGNAL(networkPolicyChanged()), this, SIGNAL(effectiveNetworkPolicyChanged()));\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkWatcher::NetworkWatcher(QObject *parent, Model *model):\n      QObject(parent), m_model(model), m_desiredPolicy(NETWORK_OFFLINE)\n  {\n      Q_ASSERT(m_model);\n      connect(model, SIGNAL(networkPolicyChanged()), this, SIGNAL(effectiveNetworkPolicyChanged()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMailbox *>",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMailbox *>",
          "args": [
            "st->parent())-"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->parent",
          "args": [],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "che()",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMessage *>",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMessage *>",
          "args": [
            "st->m_children[ i ])-"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.size",
          "args": [],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::saveUidMap(TreeItemMsgList *list)\n  {\n      QList<uint> seqToUid;\n      for (int i = 0; i < list->m_children.size(); ++i)\n          seqToUid << static_cast<TreeItemMessage *>(list->m_children[ i ])->uid();\n      cache()->setUidMapping(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), seqToUid);\n  }\n}"
  },
  {
    "function_name": "unsubscribeMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1406-1421",
    "snippet": "id Model::unsubscribeMailbox(const QString &name)\n{\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        qDebug() << \"Can't manage subscriptions while offline\";\n        return;\n    }\n\n    TreeItemMailbox *mailbox = findMailboxByName(name);\n    if (!mailbox) {\n        qDebug() << \"UNSUBSCRIBE: No such mailbox.\";\n        return;\n    }\n    QModelIndex index = mailbox->toIndex(this);\n    Q_ASSERT(index.isValid());\n    m_taskFactory->createSubscribeUnsubscribeTask(this, index, UNSUBSCRIBE);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createSubscribeUnsubscribeTask",
          "args": [
            "is,",
            "dex,",
            "SUBSCRIBE);"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.isValid());"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.isValid",
          "args": [],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilbox->toIndex",
          "args": [
            "is);"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndMailboxByName(n",
          "args": [
            "me);"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::unsubscribeMailbox(const QString &name)\n  {\n      if (m_netPolicy == NETWORK_OFFLINE) {\n          qDebug() << \"Can't manage subscriptions while offline\";\n          return;\n      }\n  \n      TreeItemMailbox *mailbox = findMailboxByName(name);\n      if (!mailbox) {\n          qDebug() << \"UNSUBSCRIBE: No such mailbox.\";\n          return;\n      }\n      QModelIndex index = mailbox->toIndex(this);\n      Q_ASSERT(index.isValid());\n      m_taskFactory->createSubscribeUnsubscribeTask(this, index, UNSUBSCRIBE);\n  }\n}"
  },
  {
    "function_name": "subscribeMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1389-1404",
    "snippet": "id Model::subscribeMailbox(const QString &name)\n{\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        qDebug() << \"Can't manage subscriptions while offline\";\n        return;\n    }\n\n    TreeItemMailbox *mailbox = findMailboxByName(name);\n    if (!mailbox) {\n        qDebug() << \"SUBSCRIBE: No such mailbox.\";\n        return;\n    }\n    QModelIndex index = mailbox->toIndex(this);\n    Q_ASSERT(index.isValid());\n    m_taskFactory->createSubscribeUnsubscribeTask(this, index, SUBSCRIBE);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createSubscribeUnsubscribeTask",
          "args": [
            "is,",
            "dex,",
            "BSCRIBE);"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.isValid());"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.isValid",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilbox->toIndex",
          "args": [
            "is);"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndMailboxByName(n",
          "args": [
            "me);"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::subscribeMailbox(const QString &name)\n  {\n      if (m_netPolicy == NETWORK_OFFLINE) {\n          qDebug() << \"Can't manage subscriptions while offline\";\n          return;\n      }\n  \n      TreeItemMailbox *mailbox = findMailboxByName(name);\n      if (!mailbox) {\n          qDebug() << \"SUBSCRIBE: No such mailbox.\";\n          return;\n      }\n      QModelIndex index = mailbox->toIndex(this);\n      Q_ASSERT(index.isValid());\n      m_taskFactory->createSubscribeUnsubscribeTask(this, index, SUBSCRIBE);\n  }\n}"
  },
  {
    "function_name": "deleteMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1379-1387",
    "snippet": "id Model::deleteMailbox(const QString &name)\n{\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        qDebug() << \"Can't delete mailboxes while offline\";\n        return;\n    }\n\n    m_taskFactory->createDeleteMailboxTask(this, name);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createDeleteMailboxTask",
          "args": [
            "is,",
            "me);"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::deleteMailbox(const QString &name)\n  {\n      if (m_netPolicy == NETWORK_OFFLINE) {\n          qDebug() << \"Can't delete mailboxes while offline\";\n          return;\n      }\n  \n      m_taskFactory->createDeleteMailboxTask(this, name);\n  }\n}"
  },
  {
    "function_name": "createMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1369-1377",
    "snippet": "id Model::createMailbox(const QString &name)\n{\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        qDebug() << \"Can't create mailboxes while offline\";\n        return;\n    }\n\n    m_taskFactory->createCreateMailboxTask(this, name);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createCreateMailboxTask",
          "args": [
            "is,",
            "me);"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::createMailbox(const QString &name)\n  {\n      if (m_netPolicy == NETWORK_OFFLINE) {\n          qDebug() << \"Can't create mailboxes while offline\";\n          return;\n      }\n  \n      m_taskFactory->createCreateMailboxTask(this, name);\n  }\n}"
  },
  {
    "function_name": "expungeMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1356-1367",
    "snippet": "id Model::expungeMailbox(const QModelIndex &mailbox)\n{\n    if (!mailbox.isValid())\n        return;\n\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        qDebug() << \"Can't expunge while offline\";\n        return;\n    }\n\n    m_taskFactory->createExpungeMailboxTask(this, mailbox);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createExpungeMailboxTask",
          "args": [
            "is,",
            "ilbox);"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilbox.isValid",
          "args": [],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::expungeMailbox(const QModelIndex &mailbox)\n  {\n      if (!mailbox.isValid())\n          return;\n  \n      if (m_netPolicy == NETWORK_OFFLINE) {\n          qDebug() << \"Can't expunge while offline\";\n          return;\n      }\n  \n      m_taskFactory->createExpungeMailboxTask(this, mailbox);\n  }\n}"
  },
  {
    "function_name": "findMessageOrNextOneByUid(T",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1306-1309",
    "snippet": "eeItemChildrenList::iterator Model::findMessageOrNextOneByUid(TreeItemMsgList *list, const uint uid)\n{\n    return Common::lowerBoundWithUnknownElements(list->m_children.begin(), list->m_children.end(), uid, messageHasUidZero, uidComparator);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmon::lowerBoundWithUnknownElements(l",
          "args": [
            "st->m_children.begin(),",
            "st->m_children.end(),",
            "d,",
            "ssageHasUidZero,",
            "dComparator);"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.end",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.begin",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  eeItemChildrenList::iterator Model::findMessageOrNextOneByUid(TreeItemMsgList *list, const uint uid)\n  {\n      return Common::lowerBoundWithUnknownElements(list->m_children.begin(), list->m_children.end(), uid, messageHasUidZero, uidComparator);\n  }\n}"
  },
  {
    "function_name": "findMessagesByUids(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1278-1299",
    "snippet": "ist<TreeItemMessage *> Model::findMessagesByUids(const TreeItemMailbox *const mailbox, const QList<uint> &uids)\n{\n    const TreeItemMsgList *const list = dynamic_cast<const TreeItemMsgList *const>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    QList<TreeItemMessage *> res;\n    auto it = list->m_children.constBegin();\n    uint lastUid = 0;\n    Q_FOREACH(const uint& uid, uids) {\n        if (lastUid == uid) {\n            // we have to filter out duplicates\n            continue;\n        }\n        lastUid = uid;\n        it = Common::lowerBoundWithUnknownElements(it, list->m_children.constEnd(), uid, messageHasUidZero, uidComparator);\n        if (it != list->m_children.end() && static_cast<TreeItemMessage *>(*it)->uid() == uid) {\n            res << static_cast<TreeItemMessage *>(*it);\n        } else {\n            qDebug() << \"Can't find UID\" << uid;\n        }\n    }\n    return res;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebug()",
          "args": [],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMessage *>",
          "args": [
            "t);"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMessage *>",
          "args": [],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItemMessage *>",
          "args": [
            "t)-"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.end",
          "args": [],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmon::lowerBoundWithUnknownElements(i",
          "args": [
            ",",
            "st->m_children.constEnd(),",
            "d,",
            "ssageHasUidZero,",
            "dComparator);"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.constEnd",
          "args": [],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->m_children.constBegin",
          "args": [],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(l",
          "args": [
            "st);"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<const TreeItemMsgList *const>",
          "args": [
            "ilbox->m_children[0]);"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  ist<TreeItemMessage *> Model::findMessagesByUids(const TreeItemMailbox *const mailbox, const QList<uint> &uids)\n  {\n      const TreeItemMsgList *const list = dynamic_cast<const TreeItemMsgList *const>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      QList<TreeItemMessage *> res;\n      auto it = list->m_children.constBegin();\n      uint lastUid = 0;\n      Q_FOREACH(const uint& uid, uids) {\n          if (lastUid == uid) {\n              // we have to filter out duplicates\n              continue;\n          }\n          lastUid = uid;\n          it = Common::lowerBoundWithUnknownElements(it, list->m_children.constEnd(), uid, messageHasUidZero, uidComparator);\n          if (it != list->m_children.end() && static_cast<TreeItemMessage *>(*it)->uid() == uid) {\n              res << static_cast<TreeItemMessage *>(*it);\n          } else {\n              qDebug() << \"Can't find UID\" << uid;\n          }\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "copyMoveMessages(T",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1257-1275",
    "snippet": "id Model::copyMoveMessages(TreeItemMailbox *sourceMbox, const QString &destMailboxName, QList<uint> uids, const CopyMoveOperation op)\n{\n    if (m_netPolicy == NETWORK_OFFLINE) {\n        // FIXME: error signalling\n        return;\n    }\n\n    Q_ASSERT(sourceMbox);\n\n    qSort(uids);\n\n    QModelIndexList messages;\n    Sequence seq;\n    Q_FOREACH(TreeItemMessage* m, findMessagesByUids(sourceMbox, uids)) {\n        messages << m->toIndex(this);\n        seq.add(m->uid());\n    }\n    m_taskFactory->createCopyMoveMessagesTask(this, messages, destMailboxName, op);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createCopyMoveMessagesTask",
          "args": [
            "is,",
            "ssages,",
            "stMailboxName,",
            ");"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q.add",
          "args": [
            ">uid());"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">uid",
          "args": [],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">toIndex",
          "args": [
            "is);"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ort(u",
          "args": [
            "ds);"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(s",
          "args": [
            "urceMbox);"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::copyMoveMessages(TreeItemMailbox *sourceMbox, const QString &destMailboxName, QList<uint> uids, const CopyMoveOperation op)\n  {\n      if (m_netPolicy == NETWORK_OFFLINE) {\n          // FIXME: error signalling\n          return;\n      }\n  \n      Q_ASSERT(sourceMbox);\n  \n      qSort(uids);\n  \n      QModelIndexList messages;\n      Sequence seq;\n      Q_FOREACH(TreeItemMessage* m, findMessagesByUids(sourceMbox, uids)) {\n          messages << m->toIndex(this);\n          seq.add(m->uid());\n      }\n      m_taskFactory->createCopyMoveMessagesTask(this, messages, destMailboxName, op);\n  }\n}"
  },
  {
    "function_name": "markMessagesRead(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1252-1255",
    "snippet": "id Model::markMessagesRead(const QModelIndexList &messages, const FlagsOperation marked)\n{\n    this->setMessageFlags(messages, \"\\\\Seen\", marked);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is->setMessageFlags",
          "args": [
            "ssages,",
            "\\Seen\",",
            "rked);"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::markMessagesRead(const QModelIndexList &messages, const FlagsOperation marked)\n  {\n      this->setMessageFlags(messages, \"\\\\Seen\", marked);\n  }\n}"
  },
  {
    "function_name": "markMailboxAsRead(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1239-1250",
    "snippet": "id Model::markMailboxAsRead(const QModelIndex &mailbox)\n{\n    if (!mailbox.isValid())\n        return;\n\n    QModelIndex index;\n    realTreeItem(mailbox, 0, &index);\n    Q_ASSERT(index.isValid());\n    Q_ASSERT(index.model() == this);\n    Q_ASSERT(dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(index.internalPointer())));\n    m_taskFactory->createUpdateFlagsOfAllMessagesTask(this, index, Imap::Mailbox::FLAG_ADD_SILENT, QLatin1String(\"\\\\Seen\"));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "taskFactory->createUpdateFlagsOfAllMessagesTask",
          "args": [
            "is,",
            "dex,",
            "ap::Mailbox::FLAG_ADD_SILENT,",
            "atin1String(\"\\\\Seen\"));"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "\\Seen\"))"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(d",
          "args": [
            "namic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(index.internalPointer())));"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namic_cast<TreeItemMailbox*>",
          "args": [
            "atic_cast<TreeItem*>(index.internalPointer())))"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atic_cast<TreeItem*>",
          "args": [
            "dex.internalPointer()))"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.internalPointer",
          "args": [],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.model() == this);"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.model",
          "args": [],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(i",
          "args": [
            "dex.isValid());"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex.isValid",
          "args": [],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alTreeItem(m",
          "args": [
            "ilbox,",
            "ndex);"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::markMailboxAsRead(const QModelIndex &mailbox)\n  {\n      if (!mailbox.isValid())\n          return;\n  \n      QModelIndex index;\n      realTreeItem(mailbox, 0, &index);\n      Q_ASSERT(index.isValid());\n      Q_ASSERT(index.model() == this);\n      Q_ASSERT(dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(index.internalPointer())));\n      m_taskFactory->createUpdateFlagsOfAllMessagesTask(this, index, Imap::Mailbox::FLAG_ADD_SILENT, QLatin1String(\"\\\\Seen\"));\n  }\n}"
  },
  {
    "function_name": "markMessagesDeleted(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1234-1237",
    "snippet": "id Model::markMessagesDeleted(const QModelIndexList &messages, const FlagsOperation marked)\n{\n    this->setMessageFlags(messages, \"\\\\Deleted\", marked);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is->setMessageFlags",
          "args": [
            "ssages,",
            "\\Deleted\",",
            "rked);"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::markMessagesDeleted(const QModelIndexList &messages, const FlagsOperation marked)\n  {\n      this->setMessageFlags(messages, \"\\\\Deleted\", marked);\n  }\n}"
  },
  {
    "function_name": "updateCapabilities(P",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1193-1225",
    "snippet": "id Model::updateCapabilities(Parser *parser, const QStringList capabilities)\n{\n    Q_ASSERT(parser);\n    QStringList uppercaseCaps;\n    Q_FOREACH(const QString& str, capabilities) {\n        QString cap = str.toUpper();\n        if (m_capabilitiesBlacklist.contains(cap)) {\n            logTrace(parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"Ignoring capability \\\"%1\\\"\").arg(cap));\n            continue;\n        }\n        uppercaseCaps << cap;\n    }\n    accessParser(parser).capabilities = uppercaseCaps;\n    accessParser(parser).capabilitiesFresh = true;\n    parser->enableLiteralPlus(uppercaseCaps.contains(QLatin1String(\"LITERAL+\")));\n\n    for (QMap<Parser *,ParserState>::const_iterator it = m_parsers.constBegin(); it != m_parsers.constEnd(); ++it) {\n        if (it->connState == CONN_STATE_LOGOUT) {\n            // Skip all parsers which are currently stuck in LOGOUT\n            continue;\n        } else {\n            // The CAPABILITIES were received by a first \"usable\" parser; let's treat this one as the authoritative one\n            emit capabilitiesUpdated(uppercaseCaps);\n        }\n    }\n\n    if (!uppercaseCaps.contains(QLatin1String(\"IMAP4REV1\"))) {\n        changeConnectionState(parser, CONN_STATE_LOGOUT);\n        accessParser(parser).logoutCmd = parser->logout();\n        EMIT_LATER(this, imapError, Q_ARG(QString, tr(\"We aren't talking to an IMAP4 server\")));\n        setNetworkPolicy(NETWORK_OFFLINE);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tNetworkPolicy(N",
          "args": [
            "TWORK_OFFLINE);"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LATER(t",
          "args": [
            "is,",
            "apError,",
            "ARG(QString, tr(\"We aren't talking to an IMAP4 server\")));"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG(Q",
          "args": [
            "tring,",
            "(\"We aren't talking to an IMAP4 server\")))"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(\"",
          "args": [
            "e aren't talking to an IMAP4 server\"))"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->logout",
          "args": [],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "107-113",
          "snippet": "ommandHandle Parser::logout()\n{\n    return queueCommand(Commands::Command(\"LOGOUT\"));\n\n    // Queue a request for closing the socket. It'll get closed after a short while.\n    QTimer::singleShot(1000, this, SLOT(closeConnection()));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::logout()\n  {\n      return queueCommand(Commands::Command(\"LOGOUT\"));\n  \n      // Queue a request for closing the socket. It'll get closed after a short while.\n      QTimer::singleShot(1000, this, SLOT(closeConnection()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "angeConnectionState(p",
          "args": [
            "rser,",
            "NN_STATE_LOGOUT);"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percaseCaps.contains",
          "args": [
            "atin1String(\"IMAP4REV1\")))"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "MAP4REV1\"))"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constEnd",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsers.constBegin",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->enableLiteralPlus",
          "args": [
            "percaseCaps.contains(QLatin1String(\"LITERAL+\")));"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "enableLiteralPlus(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1128-1131",
          "snippet": "oid Parser::enableLiteralPlus(const bool enabled)\n{\n    literalPlus = enabled;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::enableLiteralPlus(const bool enabled)\n  {\n      literalPlus = enabled;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "percaseCaps.contains",
          "args": [
            "atin1String(\"LITERAL+\")))"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "ITERAL+\"))"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cessParser(p",
          "args": [
            "rser)."
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gTrace(p",
          "args": [
            "rser->parserId(),",
            "mmon::LOG_OTHER,",
            "atin1String(\"Model\"),",
            "tring::fromUtf8(\"Ignoring capability \\\"%1\\\"\").arg(cap));"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "p))"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "gnoring capability \\\"%1\\\"\")."
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "odel\"),"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rser->parserId",
          "args": [],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "capabilitiesBlacklist.contains",
          "args": [
            "p))"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.toUpper",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(p",
          "args": [
            "rser);"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::updateCapabilities(Parser *parser, const QStringList capabilities)\n  {\n      Q_ASSERT(parser);\n      QStringList uppercaseCaps;\n      Q_FOREACH(const QString& str, capabilities) {\n          QString cap = str.toUpper();\n          if (m_capabilitiesBlacklist.contains(cap)) {\n              logTrace(parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"Ignoring capability \\\"%1\\\"\").arg(cap));\n              continue;\n          }\n          uppercaseCaps << cap;\n      }\n      accessParser(parser).capabilities = uppercaseCaps;\n      accessParser(parser).capabilitiesFresh = true;\n      parser->enableLiteralPlus(uppercaseCaps.contains(QLatin1String(\"LITERAL+\")));\n  \n      for (QMap<Parser *,ParserState>::const_iterator it = m_parsers.constBegin(); it != m_parsers.constEnd(); ++it) {\n          if (it->connState == CONN_STATE_LOGOUT) {\n              // Skip all parsers which are currently stuck in LOGOUT\n              continue;\n          } else {\n              // The CAPABILITIES were received by a first \"usable\" parser; let's treat this one as the authoritative one\n              emit capabilitiesUpdated(uppercaseCaps);\n          }\n      }\n  \n      if (!uppercaseCaps.contains(QLatin1String(\"IMAP4REV1\"))) {\n          changeConnectionState(parser, CONN_STATE_LOGOUT);\n          accessParser(parser).logoutCmd = parser->logout();\n          EMIT_LATER(this, imapError, Q_ARG(QString, tr(\"We aren't talking to an IMAP4 server\")));\n          setNetworkPolicy(NETWORK_OFFLINE);\n      }\n  }\n}"
  },
  {
    "function_name": "switchToMailbox(c",
    "container": "del",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1182-1191",
    "snippet": "id Model::switchToMailbox(const QModelIndex &mbox)\n{\n    if (! mbox.isValid())\n        return;\n\n    if (m_netPolicy == NETWORK_OFFLINE)\n        return;\n\n    findTaskResponsibleFor(mbox);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndTaskResponsibleFor(m",
          "args": [
            "ox);"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ox.isValid",
          "args": [],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::switchToMailbox(const QModelIndex &mbox)\n  {\n      if (! mbox.isValid())\n          return;\n  \n      if (m_netPolicy == NETWORK_OFFLINE)\n          return;\n  \n      findTaskResponsibleFor(mbox);\n  }\n}"
  },
  {
    "function_name": "broadcastParseError(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1150-1180",
    "snippet": "oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n{\n    emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n    QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n    logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n    QString message;\n    if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n        QString service;\n        if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n            service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n        } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n            service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n        }\n        message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                         \"%1\"\n                         \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                         \"A typical port number for IMAP is 143 or 993.</p>\"\n                         \"<p>The server said:</p>\"\n                         \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n    } else {\n        message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                         \"This might either mean that there's a bug in Trojit's code, or \"\n                         \"that the IMAP server you are connected to is broken. Please \"\n                         \"report this as a bug anyway. Here are the details:</p>\"\n                         \"<p><b>%1</b>: %2</p>\"\n                         \"<pre>%3\\n%4</pre>\"\n                         ).arg(exceptionClass, errorMessage, line, details);\n    }\n    EMIT_LATER(this, imapError, Q_ARG(QString, message));\n    setNetworkPolicy(NETWORK_OFFLINE);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tNetworkPolicy(N",
          "args": [
            "TWORK_OFFLINE);"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_LATER(t",
          "args": [
            "is,",
            "apError,",
            "ARG(QString, message));"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG(Q",
          "args": [
            "tring,",
            "ssage))"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rUtf8",
          "args": [
            "ceptionClass,",
            "rorMessage,",
            "ne,",
            "tails);"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rUtf8(",
          "args": [
            "<p>The IMAP server sent us a reply which we could not parse. \"\n                         \"This might either mean that there's a bug in Trojit's code, or \"\n                         \"that the IMAP server you are connected to is broken. Please \"\n                         \"report this as a bug anyway. Here are the details:</p>\"\n                         \"<p><b>%1</b>: %2</p>\"\n                         \"<pre>%3\\n%4</pre>\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rUtf8",
          "args": [
            "ervice,",
            "String::fromUtf8(line.constData()))"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "ine.constData())"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rUtf8(",
          "args": [
            "<h2>This is not an IMAP server</h2>\"\n                         \"%1\"\n                         \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                         \"A typical port number for IMAP is 143 or 993.</p>\"\n                         \"<p>The server said:</p>\"\n                         \"<pre>%2</pre>\")"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\")"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "setImapUser(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1851-1854",
          "snippet": "id Model::setImapUser(const QString &imapUser)\n{\n    m_imapUser = imapUser;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setImapUser(const QString &imapUser)\n  {\n      m_imapUser = imapUser;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "220-\")"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "220 \")"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "-ERR\")"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "+OK\")"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "NotAnImapServerError\")"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "arser,",
            "ommon::LOG_PARSE_ERROR,",
            "xceptionClass,",
            "String::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details))"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1774-1794",
          "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "rrorMessage,",
            "ine,",
            "etails)"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1\\n%2\\n%3\")"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "^ here\")"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "osition,",
            "')"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n  {\n      emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n      QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n      logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n      QString message;\n      if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n          QString service;\n          if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n              service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n          } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n              service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n          }\n          message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                           \"%1\"\n                           \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                           \"A typical port number for IMAP is 143 or 993.</p>\"\n                           \"<p>The server said:</p>\"\n                           \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n      } else {\n          message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                           \"This might either mean that there's a bug in Trojit's code, or \"\n                           \"that the IMAP server you are connected to is broken. Please \"\n                           \"report this as a bug anyway. Here are the details:</p>\"\n                           \"<p><b>%1</b>: %2</p>\"\n                           \"<pre>%3\\n%4</pre>\"\n                           ).arg(exceptionClass, errorMessage, line, details);\n      }\n      EMIT_LATER(this, imapError, Q_ARG(QString, message));\n      setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
  },
  {
    "function_name": "handleParseErrorResponse(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1143-1148",
    "snippet": "oid Model::handleParseErrorResponse(Imap::Parser *ptr, const Imap::Responses::ParseErrorResponse *const resp)\n{\n    Q_ASSERT(ptr);\n    broadcastParseError(ptr->parserId(), resp->exceptionClass, resp->message, resp->line, resp->offset);\n    killParser(ptr, PARSER_KILL_HARD);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "illParser(",
          "args": [
            "tr,",
            "ARSER_KILL_HARD)"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "killParser(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1462-1493",
          "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roadcastParseError(",
          "args": [
            "tr->parserId(),",
            "esp->exceptionClass,",
            "esp->message,",
            "esp->line,",
            "esp->offset)"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "broadcastParseError(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1150-1180",
          "snippet": "oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n{\n    emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n    QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n    logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n    QString message;\n    if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n        QString service;\n        if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n            service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n        } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n            service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n        }\n        message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                         \"%1\"\n                         \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                         \"A typical port number for IMAP is 143 or 993.</p>\"\n                         \"<p>The server said:</p>\"\n                         \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n    } else {\n        message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                         \"This might either mean that there's a bug in Trojit's code, or \"\n                         \"that the IMAP server you are connected to is broken. Please \"\n                         \"report this as a bug anyway. Here are the details:</p>\"\n                         \"<p><b>%1</b>: %2</p>\"\n                         \"<pre>%3\\n%4</pre>\"\n                         ).arg(exceptionClass, errorMessage, line, details);\n    }\n    EMIT_LATER(this, imapError, Q_ARG(QString, message));\n    setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n  {\n      emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n      QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n      logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n      QString message;\n      if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n          QString service;\n          if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n              service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n          } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n              service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n          }\n          message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                           \"%1\"\n                           \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                           \"A typical port number for IMAP is 143 or 993.</p>\"\n                           \"<p>The server said:</p>\"\n                           \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n      } else {\n          message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                           \"This might either mean that there's a bug in Trojit's code, or \"\n                           \"that the IMAP server you are connected to is broken. Please \"\n                           \"report this as a bug anyway. Here are the details:</p>\"\n                           \"<p><b>%1</b>: %2</p>\"\n                           \"<pre>%3\\n%4</pre>\"\n                           ).arg(exceptionClass, errorMessage, line, details);\n      }\n      EMIT_LATER(this, imapError, Q_ARG(QString, message));\n      setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr->parserId",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tr)"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleParseErrorResponse(Imap::Parser *ptr, const Imap::Responses::ParseErrorResponse *const resp)\n  {\n      Q_ASSERT(ptr);\n      broadcastParseError(ptr->parserId(), resp->exceptionClass, resp->message, resp->line, resp->offset);\n      killParser(ptr, PARSER_KILL_HARD);\n  }\n}"
  },
  {
    "function_name": "handleSocketDisconnectedResponse(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1126-1141",
    "snippet": "oid Model::handleSocketDisconnectedResponse(Parser *ptr, const Responses::SocketDisconnectedResponse *const resp)\n{\n    if (!accessParser(ptr).logoutCmd.isEmpty() || accessParser(ptr).connState == CONN_STATE_LOGOUT) {\n        // If we're already scheduled for logout, don't treat connection errors as, well, errors.\n        // This branch can be reached by e.g. user selecting offline after a network change, with logout\n        // already on the fly.\n\n        // But we still absolutely want to clean up and kill the connection/Parser anyway\n        killParser(ptr, PARSER_KILL_EXPECTED);\n    } else {\n        logTrace(ptr->parserId(), Common::LOG_PARSE_ERROR, QString(), resp->message);\n        killParser(ptr, PARSER_KILL_EXPECTED);\n        EMIT_LATER(this, networkError, Q_ARG(QString, resp->message));\n        setNetworkPolicy(NETWORK_OFFLINE);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etNetworkPolicy(",
          "args": [
            "ETWORK_OFFLINE)"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "setNetworkPolicy(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1069-1124",
          "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "his,",
            "etworkError,",
            "_ARG(QString, resp->message))"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "esp->message)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "illParser(",
          "args": [
            "tr,",
            "ARSER_KILL_EXPECTED)"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "killParser(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1462-1493",
          "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "tr->parserId(),",
            "ommon::LOG_PARSE_ERROR,",
            "String(),",
            "esp->message)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1774-1794",
          "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "modifierToString(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1624-1640",
          "snippet": "String TreeItemModifiedPart::modifierToString() const\n{\n    switch (m_modifier) {\n    case OFFSET_HEADER:\n        return QLatin1String(\"HEADER\");\n    case OFFSET_TEXT:\n        return QLatin1String(\"TEXT\");\n    case OFFSET_MIME:\n        return QLatin1String(\"MIME\");\n    case OFFSET_RAW_CONTENTS:\n        Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n        // fall through\n    default:\n        Q_ASSERT(false);\n        return QString();\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  String TreeItemModifiedPart::modifierToString() const\n  {\n      switch (m_modifier) {\n      case OFFSET_HEADER:\n          return QLatin1String(\"HEADER\");\n      case OFFSET_TEXT:\n          return QLatin1String(\"TEXT\");\n      case OFFSET_MIME:\n          return QLatin1String(\"MIME\");\n      case OFFSET_RAW_CONTENTS:\n          Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n          // fall through\n      default:\n          Q_ASSERT(false);\n          return QString();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr->parserId",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleSocketDisconnectedResponse(Parser *ptr, const Responses::SocketDisconnectedResponse *const resp)\n  {\n      if (!accessParser(ptr).logoutCmd.isEmpty() || accessParser(ptr).connState == CONN_STATE_LOGOUT) {\n          // If we're already scheduled for logout, don't treat connection errors as, well, errors.\n          // This branch can be reached by e.g. user selecting offline after a network change, with logout\n          // already on the fly.\n  \n          // But we still absolutely want to clean up and kill the connection/Parser anyway\n          killParser(ptr, PARSER_KILL_EXPECTED);\n      } else {\n          logTrace(ptr->parserId(), Common::LOG_PARSE_ERROR, QString(), resp->message);\n          killParser(ptr, PARSER_KILL_EXPECTED);\n          EMIT_LATER(this, networkError, Q_ARG(QString, resp->message));\n          setNetworkPolicy(NETWORK_OFFLINE);\n      }\n  }\n}"
  },
  {
    "function_name": "setNetworkPolicy(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1069-1124",
    "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvalidateAllMessageCounts(",
          "args": [],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "invalidateAllMessageCounts()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1947-1966",
          "snippet": "id Model::invalidateAllMessageCounts()\n{\n    QList<TreeItemMailbox*> queue;\n    queue.append(m_mailboxes);\n    while (!queue.isEmpty()) {\n        TreeItemMailbox *head = queue.takeFirst();\n        // ignore first child, the TreeItemMsgList\n        for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n            queue.append(static_cast<TreeItemMailbox*>(*it));\n        }\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n\n        if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n            // Ask only for data which were previously available\n            // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n            list->m_numberFetchingStatus = TreeItem::NONE;\n            emitMessageCountChanged(head);\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::invalidateAllMessageCounts()\n  {\n      QList<TreeItemMailbox*> queue;\n      queue.append(m_mailboxes);\n      while (!queue.isEmpty()) {\n          TreeItemMailbox *head = queue.takeFirst();\n          // ignore first child, the TreeItemMsgList\n          for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n              queue.append(static_cast<TreeItemMailbox*>(*it));\n          }\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n  \n          if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n              // Ask only for data which were previously available\n              // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n              list->m_numberFetchingStatus = TreeItem::NONE;\n              emitMessageCountChanged(head);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eloadMailboxList(",
          "args": [],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "reloadMailboxList(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "832-835",
          "snippet": "oid Model::reloadMailboxList()\n{\n    m_mailboxes->rescanForChildMailboxes(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::reloadMailboxList()\n  {\n      m_mailboxes->rescanForChildMailboxes(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mailboxes->accessFetchStatus",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_periodicMailboxNumbersRefresh->start",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_periodicMailboxNumbersRefresh->stop",
          "args": [],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_periodicMailboxNumbersRefresh->stop",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->logout",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->die",
          "args": [
            "r(\"Going offline\"))"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Going offline\")"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "setImapUser(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1851-1854",
          "snippet": "id Model::setImapUser(const QString &imapUser)\n{\n    m_imapUser = imapUser;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setImapUser(const QString &imapUser)\n  {\n      m_imapUser = imapUser;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_FOREACH(",
          "args": [
            "mapTask *task,",
            "t->activeTasks)"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "_FOREACH(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/PartWidget.cpp",
          "lines": "209-216",
          "snippet": "_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"PartWidgetFactory.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"LoadablePartWidget.h\"\n#",
            "include \"EnvelopeView.h\"\n#",
            "include <QTabBar>",
            "include <QVBoxLayout>\n#",
            "include <QModelIndex>\n#",
            "include <QLabel>\n#",
            "include \"PartWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"PartWidgetFactory.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"LoadablePartWidget.h\"\n#\ninclude \"EnvelopeView.h\"\n#\ninclude <QTabBar>\ninclude <QVBoxLayout>\n#\ninclude <QModelIndex>\n#\ninclude <QLabel>\n#\ninclude \"PartWidget.h\"\n\n_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\"
        }
      },
      {
        "call_info": {
          "callee": "t->maintainingTask->stopForLogout",
          "args": [],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t->parser)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parsers.end",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parsers.begin",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
  },
  {
    "function_name": "resyncMailbox(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "1064-1067",
    "snippet": "oid Model::resyncMailbox(const QModelIndex &mbox)\n{\n    findTaskResponsibleFor(mbox)->resynchronizeMailbox();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "indTaskResponsibleFor",
          "args": [],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor(",
          "args": [
            "box)"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::resyncMailbox(const QModelIndex &mbox)\n  {\n      findTaskResponsibleFor(mbox)->resynchronizeMailbox();\n  }\n}"
  },
  {
    "function_name": "askForMsgPart(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "998-1062",
    "snippet": "oid Model::askForMsgPart(TreeItemPart *item, bool onlyFromCache)\n{\n    Q_ASSERT(item->message());   // TreeItemMessage\n    Q_ASSERT(item->message()->parent());   // TreeItemMsgList\n    Q_ASSERT(item->message()->parent()->parent());   // TreeItemMailbox\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->message()->parent()->parent());\n    Q_ASSERT(mailboxPtr);\n\n    // We are asking for a message part, which means that the structure of a message is already known.\n    // If the UID was zero at this point, it would mean that we are completely doomed.\n    uint uid = static_cast<TreeItemMessage *>(item->message())->uid();\n    Q_ASSERT(uid);\n\n    // Check whether this is a request for fetching the special item representing the raw contents prior to any CTE undoing\n    TreeItemPart *itemForFetchOperation = item;\n    TreeItemModifiedPart *modifiedPart = dynamic_cast<TreeItemModifiedPart*>(item);\n    bool isSpecialRawPart = modifiedPart && modifiedPart->kind() == TreeItem::OFFSET_RAW_CONTENTS;\n    if (isSpecialRawPart) {\n        itemForFetchOperation = dynamic_cast<TreeItemPart*>(item->parent());\n        Q_ASSERT(itemForFetchOperation);\n    }\n\n    const QByteArray &data = cache()->messagePart(mailboxPtr->mailbox(), uid,\n                                                  isSpecialRawPart ?\n                                                      itemForFetchOperation->partId() + QLatin1String(\".X-RAW\")\n                                                    : item->partId());\n    if (! data.isNull()) {\n        item->m_data = data;\n        item->setFetchStatus(TreeItem::DONE);\n        return;\n    }\n\n    if (!isSpecialRawPart) {\n        const QByteArray &data = cache()->messagePart(mailboxPtr->mailbox(), uid,\n                                                      itemForFetchOperation->partId() + QLatin1String(\".X-RAW\"));\n\n        if (!data.isNull()) {\n            Imap::decodeContentTransferEncoding(data, item->encoding(), item->dataPtr());\n            item->setFetchStatus(TreeItem::DONE);\n            return;\n        }\n\n        if (item->m_partRaw && item->m_partRaw->loading()) {\n            // There's already a request for the raw data. Let's use it and don't queue an extra fetch here.\n            item->setFetchStatus(TreeItem::LOADING);\n            return;\n        }\n    }\n\n    if (networkPolicy() == NETWORK_OFFLINE) {\n        if (item->accessFetchStatus() != TreeItem::DONE)\n            item->setFetchStatus(TreeItem::UNAVAILABLE);\n    } else if (! onlyFromCache) {\n        KeepMailboxOpenTask *keepTask = findTaskResponsibleFor(mailboxPtr);\n        TreeItemPart::PartFetchingMode fetchingMode = TreeItemPart::FETCH_PART_IMAP;\n        if (!isSpecialRawPart && keepTask->parser && accessParser(keepTask->parser).capabilitiesFresh &&\n                accessParser(keepTask->parser).capabilities.contains(QLatin1String(\"BINARY\"))) {\n            if (!item->hasChildren(0)) {\n                // The BINARY only actually makes sense on leaf MIME nodes\n                fetchingMode = TreeItemPart::FETCH_PART_BINARY;\n            }\n        }\n        keepTask->requestPartDownload(item->message()->m_uid, itemForFetchOperation->partIdForFetch(fetchingMode), item->octets());\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eepTask->requestPartDownload",
          "args": [
            "tem->message()->m_uid,",
            "temForFetchOperation->partIdForFetch(fetchingMode),",
            "tem->octets())"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->octets",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temForFetchOperation->partIdForFetch",
          "args": [
            "etchingMode)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->hasChildren",
          "args": [
            ")"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser",
          "args": [
            "Latin1String(\"BINARY\"))"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "BINARY\")"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "eepTask->parser)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "eepTask->parser)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etworkPolicy(",
          "args": [],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "desiredNetworkPolicy(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "54-57",
          "snippet": "etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n{\n    return m_desiredPolicy;\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n  {\n      return m_desiredPolicy;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::LOADING)"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->m_partRaw->loading",
          "args": [],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::decodeContentTransferEncoding(",
          "args": [
            "ata,",
            "tem->encoding(),",
            "tem->dataPtr())"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->dataPtr",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->encoding",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata.isNull",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailboxPtr->mailbox(),",
            "id,",
            "temForFetchOperation->partId() + QLatin1String(\".X-RAW\"))"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "forgetMessagePart(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "785-797",
          "snippet": "oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n#endif\n    touchingDB();\n    queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n    queryForgetMessagePart.bindValue(1, uid);\n    queryForgetMessagePart.bindValue(2, partId);\n    if (! queryForgetMessagePart.exec()) {\n        emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n  #endif\n      touchingDB();\n      queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n      queryForgetMessagePart.bindValue(1, uid);\n      queryForgetMessagePart.bindValue(2, partId);\n      if (! queryForgetMessagePart.exec()) {\n          emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ".X-RAW\")"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temForFetchOperation->partId",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata.isNull",
          "args": [],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->partId",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ".X-RAW\")"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temForFetchOperation->partId",
          "args": [],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "temForFetchOperation)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemPart*>",
          "args": [
            "tem->parent())"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->parent",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odifiedPart->kind",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "kind(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1619-1622",
          "snippet": "reeItem::PartModifier TreeItemModifiedPart::kind() const\n{\n    return m_modifier;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  reeItem::PartModifier TreeItemModifiedPart::kind() const\n  {\n      return m_modifier;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemModifiedPart*>",
          "args": [
            "tem)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "id)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "tem->message())"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tem->message()->parent()->parent())"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->message()->parent()->parent())"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->message()->parent())"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->message())"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->message",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForMsgPart(TreeItemPart *item, bool onlyFromCache)\n  {\n      Q_ASSERT(item->message());   // TreeItemMessage\n      Q_ASSERT(item->message()->parent());   // TreeItemMsgList\n      Q_ASSERT(item->message()->parent()->parent());   // TreeItemMailbox\n      TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->message()->parent()->parent());\n      Q_ASSERT(mailboxPtr);\n  \n      // We are asking for a message part, which means that the structure of a message is already known.\n      // If the UID was zero at this point, it would mean that we are completely doomed.\n      uint uid = static_cast<TreeItemMessage *>(item->message())->uid();\n      Q_ASSERT(uid);\n  \n      // Check whether this is a request for fetching the special item representing the raw contents prior to any CTE undoing\n      TreeItemPart *itemForFetchOperation = item;\n      TreeItemModifiedPart *modifiedPart = dynamic_cast<TreeItemModifiedPart*>(item);\n      bool isSpecialRawPart = modifiedPart && modifiedPart->kind() == TreeItem::OFFSET_RAW_CONTENTS;\n      if (isSpecialRawPart) {\n          itemForFetchOperation = dynamic_cast<TreeItemPart*>(item->parent());\n          Q_ASSERT(itemForFetchOperation);\n      }\n  \n      const QByteArray &data = cache()->messagePart(mailboxPtr->mailbox(), uid,\n                                                    isSpecialRawPart ?\n                                                        itemForFetchOperation->partId() + QLatin1String(\".X-RAW\")\n                                                      : item->partId());\n      if (! data.isNull()) {\n          item->m_data = data;\n          item->setFetchStatus(TreeItem::DONE);\n          return;\n      }\n  \n      if (!isSpecialRawPart) {\n          const QByteArray &data = cache()->messagePart(mailboxPtr->mailbox(), uid,\n                                                        itemForFetchOperation->partId() + QLatin1String(\".X-RAW\"));\n  \n          if (!data.isNull()) {\n              Imap::decodeContentTransferEncoding(data, item->encoding(), item->dataPtr());\n              item->setFetchStatus(TreeItem::DONE);\n              return;\n          }\n  \n          if (item->m_partRaw && item->m_partRaw->loading()) {\n              // There's already a request for the raw data. Let's use it and don't queue an extra fetch here.\n              item->setFetchStatus(TreeItem::LOADING);\n              return;\n          }\n      }\n  \n      if (networkPolicy() == NETWORK_OFFLINE) {\n          if (item->accessFetchStatus() != TreeItem::DONE)\n              item->setFetchStatus(TreeItem::UNAVAILABLE);\n      } else if (! onlyFromCache) {\n          KeepMailboxOpenTask *keepTask = findTaskResponsibleFor(mailboxPtr);\n          TreeItemPart::PartFetchingMode fetchingMode = TreeItemPart::FETCH_PART_IMAP;\n          if (!isSpecialRawPart && keepTask->parser && accessParser(keepTask->parser).capabilitiesFresh &&\n                  accessParser(keepTask->parser).capabilities.contains(QLatin1String(\"BINARY\"))) {\n              if (!item->hasChildren(0)) {\n                  // The BINARY only actually makes sense on leaf MIME nodes\n                  fetchingMode = TreeItemPart::FETCH_PART_BINARY;\n              }\n          }\n          keepTask->requestPartDownload(item->message()->m_uid, itemForFetchOperation->partIdForFetch(fetchingMode), item->octets());\n      }\n  }\n}"
  },
  {
    "function_name": "askForMsgMetadata(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "911-996",
    "snippet": "oid Model::askForMsgMetadata(TreeItemMessage *item, const PreloadingMode preloadMode)\n{\n    Q_ASSERT(item->uid());\n    Q_ASSERT(!item->fetched());\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(item->parent());\n    Q_ASSERT(list);\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(list->parent());\n    Q_ASSERT(mailboxPtr);\n\n    if (item->uid()) {\n        AbstractCache::MessageDataBundle data = cache()->messageMetadata(mailboxPtr->mailbox(), item->uid());\n        if (data.uid == item->uid()) {\n            item->data()->m_envelope = data.envelope;\n            item->data()->m_size = data.size;\n            item->data()->m_hdrReferences = data.hdrReferences;\n            item->data()->m_hdrListPost = data.hdrListPost;\n            item->data()->m_hdrListPostNo = data.hdrListPostNo;\n            QDataStream stream(&data.serializedBodyStructure, QIODevice::ReadOnly);\n            stream.setVersion(QDataStream::Qt_4_6);\n            QVariantList unserialized;\n            stream >> unserialized;\n            QSharedPointer<Message::AbstractMessage> abstractMessage;\n            try {\n                abstractMessage = Message::AbstractMessage::fromList(unserialized, QByteArray(), 0);\n            } catch (Imap::ParserException &e) {\n                qDebug() << \"Error when parsing cached BODYSTRUCTURE\" << e.what();\n            }\n            if (! abstractMessage) {\n                item->setFetchStatus(TreeItem::UNAVAILABLE);\n            } else {\n                auto newChildren = abstractMessage->createTreeItems(item);\n                if (item->m_children.isEmpty()) {\n                    TreeItemChildrenList oldChildren = item->setChildren(newChildren);\n                    Q_ASSERT(oldChildren.size() == 0);\n                } else {\n                    // The following assert guards against that crazy signal emitting we had when various askFor*()\n                    // functions were not delayed. If it gets hit, it means that someone tried to call this function\n                    // on an item which was already loaded.\n                    Q_ASSERT(item->m_children.isEmpty());\n                    item->setChildren(newChildren);\n                }\n                item->setFetchStatus(TreeItem::DONE);\n            }\n        }\n    }\n\n    switch (networkPolicy()) {\n    case NETWORK_OFFLINE:\n        if (item->accessFetchStatus() != TreeItem::DONE)\n            item->setFetchStatus(TreeItem::UNAVAILABLE);\n        break;\n    case NETWORK_EXPENSIVE:\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n        break;\n    case NETWORK_ONLINE:\n    {\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n\n        // preload\n        if (preloadMode != PRELOAD_PER_POLICY)\n            break;\n        bool ok;\n        int preload = property(\"trojita-imap-preload-msg-metadata\").toInt(&ok);\n        if (! ok)\n            preload = 50;\n        int order = item->row();\n        for (int i = qMax(0, order - preload); i < qMin(list->m_children.size(), order + preload); ++i) {\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(list->m_children[i]);\n            Q_ASSERT(message);\n            if (item != message && !message->fetched() && !message->loading() && message->uid()) {\n                message->setFetchStatus(TreeItem::LOADING);\n                // cannot ask the KeepTask directly, that'd completely ignore the cache\n                // but we absolutely have to block the preload :)\n                askForMsgMetadata(message, PRELOAD_DISABLED);\n            }\n        }\n    }\n    break;\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForMsgMetadata(",
          "args": [
            "essage,",
            "RELOAD_DISABLED)"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "askForMsgMetadata(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "911-996",
          "snippet": "oid Model::askForMsgMetadata(TreeItemMessage *item, const PreloadingMode preloadMode)\n{\n    Q_ASSERT(item->uid());\n    Q_ASSERT(!item->fetched());\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(item->parent());\n    Q_ASSERT(list);\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(list->parent());\n    Q_ASSERT(mailboxPtr);\n\n    if (item->uid()) {\n        AbstractCache::MessageDataBundle data = cache()->messageMetadata(mailboxPtr->mailbox(), item->uid());\n        if (data.uid == item->uid()) {\n            item->data()->m_envelope = data.envelope;\n            item->data()->m_size = data.size;\n            item->data()->m_hdrReferences = data.hdrReferences;\n            item->data()->m_hdrListPost = data.hdrListPost;\n            item->data()->m_hdrListPostNo = data.hdrListPostNo;\n            QDataStream stream(&data.serializedBodyStructure, QIODevice::ReadOnly);\n            stream.setVersion(QDataStream::Qt_4_6);\n            QVariantList unserialized;\n            stream >> unserialized;\n            QSharedPointer<Message::AbstractMessage> abstractMessage;\n            try {\n                abstractMessage = Message::AbstractMessage::fromList(unserialized, QByteArray(), 0);\n            } catch (Imap::ParserException &e) {\n                qDebug() << \"Error when parsing cached BODYSTRUCTURE\" << e.what();\n            }\n            if (! abstractMessage) {\n                item->setFetchStatus(TreeItem::UNAVAILABLE);\n            } else {\n                auto newChildren = abstractMessage->createTreeItems(item);\n                if (item->m_children.isEmpty()) {\n                    TreeItemChildrenList oldChildren = item->setChildren(newChildren);\n                    Q_ASSERT(oldChildren.size() == 0);\n                } else {\n                    // The following assert guards against that crazy signal emitting we had when various askFor*()\n                    // functions were not delayed. If it gets hit, it means that someone tried to call this function\n                    // on an item which was already loaded.\n                    Q_ASSERT(item->m_children.isEmpty());\n                    item->setChildren(newChildren);\n                }\n                item->setFetchStatus(TreeItem::DONE);\n            }\n        }\n    }\n\n    switch (networkPolicy()) {\n    case NETWORK_OFFLINE:\n        if (item->accessFetchStatus() != TreeItem::DONE)\n            item->setFetchStatus(TreeItem::UNAVAILABLE);\n        break;\n    case NETWORK_EXPENSIVE:\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n        break;\n    case NETWORK_ONLINE:\n    {\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n\n        // preload\n        if (preloadMode != PRELOAD_PER_POLICY)\n            break;\n        bool ok;\n        int preload = property(\"trojita-imap-preload-msg-metadata\").toInt(&ok);\n        if (! ok)\n            preload = 50;\n        int order = item->row();\n        for (int i = qMax(0, order - preload); i < qMin(list->m_children.size(), order + preload); ++i) {\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(list->m_children[i]);\n            Q_ASSERT(message);\n            if (item != message && !message->fetched() && !message->loading() && message->uid()) {\n                message->setFetchStatus(TreeItem::LOADING);\n                // cannot ask the KeepTask directly, that'd completely ignore the cache\n                // but we absolutely have to block the preload :)\n                askForMsgMetadata(message, PRELOAD_DISABLED);\n            }\n        }\n    }\n    break;\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "essage->setFetchStatus",
          "args": [
            "reeItem::LOADING)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage->uid",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "uid(",
          "container": "reeItemMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1215-1218",
          "snippet": "int TreeItemMessage::uid() const\n{\n    return m_uid;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMessage {\n  int TreeItemMessage::uid() const\n  {\n      return m_uid;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage->loading",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage->fetched",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min(",
          "args": [
            "ist->m_children.size(),",
            "rder + preload)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            ",",
            "rder - preload)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->row",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "row(",
          "container": "reeItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "94-97",
          "snippet": "nt TreeItem::row() const\n{\n    return parent() ? parent()->m_children.indexOf(const_cast<TreeItem *>(this)) : 0;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItem {\n  nt TreeItem::row() const\n  {\n      return parent() ? parent()->m_children.indexOf(const_cast<TreeItem *>(this)) : 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roperty",
          "args": [
            "ok)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roperty(",
          "args": [
            "trojita-imap-preload-msg-metadata\")"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor",
          "args": [
            "tem->uid())"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::LOADING)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor",
          "args": [
            "tem->uid())"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indTaskResponsibleFor(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::LOADING)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etworkPolicy(",
          "args": [],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "desiredNetworkPolicy(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "54-57",
          "snippet": "etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n{\n    return m_desiredPolicy;\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n  {\n      return m_desiredPolicy;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setChildren",
          "args": [
            "ewChildren)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "setChildren(",
          "container": "reeItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "99-105",
          "snippet": "reeItemChildrenList TreeItem::setChildren(const TreeItemChildrenList &items)\n{\n    auto res = m_children;\n    m_children = items;\n    setFetchStatus(DONE);\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItem {\n  reeItemChildrenList TreeItem::setChildren(const TreeItemChildrenList &items)\n  {\n      auto res = m_children;\n      m_children = items;\n      setFetchStatus(DONE);\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->m_children.isEmpty())"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->m_children.isEmpty",
          "args": [],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ldChildren.size() == 0)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldChildren.size",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->m_children.isEmpty",
          "args": [],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bstractMessage->createTreeItems",
          "args": [
            "tem)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".what",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage::AbstractMessage::fromList(",
          "args": [
            "nserialized,",
            "ByteArray(),",
            ")"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "fromList(",
          "container": "bstractMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Message.cpp",
          "lines": "394-638",
          "snippet": "SharedPointer<AbstractMessage> AbstractMessage::fromList(const QVariantList &items, const QByteArray &line, const int start)\n{\n    if (items.size() < 2)\n        throw NoData(\"AbstractMessage::fromList: no data\", line, start);\n\n    if (items[0].type() == QVariant::ByteArray) {\n        // it's a single-part message, hurray\n\n        int i = 0;\n        QString mediaType = items[i].toString().toLower();\n        ++i;\n        QString mediaSubType = items[i].toString().toLower();\n        ++i;\n\n        if (items.size() < 7) {\n            qDebug() << \"AbstractMessage::fromList(): body-type-basic(?): yuck, too few items, using what we've got\";\n        }\n\n        bodyFldParam_t bodyFldParam;\n        if (i < items.size()) {\n            bodyFldParam = makeBodyFldParam(items[i], line, start);\n            ++i;\n        }\n\n        QByteArray bodyFldId;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-id not recognized as a ByteArray\", line, start);\n            bodyFldId = items[i].toByteArray();\n            ++i;\n        }\n\n        QByteArray bodyFldDesc;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-desc not recognized as a ByteArray\", line, start);\n            bodyFldDesc = items[i].toByteArray();\n            ++i;\n        }\n\n        QByteArray bodyFldEnc;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-enc not recognized as a ByteArray\", line, start);\n            bodyFldEnc = items[i].toByteArray();\n            ++i;\n        }\n\n        uint bodyFldOctets = 0;\n        if (i < items.size()) {\n            bodyFldOctets = extractUInt(items[i], line, start);\n            ++i;\n        }\n\n        uint bodyFldLines = 0;\n        Envelope envelope;\n        QSharedPointer<AbstractMessage> body;\n\n        enum { MESSAGE, TEXT, BASIC} kind;\n\n        if (mediaType == QLatin1String(\"message\") && mediaSubType == QLatin1String(\"rfc822\")) {\n            // extract envelope, body, body-fld-lines\n\n            if (items.size() < 10)\n                throw NoData(\"too few fields for a Message-message\", line, start);\n\n            kind = MESSAGE;\n            if (items[i].type() == QVariant::ByteArray && items[i].toByteArray().isEmpty()) {\n                // ENVELOPE is NIL, this shouldn't really happen\n                qDebug() << \"AbstractMessage::fromList(): message/rfc822: yuck, got NIL for envelope\";\n            } else if (items[i].type() != QVariant::List) {\n                throw UnexpectedHere(\"message/rfc822: envelope not a list\", line, start);\n            } else {\n                envelope = Envelope::fromList(items[i].toList(), line, start);\n            }\n            ++i;\n\n            if (items[i].type() != QVariant::List)\n                throw UnexpectedHere(\"message/rfc822: body not recognized as a list\", line, start);\n            body = AbstractMessage::fromList(items[i].toList(), line, start);\n            ++i;\n\n            try {\n                bodyFldLines = extractUInt(items[i], line, start);\n            } catch (const UnexpectedHere &) {\n                qDebug() << \"AbstractMessage::fromList(): message/rfc822: yuck, invalid body-fld-lines\";\n            }\n            ++i;\n\n        } else if (mediaType == QLatin1String(\"text\")) {\n            kind = TEXT;\n            if (i < items.size()) {\n                // extract body-fld-lines\n                bodyFldLines = extractUInt(items[i], line, start);\n                ++i;\n            }\n        } else {\n            // don't extract anything as we're done here\n            kind = BASIC;\n        }\n\n        // extract body-ext-1part\n\n        // body-fld-md5\n        QByteArray bodyFldMd5;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-md5 not a ByteArray\", line, start);\n            bodyFldMd5 = items[i].toByteArray();\n            ++i;\n        }\n\n        // body-fld-dsp\n        bodyFldDsp_t bodyFldDsp;\n        if (i < items.size()) {\n            bodyFldDsp = makeBodyFldDsp(items[i], line, start);\n            ++i;\n        }\n\n        // body-fld-lang\n        QList<QByteArray> bodyFldLang;\n        if (i < items.size()) {\n            bodyFldLang = makeBodyFldLang(items[i], line, start);\n            ++i;\n        }\n\n        // body-fld-loc\n        QByteArray bodyFldLoc;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-loc not found\", line, start);\n            bodyFldLoc = items[i].toByteArray();\n            ++i;\n        }\n\n        // body-extension\n        QVariant bodyExtension;\n        if (i < items.size()) {\n            if (i == items.size() - 1) {\n                bodyExtension = items[i];\n                ++i;\n            } else {\n                QVariantList list;\n                for (; i < items.size(); ++i)\n                    list << items[i];\n                bodyExtension = list;\n            }\n        }\n\n        switch (kind) {\n        case MESSAGE:\n            return QSharedPointer<AbstractMessage>(\n                       new MsgMessage(mediaType, mediaSubType, bodyFldParam,\n                                      bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                      bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                      bodyExtension, envelope, body, bodyFldLines)\n                   );\n        case TEXT:\n            return QSharedPointer<AbstractMessage>(\n                       new TextMessage(mediaType, mediaSubType, bodyFldParam,\n                                       bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                       bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                       bodyExtension, bodyFldLines)\n                   );\n        case BASIC:\n        default:\n            return QSharedPointer<AbstractMessage>(\n                       new BasicMessage(mediaType, mediaSubType, bodyFldParam,\n                                        bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                        bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                        bodyExtension)\n                   );\n        }\n\n    } else if (items[0].type() == QVariant::List) {\n\n        if (items.size() < 2)\n            throw ParseError(\"body-type-mpart: structure should be \\\"body* string\\\"\", line, start);\n\n        int i = 0;\n\n        QList<QSharedPointer<AbstractMessage> > bodies;\n        while (items[i].type() == QVariant::List) {\n            bodies << fromList(items[i].toList(), line, start);\n            ++i;\n        }\n\n        if (items[i].type() != QVariant::ByteArray)\n            throw UnexpectedHere(\"body-type-mpart: media-subtype not recognized\", line, start);\n        QString mediaSubType = items[i].toString().toLower();\n        ++i;\n\n        // body-ext-mpart\n\n        // body-fld-param\n        bodyFldParam_t bodyFldParam;\n        if (i < items.size()) {\n            bodyFldParam = makeBodyFldParam(items[i], line, start);\n            ++i;\n        }\n\n        // body-fld-dsp\n        bodyFldDsp_t bodyFldDsp;\n        if (i < items.size()) {\n            bodyFldDsp = makeBodyFldDsp(items[i], line, start);\n            ++i;\n        }\n\n        // body-fld-lang\n        QList<QByteArray> bodyFldLang;\n        if (i < items.size()) {\n            bodyFldLang = makeBodyFldLang(items[i], line, start);\n            ++i;\n        }\n\n        // body-fld-loc\n        QByteArray bodyFldLoc;\n        if (i < items.size()) {\n            if (items[i].type() != QVariant::ByteArray)\n                throw UnexpectedHere(\"body-fld-loc not found\", line, start);\n            bodyFldLoc = items[i].toByteArray();\n            ++i;\n        }\n\n        // body-extension\n        QVariant bodyExtension;\n        if (i < items.size()) {\n            if (i == items.size() - 1) {\n                bodyExtension = items[i];\n                ++i;\n            } else {\n                QVariantList list;\n                for (; i < items.size(); ++i)\n                    list << items[i];\n                bodyExtension = list;\n            }\n        }\n\n        return QSharedPointer<AbstractMessage>(\n                   new MultiMessage(bodies, mediaSubType, bodyFldParam,\n                                    bodyFldDsp, bodyFldLang, bodyFldLoc, bodyExtension));\n    } else {\n        throw UnexpectedHere(\"AbstractMessage::fromList: invalid data type of first item\", line, start);\n    }\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include \"Message.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude \"Message.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nbstractMessage {\n  SharedPointer<AbstractMessage> AbstractMessage::fromList(const QVariantList &items, const QByteArray &line, const int start)\n  {\n      if (items.size() < 2)\n          throw NoData(\"AbstractMessage::fromList: no data\", line, start);\n  \n      if (items[0].type() == QVariant::ByteArray) {\n          // it's a single-part message, hurray\n  \n          int i = 0;\n          QString mediaType = items[i].toString().toLower();\n          ++i;\n          QString mediaSubType = items[i].toString().toLower();\n          ++i;\n  \n          if (items.size() < 7) {\n              qDebug() << \"AbstractMessage::fromList(): body-type-basic(?): yuck, too few items, using what we've got\";\n          }\n  \n          bodyFldParam_t bodyFldParam;\n          if (i < items.size()) {\n              bodyFldParam = makeBodyFldParam(items[i], line, start);\n              ++i;\n          }\n  \n          QByteArray bodyFldId;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-id not recognized as a ByteArray\", line, start);\n              bodyFldId = items[i].toByteArray();\n              ++i;\n          }\n  \n          QByteArray bodyFldDesc;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-desc not recognized as a ByteArray\", line, start);\n              bodyFldDesc = items[i].toByteArray();\n              ++i;\n          }\n  \n          QByteArray bodyFldEnc;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-enc not recognized as a ByteArray\", line, start);\n              bodyFldEnc = items[i].toByteArray();\n              ++i;\n          }\n  \n          uint bodyFldOctets = 0;\n          if (i < items.size()) {\n              bodyFldOctets = extractUInt(items[i], line, start);\n              ++i;\n          }\n  \n          uint bodyFldLines = 0;\n          Envelope envelope;\n          QSharedPointer<AbstractMessage> body;\n  \n          enum { MESSAGE, TEXT, BASIC} kind;\n  \n          if (mediaType == QLatin1String(\"message\") && mediaSubType == QLatin1String(\"rfc822\")) {\n              // extract envelope, body, body-fld-lines\n  \n              if (items.size() < 10)\n                  throw NoData(\"too few fields for a Message-message\", line, start);\n  \n              kind = MESSAGE;\n              if (items[i].type() == QVariant::ByteArray && items[i].toByteArray().isEmpty()) {\n                  // ENVELOPE is NIL, this shouldn't really happen\n                  qDebug() << \"AbstractMessage::fromList(): message/rfc822: yuck, got NIL for envelope\";\n              } else if (items[i].type() != QVariant::List) {\n                  throw UnexpectedHere(\"message/rfc822: envelope not a list\", line, start);\n              } else {\n                  envelope = Envelope::fromList(items[i].toList(), line, start);\n              }\n              ++i;\n  \n              if (items[i].type() != QVariant::List)\n                  throw UnexpectedHere(\"message/rfc822: body not recognized as a list\", line, start);\n              body = AbstractMessage::fromList(items[i].toList(), line, start);\n              ++i;\n  \n              try {\n                  bodyFldLines = extractUInt(items[i], line, start);\n              } catch (const UnexpectedHere &) {\n                  qDebug() << \"AbstractMessage::fromList(): message/rfc822: yuck, invalid body-fld-lines\";\n              }\n              ++i;\n  \n          } else if (mediaType == QLatin1String(\"text\")) {\n              kind = TEXT;\n              if (i < items.size()) {\n                  // extract body-fld-lines\n                  bodyFldLines = extractUInt(items[i], line, start);\n                  ++i;\n              }\n          } else {\n              // don't extract anything as we're done here\n              kind = BASIC;\n          }\n  \n          // extract body-ext-1part\n  \n          // body-fld-md5\n          QByteArray bodyFldMd5;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-md5 not a ByteArray\", line, start);\n              bodyFldMd5 = items[i].toByteArray();\n              ++i;\n          }\n  \n          // body-fld-dsp\n          bodyFldDsp_t bodyFldDsp;\n          if (i < items.size()) {\n              bodyFldDsp = makeBodyFldDsp(items[i], line, start);\n              ++i;\n          }\n  \n          // body-fld-lang\n          QList<QByteArray> bodyFldLang;\n          if (i < items.size()) {\n              bodyFldLang = makeBodyFldLang(items[i], line, start);\n              ++i;\n          }\n  \n          // body-fld-loc\n          QByteArray bodyFldLoc;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-loc not found\", line, start);\n              bodyFldLoc = items[i].toByteArray();\n              ++i;\n          }\n  \n          // body-extension\n          QVariant bodyExtension;\n          if (i < items.size()) {\n              if (i == items.size() - 1) {\n                  bodyExtension = items[i];\n                  ++i;\n              } else {\n                  QVariantList list;\n                  for (; i < items.size(); ++i)\n                      list << items[i];\n                  bodyExtension = list;\n              }\n          }\n  \n          switch (kind) {\n          case MESSAGE:\n              return QSharedPointer<AbstractMessage>(\n                         new MsgMessage(mediaType, mediaSubType, bodyFldParam,\n                                        bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                        bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                        bodyExtension, envelope, body, bodyFldLines)\n                     );\n          case TEXT:\n              return QSharedPointer<AbstractMessage>(\n                         new TextMessage(mediaType, mediaSubType, bodyFldParam,\n                                         bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                         bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                         bodyExtension, bodyFldLines)\n                     );\n          case BASIC:\n          default:\n              return QSharedPointer<AbstractMessage>(\n                         new BasicMessage(mediaType, mediaSubType, bodyFldParam,\n                                          bodyFldId, bodyFldDesc, bodyFldEnc, bodyFldOctets,\n                                          bodyFldMd5, bodyFldDsp, bodyFldLang, bodyFldLoc,\n                                          bodyExtension)\n                     );\n          }\n  \n      } else if (items[0].type() == QVariant::List) {\n  \n          if (items.size() < 2)\n              throw ParseError(\"body-type-mpart: structure should be \\\"body* string\\\"\", line, start);\n  \n          int i = 0;\n  \n          QList<QSharedPointer<AbstractMessage> > bodies;\n          while (items[i].type() == QVariant::List) {\n              bodies << fromList(items[i].toList(), line, start);\n              ++i;\n          }\n  \n          if (items[i].type() != QVariant::ByteArray)\n              throw UnexpectedHere(\"body-type-mpart: media-subtype not recognized\", line, start);\n          QString mediaSubType = items[i].toString().toLower();\n          ++i;\n  \n          // body-ext-mpart\n  \n          // body-fld-param\n          bodyFldParam_t bodyFldParam;\n          if (i < items.size()) {\n              bodyFldParam = makeBodyFldParam(items[i], line, start);\n              ++i;\n          }\n  \n          // body-fld-dsp\n          bodyFldDsp_t bodyFldDsp;\n          if (i < items.size()) {\n              bodyFldDsp = makeBodyFldDsp(items[i], line, start);\n              ++i;\n          }\n  \n          // body-fld-lang\n          QList<QByteArray> bodyFldLang;\n          if (i < items.size()) {\n              bodyFldLang = makeBodyFldLang(items[i], line, start);\n              ++i;\n          }\n  \n          // body-fld-loc\n          QByteArray bodyFldLoc;\n          if (i < items.size()) {\n              if (items[i].type() != QVariant::ByteArray)\n                  throw UnexpectedHere(\"body-fld-loc not found\", line, start);\n              bodyFldLoc = items[i].toByteArray();\n              ++i;\n          }\n  \n          // body-extension\n          QVariant bodyExtension;\n          if (i < items.size()) {\n              if (i == items.size() - 1) {\n                  bodyExtension = items[i];\n                  ++i;\n              } else {\n                  QVariantList list;\n                  for (; i < items.size(); ++i)\n                      list << items[i];\n                  bodyExtension = list;\n              }\n          }\n  \n          return QSharedPointer<AbstractMessage>(\n                     new MultiMessage(bodies, mediaSubType, bodyFldParam,\n                                      bodyFldDsp, bodyFldLang, bodyFldLoc, bodyExtension));\n      } else {\n          throw UnexpectedHere(\"AbstractMessage::fromList: invalid data type of first item\", line, start);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "DataStream::Qt_4_6)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->data",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailboxPtr->mailbox(),",
            "tem->uid())"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "setMessageThreading(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "815-831",
          "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "ist->parent())"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->parent",
          "args": [],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "tem->parent())"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "item->fetched())"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->fetched",
          "args": [],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->uid())"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->uid",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForMsgMetadata(TreeItemMessage *item, const PreloadingMode preloadMode)\n  {\n      Q_ASSERT(item->uid());\n      Q_ASSERT(!item->fetched());\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(item->parent());\n      Q_ASSERT(list);\n      TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(list->parent());\n      Q_ASSERT(mailboxPtr);\n  \n      if (item->uid()) {\n          AbstractCache::MessageDataBundle data = cache()->messageMetadata(mailboxPtr->mailbox(), item->uid());\n          if (data.uid == item->uid()) {\n              item->data()->m_envelope = data.envelope;\n              item->data()->m_size = data.size;\n              item->data()->m_hdrReferences = data.hdrReferences;\n              item->data()->m_hdrListPost = data.hdrListPost;\n              item->data()->m_hdrListPostNo = data.hdrListPostNo;\n              QDataStream stream(&data.serializedBodyStructure, QIODevice::ReadOnly);\n              stream.setVersion(QDataStream::Qt_4_6);\n              QVariantList unserialized;\n              stream >> unserialized;\n              QSharedPointer<Message::AbstractMessage> abstractMessage;\n              try {\n                  abstractMessage = Message::AbstractMessage::fromList(unserialized, QByteArray(), 0);\n              } catch (Imap::ParserException &e) {\n                  qDebug() << \"Error when parsing cached BODYSTRUCTURE\" << e.what();\n              }\n              if (! abstractMessage) {\n                  item->setFetchStatus(TreeItem::UNAVAILABLE);\n              } else {\n                  auto newChildren = abstractMessage->createTreeItems(item);\n                  if (item->m_children.isEmpty()) {\n                      TreeItemChildrenList oldChildren = item->setChildren(newChildren);\n                      Q_ASSERT(oldChildren.size() == 0);\n                  } else {\n                      // The following assert guards against that crazy signal emitting we had when various askFor*()\n                      // functions were not delayed. If it gets hit, it means that someone tried to call this function\n                      // on an item which was already loaded.\n                      Q_ASSERT(item->m_children.isEmpty());\n                      item->setChildren(newChildren);\n                  }\n                  item->setFetchStatus(TreeItem::DONE);\n              }\n          }\n      }\n  \n      switch (networkPolicy()) {\n      case NETWORK_OFFLINE:\n          if (item->accessFetchStatus() != TreeItem::DONE)\n              item->setFetchStatus(TreeItem::UNAVAILABLE);\n          break;\n      case NETWORK_EXPENSIVE:\n          if (item->accessFetchStatus() != TreeItem::DONE) {\n              item->setFetchStatus(TreeItem::LOADING);\n              findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n          }\n          break;\n      case NETWORK_ONLINE:\n      {\n          if (item->accessFetchStatus() != TreeItem::DONE) {\n              item->setFetchStatus(TreeItem::LOADING);\n              findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n          }\n  \n          // preload\n          if (preloadMode != PRELOAD_PER_POLICY)\n              break;\n          bool ok;\n          int preload = property(\"trojita-imap-preload-msg-metadata\").toInt(&ok);\n          if (! ok)\n              preload = 50;\n          int order = item->row();\n          for (int i = qMax(0, order - preload); i < qMin(list->m_children.size(), order + preload); ++i) {\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(list->m_children[i]);\n              Q_ASSERT(message);\n              if (item != message && !message->fetched() && !message->loading() && message->uid()) {\n                  message->setFetchStatus(TreeItem::LOADING);\n                  // cannot ask the KeepTask directly, that'd completely ignore the cache\n                  // but we absolutely have to block the preload :)\n                  askForMsgMetadata(message, PRELOAD_DISABLED);\n              }\n          }\n      }\n      break;\n      }\n  }\n}"
  },
  {
    "function_name": "askForNumberOfMessages(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "889-909",
    "snippet": "oid Model::askForNumberOfMessages(TreeItemMsgList *item)\n{\n    Q_ASSERT(item->parent());\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->parent());\n    Q_ASSERT(mailboxPtr);\n\n    if (networkPolicy() == NETWORK_OFFLINE) {\n        Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailboxPtr->mailbox());\n        if (syncState.isUsableForNumbers()) {\n            item->m_unreadMessageCount = syncState.unSeenCount();\n            item->m_totalMessageCount = syncState.exists();\n            item->m_recentMessageCount = syncState.recent();\n            item->m_numberFetchingStatus = TreeItem::DONE;\n            emitMessageCountChanged(mailboxPtr);\n        } else {\n            item->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n        }\n    } else {\n        m_taskFactory->createNumberOfMessagesTask(this, mailboxPtr->toIndex(this));\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_taskFactory->createNumberOfMessagesTask",
          "args": [
            "his,",
            "ailboxPtr->toIndex(this))"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->toIndex",
          "args": [
            "his)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mitMessageCountChanged(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "emitMessageCountChanged(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "495-501",
          "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.recent",
          "args": [],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "recent(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "86-89",
          "snippet": "int SyncState::recent() const\n{\n    return m_recent;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::recent() const\n  {\n      return m_recent;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.exists",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "exists(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "53-56",
          "snippet": "int SyncState::exists() const\n{\n    return m_exists;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::exists() const\n  {\n      return m_exists;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.unSeenCount",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "unSeenCount(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "119-122",
          "snippet": "int SyncState::unSeenCount() const\n{\n    return m_unSeenCount;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::unSeenCount() const\n  {\n      return m_unSeenCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.isUsableForNumbers",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "isUsableForNumbers(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "38-41",
          "snippet": "ool SyncState::isUsableForNumbers() const\n{\n    return m_hasExists && m_hasRecent && m_hasUnSeenCount;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  ool SyncState::isUsableForNumbers() const\n  {\n      return m_hasExists && m_hasRecent && m_hasUnSeenCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailboxPtr->mailbox())"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "setCache(A",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1505-1511",
          "snippet": "id Model::setCache(AbstractCache *cache)\n{\n    if (m_cache)\n        m_cache->deleteLater();\n    m_cache = cache;\n    m_cache->setParent(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCache(AbstractCache *cache)\n  {\n      if (m_cache)\n          m_cache->deleteLater();\n      m_cache = cache;\n      m_cache->setParent(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etworkPolicy(",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "desiredNetworkPolicy(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "54-57",
          "snippet": "etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n{\n    return m_desiredPolicy;\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n  {\n      return m_desiredPolicy;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tem->parent())"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->parent",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->parent())"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForNumberOfMessages(TreeItemMsgList *item)\n  {\n      Q_ASSERT(item->parent());\n      TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->parent());\n      Q_ASSERT(mailboxPtr);\n  \n      if (networkPolicy() == NETWORK_OFFLINE) {\n          Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailboxPtr->mailbox());\n          if (syncState.isUsableForNumbers()) {\n              item->m_unreadMessageCount = syncState.unSeenCount();\n              item->m_totalMessageCount = syncState.exists();\n              item->m_recentMessageCount = syncState.recent();\n              item->m_numberFetchingStatus = TreeItem::DONE;\n              emitMessageCountChanged(mailboxPtr);\n          } else {\n              item->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n          }\n      } else {\n          m_taskFactory->createNumberOfMessagesTask(this, mailboxPtr->toIndex(this));\n      }\n  }\n}"
  },
  {
    "function_name": "askForMessagesInMailbox(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "837-887",
    "snippet": "oid Model::askForMessagesInMailbox(TreeItemMsgList *item)\n{\n    Q_ASSERT(item->parent());\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->parent());\n    Q_ASSERT(mailboxPtr);\n\n    QString mailbox = mailboxPtr->mailbox();\n\n    Q_ASSERT(item->m_children.size() == 0);\n\n    QList<uint> uidMapping = cache()->uidMapping(mailbox);\n    auto oldSyncState = cache()->mailboxSyncState(mailbox);\n    if (networkPolicy() == NETWORK_OFFLINE && oldSyncState.isUsableForSyncing()\n            && static_cast<uint>(uidMapping.size()) != oldSyncState.exists()) {\n        // Problem with the cached data\n        qDebug() << \"UID cache stale for mailbox\" << mailbox\n                 << \"(\" << uidMapping.size() << \"in UID cache vs.\" << oldSyncState.exists() << \"in the sync state and\"\n                 << item->m_totalMessageCount << \"as totalMessageCount (possibly updated by STATUS))\";\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n    } else if (networkPolicy() == NETWORK_OFFLINE && !oldSyncState.isUsableForSyncing()) {\n        // Nothing in the cache\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n    } else if (oldSyncState.isUsableForSyncing()) {\n        // We can pre-populate the tree with data from cache\n        Q_ASSERT(item->m_children.isEmpty());\n        Q_ASSERT(item->accessFetchStatus() == TreeItem::LOADING);\n        QModelIndex listIndex = item->toIndex(this);\n        if (uidMapping.size()) {\n            beginInsertRows(listIndex, 0, uidMapping.size() - 1);\n            for (uint seq = 0; seq < static_cast<uint>(uidMapping.size()); ++seq) {\n                TreeItemMessage *message = new TreeItemMessage(item);\n                message->m_offset = seq;\n                message->m_uid = uidMapping[seq];\n                item->m_children << message;\n                QStringList flags = cache()->msgFlags(mailbox, message->m_uid);\n                flags.removeOne(QLatin1String(\"\\\\Recent\"));\n                message->m_flags = normalizeFlags(flags);\n            }\n            endInsertRows();\n        }\n        mailboxPtr->syncState = oldSyncState;\n        item->setFetchStatus(TreeItem::DONE); // required for FETCH processing later on\n        // The list of messages was satisfied from cache. Do the same for the message counts, if applicable\n        item->recalcVariousMessageCounts(this);\n    }\n\n    if (networkPolicy() != NETWORK_OFFLINE) {\n        findTaskResponsibleFor(mailboxPtr);\n        // and that's all -- the task will detect following replies and sync automatically\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "indTaskResponsibleFor(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etworkPolicy(",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "desiredNetworkPolicy(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "54-57",
          "snippet": "etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n{\n    return m_desiredPolicy;\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n  {\n      return m_desiredPolicy;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->recalcVariousMessageCounts",
          "args": [
            "his)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ormalizeFlags(",
          "args": [
            "lags)"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "normalizeFlags(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1813-1848",
          "snippet": "tringList Model::normalizeFlags(const QStringList &source) const\n{\n    QStringList res;\n#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\n    res.reserve(source.size());\n#endif\n    for (QStringList::const_iterator flag = source.constBegin(); flag != source.constEnd(); ++flag) {\n\n        // At first, perform a case-insensitive lookup in the (rather short) list of known special flags\n        // Only call the toLower for flags which could possibly be in that mapping. Looking at the first letter is\n        // a good approximation.\n        if (!flag->isEmpty() && ((*flag)[0] == QLatin1Char('\\\\') || (*flag)[0] == QLatin1Char('$'))) {\n            QString lowerCase = flag->toLower();\n            QHash<QString,QString>::const_iterator known = m_specialFlagNames.constFind(lowerCase);\n            if (known != m_specialFlagNames.constEnd()) {\n                res.append(*known);\n                continue;\n            }\n        }\n\n        // If it isn't a special flag, just check whether it's been encountered already\n        QSet<QString>::const_iterator it = m_flagLiterals.constFind(*flag);\n        if (it == m_flagLiterals.constEnd()) {\n            // Not in cache, so add it and return an implicitly shared copy\n            m_flagLiterals.insert(*flag);\n            res.append(*flag);\n        } else {\n            // It's in the cache already, se let's QString share the data\n            res.append(*it);\n        }\n    }\n    // Always sort the flags when performing normalization to obtain reasonable results and be ready for possible future\n    // deduplication of the actual QLists\n    res.sort();\n    return res;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  tringList Model::normalizeFlags(const QStringList &source) const\n  {\n      QStringList res;\n  #if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)\n      res.reserve(source.size());\n  #endif\n      for (QStringList::const_iterator flag = source.constBegin(); flag != source.constEnd(); ++flag) {\n  \n          // At first, perform a case-insensitive lookup in the (rather short) list of known special flags\n          // Only call the toLower for flags which could possibly be in that mapping. Looking at the first letter is\n          // a good approximation.\n          if (!flag->isEmpty() && ((*flag)[0] == QLatin1Char('\\\\') || (*flag)[0] == QLatin1Char('$'))) {\n              QString lowerCase = flag->toLower();\n              QHash<QString,QString>::const_iterator known = m_specialFlagNames.constFind(lowerCase);\n              if (known != m_specialFlagNames.constEnd()) {\n                  res.append(*known);\n                  continue;\n              }\n          }\n  \n          // If it isn't a special flag, just check whether it's been encountered already\n          QSet<QString>::const_iterator it = m_flagLiterals.constFind(*flag);\n          if (it == m_flagLiterals.constEnd()) {\n              // Not in cache, so add it and return an implicitly shared copy\n              m_flagLiterals.insert(*flag);\n              res.append(*flag);\n          } else {\n              // It's in the cache already, se let's QString share the data\n              res.append(*it);\n          }\n      }\n      // Always sort the flags when performing normalization to obtain reasonable results and be ready for possible future\n      // deduplication of the actual QLists\n      res.sort();\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lags.removeOne",
          "args": [
            "Latin1String(\"\\\\Recent\"))"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\\\Recent\")"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailbox,",
            "essage->m_uid)"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "setMessageThreading(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "815-831",
          "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "idMapping.size())"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMapping.size",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "istIndex,",
            ",",
            "idMapping.size() - 1)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMapping.size",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMapping.size",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->toIndex",
          "args": [
            "his)"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "toIndex(",
          "container": "reeItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "124-129",
          "snippet": "ModelIndex TreeItem::toIndex(Model *const model) const\n{\n    Q_ASSERT(model);\n    // void* != const void*, but I believe that it's safe in this context\n    return model->createIndex(row(), 0, const_cast<TreeItem *>(this));\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItem {\n  ModelIndex TreeItem::toIndex(Model *const model) const\n  {\n      Q_ASSERT(model);\n      // void* != const void*, but I believe that it's safe in this context\n      return model->createIndex(row(), 0, const_cast<TreeItem *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->accessFetchStatus() == TreeItem::LOADING)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->m_children.isEmpty())"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->m_children.isEmpty",
          "args": [],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForSyncing",
          "args": [],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForSyncing",
          "args": [],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMapping.size",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "idMapping.size())"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMapping.size",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForSyncing",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailbox)"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "setCache(A",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1505-1511",
          "snippet": "id Model::setCache(AbstractCache *cache)\n{\n    if (m_cache)\n        m_cache->deleteLater();\n    m_cache = cache;\n    m_cache->setParent(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCache(AbstractCache *cache)\n  {\n      if (m_cache)\n          m_cache->deleteLater();\n      m_cache = cache;\n      m_cache->setParent(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->m_children.size() == 0)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->m_children.size",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tem->parent())"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->parent",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem->parent())"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForMessagesInMailbox(TreeItemMsgList *item)\n  {\n      Q_ASSERT(item->parent());\n      TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->parent());\n      Q_ASSERT(mailboxPtr);\n  \n      QString mailbox = mailboxPtr->mailbox();\n  \n      Q_ASSERT(item->m_children.size() == 0);\n  \n      QList<uint> uidMapping = cache()->uidMapping(mailbox);\n      auto oldSyncState = cache()->mailboxSyncState(mailbox);\n      if (networkPolicy() == NETWORK_OFFLINE && oldSyncState.isUsableForSyncing()\n              && static_cast<uint>(uidMapping.size()) != oldSyncState.exists()) {\n          // Problem with the cached data\n          qDebug() << \"UID cache stale for mailbox\" << mailbox\n                   << \"(\" << uidMapping.size() << \"in UID cache vs.\" << oldSyncState.exists() << \"in the sync state and\"\n                   << item->m_totalMessageCount << \"as totalMessageCount (possibly updated by STATUS))\";\n          item->setFetchStatus(TreeItem::UNAVAILABLE);\n      } else if (networkPolicy() == NETWORK_OFFLINE && !oldSyncState.isUsableForSyncing()) {\n          // Nothing in the cache\n          item->setFetchStatus(TreeItem::UNAVAILABLE);\n      } else if (oldSyncState.isUsableForSyncing()) {\n          // We can pre-populate the tree with data from cache\n          Q_ASSERT(item->m_children.isEmpty());\n          Q_ASSERT(item->accessFetchStatus() == TreeItem::LOADING);\n          QModelIndex listIndex = item->toIndex(this);\n          if (uidMapping.size()) {\n              beginInsertRows(listIndex, 0, uidMapping.size() - 1);\n              for (uint seq = 0; seq < static_cast<uint>(uidMapping.size()); ++seq) {\n                  TreeItemMessage *message = new TreeItemMessage(item);\n                  message->m_offset = seq;\n                  message->m_uid = uidMapping[seq];\n                  item->m_children << message;\n                  QStringList flags = cache()->msgFlags(mailbox, message->m_uid);\n                  flags.removeOne(QLatin1String(\"\\\\Recent\"));\n                  message->m_flags = normalizeFlags(flags);\n              }\n              endInsertRows();\n          }\n          mailboxPtr->syncState = oldSyncState;\n          item->setFetchStatus(TreeItem::DONE); // required for FETCH processing later on\n          // The list of messages was satisfied from cache. Do the same for the message counts, if applicable\n          item->recalcVariousMessageCounts(this);\n      }\n  \n      if (networkPolicy() != NETWORK_OFFLINE) {\n          findTaskResponsibleFor(mailboxPtr);\n          // and that's all -- the task will detect following replies and sync automatically\n      }\n  }\n}"
  },
  {
    "function_name": "reloadMailboxList(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "832-835",
    "snippet": "oid Model::reloadMailboxList()\n{\n    m_mailboxes->rescanForChildMailboxes(this);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_mailboxes->rescanForChildMailboxes",
          "args": [
            "his)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::reloadMailboxList()\n  {\n      m_mailboxes->rescanForChildMailboxes(this);\n  }\n}"
  },
  {
    "function_name": "askForChildrenOfMailbox(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "793-830",
    "snippet": "oid Model::askForChildrenOfMailbox(TreeItemMailbox *item, bool forceReload)\n{\n    if (!forceReload && cache()->childMailboxesFresh(item->mailbox())) {\n        // The permanent cache contains relevant data\n        QList<MailboxMetadata> metadata = cache()->childMailboxes(item->mailbox());\n        TreeItemChildrenList mailboxes;\n        for (QList<MailboxMetadata>::const_iterator it = metadata.constBegin(); it != metadata.constEnd(); ++it) {\n            TreeItemMailbox *mailbox = TreeItemMailbox::fromMetadata(item, *it);\n            TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n            Q_ASSERT(list);\n            Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailbox->mailbox());\n            if (syncState.isUsableForNumbers()) {\n                list->m_unreadMessageCount = syncState.unSeenCount();\n                list->m_totalMessageCount = syncState.exists();\n                list->m_recentMessageCount = syncState.recent();\n                list->m_numberFetchingStatus = TreeItem::LOADING;\n            } else {\n                list->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n            }\n            mailboxes << mailbox;\n        }\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item);\n        Q_ASSERT(mailboxPtr);\n        replaceChildMailboxes(mailboxPtr, mailboxes);\n    } else if (networkPolicy() == NETWORK_OFFLINE) {\n        // No cached data, no network -> fail\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n        QModelIndex idx = item->toIndex(this);\n        emit dataChanged(idx, idx);\n        return;\n    }\n\n    // We shall ask the network\n    m_taskFactory->createListChildMailboxesTask(this, item->toIndex(this));\n\n    QModelIndex idx = item->toIndex(this);\n    emit dataChanged(idx, idx);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tem->toIndex",
          "args": [
            "his)"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "toIndex(",
          "container": "reeItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "124-129",
          "snippet": "ModelIndex TreeItem::toIndex(Model *const model) const\n{\n    Q_ASSERT(model);\n    // void* != const void*, but I believe that it's safe in this context\n    return model->createIndex(row(), 0, const_cast<TreeItem *>(this));\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItem {\n  ModelIndex TreeItem::toIndex(Model *const model) const\n  {\n      Q_ASSERT(model);\n      // void* != const void*, but I believe that it's safe in this context\n      return model->createIndex(row(), 0, const_cast<TreeItem *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_taskFactory->createListChildMailboxesTask",
          "args": [
            "his,",
            "tem->toIndex(this))"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setFetchStatus",
          "args": [
            "reeItem::UNAVAILABLE)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etworkPolicy(",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "desiredNetworkPolicy(",
          "container": "etworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/NetworkWatcher.cpp",
          "lines": "54-57",
          "snippet": "etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n{\n    return m_desiredPolicy;\n}",
          "includes": [
            "include \"Model.h\"",
            "include \"NetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude \"NetworkWatcher.h\"\n#\n\networkWatcher {\n  etworkPolicy NetworkWatcher::desiredNetworkPolicy() const\n  {\n      return m_desiredPolicy;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eplaceChildMailboxes(",
          "args": [
            "ailboxPtr,",
            "ailboxes)"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "replaceChildMailboxes(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "434-493",
          "snippet": "oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n{\n    /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n       resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n\n    ==23294== Invalid read of size 4\n    ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n    ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n    ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n    ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n    ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n    ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n    ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n    ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n    ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n    ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n    ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n    ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n    ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n    ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n    ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n    ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n    ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n    ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n    ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n    ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n    ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n    ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n    ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n    ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n    ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n\n       I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n       that the code should *not* use tham after that point. That's just weird.\n    */\n\n    QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n\n    if (mailboxPtr->m_children.size() != 1) {\n        // There's something besides the TreeItemMsgList and we're going to\n        // overwrite them, so we have to delete them right now\n        int count = mailboxPtr->rowCount(this);\n        beginRemoveRows(parent, 1, count - 1);\n        auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n        endRemoveRows();\n\n        qDeleteAll(oldItems);\n    }\n\n    if (! mailboxes.isEmpty()) {\n        beginInsertRows(parent, 1, mailboxes.size());\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        endInsertRows();\n        Q_ASSERT(dummy.isEmpty());\n    } else {\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        Q_ASSERT(dummy.isEmpty());\n    }\n    emit dataChanged(parent, parent);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n  {\n      /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n         resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n  \n      ==23294== Invalid read of size 4\n      ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n      ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n      ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n      ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n      ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n      ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n      ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n      ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n      ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n      ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n      ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n      ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n      ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n      ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n      ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n      ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n      ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n      ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n      ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n      ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n      ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n      ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n      ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n      ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n      ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n  \n         I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n         that the code should *not* use tham after that point. That's just weird.\n      */\n  \n      QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n  \n      if (mailboxPtr->m_children.size() != 1) {\n          // There's something besides the TreeItemMsgList and we're going to\n          // overwrite them, so we have to delete them right now\n          int count = mailboxPtr->rowCount(this);\n          beginRemoveRows(parent, 1, count - 1);\n          auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n          endRemoveRows();\n  \n          qDeleteAll(oldItems);\n      }\n  \n      if (! mailboxes.isEmpty()) {\n          beginInsertRows(parent, 1, mailboxes.size());\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          endInsertRows();\n          Q_ASSERT(dummy.isEmpty());\n      } else {\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          Q_ASSERT(dummy.isEmpty());\n      }\n      emit dataChanged(parent, parent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxPtr)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tem)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.recent",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "recent(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "86-89",
          "snippet": "int SyncState::recent() const\n{\n    return m_recent;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::recent() const\n  {\n      return m_recent;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.exists",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "exists(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "53-56",
          "snippet": "int SyncState::exists() const\n{\n    return m_exists;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::exists() const\n  {\n      return m_exists;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.unSeenCount",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "unSeenCount(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "119-122",
          "snippet": "int SyncState::unSeenCount() const\n{\n    return m_unSeenCount;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::unSeenCount() const\n  {\n      return m_unSeenCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState.isUsableForNumbers",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "isUsableForNumbers(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "38-41",
          "snippet": "ool SyncState::isUsableForNumbers() const\n{\n    return m_hasExists && m_hasRecent && m_hasUnSeenCount;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  ool SyncState::isUsableForNumbers() const\n  {\n      return m_hasExists && m_hasRecent && m_hasUnSeenCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "setCache(A",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1505-1511",
          "snippet": "id Model::setCache(AbstractCache *cache)\n{\n    if (m_cache)\n        m_cache->deleteLater();\n    m_cache = cache;\n    m_cache->setParent(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCache(AbstractCache *cache)\n  {\n      if (m_cache)\n          m_cache->deleteLater();\n      m_cache = cache;\n      m_cache->setParent(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList*>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reeItemMailbox::fromMetadata(",
          "args": [
            "tem,",
            "it)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etadata.constEnd",
          "args": [],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etadata.constBegin",
          "args": [],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->mailbox",
          "args": [],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->mailbox",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForChildrenOfMailbox(TreeItemMailbox *item, bool forceReload)\n  {\n      if (!forceReload && cache()->childMailboxesFresh(item->mailbox())) {\n          // The permanent cache contains relevant data\n          QList<MailboxMetadata> metadata = cache()->childMailboxes(item->mailbox());\n          TreeItemChildrenList mailboxes;\n          for (QList<MailboxMetadata>::const_iterator it = metadata.constBegin(); it != metadata.constEnd(); ++it) {\n              TreeItemMailbox *mailbox = TreeItemMailbox::fromMetadata(item, *it);\n              TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n              Q_ASSERT(list);\n              Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailbox->mailbox());\n              if (syncState.isUsableForNumbers()) {\n                  list->m_unreadMessageCount = syncState.unSeenCount();\n                  list->m_totalMessageCount = syncState.exists();\n                  list->m_recentMessageCount = syncState.recent();\n                  list->m_numberFetchingStatus = TreeItem::LOADING;\n              } else {\n                  list->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n              }\n              mailboxes << mailbox;\n          }\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item);\n          Q_ASSERT(mailboxPtr);\n          replaceChildMailboxes(mailboxPtr, mailboxes);\n      } else if (networkPolicy() == NETWORK_OFFLINE) {\n          // No cached data, no network -> fail\n          item->setFetchStatus(TreeItem::UNAVAILABLE);\n          QModelIndex idx = item->toIndex(this);\n          emit dataChanged(idx, idx);\n          return;\n      }\n  \n      // We shall ask the network\n      m_taskFactory->createListChildMailboxesTask(this, item->toIndex(this));\n  \n      QModelIndex idx = item->toIndex(this);\n      emit dataChanged(idx, idx);\n  }\n}"
  },
  {
    "function_name": "askForMessagesInMailbox(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "783-791",
    "snippet": "oid Model::askForMessagesInMailbox(const QModelIndex &index)\n{\n    if (!index.isValid())\n        return;\n    Q_ASSERT(index.model() == this);\n    auto msgList = dynamic_cast<TreeItemMsgList *>(static_cast<TreeItem *>(index.internalPointer()));\n    Q_ASSERT(msgList);\n    askForMessagesInMailbox(msgList);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForMessagesInMailbox(",
          "args": [
            "sgList)"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "askForMessagesInMailbox(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "837-887",
          "snippet": "oid Model::askForMessagesInMailbox(TreeItemMsgList *item)\n{\n    Q_ASSERT(item->parent());\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item->parent());\n    Q_ASSERT(mailboxPtr);\n\n    QString mailbox = mailboxPtr->mailbox();\n\n    Q_ASSERT(item->m_children.size() == 0);\n\n    QList<uint> uidMapping = cache()->uidMapping(mailbox);\n    auto oldSyncState = cache()->mailboxSyncState(mailbox);\n    if (networkPolicy() == NETWORK_OFFLINE && oldSyncState.isUsableForSyncing()\n            && static_cast<uint>(uidMapping.size()) != oldSyncState.exists()) {\n        // Problem with the cached data\n        qDebug() << \"UID cache stale for mailbox\" << mailbox\n                 << \"(\" << uidMapping.size() << \"in UID cache vs.\" << oldSyncState.exists() << \"in the sync state and\"\n                 << item->m_totalMessageCount << \"as totalMessageCount (possibly updated by STATUS))\";\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n    } else if (networkPolicy() == NETWORK_OFFLINE && !oldSyncState.isUsableForSyncing()) {\n        // Nothing in the cache\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n    } else if (oldSyncState.isUsableForSyncing()) {\n        // We can pre-populate the tree with data from cache\n        Q_ASSERT(item->m_children.isEmpty());\n        Q_ASSERT(item->accessFetchStatus() == TreeItem::LOADING);\n        QModelIndex listIndex = item->toIndex(this);\n        if (uidMapping.size()) {\n            beginInsertRows(listIndex, 0, uidMapping.size() - 1);\n            for (uint seq = 0; seq < static_cast<uint>(uidMapping.size()); ++seq) {\n                TreeItemMessage *message = new TreeItemMessage(item);\n                message->m_offset = seq;\n                message->m_uid = uidMapping[seq];\n                item->m_children << message;\n                QStringList flags = cache()->msgFlags(mailbox, message->m_uid);\n                flags.removeOne(QLatin1String(\"\\\\Recent\"));\n                message->m_flags = normalizeFlags(flags);\n            }\n            endInsertRows();\n        }\n        mailboxPtr->syncState = oldSyncState;\n        item->setFetchStatus(TreeItem::DONE); // required for FETCH processing later on\n        // The list of messages was satisfied from cache. Do the same for the message counts, if applicable\n        item->recalcVariousMessageCounts(this);\n    }\n\n    if (networkPolicy() != NETWORK_OFFLINE) {\n        findTaskResponsibleFor(mailboxPtr);\n        // and that's all -- the task will detect following replies and sync automatically\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sgList)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "tatic_cast<TreeItem *>(index.internalPointer()))"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForMessagesInMailbox(const QModelIndex &index)\n  {\n      if (!index.isValid())\n          return;\n      Q_ASSERT(index.model() == this);\n      auto msgList = dynamic_cast<TreeItemMsgList *>(static_cast<TreeItem *>(index.internalPointer()));\n      Q_ASSERT(msgList);\n      askForMessagesInMailbox(msgList);\n  }\n}"
  },
  {
    "function_name": "askForChildrenOfMailbox(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "773-781",
    "snippet": "oid Model::askForChildrenOfMailbox(const QModelIndex &index, const CacheLoadingMode cacheMode)\n{\n    if (!index.isValid())\n        return;\n    Q_ASSERT(index.model() == this);\n    auto mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(index.internalPointer()));\n    Q_ASSERT(mailbox);\n    askForChildrenOfMailbox(mailbox, cacheMode == LOAD_FORCE_RELOAD);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForChildrenOfMailbox(",
          "args": [
            "ailbox,",
            "acheMode == LOAD_FORCE_RELOAD)"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "askForChildrenOfMailbox(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "793-830",
          "snippet": "oid Model::askForChildrenOfMailbox(TreeItemMailbox *item, bool forceReload)\n{\n    if (!forceReload && cache()->childMailboxesFresh(item->mailbox())) {\n        // The permanent cache contains relevant data\n        QList<MailboxMetadata> metadata = cache()->childMailboxes(item->mailbox());\n        TreeItemChildrenList mailboxes;\n        for (QList<MailboxMetadata>::const_iterator it = metadata.constBegin(); it != metadata.constEnd(); ++it) {\n            TreeItemMailbox *mailbox = TreeItemMailbox::fromMetadata(item, *it);\n            TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n            Q_ASSERT(list);\n            Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailbox->mailbox());\n            if (syncState.isUsableForNumbers()) {\n                list->m_unreadMessageCount = syncState.unSeenCount();\n                list->m_totalMessageCount = syncState.exists();\n                list->m_recentMessageCount = syncState.recent();\n                list->m_numberFetchingStatus = TreeItem::LOADING;\n            } else {\n                list->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n            }\n            mailboxes << mailbox;\n        }\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item);\n        Q_ASSERT(mailboxPtr);\n        replaceChildMailboxes(mailboxPtr, mailboxes);\n    } else if (networkPolicy() == NETWORK_OFFLINE) {\n        // No cached data, no network -> fail\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n        QModelIndex idx = item->toIndex(this);\n        emit dataChanged(idx, idx);\n        return;\n    }\n\n    // We shall ask the network\n    m_taskFactory->createListChildMailboxesTask(this, item->toIndex(this));\n\n    QModelIndex idx = item->toIndex(this);\n    emit dataChanged(idx, idx);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(index.internalPointer()))"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForChildrenOfMailbox(const QModelIndex &index, const CacheLoadingMode cacheMode)\n  {\n      if (!index.isValid())\n          return;\n      Q_ASSERT(index.model() == this);\n      auto mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(index.internalPointer()));\n      Q_ASSERT(mailbox);\n      askForChildrenOfMailbox(mailbox, cacheMode == LOAD_FORCE_RELOAD);\n  }\n}"
  },
  {
    "function_name": "askForTopLevelChildren(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "768-771",
    "snippet": "oid Model::askForTopLevelChildren(const CacheLoadingMode cacheMode)\n{\n    askForChildrenOfMailbox(m_mailboxes, cacheMode == LOAD_FORCE_RELOAD);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForChildrenOfMailbox(",
          "args": [
            "_mailboxes,",
            "acheMode == LOAD_FORCE_RELOAD)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "askForChildrenOfMailbox(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "793-830",
          "snippet": "oid Model::askForChildrenOfMailbox(TreeItemMailbox *item, bool forceReload)\n{\n    if (!forceReload && cache()->childMailboxesFresh(item->mailbox())) {\n        // The permanent cache contains relevant data\n        QList<MailboxMetadata> metadata = cache()->childMailboxes(item->mailbox());\n        TreeItemChildrenList mailboxes;\n        for (QList<MailboxMetadata>::const_iterator it = metadata.constBegin(); it != metadata.constEnd(); ++it) {\n            TreeItemMailbox *mailbox = TreeItemMailbox::fromMetadata(item, *it);\n            TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n            Q_ASSERT(list);\n            Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailbox->mailbox());\n            if (syncState.isUsableForNumbers()) {\n                list->m_unreadMessageCount = syncState.unSeenCount();\n                list->m_totalMessageCount = syncState.exists();\n                list->m_recentMessageCount = syncState.recent();\n                list->m_numberFetchingStatus = TreeItem::LOADING;\n            } else {\n                list->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n            }\n            mailboxes << mailbox;\n        }\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item);\n        Q_ASSERT(mailboxPtr);\n        replaceChildMailboxes(mailboxPtr, mailboxes);\n    } else if (networkPolicy() == NETWORK_OFFLINE) {\n        // No cached data, no network -> fail\n        item->setFetchStatus(TreeItem::UNAVAILABLE);\n        QModelIndex idx = item->toIndex(this);\n        emit dataChanged(idx, idx);\n        return;\n    }\n\n    // We shall ask the network\n    m_taskFactory->createListChildMailboxesTask(this, item->toIndex(this));\n\n    QModelIndex idx = item->toIndex(this);\n    emit dataChanged(idx, idx);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForChildrenOfMailbox(TreeItemMailbox *item, bool forceReload)\n  {\n      if (!forceReload && cache()->childMailboxesFresh(item->mailbox())) {\n          // The permanent cache contains relevant data\n          QList<MailboxMetadata> metadata = cache()->childMailboxes(item->mailbox());\n          TreeItemChildrenList mailboxes;\n          for (QList<MailboxMetadata>::const_iterator it = metadata.constBegin(); it != metadata.constEnd(); ++it) {\n              TreeItemMailbox *mailbox = TreeItemMailbox::fromMetadata(item, *it);\n              TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n              Q_ASSERT(list);\n              Imap::Mailbox::SyncState syncState = cache()->mailboxSyncState(mailbox->mailbox());\n              if (syncState.isUsableForNumbers()) {\n                  list->m_unreadMessageCount = syncState.unSeenCount();\n                  list->m_totalMessageCount = syncState.exists();\n                  list->m_recentMessageCount = syncState.recent();\n                  list->m_numberFetchingStatus = TreeItem::LOADING;\n              } else {\n                  list->m_numberFetchingStatus = TreeItem::UNAVAILABLE;\n              }\n              mailboxes << mailbox;\n          }\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(item);\n          Q_ASSERT(mailboxPtr);\n          replaceChildMailboxes(mailboxPtr, mailboxes);\n      } else if (networkPolicy() == NETWORK_OFFLINE) {\n          // No cached data, no network -> fail\n          item->setFetchStatus(TreeItem::UNAVAILABLE);\n          QModelIndex idx = item->toIndex(this);\n          emit dataChanged(idx, idx);\n          return;\n      }\n  \n      // We shall ask the network\n      m_taskFactory->createListChildMailboxesTask(this, item->toIndex(this));\n  \n      QModelIndex idx = item->toIndex(this);\n      emit dataChanged(idx, idx);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForTopLevelChildren(const CacheLoadingMode cacheMode)\n  {\n      askForChildrenOfMailbox(m_mailboxes, cacheMode == LOAD_FORCE_RELOAD);\n  }\n}"
  },
  {
    "function_name": "hasChildren(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "754-766",
    "snippet": "ool Model::hasChildren(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        Q_ASSERT(parent.model() == this);\n    }\n\n    TreeItem *node = translatePtr(parent);\n\n    if (node)\n        return node->hasChildren(const_cast<Model *>(this));\n    else\n        return false;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ode->hasChildren",
          "args": [
            "onst_cast<Model *>(this))"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "his)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslatePtr(",
          "args": [
            "arent)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arent.model() == this)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.model",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  ool Model::hasChildren(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          Q_ASSERT(parent.model() == this);\n      }\n  \n      TreeItem *node = translatePtr(parent);\n  \n      if (node)\n          return node->hasChildren(const_cast<Model *>(this));\n      else\n          return false;\n  }\n}"
  },
  {
    "function_name": "columnCount(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "742-752",
    "snippet": "nt Model::columnCount(const QModelIndex &index) const\n{\n    TreeItem *node = static_cast<TreeItem *>(index.internalPointer());\n    if (!node) {\n        node = m_mailboxes;\n    } else {\n        Q_ASSERT(index.model() == this);\n    }\n    Q_ASSERT(node);\n    return node->columnCount();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ode->columnCount",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "columnCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "158-171",
          "snippet": "void ModelTest::columnCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->columnCount(topIndex) >= 0);\n\n    // check a column count where parent is valid\n    QModelIndex childIndex = model->index(0, 0, topIndex);\n    if (childIndex.isValid())\n        Q_ASSERT(model->columnCount(childIndex) >= 0);\n\n    // columnCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::columnCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->columnCount(topIndex) >= 0);\n  \n      // check a column count where parent is valid\n      QModelIndex childIndex = model->index(0, 0, topIndex);\n      if (childIndex.isValid())\n          Q_ASSERT(model->columnCount(childIndex) >= 0);\n  \n      // columnCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ode)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  nt Model::columnCount(const QModelIndex &index) const\n  {\n      TreeItem *node = static_cast<TreeItem *>(index.internalPointer());\n      if (!node) {\n          node = m_mailboxes;\n      } else {\n          Q_ASSERT(index.model() == this);\n      }\n      Q_ASSERT(node);\n      return node->columnCount();\n  }\n}"
  },
  {
    "function_name": "rowCount(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "730-740",
    "snippet": "nt Model::rowCount(const QModelIndex &index) const\n{\n    TreeItem *node = static_cast<TreeItem *>(index.internalPointer());\n    if (!node) {\n        node = m_mailboxes;\n    } else {\n        Q_ASSERT(index.model() == this);\n    }\n    Q_ASSERT(node);\n    return node->rowCount(const_cast<Model *>(this));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ode->rowCount",
          "args": [
            "onst_cast<Model *>(this))"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "his)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ode)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  nt Model::rowCount(const QModelIndex &index) const\n  {\n      TreeItem *node = static_cast<TreeItem *>(index.internalPointer());\n      if (!node) {\n          node = m_mailboxes;\n      } else {\n          Q_ASSERT(index.model() == this);\n      }\n      Q_ASSERT(node);\n      return node->rowCount(const_cast<Model *>(this));\n  }\n}"
  },
  {
    "function_name": "parent(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "714-728",
    "snippet": "ModelIndex Model::parent(const QModelIndex &index) const\n{\n    if (!index.isValid())\n        return QModelIndex();\n\n    Q_ASSERT(index.model() == this);\n\n    TreeItem *childItem = static_cast<TreeItem *>(index.internalPointer());\n    TreeItem *parentItem = childItem->parent();\n\n    if (! parentItem || parentItem == m_mailboxes)\n        return QModelIndex();\n\n    return QAbstractItemModel::createIndex(parentItem->row(), 0, parentItem);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AbstractItemModel::createIndex(",
          "args": [
            "arentItem->row(),",
            ",",
            "arentItem)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentItem->row",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->parent",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  ModelIndex Model::parent(const QModelIndex &index) const\n  {\n      if (!index.isValid())\n          return QModelIndex();\n  \n      Q_ASSERT(index.model() == this);\n  \n      TreeItem *childItem = static_cast<TreeItem *>(index.internalPointer());\n      TreeItem *parentItem = childItem->parent();\n  \n      if (! parentItem || parentItem == m_mailboxes)\n          return QModelIndex();\n  \n      return QAbstractItemModel::createIndex(parentItem->row(), 0, parentItem);\n  }\n}"
  },
  {
    "function_name": "index(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "690-712",
    "snippet": "ModelIndex Model::index(int row, int column, const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        Q_ASSERT(parent.model() == this);\n    }\n\n    TreeItem *parentItem = translatePtr(parent);\n\n    // Deal with the possibility of an \"irregular shape\" of our model here.\n    // The issue is that some items have child items not only in column #0\n    // and in specified number of rows, but also in row #0 and various columns.\n    if (column != 0) {\n        TreeItem *item = parentItem->specialColumnPtr(row, column);\n        if (item)\n            return QAbstractItemModel::createIndex(row, column, item);\n        else\n            return QModelIndex();\n    }\n\n    TreeItem *child = parentItem->child(row, const_cast<Model *>(this));\n\n    return child ? QAbstractItemModel::createIndex(row, column, child) : QModelIndex();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbstractItemModel::createIndex(",
          "args": [
            "ow,",
            "olumn,",
            "hild)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentItem->child",
          "args": [
            "ow,",
            "onst_cast<Model *>(this))"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "his)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbstractItemModel::createIndex(",
          "args": [
            "ow,",
            "olumn,",
            "tem)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentItem->specialColumnPtr",
          "args": [
            "ow,",
            "olumn)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslatePtr(",
          "args": [
            "arent)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arent.model() == this)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.model",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  ModelIndex Model::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          Q_ASSERT(parent.model() == this);\n      }\n  \n      TreeItem *parentItem = translatePtr(parent);\n  \n      // Deal with the possibility of an \"irregular shape\" of our model here.\n      // The issue is that some items have child items not only in column #0\n      // and in specified number of rows, but also in row #0 and various columns.\n      if (column != 0) {\n          TreeItem *item = parentItem->specialColumnPtr(row, column);\n          if (item)\n              return QAbstractItemModel::createIndex(row, column, item);\n          else\n              return QModelIndex();\n      }\n  \n      TreeItem *child = parentItem->child(row, const_cast<Model *>(this));\n  \n      return child ? QAbstractItemModel::createIndex(row, column, child) : QModelIndex();\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "685-688",
    "snippet": "Variant Model::data(const QModelIndex &index, int role) const\n{\n    return translatePtr(index)->data(const_cast<Model *>(this), role);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ranslatePtr",
          "args": [
            "onst_cast<Model *>(this),",
            "ole)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "his)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslatePtr(",
          "args": [
            "ndex)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  Variant Model::data(const QModelIndex &index, int role) const\n  {\n      return translatePtr(index)->data(const_cast<Model *>(this), role);\n  }\n}"
  },
  {
    "function_name": "handleSocketEncryptedResponse(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "673-678",
    "snippet": "oid Model::handleSocketEncryptedResponse(Parser *ptr, const Responses::SocketEncryptedResponse *const resp)\n{\n    Q_UNUSED(resp);\n    logTrace(ptr->parserId(), Common::LOG_IO_READ, \"Model\", \"Information about the SSL state not handled by the upper layers -- disconnect?\");\n    killParser(ptr, PARSER_KILL_EXPECTED);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "illParser(",
          "args": [
            "tr,",
            "ARSER_KILL_EXPECTED)"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "killParser(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1462-1493",
          "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "tr->parserId(),",
            "ommon::LOG_IO_READ,",
            "Model\",",
            "Information about the SSL state not handled by the upper layers -- disconnect?\")"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1774-1794",
          "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr->parserId",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "esp)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleSocketEncryptedResponse(Parser *ptr, const Responses::SocketEncryptedResponse *const resp)\n  {\n      Q_UNUSED(resp);\n      logTrace(ptr->parserId(), Common::LOG_IO_READ, \"Model\", \"Information about the SSL state not handled by the upper layers -- disconnect?\");\n      killParser(ptr, PARSER_KILL_EXPECTED);\n  }\n}"
  },
  {
    "function_name": "handleGenUrlAuth(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "666-671",
    "snippet": "oid Model::handleGenUrlAuth(Parser *ptr, const Responses::GenUrlAuth *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"Unhandled GENURLAUTH response\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled GENURLAUTH response\",",
            "resp)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleGenUrlAuth(Parser *ptr, const Responses::GenUrlAuth *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"Unhandled GENURLAUTH response\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleVanished(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "659-664",
    "snippet": "oid Model::handleVanished(Parser *ptr, const Responses::Vanished *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"Unhandled VANISHED response\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled VANISHED response\",",
            "resp)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleVanished(Parser *ptr, const Responses::Vanished *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"Unhandled VANISHED response\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleEnabled(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "652-657",
    "snippet": "oid Model::handleEnabled(Parser *ptr, const Responses::Enabled *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"Unhandled ENABLED response\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled ENABLED response\",",
            "resp)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleEnabled(Parser *ptr, const Responses::Enabled *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"Unhandled ENABLED response\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleId(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "645-650",
    "snippet": "oid Model::handleId(Parser *ptr, const Responses::Id *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"Unhandled ID response\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled ID response\",",
            "resp)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleId(Parser *ptr, const Responses::Id *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"Unhandled ID response\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleThread(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "638-643",
    "snippet": "oid Model::handleThread(Imap::Parser *ptr, const Imap::Responses::Thread *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Thread\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled Thread\",",
            "resp)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleThread(Imap::Parser *ptr, const Imap::Responses::Thread *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Thread\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleSort(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "631-636",
    "snippet": "oid Model::handleSort(Imap::Parser *ptr, const Imap::Responses::Sort *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Sort\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled Sort\",",
            "resp)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleSort(Imap::Parser *ptr, const Imap::Responses::Sort *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Sort\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleNamespace(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "622-629",
    "snippet": "oid Model::handleNamespace(Imap::Parser *ptr, const Imap::Responses::Namespace *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    return; // because it's broken and won't fly\n    Q_UNUSED(ptr);\n    Q_UNUSED(resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "esp)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "tr)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleNamespace(Imap::Parser *ptr, const Imap::Responses::Namespace *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      return; // because it's broken and won't fly\n      Q_UNUSED(ptr);\n      Q_UNUSED(resp);\n  }\n}"
  },
  {
    "function_name": "handleFetch(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "615-620",
    "snippet": "oid Model::handleFetch(Imap::Parser *ptr, const Imap::Responses::Fetch *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Fetch\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled Fetch\",",
            "resp)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleFetch(Imap::Parser *ptr, const Imap::Responses::Fetch *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Fetch\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleStatus(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "569-613",
    "snippet": "oid Model::handleStatus(Imap::Parser *ptr, const Imap::Responses::Status *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    Q_UNUSED(ptr);\n    TreeItemMailbox *mailbox = findMailboxByName(resp->mailbox);\n    if (! mailbox) {\n        qDebug() << \"Couldn't find out which mailbox is\" << resp->mailbox << \"when parsing a STATUS reply\";\n        return;\n    }\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    bool updateCache = false;\n    Imap::Responses::Status::stateDataType::const_iterator it = resp->states.constEnd();\n    if ((it = resp->states.constFind(Imap::Responses::Status::MESSAGES)) != resp->states.constEnd()) {\n        updateCache |= list->m_totalMessageCount != static_cast<const int>(it.value());\n        list->m_totalMessageCount = it.value();\n    }\n    if ((it = resp->states.constFind(Imap::Responses::Status::UNSEEN)) != resp->states.constEnd()) {\n        updateCache |= list->m_unreadMessageCount != static_cast<const int>(it.value());\n        list->m_unreadMessageCount = it.value();\n    }\n    if ((it = resp->states.constFind(Imap::Responses::Status::RECENT)) != resp->states.constEnd()) {\n        updateCache |= list->m_recentMessageCount != static_cast<const int>(it.value());\n        list->m_recentMessageCount = it.value();\n    }\n    list->m_numberFetchingStatus = TreeItem::DONE;\n    emitMessageCountChanged(mailbox);\n\n    if (updateCache) {\n        // We have to be very careful to only touch the bits which are *not* used by the mailbox syncing code.\n        // This is absolutely crucial -- STATUS is just a meaningless indicator, and stuff like the UID mapping\n        // is definitely *not* updated at the same time. That's also why we completely ignore any data whatsoever\n        // from the TreeItemMailbox' syncState, if any, and just work with the cache directly.\n        auto state = cache()->mailboxSyncState(mailbox->mailbox());\n        // We are *not* updating the total message count as that conflicts with the mailbox syncing\n        if (list->m_unreadMessageCount != -1) {\n            state.setUnSeenCount(list->m_unreadMessageCount);\n        }\n        if (list->m_recentMessageCount != -1) {\n            state.setRecent(list->m_recentMessageCount);\n        }\n        cache()->setMailboxSyncState(mailbox->mailbox(), state);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailbox->mailbox(),",
            "tate)"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "setMessageThreading(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "815-831",
          "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tate.setRecent",
          "args": [
            "ist->m_recentMessageCount)"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "setRecent(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "91-95",
          "snippet": "oid SyncState::setRecent(const uint recent)\n{\n    m_recent = recent;\n    m_hasRecent = true;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  oid SyncState::setRecent(const uint recent)\n  {\n      m_recent = recent;\n      m_hasRecent = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tate.setUnSeenCount",
          "args": [
            "ist->m_unreadMessageCount)"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "setUnSeenCount(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "124-128",
          "snippet": "oid SyncState::setUnSeenCount(const uint unSeen)\n{\n    m_unSeenCount = unSeen;\n    m_hasUnSeenCount = true;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  oid SyncState::setUnSeenCount(const uint unSeen)\n  {\n      m_unSeenCount = unSeen;\n      m_hasUnSeenCount = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "setCache(A",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1505-1511",
          "snippet": "id Model::setCache(AbstractCache *cache)\n{\n    if (m_cache)\n        m_cache->deleteLater();\n    m_cache = cache;\n    m_cache->setParent(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setCache(AbstractCache *cache)\n  {\n      if (m_cache)\n          m_cache->deleteLater();\n      m_cache = cache;\n      m_cache->setParent(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mitMessageCountChanged(",
          "args": [
            "ailbox)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "emitMessageCountChanged(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "495-501",
          "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.value",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<const int>",
          "args": [
            "t.value())"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constEnd",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constFind",
          "args": [
            "map::Responses::Status::RECENT)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<const int>",
          "args": [
            "t.value())"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constEnd",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constFind",
          "args": [
            "map::Responses::Status::UNSEEN)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<const int>",
          "args": [
            "t.value())"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constEnd",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constFind",
          "args": [
            "map::Responses::Status::MESSAGES)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->states.constEnd",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indMailboxByName(",
          "args": [
            "esp->mailbox)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "tr)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleStatus(Imap::Parser *ptr, const Imap::Responses::Status *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      Q_UNUSED(ptr);\n      TreeItemMailbox *mailbox = findMailboxByName(resp->mailbox);\n      if (! mailbox) {\n          qDebug() << \"Couldn't find out which mailbox is\" << resp->mailbox << \"when parsing a STATUS reply\";\n          return;\n      }\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      bool updateCache = false;\n      Imap::Responses::Status::stateDataType::const_iterator it = resp->states.constEnd();\n      if ((it = resp->states.constFind(Imap::Responses::Status::MESSAGES)) != resp->states.constEnd()) {\n          updateCache |= list->m_totalMessageCount != static_cast<const int>(it.value());\n          list->m_totalMessageCount = it.value();\n      }\n      if ((it = resp->states.constFind(Imap::Responses::Status::UNSEEN)) != resp->states.constEnd()) {\n          updateCache |= list->m_unreadMessageCount != static_cast<const int>(it.value());\n          list->m_unreadMessageCount = it.value();\n      }\n      if ((it = resp->states.constFind(Imap::Responses::Status::RECENT)) != resp->states.constEnd()) {\n          updateCache |= list->m_recentMessageCount != static_cast<const int>(it.value());\n          list->m_recentMessageCount = it.value();\n      }\n      list->m_numberFetchingStatus = TreeItem::DONE;\n      emitMessageCountChanged(mailbox);\n  \n      if (updateCache) {\n          // We have to be very careful to only touch the bits which are *not* used by the mailbox syncing code.\n          // This is absolutely crucial -- STATUS is just a meaningless indicator, and stuff like the UID mapping\n          // is definitely *not* updated at the same time. That's also why we completely ignore any data whatsoever\n          // from the TreeItemMailbox' syncState, if any, and just work with the cache directly.\n          auto state = cache()->mailboxSyncState(mailbox->mailbox());\n          // We are *not* updating the total message count as that conflicts with the mailbox syncing\n          if (list->m_unreadMessageCount != -1) {\n              state.setUnSeenCount(list->m_unreadMessageCount);\n          }\n          if (list->m_recentMessageCount != -1) {\n              state.setRecent(list->m_recentMessageCount);\n          }\n          cache()->setMailboxSyncState(mailbox->mailbox(), state);\n      }\n  }\n}"
  },
  {
    "function_name": "handleESearch(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "562-567",
    "snippet": "oid Model::handleESearch(Imap::Parser *ptr, const Imap::Responses::ESearch *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"Unhandled ESEARCH\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled ESEARCH\",",
            "resp)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleESearch(Imap::Parser *ptr, const Imap::Responses::ESearch *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"Unhandled ESEARCH\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleSearch(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "555-560",
    "snippet": "oid Model::handleSearch(Imap::Parser *ptr, const Imap::Responses::Search *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Search\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled Search\",",
            "resp)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleSearch(Imap::Parser *ptr, const Imap::Responses::Search *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Search\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleFlags(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "548-553",
    "snippet": "oid Model::handleFlags(Imap::Parser *ptr, const Imap::Responses::Flags *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Flags\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled Flags\",",
            "resp)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleFlags(Imap::Parser *ptr, const Imap::Responses::Flags *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled Flags\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleList(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "541-546",
    "snippet": "oid Model::handleList(Imap::Parser *ptr, const Imap::Responses::List *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    accessParser(ptr).listResponses << *resp;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleList(Imap::Parser *ptr, const Imap::Responses::List *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      accessParser(ptr).listResponses << *resp;\n  }\n}"
  },
  {
    "function_name": "handleNumberResponse(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "534-539",
    "snippet": "oid Model::handleNumberResponse(Imap::Parser *ptr, const Imap::Responses::NumberResponse *const resp)\n{\n    if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n        return;\n    throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled NumberResponse\", *resp);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "[Tasks API Port] Unhandled NumberResponse\",",
            "resp)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleNumberResponse(Imap::Parser *ptr, const Imap::Responses::NumberResponse *const resp)\n  {\n      if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n          return;\n      throw UnexpectedResponseReceived(\"[Tasks API Port] Unhandled NumberResponse\", *resp);\n  }\n}"
  },
  {
    "function_name": "handleCapability(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "529-532",
    "snippet": "oid Model::handleCapability(Imap::Parser *ptr, const Imap::Responses::Capability *const resp)\n{\n    updateCapabilities(ptr, resp->capabilities);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdateCapabilities(",
          "args": [
            "tr,",
            "esp->capabilities)"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "updateCapabilities(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1193-1225",
          "snippet": "id Model::updateCapabilities(Parser *parser, const QStringList capabilities)\n{\n    Q_ASSERT(parser);\n    QStringList uppercaseCaps;\n    Q_FOREACH(const QString& str, capabilities) {\n        QString cap = str.toUpper();\n        if (m_capabilitiesBlacklist.contains(cap)) {\n            logTrace(parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"Ignoring capability \\\"%1\\\"\").arg(cap));\n            continue;\n        }\n        uppercaseCaps << cap;\n    }\n    accessParser(parser).capabilities = uppercaseCaps;\n    accessParser(parser).capabilitiesFresh = true;\n    parser->enableLiteralPlus(uppercaseCaps.contains(QLatin1String(\"LITERAL+\")));\n\n    for (QMap<Parser *,ParserState>::const_iterator it = m_parsers.constBegin(); it != m_parsers.constEnd(); ++it) {\n        if (it->connState == CONN_STATE_LOGOUT) {\n            // Skip all parsers which are currently stuck in LOGOUT\n            continue;\n        } else {\n            // The CAPABILITIES were received by a first \"usable\" parser; let's treat this one as the authoritative one\n            emit capabilitiesUpdated(uppercaseCaps);\n        }\n    }\n\n    if (!uppercaseCaps.contains(QLatin1String(\"IMAP4REV1\"))) {\n        changeConnectionState(parser, CONN_STATE_LOGOUT);\n        accessParser(parser).logoutCmd = parser->logout();\n        EMIT_LATER(this, imapError, Q_ARG(QString, tr(\"We aren't talking to an IMAP4 server\")));\n        setNetworkPolicy(NETWORK_OFFLINE);\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::updateCapabilities(Parser *parser, const QStringList capabilities)\n  {\n      Q_ASSERT(parser);\n      QStringList uppercaseCaps;\n      Q_FOREACH(const QString& str, capabilities) {\n          QString cap = str.toUpper();\n          if (m_capabilitiesBlacklist.contains(cap)) {\n              logTrace(parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"Ignoring capability \\\"%1\\\"\").arg(cap));\n              continue;\n          }\n          uppercaseCaps << cap;\n      }\n      accessParser(parser).capabilities = uppercaseCaps;\n      accessParser(parser).capabilitiesFresh = true;\n      parser->enableLiteralPlus(uppercaseCaps.contains(QLatin1String(\"LITERAL+\")));\n  \n      for (QMap<Parser *,ParserState>::const_iterator it = m_parsers.constBegin(); it != m_parsers.constEnd(); ++it) {\n          if (it->connState == CONN_STATE_LOGOUT) {\n              // Skip all parsers which are currently stuck in LOGOUT\n              continue;\n          } else {\n              // The CAPABILITIES were received by a first \"usable\" parser; let's treat this one as the authoritative one\n              emit capabilitiesUpdated(uppercaseCaps);\n          }\n      }\n  \n      if (!uppercaseCaps.contains(QLatin1String(\"IMAP4REV1\"))) {\n          changeConnectionState(parser, CONN_STATE_LOGOUT);\n          accessParser(parser).logoutCmd = parser->logout();\n          EMIT_LATER(this, imapError, Q_ARG(QString, tr(\"We aren't talking to an IMAP4 server\")));\n          setNetworkPolicy(NETWORK_OFFLINE);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleCapability(Imap::Parser *ptr, const Imap::Responses::Capability *const resp)\n  {\n      updateCapabilities(ptr, resp->capabilities);\n  }\n}"
  },
  {
    "function_name": "finalizeFetchPart(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "504-527",
    "snippet": "oid Model::finalizeFetchPart(TreeItemMailbox *const mailbox, const uint sequenceNo, const QString &partId)\n{\n    // At first, verify that the message itself is marked as loaded.\n    // If it isn't, it's probably because of Model::releaseMessageData().\n    TreeItem *item = mailbox->m_children[0]; // TreeItemMsgList\n    item = item->child(sequenceNo - 1, this);   // TreeItemMessage\n    Q_ASSERT(item);   // FIXME: or rather throw an exception?\n    if (item->accessFetchStatus() == TreeItem::NONE) {\n        // ...and it indeed got released, so let's just return and don't try to check anything\n        return;\n    }\n\n    TreeItemPart *part = mailbox->partIdToPtr(this, static_cast<TreeItemMessage *>(item), partId);\n    if (! part) {\n        qDebug() << \"Can't verify part fetching status: part is not here!\";\n        return;\n    }\n    if (part->loading()) {\n        // basically, there's nothing to do if the FETCH targetted a message part and not the message as a whole\n        qDebug() << \"Imap::Model::_finalizeFetch(): didn't receive anything about message\" <<\n                 part->message()->row() << \"part\" << part->partId();\n        part->setFetchStatus(TreeItem::DONE);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "art->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art->partId",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "partId(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1601-1617",
          "snippet": "String TreeItemModifiedPart::partId() const\n{\n    if (m_modifier == OFFSET_RAW_CONTENTS) {\n        // This item is not directly fetcheable, so it does *not* make sense to ask for it.\n        // We cannot really assert at this point, though, because this function is published via the MVC interface.\n        return QLatin1String(\"application-bug-dont-fetch-this\");\n    } else if (TreeItemPart *part = dynamic_cast<TreeItemPart *>(parent())) {\n        // The TreeItemPart is supposed to prevent creation of any special subparts if it's a top-level multipart\n        Q_ASSERT(!part->isTopLevelMultiPart());\n        return part->partId() + QLatin1Char('.') + modifierToString();\n    } else {\n        // Our parent is a message/rfc822, and it's definitely not nested -> no need for parent id here\n        // Cannot assert() on a dynamic_cast<TreeItemMessage*> at this point because the part is already nullptr at this time\n        Q_ASSERT(dynamic_cast<TreeItemMessage*>(parent()));\n        return modifierToString();\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  String TreeItemModifiedPart::partId() const\n  {\n      if (m_modifier == OFFSET_RAW_CONTENTS) {\n          // This item is not directly fetcheable, so it does *not* make sense to ask for it.\n          // We cannot really assert at this point, though, because this function is published via the MVC interface.\n          return QLatin1String(\"application-bug-dont-fetch-this\");\n      } else if (TreeItemPart *part = dynamic_cast<TreeItemPart *>(parent())) {\n          // The TreeItemPart is supposed to prevent creation of any special subparts if it's a top-level multipart\n          Q_ASSERT(!part->isTopLevelMultiPart());\n          return part->partId() + QLatin1Char('.') + modifierToString();\n      } else {\n          // Our parent is a message/rfc822, and it's definitely not nested -> no need for parent id here\n          // Cannot assert() on a dynamic_cast<TreeItemMessage*> at this point because the part is already nullptr at this time\n          Q_ASSERT(dynamic_cast<TreeItemMessage*>(parent()));\n          return modifierToString();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art->message",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art->message",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art->loading",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->partIdToPtr",
          "args": [
            "his,",
            "tatic_cast<TreeItemMessage *>(item),",
            "artId)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "tem)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->accessFetchStatus",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->child",
          "args": [
            "equenceNo - 1,",
            "his)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::finalizeFetchPart(TreeItemMailbox *const mailbox, const uint sequenceNo, const QString &partId)\n  {\n      // At first, verify that the message itself is marked as loaded.\n      // If it isn't, it's probably because of Model::releaseMessageData().\n      TreeItem *item = mailbox->m_children[0]; // TreeItemMsgList\n      item = item->child(sequenceNo - 1, this);   // TreeItemMessage\n      Q_ASSERT(item);   // FIXME: or rather throw an exception?\n      if (item->accessFetchStatus() == TreeItem::NONE) {\n          // ...and it indeed got released, so let's just return and don't try to check anything\n          return;\n      }\n  \n      TreeItemPart *part = mailbox->partIdToPtr(this, static_cast<TreeItemMessage *>(item), partId);\n      if (! part) {\n          qDebug() << \"Can't verify part fetching status: part is not here!\";\n          return;\n      }\n      if (part->loading()) {\n          // basically, there's nothing to do if the FETCH targetted a message part and not the message as a whole\n          qDebug() << \"Imap::Model::_finalizeFetch(): didn't receive anything about message\" <<\n                   part->message()->row() << \"part\" << part->partId();\n          part->setFetchStatus(TreeItem::DONE);\n      }\n  }\n}"
  },
  {
    "function_name": "emitMessageCountChanged(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "495-501",
    "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox->toIndex",
          "args": [
            "his)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->toIndex",
          "args": [
            "his)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
  },
  {
    "function_name": "replaceChildMailboxes(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "434-493",
    "snippet": "oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n{\n    /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n       resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n\n    ==23294== Invalid read of size 4\n    ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n    ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n    ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n    ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n    ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n    ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n    ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n    ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n    ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n    ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n    ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n    ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n    ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n    ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n    ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n    ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n    ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n    ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n    ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n    ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n    ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n    ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n    ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n    ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n    ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n\n       I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n       that the code should *not* use tham after that point. That's just weird.\n    */\n\n    QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n\n    if (mailboxPtr->m_children.size() != 1) {\n        // There's something besides the TreeItemMsgList and we're going to\n        // overwrite them, so we have to delete them right now\n        int count = mailboxPtr->rowCount(this);\n        beginRemoveRows(parent, 1, count - 1);\n        auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n        endRemoveRows();\n\n        qDeleteAll(oldItems);\n    }\n\n    if (! mailboxes.isEmpty()) {\n        beginInsertRows(parent, 1, mailboxes.size());\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        endInsertRows();\n        Q_ASSERT(dummy.isEmpty());\n    } else {\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        Q_ASSERT(dummy.isEmpty());\n    }\n    emit dataChanged(parent, parent);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ummy.isEmpty())"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ummy.isEmpty",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->setChildren",
          "args": [
            "ailboxes)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ummy.isEmpty())"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ummy.isEmpty",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->setChildren",
          "args": [
            "ailboxes)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "arent,",
            ",",
            "ailboxes.size())"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.size",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.isEmpty",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "ldItems)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndRemoveRows(",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->setChildren",
          "args": [
            "reeItemChildrenList())"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reeItemChildrenList(",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginRemoveRows(",
          "args": [
            "arent,",
            ",",
            "ount - 1)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->rowCount",
          "args": [
            "his)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->m_children.size",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->toIndex",
          "args": [
            "his)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n  {\n      /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n         resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n  \n      ==23294== Invalid read of size 4\n      ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n      ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n      ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n      ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n      ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n      ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n      ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n      ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n      ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n      ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n      ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n      ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n      ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n      ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n      ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n      ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n      ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n      ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n      ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n      ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n      ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n      ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n      ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n      ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n      ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n  \n         I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n         that the code should *not* use tham after that point. That's just weird.\n      */\n  \n      QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n  \n      if (mailboxPtr->m_children.size() != 1) {\n          // There's something besides the TreeItemMsgList and we're going to\n          // overwrite them, so we have to delete them right now\n          int count = mailboxPtr->rowCount(this);\n          beginRemoveRows(parent, 1, count - 1);\n          auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n          endRemoveRows();\n  \n          qDeleteAll(oldItems);\n      }\n  \n      if (! mailboxes.isEmpty()) {\n          beginInsertRows(parent, 1, mailboxes.size());\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          endInsertRows();\n          Q_ASSERT(dummy.isEmpty());\n      } else {\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          Q_ASSERT(dummy.isEmpty());\n      }\n      emit dataChanged(parent, parent);\n  }\n}"
  },
  {
    "function_name": "finalizeIncrementalList(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "387-432",
    "snippet": "oid Model::finalizeIncrementalList(Parser *parser, const QString &parentMailboxName)\n{\n    TreeItemMailbox *parentMbox = findParentMailboxByName(parentMailboxName);\n    if (! parentMbox) {\n        qDebug() << \"Weird, no idea where to put the newly created mailbox\" << parentMailboxName;\n        return;\n    }\n\n    QList<TreeItem *> mailboxes;\n\n    QList<Responses::List> &listResponses = accessParser(parser).listResponses;\n    for (QList<Responses::List>::iterator it = listResponses.begin();\n         it != listResponses.end(); /* nothing */) {\n        if (it->mailbox == parentMailboxName) {\n            mailboxes << new TreeItemMailbox(parentMbox, *it);\n            it = listResponses.erase(it);\n        } else {\n            // it clearly is someone else's LIST response\n            ++it;\n        }\n    }\n    qSort(mailboxes.begin(), mailboxes.end(), MailboxNameComparator);\n\n    if (mailboxes.size() == 0) {\n        qDebug() << \"Weird, no matching LIST response for our prompt after CREATE\";\n        qDeleteAll(mailboxes);\n        return;\n    } else if (mailboxes.size() > 1) {\n        qDebug() << \"Weird, too many LIST responses for our prompt after CREATE\";\n        qDeleteAll(mailboxes);\n        return;\n    }\n\n    auto it = parentMbox->m_children.begin();\n    Q_ASSERT(it != parentMbox->m_children.end());\n    ++it;\n    while (it != parentMbox->m_children.end() && MailboxNameComparator(*it, mailboxes[0]))\n        ++it;\n    QModelIndex parentIdx = parentMbox == m_mailboxes ? QModelIndex() : parentMbox->toIndex(this);\n    if (it == parentMbox->m_children.end())\n        beginInsertRows(parentIdx, parentMbox->m_children.size(), parentMbox->m_children.size());\n    else\n        beginInsertRows(parentIdx, (*it)->row(), (*it)->row());\n    parentMbox->m_children.insert(it, mailboxes[0]);\n    endInsertRows();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.insert",
          "args": [
            "t,",
            "ailboxes[0])"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "arentIdx,",
            "*it)->row(),",
            "*it)->row())"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*it)->row",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*it)->row",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "arentIdx,",
            "arentMbox->m_children.size(),",
            "arentMbox->m_children.size())"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.size",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.size",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.end",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->toIndex",
          "args": [
            "his)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxNameComparator(",
          "args": [
            "it,",
            "ailboxes[0])"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ailboxNameComparator(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "69-79",
          "snippet": "ool MailboxNameComparator(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n\n    if (mailboxA->mailbox() == QLatin1String(\"INBOX\"))\n        return true;\n    if (mailboxB->mailbox() == QLatin1String(\"INBOX\"))\n        return false;\n    return mailboxA->mailbox().compare(mailboxB->mailbox(), Qt::CaseInsensitive) < 1;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool MailboxNameComparator(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n\n    if (mailboxA->mailbox() == QLatin1String(\"INBOX\"))\n        return true;\n    if (mailboxB->mailbox() == QLatin1String(\"INBOX\"))\n        return false;\n    return mailboxA->mailbox().compare(mailboxB->mailbox(), Qt::CaseInsensitive) < 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.end",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != parentMbox->m_children.end())"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.end",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arentMbox->m_children.begin",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "ailboxes)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.size",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "ailboxes)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.size",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sort(",
          "args": [
            "ailboxes.begin(),",
            "ailboxes.end(),",
            "ailboxNameComparator)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "uidSort(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "372-375",
          "snippet": "ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxes.end",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.begin",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.erase",
          "args": [
            "t)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.end",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.begin",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "arser)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indParentMailboxByName(",
          "args": [
            "arentMailboxName)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::finalizeIncrementalList(Parser *parser, const QString &parentMailboxName)\n  {\n      TreeItemMailbox *parentMbox = findParentMailboxByName(parentMailboxName);\n      if (! parentMbox) {\n          qDebug() << \"Weird, no idea where to put the newly created mailbox\" << parentMailboxName;\n          return;\n      }\n  \n      QList<TreeItem *> mailboxes;\n  \n      QList<Responses::List> &listResponses = accessParser(parser).listResponses;\n      for (QList<Responses::List>::iterator it = listResponses.begin();\n           it != listResponses.end(); /* nothing */) {\n          if (it->mailbox == parentMailboxName) {\n              mailboxes << new TreeItemMailbox(parentMbox, *it);\n              it = listResponses.erase(it);\n          } else {\n              // it clearly is someone else's LIST response\n              ++it;\n          }\n      }\n      qSort(mailboxes.begin(), mailboxes.end(), MailboxNameComparator);\n  \n      if (mailboxes.size() == 0) {\n          qDebug() << \"Weird, no matching LIST response for our prompt after CREATE\";\n          qDeleteAll(mailboxes);\n          return;\n      } else if (mailboxes.size() > 1) {\n          qDebug() << \"Weird, too many LIST responses for our prompt after CREATE\";\n          qDeleteAll(mailboxes);\n          return;\n      }\n  \n      auto it = parentMbox->m_children.begin();\n      Q_ASSERT(it != parentMbox->m_children.end());\n      ++it;\n      while (it != parentMbox->m_children.end() && MailboxNameComparator(*it, mailboxes[0]))\n          ++it;\n      QModelIndex parentIdx = parentMbox == m_mailboxes ? QModelIndex() : parentMbox->toIndex(this);\n      if (it == parentMbox->m_children.end())\n          beginInsertRows(parentIdx, parentMbox->m_children.size(), parentMbox->m_children.size());\n      else\n          beginInsertRows(parentIdx, (*it)->row(), (*it)->row());\n      parentMbox->m_children.insert(it, mailboxes[0]);\n      endInsertRows();\n  }\n}"
  },
  {
    "function_name": "finalizeList(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "334-385",
    "snippet": "oid Model::finalizeList(Parser *parser, TreeItemMailbox *mailboxPtr)\n{\n    TreeItemChildrenList mailboxes;\n\n    QList<Responses::List> &listResponses = accessParser(parser).listResponses;\n    const QString prefix = mailboxPtr->mailbox() + mailboxPtr->separator();\n    for (QList<Responses::List>::iterator it = listResponses.begin(); it != listResponses.end(); /* nothing */) {\n        if (it->mailbox == mailboxPtr->mailbox() || it->mailbox == prefix) {\n            // rubbish, ignore\n            it = listResponses.erase(it);\n        } else if (it->mailbox.startsWith(prefix)) {\n            mailboxes << new TreeItemMailbox(mailboxPtr, *it);\n            it = listResponses.erase(it);\n        } else {\n            // it clearly is someone else's LIST response\n            ++it;\n        }\n    }\n    qSort(mailboxes.begin(), mailboxes.end(), MailboxNameComparator);\n\n    // Remove duplicates; would be great if this could be done in a STLish way,\n    // but unfortunately std::unique won't help here (the \"duped\" part of the\n    // sequence contains undefined items)\n    if (mailboxes.size() > 1) {\n        auto it = mailboxes.begin();\n        // We've got to ignore the first one, that's the message list\n        ++it;\n        while (it != mailboxes.end()) {\n            if (MailboxNamesEqual(it[-1], *it)) {\n                delete *it;\n                it = mailboxes.erase(it);\n            } else {\n                ++it;\n            }\n        }\n    }\n\n    QList<MailboxMetadata> metadataToCache;\n    TreeItemChildrenList mailboxesWithoutChildren;\n    for (auto it = mailboxes.constBegin(); it != mailboxes.constEnd(); ++it) {\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(*it);\n        Q_ASSERT(mailbox);\n        metadataToCache.append(mailbox->mailboxMetadata());\n        if (mailbox->hasNoChildMailboxesAlreadyKnown()) {\n            mailboxesWithoutChildren << mailbox;\n        }\n    }\n    cache()->setChildMailboxes(mailboxPtr->mailbox(), metadataToCache);\n    for (auto it = mailboxesWithoutChildren.constBegin(); it != mailboxesWithoutChildren.constEnd(); ++it)\n        cache()->setChildMailboxes(static_cast<TreeItemMailbox *>(*it)->mailbox(), QList<MailboxMetadata>());\n    replaceChildMailboxes(mailboxPtr, mailboxes);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eplaceChildMailboxes(",
          "args": [
            "ailboxPtr,",
            "ailboxes)"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "replaceChildMailboxes(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "434-493",
          "snippet": "oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n{\n    /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n       resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n\n    ==23294== Invalid read of size 4\n    ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n    ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n    ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n    ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n    ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n    ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n    ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n    ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n    ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n    ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n    ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n    ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n    ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n    ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n    ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n    ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n    ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n    ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n    ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n    ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n    ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n    ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n    ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n    ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n    ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n\n       I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n       that the code should *not* use tham after that point. That's just weird.\n    */\n\n    QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n\n    if (mailboxPtr->m_children.size() != 1) {\n        // There's something besides the TreeItemMsgList and we're going to\n        // overwrite them, so we have to delete them right now\n        int count = mailboxPtr->rowCount(this);\n        beginRemoveRows(parent, 1, count - 1);\n        auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n        endRemoveRows();\n\n        qDeleteAll(oldItems);\n    }\n\n    if (! mailboxes.isEmpty()) {\n        beginInsertRows(parent, 1, mailboxes.size());\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        endInsertRows();\n        Q_ASSERT(dummy.isEmpty());\n    } else {\n        auto dummy = mailboxPtr->setChildren(mailboxes);\n        Q_ASSERT(dummy.isEmpty());\n    }\n    emit dataChanged(parent, parent);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::replaceChildMailboxes(TreeItemMailbox *mailboxPtr, const TreeItemChildrenList &mailboxes)\n  {\n      /* Previously, we would call layoutAboutToBeChanged() and layoutChanged() here, but it\n         resulted in invalid memory access in the attached QSortFilterProxyModels like this one:\n  \n      ==23294== Invalid read of size 4\n      ==23294==    at 0x5EA34B1: QSortFilterProxyModelPrivate::index_to_iterator(QModelIndex const&) const (qsortfilterproxymodel.cpp:191)\n      ==23294==    by 0x5E9F8A3: QSortFilterProxyModel::parent(QModelIndex const&) const (qsortfilterproxymodel.cpp:1654)\n      ==23294==    by 0x5C5D45D: QModelIndex::parent() const (qabstractitemmodel.h:389)\n      ==23294==    by 0x5E47C48: QTreeView::drawRow(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const (qtreeview.cpp:1479)\n      ==23294==    by 0x5E479D9: QTreeView::drawTree(QPainter*, QRegion const&) const (qtreeview.cpp:1441)\n      ==23294==    by 0x5E4703A: QTreeView::paintEvent(QPaintEvent*) (qtreeview.cpp:1274)\n      ==23294==    by 0x5810C30: QWidget::event(QEvent*) (qwidget.cpp:8346)\n      ==23294==    by 0x5C91D03: QFrame::event(QEvent*) (qframe.cpp:557)\n      ==23294==    by 0x5D4259C: QAbstractScrollArea::viewportEvent(QEvent*) (qabstractscrollarea.cpp:1043)\n      ==23294==    by 0x5DFFD6E: QAbstractItemView::viewportEvent(QEvent*) (qabstractitemview.cpp:1619)\n      ==23294==    by 0x5E46EE0: QTreeView::viewportEvent(QEvent*) (qtreeview.cpp:1256)\n      ==23294==    by 0x5D43110: QAbstractScrollAreaPrivate::viewportEvent(QEvent*) (qabstractscrollarea_p.h:100)\n      ==23294==  Address 0x908dbec is 20 bytes inside a block of size 24 free'd\n      ==23294==    at 0x4024D74: operator delete(void*) (vg_replace_malloc.c:346)\n      ==23294==    by 0x5EA5236: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator>(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator, QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*>::const_iterator) (qalgorithms.h:322)\n      ==23294==    by 0x5EA3C06: void qDeleteAll<QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> >(QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping*> const&) (qalgorithms.h:330)\n      ==23294==    by 0x5E9E64B: QSortFilterProxyModelPrivate::_q_sourceLayoutChanged() (qsortfilterproxymodel.cpp:1249)\n      ==23294==    by 0x5EA29EC: QSortFilterProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qsortfilterproxymodel.cpp:133)\n      ==23294==    by 0x80EB205: Imap::Mailbox::PrettyMailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_PrettyMailboxModel.cpp:64)\n      ==23294==    by 0x65D3EAD: QMetaObject::metacall(QObject*, QMetaObject::Call, int, void**) (qmetaobject.cpp:237)\n      ==23294==    by 0x65E8D7C: QMetaObject::activate(QObject*, QMetaObject const*, int, void**) (qobject.cpp:3272)\n      ==23294==    by 0x664A7E8: QAbstractItemModel::layoutChanged() (moc_qabstractitemmodel.cpp:161)\n      ==23294==    by 0x664A354: QAbstractItemModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractitemmodel.cpp:118)\n      ==23294==    by 0x5E9A3A9: QAbstractProxyModel::qt_metacall(QMetaObject::Call, int, void**) (moc_qabstractproxymodel.cpp:67)\n      ==23294==    by 0x80EAF3D: Imap::Mailbox::MailboxModel::qt_metacall(QMetaObject::Call, int, void**) (moc_MailboxModel.cpp:81)\n  \n         I have no idea why something like that happens -- layoutChanged() should be a hint that the indexes are gone now, which means\n         that the code should *not* use tham after that point. That's just weird.\n      */\n  \n      QModelIndex parent = mailboxPtr == m_mailboxes ? QModelIndex() : mailboxPtr->toIndex(this);\n  \n      if (mailboxPtr->m_children.size() != 1) {\n          // There's something besides the TreeItemMsgList and we're going to\n          // overwrite them, so we have to delete them right now\n          int count = mailboxPtr->rowCount(this);\n          beginRemoveRows(parent, 1, count - 1);\n          auto oldItems = mailboxPtr->setChildren(TreeItemChildrenList());\n          endRemoveRows();\n  \n          qDeleteAll(oldItems);\n      }\n  \n      if (! mailboxes.isEmpty()) {\n          beginInsertRows(parent, 1, mailboxes.size());\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          endInsertRows();\n          Q_ASSERT(dummy.isEmpty());\n      } else {\n          auto dummy = mailboxPtr->setChildren(mailboxes);\n          Q_ASSERT(dummy.isEmpty());\n      }\n      emit dataChanged(parent, parent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ache",
          "args": [
            "tatic_cast<TreeItemMailbox *>(*it)->mailbox(),",
            "List<MailboxMetadata>())"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "setMessageThreading(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "815-831",
          "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "List<MailboxMetadata>",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "reloadMailboxList(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "832-835",
          "snippet": "oid Model::reloadMailboxList()\n{\n    m_mailboxes->rescanForChildMailboxes(this);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::reloadMailboxList()\n  {\n      m_mailboxes->rescanForChildMailboxes(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMailbox *>",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMailbox *>",
          "args": [
            "it)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ache(",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "~AbstractCache(",
          "container": "bstractCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Cache.cpp",
          "lines": "32-34",
          "snippet": "bstractCache::~AbstractCache()\n{\n}",
          "includes": [
            "include \"Cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Cache.h\"\n\nbstractCache {\n  bstractCache::~AbstractCache()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxesWithoutChildren.constEnd",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxesWithoutChildren.constBegin",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->hasNoChildMailboxesAlreadyKnown",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "hasNoChildMailboxesAlreadyKnown(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "284-292",
          "snippet": "ool TreeItemMailbox::hasNoChildMailboxesAlreadyKnown()\n{\n    if (m_metadata.flags.contains(flagNoInferiors) ||\n        (m_metadata.flags.contains(flagHasNoChildren) &&\n         ! m_metadata.flags.contains(flagHasChildren)))\n        return true;\n    else\n        return false;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  ool TreeItemMailbox::hasNoChildMailboxesAlreadyKnown()\n  {\n      if (m_metadata.flags.contains(flagNoInferiors) ||\n          (m_metadata.flags.contains(flagHasNoChildren) &&\n           ! m_metadata.flags.contains(flagHasChildren)))\n          return true;\n      else\n          return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etadataToCache.append",
          "args": [
            "ailbox->mailboxMetadata())"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailboxMetadata",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "it)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.constEnd",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.constBegin",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.erase",
          "args": [
            "t)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxNamesEqual(",
          "args": [
            "t[-1],",
            "it)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ailboxNamesEqual(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "55-63",
          "snippet": "ool MailboxNamesEqual(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n    Q_ASSERT(mailboxA);\n    Q_ASSERT(mailboxB);\n\n    return mailboxA->mailbox() == mailboxB->mailbox();\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool MailboxNamesEqual(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n    Q_ASSERT(mailboxA);\n    Q_ASSERT(mailboxB);\n\n    return mailboxA->mailbox() == mailboxB->mailbox();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxes.end",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.begin",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.size",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sort(",
          "args": [
            "ailboxes.begin(),",
            "ailboxes.end(),",
            "ailboxNameComparator)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "uidSort(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "372-375",
          "snippet": "ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxes.end",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxes.begin",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.erase",
          "args": [
            "t)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->mailbox.startsWith",
          "args": [
            "refix)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.erase",
          "args": [
            "t)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.end",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istResponses.begin",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->separator",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxPtr->mailbox",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "arser)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::finalizeList(Parser *parser, TreeItemMailbox *mailboxPtr)\n  {\n      TreeItemChildrenList mailboxes;\n  \n      QList<Responses::List> &listResponses = accessParser(parser).listResponses;\n      const QString prefix = mailboxPtr->mailbox() + mailboxPtr->separator();\n      for (QList<Responses::List>::iterator it = listResponses.begin(); it != listResponses.end(); /* nothing */) {\n          if (it->mailbox == mailboxPtr->mailbox() || it->mailbox == prefix) {\n              // rubbish, ignore\n              it = listResponses.erase(it);\n          } else if (it->mailbox.startsWith(prefix)) {\n              mailboxes << new TreeItemMailbox(mailboxPtr, *it);\n              it = listResponses.erase(it);\n          } else {\n              // it clearly is someone else's LIST response\n              ++it;\n          }\n      }\n      qSort(mailboxes.begin(), mailboxes.end(), MailboxNameComparator);\n  \n      // Remove duplicates; would be great if this could be done in a STLish way,\n      // but unfortunately std::unique won't help here (the \"duped\" part of the\n      // sequence contains undefined items)\n      if (mailboxes.size() > 1) {\n          auto it = mailboxes.begin();\n          // We've got to ignore the first one, that's the message list\n          ++it;\n          while (it != mailboxes.end()) {\n              if (MailboxNamesEqual(it[-1], *it)) {\n                  delete *it;\n                  it = mailboxes.erase(it);\n              } else {\n                  ++it;\n              }\n          }\n      }\n  \n      QList<MailboxMetadata> metadataToCache;\n      TreeItemChildrenList mailboxesWithoutChildren;\n      for (auto it = mailboxes.constBegin(); it != mailboxes.constEnd(); ++it) {\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(*it);\n          Q_ASSERT(mailbox);\n          metadataToCache.append(mailbox->mailboxMetadata());\n          if (mailbox->hasNoChildMailboxesAlreadyKnown()) {\n              mailboxesWithoutChildren << mailbox;\n          }\n      }\n      cache()->setChildMailboxes(mailboxPtr->mailbox(), metadataToCache);\n      for (auto it = mailboxesWithoutChildren.constBegin(); it != mailboxesWithoutChildren.constEnd(); ++it)\n          cache()->setChildMailboxes(static_cast<TreeItemMailbox *>(*it)->mailbox(), QList<MailboxMetadata>());\n      replaceChildMailboxes(mailboxPtr, mailboxes);\n  }\n}"
  },
  {
    "function_name": "handleState(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "282-332",
    "snippet": "oid Model::handleState(Imap::Parser *ptr, const Imap::Responses::State *const resp)\n{\n    // OK/NO/BAD/PREAUTH/BYE\n    using namespace Imap::Responses;\n\n    const QString &tag = resp->tag;\n\n    if (!tag.isEmpty()) {\n        if (tag == accessParser(ptr).logoutCmd) {\n            // The LOGOUT is special, as it isn't associated with any task\n            killParser(ptr, PARSER_KILL_EXPECTED);\n        } else {\n            if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n                return;\n            // Unhandled command -- this is *extremely* weird\n            throw CantHappen(\"The following command should have been handled elsewhere\", *resp);\n        }\n    } else {\n        // untagged response\n        // FIXME: we should probably just eat them and don't bother, as untagged OK/NO could be rather common...\n        switch (resp->kind) {\n        case BYE:\n            if (accessParser(ptr).logoutCmd.isEmpty()) {\n                // The connection got closed but we haven't really requested that -- we better treat that as error, including\n                // going offline...\n                // ... but before that, expect that the connection will get closed soon\n                accessParser(ptr).connState = CONN_STATE_LOGOUT;\n                EMIT_LATER(this, imapError, Q_ARG(QString, resp->message));\n                setNetworkPolicy(NETWORK_OFFLINE);\n            }\n            if (accessParser(ptr).parser) {\n                // previous block could enter the event loop and hence kill our parser; we shouldn't try to kill it twice\n                killParser(ptr, PARSER_KILL_EXPECTED);\n            }\n            break;\n        case OK:\n            if (resp->respCode == NONE) {\n                // This one probably should not be logged at all; dovecot sends these reponses to keep NATted connections alive\n                break;\n            } else {\n                logTrace(ptr->parserId(), Common::LOG_OTHER, QString(), QLatin1String(\"Warning: unhandled untagged OK with a response code\"));\n                break;\n            }\n        case NO:\n            logTrace(ptr->parserId(), Common::LOG_OTHER, QString(), QLatin1String(\"Warning: unhandled untagged NO...\"));\n            break;\n        default:\n            throw UnexpectedResponseReceived(\"Unhandled untagged response, sorry\", *resp);\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "Unhandled untagged response, sorry\",",
            "resp)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "tr->parserId(),",
            "ommon::LOG_OTHER,",
            "String(),",
            "Latin1String(\"Warning: unhandled untagged NO...\"))"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1774-1794",
          "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Warning: unhandled untagged NO...\")"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "modifierToString(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1624-1640",
          "snippet": "String TreeItemModifiedPart::modifierToString() const\n{\n    switch (m_modifier) {\n    case OFFSET_HEADER:\n        return QLatin1String(\"HEADER\");\n    case OFFSET_TEXT:\n        return QLatin1String(\"TEXT\");\n    case OFFSET_MIME:\n        return QLatin1String(\"MIME\");\n    case OFFSET_RAW_CONTENTS:\n        Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n        // fall through\n    default:\n        Q_ASSERT(false);\n        return QString();\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  String TreeItemModifiedPart::modifierToString() const\n  {\n      switch (m_modifier) {\n      case OFFSET_HEADER:\n          return QLatin1String(\"HEADER\");\n      case OFFSET_TEXT:\n          return QLatin1String(\"TEXT\");\n      case OFFSET_MIME:\n          return QLatin1String(\"MIME\");\n      case OFFSET_RAW_CONTENTS:\n          Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n          // fall through\n      default:\n          Q_ASSERT(false);\n          return QString();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr->parserId",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Warning: unhandled untagged OK with a response code\")"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr->parserId",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "illParser(",
          "args": [
            "tr,",
            "ARSER_KILL_EXPECTED)"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "killParser(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1462-1493",
          "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etNetworkPolicy(",
          "args": [
            "ETWORK_OFFLINE)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "setNetworkPolicy(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1069-1124",
          "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "his,",
            "mapError,",
            "_ARG(QString, resp->message))"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "esp->message)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "The following command should have been handled elsewhere\",",
            "resp)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessParser(",
          "args": [
            "tr)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag.isEmpty",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::handleState(Imap::Parser *ptr, const Imap::Responses::State *const resp)\n  {\n      // OK/NO/BAD/PREAUTH/BYE\n      using namespace Imap::Responses;\n  \n      const QString &tag = resp->tag;\n  \n      if (!tag.isEmpty()) {\n          if (tag == accessParser(ptr).logoutCmd) {\n              // The LOGOUT is special, as it isn't associated with any task\n              killParser(ptr, PARSER_KILL_EXPECTED);\n          } else {\n              if (accessParser(ptr).connState == CONN_STATE_LOGOUT)\n                  return;\n              // Unhandled command -- this is *extremely* weird\n              throw CantHappen(\"The following command should have been handled elsewhere\", *resp);\n          }\n      } else {\n          // untagged response\n          // FIXME: we should probably just eat them and don't bother, as untagged OK/NO could be rather common...\n          switch (resp->kind) {\n          case BYE:\n              if (accessParser(ptr).logoutCmd.isEmpty()) {\n                  // The connection got closed but we haven't really requested that -- we better treat that as error, including\n                  // going offline...\n                  // ... but before that, expect that the connection will get closed soon\n                  accessParser(ptr).connState = CONN_STATE_LOGOUT;\n                  EMIT_LATER(this, imapError, Q_ARG(QString, resp->message));\n                  setNetworkPolicy(NETWORK_OFFLINE);\n              }\n              if (accessParser(ptr).parser) {\n                  // previous block could enter the event loop and hence kill our parser; we shouldn't try to kill it twice\n                  killParser(ptr, PARSER_KILL_EXPECTED);\n              }\n              break;\n          case OK:\n              if (resp->respCode == NONE) {\n                  // This one probably should not be logged at all; dovecot sends these reponses to keep NATted connections alive\n                  break;\n              } else {\n                  logTrace(ptr->parserId(), Common::LOG_OTHER, QString(), QLatin1String(\"Warning: unhandled untagged OK with a response code\"));\n                  break;\n              }\n          case NO:\n              logTrace(ptr->parserId(), Common::LOG_OTHER, QString(), QLatin1String(\"Warning: unhandled untagged NO...\"));\n              break;\n          default:\n              throw UnexpectedResponseReceived(\"Unhandled untagged response, sorry\", *resp);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "responseReceived(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "167-280",
    "snippet": "oid Model::responseReceived(const QMap<Parser *,ParserState>::iterator it)\n{\n    Q_ASSERT(it->parser);\n\n    int counter = 0;\n    while (it->parser && it->parser->hasResponse()) {\n        QSharedPointer<Imap::Responses::AbstractResponse> resp = it->parser->getResponse();\n        Q_ASSERT(resp);\n        // Always log BAD responses from a central place. They're bad enough to warant an extra treatment.\n        // FIXME: is it worth an UI popup?\n        if (Responses::State *stateResponse = dynamic_cast<Responses::State *>(resp.data())) {\n            if (stateResponse->kind == Responses::BAD) {\n                QString buf;\n                QTextStream s(&buf);\n                s << *stateResponse;\n                logTrace(it->parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"BAD response: %1\").arg(buf));\n                qDebug() << buf;\n            }\n        }\n        try {\n            /* At this point, we want to iterate over all active tasks and try them\n            for processing the server's responses (the plug() method). However, this\n            is rather complex -- this call to plug() could result in signals being\n            emitted, and certain slots connected to those signals might in turn want\n            to queue more Tasks. Therefore, it->activeTasks could be modified, some\n            items could be appended to it using the QList::append, which in turn could\n            cause a realloc to happen, happily invalidating our iterators, and that\n            kind of sucks.\n\n            So, we have to iterate over a copy of the original list and instead of\n            deleting Tasks, we store them into a temporary list. When we're done with\n            processing, we walk the original list once again and simply remove all\n            \"deleted\" items for real.\n\n            This took me 3+ hours to track it down to what the hell was happening here,\n            even though the underlying reason is simple -- QList::append() could invalidate\n            existing iterators.\n            */\n\n            bool handled = false;\n            QList<ImapTask *> taskSnapshot = it->activeTasks;\n            QList<ImapTask *> deletedTasks;\n            QList<ImapTask *>::const_iterator taskEnd = taskSnapshot.constEnd();\n\n            // Try various tasks, perhaps it's their response. Also check if they're already finished and remove them.\n            for (QList<ImapTask *>::const_iterator taskIt = taskSnapshot.constBegin(); taskIt != taskEnd; ++taskIt) {\n                if (! handled) {\n\n#ifdef DEBUG_TASK_ROUTING\n                    try {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, QString(),\n                                 QString::fromAscii(\"Routing to %1 %2\").arg((*taskIt)->metaObject()->className(),\n                                                                            (*taskIt)->debugIdentification()));\n#endif\n                    handled = resp->plug(*taskIt);\n#ifdef DEBUG_TASK_ROUTING\n                        if (handled) {\n                            logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Handled\"));\n                        }\n                    } catch (std::exception &e) {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Got exception when handling\"));\n                        throw;\n                    }\n#endif\n                }\n\n                if ((*taskIt)->isFinished()) {\n                    deletedTasks << *taskIt;\n                }\n            }\n\n            removeDeletedTasks(deletedTasks, it->activeTasks);\n\n            runReadyTasks();\n\n            if (! handled) {\n                resp->plug(it->parser, this);\n#ifdef DEBUG_TASK_ROUTING\n                if (it->parser) {\n                    logTrace(it->parser->parserId(), Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                } else {\n                    logTrace(0, Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                }\n#endif\n            }\n        } catch (Imap::StartTlsFailed &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            logTrace(parserId, Common::LOG_PARSE_ERROR, QString::fromStdString(e.exceptionClass()), QLatin1String(\"STARTTLS has failed\"));\n            EMIT_LATER(this, networkError, Q_ARG(QString, tr(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\")));\n            setNetworkPolicy(NETWORK_OFFLINE);\n            break;\n        } catch (Imap::ImapException &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            broadcastParseError(parserId, QString::fromStdString(e.exceptionClass()), e.what(), e.line(), e.offset());\n            break;\n        }\n\n        // Return to the event loop every 100 messages to handle GUI events\n        ++counter;\n        if (counter == 100) {\n            QTimer::singleShot(0, this, SLOT(responseReceived()));\n            break;\n        }\n    }\n\n    if (!it->parser) {\n        // He's dead, Jim\n        killParser(it.key(), PARSER_JUST_DELETE_LATER);\n        m_parsers.erase(it);\n        RESET_MODEL_2(m_taskModel);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ESET_MODEL_2(",
          "args": [
            "_taskModel)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parsers.erase",
          "args": [
            "t)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "illParser(",
          "args": [
            "t.key(),",
            "ARSER_JUST_DELETE_LATER)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "killParser(P",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1462-1493",
          "snippet": "id Model::killParser(Parser *parser, ParserKillingMethod method)\n{\n    if (method == PARSER_JUST_DELETE_LATER) {\n        Q_ASSERT(accessParser(parser).parser == 0);\n        Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n            task->deleteLater();\n        }\n        parser->deleteLater();\n        return;\n    }\n\n    Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n        // FIXME: now this message sucks\n        task->die(tr(\"The connection is being killed for unspecified reason\"));\n    }\n\n    parser->disconnect();\n    Q_ASSERT(accessParser(parser).parser);\n    accessParser(parser).parser = 0;\n    switch (method) {\n    case PARSER_KILL_EXPECTED:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n        return;\n    case PARSER_KILL_HARD:\n        logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n        return;\n    case PARSER_JUST_DELETE_LATER:\n        // already handled\n        return;\n    }\n    Q_ASSERT(false);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::killParser(Parser *parser, ParserKillingMethod method)\n  {\n      if (method == PARSER_JUST_DELETE_LATER) {\n          Q_ASSERT(accessParser(parser).parser == 0);\n          Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n              task->deleteLater();\n          }\n          parser->deleteLater();\n          return;\n      }\n  \n      Q_FOREACH(ImapTask *task, accessParser(parser).activeTasks) {\n          // FIXME: now this message sucks\n          task->die(tr(\"The connection is being killed for unspecified reason\"));\n      }\n  \n      parser->disconnect();\n      Q_ASSERT(accessParser(parser).parser);\n      accessParser(parser).parser = 0;\n      switch (method) {\n      case PARSER_KILL_EXPECTED:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection closed.\");\n          return;\n      case PARSER_KILL_HARD:\n          logTrace(parser->parserId(), Common::LOG_IO_WRITTEN, QString(), \"*** Connection killed.\");\n          return;\n      case PARSER_JUST_DELETE_LATER:\n          // already handled\n          return;\n      }\n      Q_ASSERT(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(responseReceived()))"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "esponseReceived())"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esponseReceived(",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "responseReceived(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "148-153",
          "snippet": "oid Model::responseReceived()\n{\n    for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n        responseReceived(it);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "roadcastParseError(",
          "args": [
            "arserId,",
            "String::fromStdString(e.exceptionClass()),",
            ".what(),",
            ".line(),",
            ".offset())"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "broadcastParseError(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1150-1180",
          "snippet": "oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n{\n    emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n    QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n    logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n    QString message;\n    if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n        QString service;\n        if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n            service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n        } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n            service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n        }\n        message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                         \"%1\"\n                         \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                         \"A typical port number for IMAP is 143 or 993.</p>\"\n                         \"<p>The server said:</p>\"\n                         \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n    } else {\n        message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                         \"This might either mean that there's a bug in Trojit's code, or \"\n                         \"that the IMAP server you are connected to is broken. Please \"\n                         \"report this as a bug anyway. Here are the details:</p>\"\n                         \"<p><b>%1</b>: %2</p>\"\n                         \"<pre>%3\\n%4</pre>\"\n                         ).arg(exceptionClass, errorMessage, line, details);\n    }\n    EMIT_LATER(this, imapError, Q_ARG(QString, message));\n    setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::broadcastParseError(const uint parser, const QString &exceptionClass, const QString &errorMessage, const QByteArray &line, int position)\n  {\n      emit logParserFatalError(parser, exceptionClass, errorMessage, line, position);\n      QByteArray details = (position == -1) ? QByteArray() : QByteArray(position, ' ') + QByteArray(\"^ here\");\n      logTrace(parser, Common::LOG_PARSE_ERROR, exceptionClass, QString::fromUtf8(\"%1\\n%2\\n%3\").arg(errorMessage, line, details));\n      QString message;\n      if (exceptionClass == QLatin1String(\"NotAnImapServerError\")) {\n          QString service;\n          if (line.startsWith(\"+OK\") || line.startsWith(\"-ERR\")) {\n              service = tr(\"<p>It appears that you are connecting to a POP3 server. That won't work here.</p>\");\n          } else if (line.startsWith(\"220 \") || line.startsWith(\"220-\")) {\n              service = tr(\"<p>It appears that you are connecting to an SMTP server. That won't work here.</p>\");\n          }\n          message = trUtf8(\"<h2>This is not an IMAP server</h2>\"\n                           \"%1\"\n                           \"<p>Please check your settings to make sure you are connecting to the IMAP service. \"\n                           \"A typical port number for IMAP is 143 or 993.</p>\"\n                           \"<p>The server said:</p>\"\n                           \"<pre>%2</pre>\").arg(service, QString::fromUtf8(line.constData()));\n      } else {\n          message = trUtf8(\"<p>The IMAP server sent us a reply which we could not parse. \"\n                           \"This might either mean that there's a bug in Trojit's code, or \"\n                           \"that the IMAP server you are connected to is broken. Please \"\n                           \"report this as a bug anyway. Here are the details:</p>\"\n                           \"<p><b>%1</b>: %2</p>\"\n                           \"<pre>%3\\n%4</pre>\"\n                           ).arg(exceptionClass, errorMessage, line, details);\n      }\n      EMIT_LATER(this, imapError, Q_ARG(QString, message));\n      setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".offset",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".line",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "sNetworkOnline(",
          "container": "odel:",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.h",
          "lines": "214-214",
          "snippet": "ool isNetworkOnline() const { return m_netPolicy == NETWORK_ONLINE; }",
          "includes": [
            "include \"Common/Logging.h\"",
            "include \"TaskFactory.h\"",
            "include \"ParserState.h\"\n#",
            "include \"NetworkPolicy.h\"\n#",
            "include \"FlagsOperation.h\"\n#",
            "include \"CopyMoveOperation.h\"\n#",
            "include \"CacheLoadingMode.h\"\n#",
            "include \"../Parser/Parser.h\"\n#",
            "include \"../ConnectionState.h\"\n#",
            "include \"Cache.h\"\n#",
            "include <QTimer>\n#",
            "include <QPointer>\n#",
            "include <QAbstractItemModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/Logging.h\"\ninclude \"TaskFactory.h\"\ninclude \"ParserState.h\"\n#\ninclude \"NetworkPolicy.h\"\n#\ninclude \"FlagsOperation.h\"\n#\ninclude \"CopyMoveOperation.h\"\n#\ninclude \"CacheLoadingMode.h\"\n#\ninclude \"../Parser/Parser.h\"\n#\ninclude \"../ConnectionState.h\"\n#\ninclude \"Cache.h\"\n#\ninclude <QTimer>\n#\ninclude <QPointer>\n#\ninclude <QAbstractItemModel>\n#\n\nodel: {\n  ool isNetworkOnline() const { return m_netPolicy == NETWORK_ONLINE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".what",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromStdString(",
          "args": [
            ".exceptionClass())"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".exceptionClass",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etNetworkPolicy(",
          "args": [
            "ETWORK_OFFLINE)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "setNetworkPolicy(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1069-1124",
          "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "his,",
            "etworkError,",
            "_ARG(QString, tr(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\")))"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "r(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\"))"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "<p>The server has refused to start the encryption through the STARTTLS command.</p>\")"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "setImapUser(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1851-1854",
          "snippet": "id Model::setImapUser(const QString &imapUser)\n{\n    m_imapUser = imapUser;\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::setImapUser(const QString &imapUser)\n  {\n      m_imapUser = imapUser;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "arserId,",
            "ommon::LOG_PARSE_ERROR,",
            "String::fromStdString(e.exceptionClass()),",
            "Latin1String(\"STARTTLS has failed\"))"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1774-1794",
          "snippet": "id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n{\n    QModelIndex translatedIndex;\n    realTreeItem(relevantIndex, 0, &translatedIndex);\n\n    // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n    uint parserId = 0;\n\n    if (translatedIndex.isValid()) {\n        Q_ASSERT(translatedIndex.model() == this);\n        QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n        Q_ASSERT(mailboxIndex.isValid());\n        TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailboxPtr);\n        if (mailboxPtr->maintainingTask) {\n            parserId = mailboxPtr->maintainingTask->parser->parserId();\n        }\n    }\n\n    logTrace(parserId, kind, source, message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::logTrace(const QModelIndex &relevantIndex, const Common::LogKind kind, const QString &source, const QString &message)\n  {\n      QModelIndex translatedIndex;\n      realTreeItem(relevantIndex, 0, &translatedIndex);\n  \n      // It appears that it's OK to use 0 here; the attached loggers apparently deal with random parsers appearing just OK\n      uint parserId = 0;\n  \n      if (translatedIndex.isValid()) {\n          Q_ASSERT(translatedIndex.model() == this);\n          QModelIndex mailboxIndex = findMailboxForItems(QModelIndexList() << translatedIndex);\n          Q_ASSERT(mailboxIndex.isValid());\n          TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailboxPtr);\n          if (mailboxPtr->maintainingTask) {\n              parserId = mailboxPtr->maintainingTask->parser->parserId();\n          }\n      }\n  \n      logTrace(parserId, kind, source, message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "STARTTLS has failed\")"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromStdString(",
          "args": [
            ".exceptionClass())"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".exceptionClass",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Handled\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Model\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Handled\")"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Model\")"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->plug",
          "args": [
            "t->parser,",
            "his)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unReadyTasks(",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "runReadyTasks()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1513-1541",
          "snippet": "id Model::runReadyTasks()\n{\n    for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n        bool runSomething = false;\n        do {\n            runSomething = false;\n            // See responseReceived() for more details about why we do need to iterate over a copy here.\n            // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n            QList<ImapTask *> origList = parserIt->activeTasks;\n            QList<ImapTask *> deletedList;\n            QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n            for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                ImapTask *task = *taskIt;\n                if (task->isReadyToRun()) {\n                    task->perform();\n                    runSomething = true;\n                }\n                if (task->isFinished()) {\n                    deletedList << task;\n                }\n            }\n            removeDeletedTasks(deletedList, parserIt->activeTasks);\n#ifdef TROJITA_DEBUG_TASK_TREE\n            if (!deletedList.isEmpty())\n                checkTaskTreeConsistency();\n#endif\n        } while (runSomething);\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::runReadyTasks()\n  {\n      for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n          bool runSomething = false;\n          do {\n              runSomething = false;\n              // See responseReceived() for more details about why we do need to iterate over a copy here.\n              // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n              QList<ImapTask *> origList = parserIt->activeTasks;\n              QList<ImapTask *> deletedList;\n              QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n              for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                  ImapTask *task = *taskIt;\n                  if (task->isReadyToRun()) {\n                      task->perform();\n                      runSomething = true;\n                  }\n                  if (task->isFinished()) {\n                      deletedList << task;\n                  }\n              }\n              removeDeletedTasks(deletedList, parserIt->activeTasks);\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              if (!deletedList.isEmpty())\n                  checkTaskTreeConsistency();\n  #endif\n          } while (runSomething);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "emoveDeletedTasks(",
          "args": [
            "eletedTasks,",
            "t->activeTasks)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "removeDeletedTasks(c",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1543-1552",
          "snippet": "id Model::removeDeletedTasks(const QList<ImapTask *> &deletedTasks, QList<ImapTask *> &activeTasks)\n{\n    // Remove the finished commands\n    for (QList<ImapTask *>::const_iterator deletedIt = deletedTasks.begin(); deletedIt != deletedTasks.end(); ++deletedIt) {\n        (*deletedIt)->deleteLater();\n        activeTasks.removeOne(*deletedIt);\n        // It isn't destroyed yet, but should be removed from the model nonetheless\n        m_taskModel->slotTaskDestroyed(*deletedIt);\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::removeDeletedTasks(const QList<ImapTask *> &deletedTasks, QList<ImapTask *> &activeTasks)\n  {\n      // Remove the finished commands\n      for (QList<ImapTask *>::const_iterator deletedIt = deletedTasks.begin(); deletedIt != deletedTasks.end(); ++deletedIt) {\n          (*deletedIt)->deleteLater();\n          activeTasks.removeOne(*deletedIt);\n          // It isn't destroyed yet, but should be removed from the model nonetheless\n          m_taskModel->slotTaskDestroyed(*deletedIt);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "*taskIt)->isFinished",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Got exception when handling\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*taskIt)->debugIdentification",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Handled\")"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*taskIt)->debugIdentification",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->plug",
          "args": [
            "taskIt)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromAscii",
          "args": [
            "*taskIt)->metaObject()->className(),",
            "*taskIt)->debugIdentification())"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*taskIt)->debugIdentification",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*taskIt)->metaObject",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*taskIt)->metaObject",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromAscii(",
          "args": [
            "Routing to %1 %2\")"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "modifierToString(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1624-1640",
          "snippet": "String TreeItemModifiedPart::modifierToString() const\n{\n    switch (m_modifier) {\n    case OFFSET_HEADER:\n        return QLatin1String(\"HEADER\");\n    case OFFSET_TEXT:\n        return QLatin1String(\"TEXT\");\n    case OFFSET_MIME:\n        return QLatin1String(\"MIME\");\n    case OFFSET_RAW_CONTENTS:\n        Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n        // fall through\n    default:\n        Q_ASSERT(false);\n        return QString();\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  String TreeItemModifiedPart::modifierToString() const\n  {\n      switch (m_modifier) {\n      case OFFSET_HEADER:\n          return QLatin1String(\"HEADER\");\n      case OFFSET_TEXT:\n          return QLatin1String(\"TEXT\");\n      case OFFSET_MIME:\n          return QLatin1String(\"MIME\");\n      case OFFSET_RAW_CONTENTS:\n          Q_ASSERT(!\"Cannot get the fetch modifier for an OFFSET_RAW_CONTENTS item\");\n          // fall through\n      default:\n          Q_ASSERT(false);\n          return QString();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "askSnapshot.constBegin",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "askSnapshot.constEnd",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "uf)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "BAD response: %1\")"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Model\")"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->parserId",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<Responses::State *>",
          "args": [
            "esp.data())"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp.data",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "esp)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->getResponse",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->parser->hasResponse",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t->parser)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::responseReceived(const QMap<Parser *,ParserState>::iterator it)\n  {\n      Q_ASSERT(it->parser);\n  \n      int counter = 0;\n      while (it->parser && it->parser->hasResponse()) {\n          QSharedPointer<Imap::Responses::AbstractResponse> resp = it->parser->getResponse();\n          Q_ASSERT(resp);\n          // Always log BAD responses from a central place. They're bad enough to warant an extra treatment.\n          // FIXME: is it worth an UI popup?\n          if (Responses::State *stateResponse = dynamic_cast<Responses::State *>(resp.data())) {\n              if (stateResponse->kind == Responses::BAD) {\n                  QString buf;\n                  QTextStream s(&buf);\n                  s << *stateResponse;\n                  logTrace(it->parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"BAD response: %1\").arg(buf));\n                  qDebug() << buf;\n              }\n          }\n          try {\n              /* At this point, we want to iterate over all active tasks and try them\n              for processing the server's responses (the plug() method). However, this\n              is rather complex -- this call to plug() could result in signals being\n              emitted, and certain slots connected to those signals might in turn want\n              to queue more Tasks. Therefore, it->activeTasks could be modified, some\n              items could be appended to it using the QList::append, which in turn could\n              cause a realloc to happen, happily invalidating our iterators, and that\n              kind of sucks.\n  \n              So, we have to iterate over a copy of the original list and instead of\n              deleting Tasks, we store them into a temporary list. When we're done with\n              processing, we walk the original list once again and simply remove all\n              \"deleted\" items for real.\n  \n              This took me 3+ hours to track it down to what the hell was happening here,\n              even though the underlying reason is simple -- QList::append() could invalidate\n              existing iterators.\n              */\n  \n              bool handled = false;\n              QList<ImapTask *> taskSnapshot = it->activeTasks;\n              QList<ImapTask *> deletedTasks;\n              QList<ImapTask *>::const_iterator taskEnd = taskSnapshot.constEnd();\n  \n              // Try various tasks, perhaps it's their response. Also check if they're already finished and remove them.\n              for (QList<ImapTask *>::const_iterator taskIt = taskSnapshot.constBegin(); taskIt != taskEnd; ++taskIt) {\n                  if (! handled) {\n  \n  #ifdef DEBUG_TASK_ROUTING\n                      try {\n                          logTrace(it->parser->parserId(), Common::LOG_TASKS, QString(),\n                                   QString::fromAscii(\"Routing to %1 %2\").arg((*taskIt)->metaObject()->className(),\n                                                                              (*taskIt)->debugIdentification()));\n  #endif\n                      handled = resp->plug(*taskIt);\n  #ifdef DEBUG_TASK_ROUTING\n                          if (handled) {\n                              logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Handled\"));\n                          }\n                      } catch (std::exception &e) {\n                          logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Got exception when handling\"));\n                          throw;\n                      }\n  #endif\n                  }\n  \n                  if ((*taskIt)->isFinished()) {\n                      deletedTasks << *taskIt;\n                  }\n              }\n  \n              removeDeletedTasks(deletedTasks, it->activeTasks);\n  \n              runReadyTasks();\n  \n              if (! handled) {\n                  resp->plug(it->parser, this);\n  #ifdef DEBUG_TASK_ROUTING\n                  if (it->parser) {\n                      logTrace(it->parser->parserId(), Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                  } else {\n                      logTrace(0, Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                  }\n  #endif\n              }\n          } catch (Imap::StartTlsFailed &e) {\n              uint parserId = it->parser->parserId();\n              killParser(it->parser, PARSER_KILL_HARD);\n              logTrace(parserId, Common::LOG_PARSE_ERROR, QString::fromStdString(e.exceptionClass()), QLatin1String(\"STARTTLS has failed\"));\n              EMIT_LATER(this, networkError, Q_ARG(QString, tr(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\")));\n              setNetworkPolicy(NETWORK_OFFLINE);\n              break;\n          } catch (Imap::ImapException &e) {\n              uint parserId = it->parser->parserId();\n              killParser(it->parser, PARSER_KILL_HARD);\n              broadcastParseError(parserId, QString::fromStdString(e.exceptionClass()), e.what(), e.line(), e.offset());\n              break;\n          }\n  \n          // Return to the event loop every 100 messages to handle GUI events\n          ++counter;\n          if (counter == 100) {\n              QTimer::singleShot(0, this, SLOT(responseReceived()));\n              break;\n          }\n      }\n  \n      if (!it->parser) {\n          // He's dead, Jim\n          killParser(it.key(), PARSER_JUST_DELETE_LATER);\n          m_parsers.erase(it);\n          RESET_MODEL_2(m_taskModel);\n      }\n  }\n}"
  },
  {
    "function_name": "responseReceived(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "156-164",
    "snippet": "oid Model::responseReceived(Parser *parser)\n{\n    QMap<Parser *,ParserState>::iterator it = m_parsers.find(parser);\n    if (it == m_parsers.end()) {\n        // This is a queued signal, so it's perfectly possible that the sender is gone already\n        return;\n    }\n    responseReceived(it);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esponseReceived(",
          "args": [
            "t)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "responseReceived(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "167-280",
          "snippet": "oid Model::responseReceived(const QMap<Parser *,ParserState>::iterator it)\n{\n    Q_ASSERT(it->parser);\n\n    int counter = 0;\n    while (it->parser && it->parser->hasResponse()) {\n        QSharedPointer<Imap::Responses::AbstractResponse> resp = it->parser->getResponse();\n        Q_ASSERT(resp);\n        // Always log BAD responses from a central place. They're bad enough to warant an extra treatment.\n        // FIXME: is it worth an UI popup?\n        if (Responses::State *stateResponse = dynamic_cast<Responses::State *>(resp.data())) {\n            if (stateResponse->kind == Responses::BAD) {\n                QString buf;\n                QTextStream s(&buf);\n                s << *stateResponse;\n                logTrace(it->parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"BAD response: %1\").arg(buf));\n                qDebug() << buf;\n            }\n        }\n        try {\n            /* At this point, we want to iterate over all active tasks and try them\n            for processing the server's responses (the plug() method). However, this\n            is rather complex -- this call to plug() could result in signals being\n            emitted, and certain slots connected to those signals might in turn want\n            to queue more Tasks. Therefore, it->activeTasks could be modified, some\n            items could be appended to it using the QList::append, which in turn could\n            cause a realloc to happen, happily invalidating our iterators, and that\n            kind of sucks.\n\n            So, we have to iterate over a copy of the original list and instead of\n            deleting Tasks, we store them into a temporary list. When we're done with\n            processing, we walk the original list once again and simply remove all\n            \"deleted\" items for real.\n\n            This took me 3+ hours to track it down to what the hell was happening here,\n            even though the underlying reason is simple -- QList::append() could invalidate\n            existing iterators.\n            */\n\n            bool handled = false;\n            QList<ImapTask *> taskSnapshot = it->activeTasks;\n            QList<ImapTask *> deletedTasks;\n            QList<ImapTask *>::const_iterator taskEnd = taskSnapshot.constEnd();\n\n            // Try various tasks, perhaps it's their response. Also check if they're already finished and remove them.\n            for (QList<ImapTask *>::const_iterator taskIt = taskSnapshot.constBegin(); taskIt != taskEnd; ++taskIt) {\n                if (! handled) {\n\n#ifdef DEBUG_TASK_ROUTING\n                    try {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, QString(),\n                                 QString::fromAscii(\"Routing to %1 %2\").arg((*taskIt)->metaObject()->className(),\n                                                                            (*taskIt)->debugIdentification()));\n#endif\n                    handled = resp->plug(*taskIt);\n#ifdef DEBUG_TASK_ROUTING\n                        if (handled) {\n                            logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Handled\"));\n                        }\n                    } catch (std::exception &e) {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Got exception when handling\"));\n                        throw;\n                    }\n#endif\n                }\n\n                if ((*taskIt)->isFinished()) {\n                    deletedTasks << *taskIt;\n                }\n            }\n\n            removeDeletedTasks(deletedTasks, it->activeTasks);\n\n            runReadyTasks();\n\n            if (! handled) {\n                resp->plug(it->parser, this);\n#ifdef DEBUG_TASK_ROUTING\n                if (it->parser) {\n                    logTrace(it->parser->parserId(), Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                } else {\n                    logTrace(0, Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                }\n#endif\n            }\n        } catch (Imap::StartTlsFailed &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            logTrace(parserId, Common::LOG_PARSE_ERROR, QString::fromStdString(e.exceptionClass()), QLatin1String(\"STARTTLS has failed\"));\n            EMIT_LATER(this, networkError, Q_ARG(QString, tr(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\")));\n            setNetworkPolicy(NETWORK_OFFLINE);\n            break;\n        } catch (Imap::ImapException &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            broadcastParseError(parserId, QString::fromStdString(e.exceptionClass()), e.what(), e.line(), e.offset());\n            break;\n        }\n\n        // Return to the event loop every 100 messages to handle GUI events\n        ++counter;\n        if (counter == 100) {\n            QTimer::singleShot(0, this, SLOT(responseReceived()));\n            break;\n        }\n    }\n\n    if (!it->parser) {\n        // He's dead, Jim\n        killParser(it.key(), PARSER_JUST_DELETE_LATER);\n        m_parsers.erase(it);\n        RESET_MODEL_2(m_taskModel);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_parsers.end",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parsers.find",
          "args": [
            "arser)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::responseReceived(Parser *parser)\n  {\n      QMap<Parser *,ParserState>::iterator it = m_parsers.find(parser);\n      if (it == m_parsers.end()) {\n          // This is a queued signal, so it's perfectly possible that the sender is gone already\n          return;\n      }\n      responseReceived(it);\n  }\n}"
  },
  {
    "function_name": "responseReceived(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "148-153",
    "snippet": "oid Model::responseReceived()\n{\n    for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n        responseReceived(it);\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esponseReceived(",
          "args": [
            "t)"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "responseReceived(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "167-280",
          "snippet": "oid Model::responseReceived(const QMap<Parser *,ParserState>::iterator it)\n{\n    Q_ASSERT(it->parser);\n\n    int counter = 0;\n    while (it->parser && it->parser->hasResponse()) {\n        QSharedPointer<Imap::Responses::AbstractResponse> resp = it->parser->getResponse();\n        Q_ASSERT(resp);\n        // Always log BAD responses from a central place. They're bad enough to warant an extra treatment.\n        // FIXME: is it worth an UI popup?\n        if (Responses::State *stateResponse = dynamic_cast<Responses::State *>(resp.data())) {\n            if (stateResponse->kind == Responses::BAD) {\n                QString buf;\n                QTextStream s(&buf);\n                s << *stateResponse;\n                logTrace(it->parser->parserId(), Common::LOG_OTHER, QLatin1String(\"Model\"), QString::fromUtf8(\"BAD response: %1\").arg(buf));\n                qDebug() << buf;\n            }\n        }\n        try {\n            /* At this point, we want to iterate over all active tasks and try them\n            for processing the server's responses (the plug() method). However, this\n            is rather complex -- this call to plug() could result in signals being\n            emitted, and certain slots connected to those signals might in turn want\n            to queue more Tasks. Therefore, it->activeTasks could be modified, some\n            items could be appended to it using the QList::append, which in turn could\n            cause a realloc to happen, happily invalidating our iterators, and that\n            kind of sucks.\n\n            So, we have to iterate over a copy of the original list and instead of\n            deleting Tasks, we store them into a temporary list. When we're done with\n            processing, we walk the original list once again and simply remove all\n            \"deleted\" items for real.\n\n            This took me 3+ hours to track it down to what the hell was happening here,\n            even though the underlying reason is simple -- QList::append() could invalidate\n            existing iterators.\n            */\n\n            bool handled = false;\n            QList<ImapTask *> taskSnapshot = it->activeTasks;\n            QList<ImapTask *> deletedTasks;\n            QList<ImapTask *>::const_iterator taskEnd = taskSnapshot.constEnd();\n\n            // Try various tasks, perhaps it's their response. Also check if they're already finished and remove them.\n            for (QList<ImapTask *>::const_iterator taskIt = taskSnapshot.constBegin(); taskIt != taskEnd; ++taskIt) {\n                if (! handled) {\n\n#ifdef DEBUG_TASK_ROUTING\n                    try {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, QString(),\n                                 QString::fromAscii(\"Routing to %1 %2\").arg((*taskIt)->metaObject()->className(),\n                                                                            (*taskIt)->debugIdentification()));\n#endif\n                    handled = resp->plug(*taskIt);\n#ifdef DEBUG_TASK_ROUTING\n                        if (handled) {\n                            logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Handled\"));\n                        }\n                    } catch (std::exception &e) {\n                        logTrace(it->parser->parserId(), Common::LOG_TASKS, (*taskIt)->debugIdentification(), QLatin1String(\"Got exception when handling\"));\n                        throw;\n                    }\n#endif\n                }\n\n                if ((*taskIt)->isFinished()) {\n                    deletedTasks << *taskIt;\n                }\n            }\n\n            removeDeletedTasks(deletedTasks, it->activeTasks);\n\n            runReadyTasks();\n\n            if (! handled) {\n                resp->plug(it->parser, this);\n#ifdef DEBUG_TASK_ROUTING\n                if (it->parser) {\n                    logTrace(it->parser->parserId(), Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                } else {\n                    logTrace(0, Common::LOG_TASKS, QLatin1String(\"Model\"), QLatin1String(\"Handled\"));\n                }\n#endif\n            }\n        } catch (Imap::StartTlsFailed &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            logTrace(parserId, Common::LOG_PARSE_ERROR, QString::fromStdString(e.exceptionClass()), QLatin1String(\"STARTTLS has failed\"));\n            EMIT_LATER(this, networkError, Q_ARG(QString, tr(\"<p>The server has refused to start the encryption through the STARTTLS command.</p>\")));\n            setNetworkPolicy(NETWORK_OFFLINE);\n            break;\n        } catch (Imap::ImapException &e) {\n            uint parserId = it->parser->parserId();\n            killParser(it->parser, PARSER_KILL_HARD);\n            broadcastParseError(parserId, QString::fromStdString(e.exceptionClass()), e.what(), e.line(), e.offset());\n            break;\n        }\n\n        // Return to the event loop every 100 messages to handle GUI events\n        ++counter;\n        if (counter == 100) {\n            QTimer::singleShot(0, this, SLOT(responseReceived()));\n            break;\n        }\n    }\n\n    if (!it->parser) {\n        // He's dead, Jim\n        killParser(it.key(), PARSER_JUST_DELETE_LATER);\n        m_parsers.erase(it);\n        RESET_MODEL_2(m_taskModel);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_parsers.end",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parsers.begin",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::responseReceived()\n  {\n      for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n          responseReceived(it);\n      }\n  }\n}"
  },
  {
    "function_name": "~Model(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "142-145",
    "snippet": "odel::~Model()\n{\n    delete m_mailboxes;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  odel::~Model()\n  {\n      delete m_mailboxes;\n  }\n}"
  },
  {
    "function_name": "Model(",
    "container": "odel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "102-140",
    "snippet": "odel::Model(QObject *parent, AbstractCache *cache, SocketFactoryPtr socketFactory, TaskFactoryPtr taskFactory):\n    // parent\n    QAbstractItemModel(parent),\n    // our tools\n    m_cache(cache), m_socketFactory(std::move(socketFactory)), m_taskFactory(std::move(taskFactory)), m_maxParsers(4), m_mailboxes(0),\n    m_netPolicy(NETWORK_OFFLINE),  m_taskModel(0), m_hasImapPassword(false)\n{\n    m_cache->setParent(this);\n    m_startTls = m_socketFactory->startTlsRequired();\n\n    m_mailboxes = new TreeItemMailbox(0);\n\n    onlineMessageFetch << QLatin1String(\"ENVELOPE\") << QLatin1String(\"BODYSTRUCTURE\") << QLatin1String(\"RFC822.SIZE\") <<\n                          QLatin1String(\"UID\") << QLatin1String(\"FLAGS\");\n\n    EMIT_LATER_NOARG(this, networkPolicyOffline);\n    EMIT_LATER_NOARG(this, networkPolicyChanged);\n\n#ifdef DEBUG_PERIODICALLY_DUMP_TASKS\n    QTimer *periodicTaskDumper = new QTimer(this);\n    periodicTaskDumper->setInterval(1000);\n    connect(periodicTaskDumper, SIGNAL(timeout()), this, SLOT(slotTasksChanged()));\n    periodicTaskDumper->start();\n#endif\n\n    m_taskModel = new TaskPresentationModel(this);\n\n    // Make sure to update the first-character check inside normalizeFlags() when adding new flags here\n    m_specialFlagNames[QLatin1String(\"\\\\seen\")] = FlagNames::seen;\n    m_specialFlagNames[QLatin1String(\"\\\\deleted\")] = FlagNames::deleted;\n    m_specialFlagNames[QLatin1String(\"\\\\answered\")] = FlagNames::answered;\n    m_specialFlagNames[QLatin1String(\"\\\\recent\")] = FlagNames::recent;\n    m_specialFlagNames[QLatin1String(\"$forwarded\")] = FlagNames::forwarded;\n\n    m_periodicMailboxNumbersRefresh = new QTimer(this);\n    // polling every five minutes\n    m_periodicMailboxNumbersRefresh->setInterval(5 * 60 * 1000);\n    connect(m_periodicMailboxNumbersRefresh, SIGNAL(timeout()), this, SLOT(invalidateAllMessageCounts()));\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_periodicMailboxNumbersRefresh,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(invalidateAllMessageCounts()))"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "nvalidateAllMessageCounts())"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvalidateAllMessageCounts(",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "invalidateAllMessageCounts()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1947-1966",
          "snippet": "id Model::invalidateAllMessageCounts()\n{\n    QList<TreeItemMailbox*> queue;\n    queue.append(m_mailboxes);\n    while (!queue.isEmpty()) {\n        TreeItemMailbox *head = queue.takeFirst();\n        // ignore first child, the TreeItemMsgList\n        for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n            queue.append(static_cast<TreeItemMailbox*>(*it));\n        }\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n\n        if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n            // Ask only for data which were previously available\n            // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n            list->m_numberFetchingStatus = TreeItem::NONE;\n            emitMessageCountChanged(head);\n        }\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::invalidateAllMessageCounts()\n  {\n      QList<TreeItemMailbox*> queue;\n      queue.append(m_mailboxes);\n      while (!queue.isEmpty()) {\n          TreeItemMailbox *head = queue.takeFirst();\n          // ignore first child, the TreeItemMsgList\n          for (auto it = head->m_children.constBegin() + 1; it != head->m_children.constEnd(); ++it) {\n              queue.append(static_cast<TreeItemMailbox*>(*it));\n          }\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(head->m_children[0]);\n  \n          if (list->m_numberFetchingStatus == TreeItem::DONE && !head->maintainingTask) {\n              // Ask only for data which were previously available\n              // Also don't mess with a mailbox which is already being kept up-to-date because it's selected.\n              list->m_numberFetchingStatus = TreeItem::NONE;\n              emitMessageCountChanged(head);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_periodicMailboxNumbersRefresh->setInterval",
          "args": [
            "* 60 * 1000)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "$forwarded\")"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\\\recent\")"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\\\answered\")"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\\\deleted\")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\\\seen\")"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eriodicTaskDumper->start",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "eriodicTaskDumper,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotTasksChanged()))"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotTasksChanged())"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotTasksChanged(",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "slotTasksChanged()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1655-1658",
          "snippet": "id Model::slotTasksChanged()\n{\n    dumpModelContents(m_taskModel);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::slotTasksChanged()\n  {\n      dumpModelContents(m_taskModel);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eriodicTaskDumper->setInterval",
          "args": [
            "000)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIT_LATER_NOARG(",
          "args": [
            "his,",
            "etworkPolicyChanged)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIT_LATER_NOARG(",
          "args": [
            "his,",
            "etworkPolicyOffline)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UID\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "RFC822.SIZE\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "BODYSTRUCTURE\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ENVELOPE\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_socketFactory->startTlsRequired",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cache->setParent",
          "args": [
            "his)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::move(",
          "args": [
            "askFactory)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::move(",
          "args": [
            "ocketFactory)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  odel::Model(QObject *parent, AbstractCache *cache, SocketFactoryPtr socketFactory, TaskFactoryPtr taskFactory):\n      // parent\n      QAbstractItemModel(parent),\n      // our tools\n      m_cache(cache), m_socketFactory(std::move(socketFactory)), m_taskFactory(std::move(taskFactory)), m_maxParsers(4), m_mailboxes(0),\n      m_netPolicy(NETWORK_OFFLINE),  m_taskModel(0), m_hasImapPassword(false)\n  {\n      m_cache->setParent(this);\n      m_startTls = m_socketFactory->startTlsRequired();\n  \n      m_mailboxes = new TreeItemMailbox(0);\n  \n      onlineMessageFetch << QLatin1String(\"ENVELOPE\") << QLatin1String(\"BODYSTRUCTURE\") << QLatin1String(\"RFC822.SIZE\") <<\n                            QLatin1String(\"UID\") << QLatin1String(\"FLAGS\");\n  \n      EMIT_LATER_NOARG(this, networkPolicyOffline);\n      EMIT_LATER_NOARG(this, networkPolicyChanged);\n  \n  #ifdef DEBUG_PERIODICALLY_DUMP_TASKS\n      QTimer *periodicTaskDumper = new QTimer(this);\n      periodicTaskDumper->setInterval(1000);\n      connect(periodicTaskDumper, SIGNAL(timeout()), this, SLOT(slotTasksChanged()));\n      periodicTaskDumper->start();\n  #endif\n  \n      m_taskModel = new TaskPresentationModel(this);\n  \n      // Make sure to update the first-character check inside normalizeFlags() when adding new flags here\n      m_specialFlagNames[QLatin1String(\"\\\\seen\")] = FlagNames::seen;\n      m_specialFlagNames[QLatin1String(\"\\\\deleted\")] = FlagNames::deleted;\n      m_specialFlagNames[QLatin1String(\"\\\\answered\")] = FlagNames::answered;\n      m_specialFlagNames[QLatin1String(\"\\\\recent\")] = FlagNames::recent;\n      m_specialFlagNames[QLatin1String(\"$forwarded\")] = FlagNames::forwarded;\n  \n      m_periodicMailboxNumbersRefresh = new QTimer(this);\n      // polling every five minutes\n      m_periodicMailboxNumbersRefresh->setInterval(5 * 60 * 1000);\n      connect(m_periodicMailboxNumbersRefresh, SIGNAL(timeout()), this, SLOT(invalidateAllMessageCounts()));\n  }\n}"
  },
  {
    "function_name": "essageHasUidZero(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "89-93",
    "snippet": "ool messageHasUidZero(const TreeItem *const item)\n{\n    const TreeItemMessage *const message = static_cast<const TreeItemMessage *const>(item);\n    return message->uid() == 0;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essage->uid",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "uid(",
          "container": "reeItemMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1215-1218",
          "snippet": "int TreeItemMessage::uid() const\n{\n    return m_uid;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMessage {\n  int TreeItemMessage::uid() const\n  {\n      return m_uid;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *const>",
          "args": [
            "tem)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool messageHasUidZero(const TreeItem *const item)\n{\n    const TreeItemMessage *const message = static_cast<const TreeItemMessage *const>(item);\n    return message->uid() == 0;\n}"
  },
  {
    "function_name": "idComparator(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "81-87",
    "snippet": "ool uidComparator(const TreeItem *const item, const uint uid)\n{\n    const TreeItemMessage *const message = static_cast<const TreeItemMessage *const>(item);\n    uint messageUid = message->uid();\n    Q_ASSERT(messageUid);\n    return messageUid < uid;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essageUid)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage->uid",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "uid(",
          "container": "reeItemMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1215-1218",
          "snippet": "int TreeItemMessage::uid() const\n{\n    return m_uid;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMessage {\n  int TreeItemMessage::uid() const\n  {\n      return m_uid;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *const>",
          "args": [
            "tem)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool uidComparator(const TreeItem *const item, const uint uid)\n{\n    const TreeItemMessage *const message = static_cast<const TreeItemMessage *const>(item);\n    uint messageUid = message->uid();\n    Q_ASSERT(messageUid);\n    return messageUid < uid;\n}"
  },
  {
    "function_name": "ailboxNameComparator(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "69-79",
    "snippet": "ool MailboxNameComparator(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n\n    if (mailboxA->mailbox() == QLatin1String(\"INBOX\"))\n        return true;\n    if (mailboxB->mailbox() == QLatin1String(\"INBOX\"))\n        return false;\n    return mailboxA->mailbox().compare(mailboxB->mailbox(), Qt::CaseInsensitive) < 1;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailboxA->mailbox",
          "args": [
            "ailboxB->mailbox(),",
            "t::CaseInsensitive)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxB->mailbox",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxA->mailbox",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INBOX\")"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxB->mailbox",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INBOX\")"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxA->mailbox",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const TreeItemMailbox *const>",
          "args": [
            ")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const TreeItemMailbox *const>",
          "args": [
            ")"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool MailboxNameComparator(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n\n    if (mailboxA->mailbox() == QLatin1String(\"INBOX\"))\n        return true;\n    if (mailboxB->mailbox() == QLatin1String(\"INBOX\"))\n        return false;\n    return mailboxA->mailbox().compare(mailboxB->mailbox(), Qt::CaseInsensitive) < 1;\n}"
  },
  {
    "function_name": "ailboxNamesEqual(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
    "lines": "55-63",
    "snippet": "ool MailboxNamesEqual(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n    Q_ASSERT(mailboxA);\n    Q_ASSERT(mailboxB);\n\n    return mailboxA->mailbox() == mailboxB->mailbox();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"Imap/Tasks/AppendTask.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/FindWithUnknown.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#",
      "include \"SpecialFlagNames.h\"\n#",
      "include \"QAIM_reset.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"Model.h\"\n#",
      "include <QtAlgorithms>\n#",
      "include <QDebug>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include <QAbstractProxyModel>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailboxB->mailbox",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxA->mailbox",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxB)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxA)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const TreeItemMailbox *const>",
          "args": [
            ")"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const TreeItemMailbox *const>",
          "args": [
            ")"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nool MailboxNamesEqual(const TreeItem *const a, const TreeItem *const b)\n{\n    const TreeItemMailbox *const mailboxA = dynamic_cast<const TreeItemMailbox *const>(a);\n    const TreeItemMailbox *const mailboxB = dynamic_cast<const TreeItemMailbox *const>(b);\n    Q_ASSERT(mailboxA);\n    Q_ASSERT(mailboxB);\n\n    return mailboxA->mailbox() == mailboxB->mailbox();\n}"
  }
]