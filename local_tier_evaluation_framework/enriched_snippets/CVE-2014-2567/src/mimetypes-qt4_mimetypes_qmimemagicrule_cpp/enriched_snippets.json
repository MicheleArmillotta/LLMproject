[
  {
    "function_name": "matches",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "363-385",
    "snippet": "bool QMimeMagicRule::matches(const QByteArray &data) const\n{\n    const bool ok = d->matchFunction && d->matchFunction(d.data(), data);\n    if (!ok)\n        return false;\n\n    // No submatch? Then we are done.\n    if (m_subMatches.isEmpty())\n        return true;\n\n    //qDebug() << \"Checking\" << m_subMatches.count() << \"sub-rules\";\n    // Check that one of the submatches matches too\n    for ( QList<QMimeMagicRule>::const_iterator it = m_subMatches.begin(), end = m_subMatches.end() ;\n          it != end ; ++it ) {\n        if ((*it).matches(data)) {\n            // One of the hierarchies matched -> mimetype recognized.\n            return true;\n        }\n    }\n    return false;\n\n\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "data"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_subMatches.end",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_subMatches.begin",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_subMatches.isEmpty",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->matchFunction",
          "args": [
            "d.data()",
            "data"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.data",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::matches(const QByteArray &data) const\n  {\n      const bool ok = d->matchFunction && d->matchFunction(d.data(), data);\n      if (!ok)\n          return false;\n  \n      // No submatch? Then we are done.\n      if (m_subMatches.isEmpty())\n          return true;\n  \n      //qDebug() << \"Checking\" << m_subMatches.count() << \"sub-rules\";\n      // Check that one of the submatches matches too\n      for ( QList<QMimeMagicRule>::const_iterator it = m_subMatches.begin(), end = m_subMatches.end() ;\n            it != end ; ++it ) {\n          if ((*it).matches(data)) {\n              // One of the hierarchies matched -> mimetype recognized.\n              return true;\n          }\n      }\n      return false;\n  \n  \n  }\n}"
  },
  {
    "function_name": "isValid",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "358-361",
    "snippet": "bool QMimeMagicRule::isValid() const\n{\n    return d->matchFunction;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::isValid() const\n  {\n      return d->matchFunction;\n  }\n}"
  },
  {
    "function_name": "mask",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "348-356",
    "snippet": "QByteArray QMimeMagicRule::mask() const\n{\n    QByteArray result = d->mask;\n    if (d->type == String) {\n        // restore '0x'\n        result = \"0x\" + result.toHex();\n    }\n    return result;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.toHex",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::mask() const\n  {\n      QByteArray result = d->mask;\n      if (d->type == String) {\n          // restore '0x'\n          result = \"0x\" + result.toHex();\n      }\n      return result;\n  }\n}"
  },
  {
    "function_name": "endPos",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "343-346",
    "snippet": "int QMimeMagicRule::endPos() const\n{\n    return d->endPos;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  int QMimeMagicRule::endPos() const\n  {\n      return d->endPos;\n  }\n}"
  },
  {
    "function_name": "startPos",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "338-341",
    "snippet": "int QMimeMagicRule::startPos() const\n{\n    return d->startPos;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  int QMimeMagicRule::startPos() const\n  {\n      return d->startPos;\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "333-336",
    "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "328-331",
    "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
  },
  {
    "function_name": "operator==",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "322-326",
    "snippet": "bool QMimeMagicRule::operator==(const QMimeMagicRule &other) const\n{\n    return d == other.d ||\n           *d == *other.d;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::operator==(const QMimeMagicRule &other) const\n  {\n      return d == other.d ||\n             *d == *other.d;\n  }\n}"
  },
  {
    "function_name": "~QMimeMagicRule",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "312-314",
    "snippet": "QMimeMagicRule::~QMimeMagicRule()\n{\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::~QMimeMagicRule()\n  {\n  }\n}"
  },
  {
    "function_name": "QMimeMagicRule",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "307-310",
    "snippet": "QMimeMagicRule::QMimeMagicRule(const QMimeMagicRule &other) :\n    d(new QMimeMagicRulePrivate(*other.d))\n{\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::QMimeMagicRule(const QMimeMagicRule &other) :\n      d(new QMimeMagicRulePrivate(*other.d))\n  {\n  }\n}"
  },
  {
    "function_name": "QMimeMagicRule",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "238-305",
    "snippet": "QMimeMagicRule::QMimeMagicRule(QMimeMagicRule::Type theType,\n                               const QByteArray &theValue,\n                               int theStartPos,\n                               int theEndPos,\n                               const QByteArray &theMask) :\n    d(new QMimeMagicRulePrivate)\n{\n    Q_ASSERT(!theValue.isEmpty());\n\n    d->type = theType;\n    d->value = theValue;\n    d->startPos = theStartPos;\n    d->endPos = theEndPos;\n    d->mask = theMask;\n    d->matchFunction = 0;\n\n    if (d->type >= Host16 && d->type <= Byte) {\n        bool ok;\n        d->number = d->value.toUInt(&ok, 0); // autodetect\n        Q_ASSERT(ok);\n        d->numberMask = !d->mask.isEmpty() ? d->mask.toUInt(&ok, 0) : 0; // autodetect\n    }\n\n    switch (d->type) {\n    case String:\n        d->pattern = makePattern(d->value);\n        d->pattern.squeeze();\n        if (!d->mask.isEmpty()) {\n            Q_ASSERT(d->mask.size() >= 4 && d->mask.startsWith(\"0x\"));\n            d->mask = QByteArray::fromHex(QByteArray::fromRawData(d->mask.constData() + 2, d->mask.size() - 2));\n            Q_ASSERT(d->mask.size() == d->pattern.size());\n        } else {\n            d->mask.fill(char(-1), d->pattern.size());\n        }\n        d->mask.squeeze();\n        d->matchFunction = matchString;\n        break;\n    case Byte:\n        if (d->number <= quint8(-1)) {\n            if (d->numberMask == 0)\n                d->numberMask = quint8(-1);\n            d->matchFunction = matchNumber<quint8>;\n        }\n        break;\n    case Big16:\n    case Host16:\n    case Little16:\n        if (d->number <= quint16(-1)) {\n            d->number = d->type == Little16 ? qFromLittleEndian<quint16>(d->number) : qFromBigEndian<quint16>(d->number);\n            if (d->numberMask == 0)\n                d->numberMask = quint16(-1);\n            d->matchFunction = matchNumber<quint16>;\n        }\n        break;\n    case Big32:\n    case Host32:\n    case Little32:\n        if (d->number <= quint32(-1)) {\n            d->number = d->type == Little32 ? qFromLittleEndian<quint32>(d->number) : qFromBigEndian<quint32>(d->number);\n            if (d->numberMask == 0)\n                d->numberMask = quint32(-1);\n            d->matchFunction = matchNumber<quint32>;\n        }\n        break;\n    default:\n        break;\n    }\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "quint32",
          "args": [
            "-1"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qFromBigEndian<quint32>",
          "args": [
            "d->number"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qFromLittleEndian<quint32>",
          "args": [
            "d->number"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quint32",
          "args": [
            "-1"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quint16",
          "args": [
            "-1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qFromBigEndian<quint16>",
          "args": [
            "d->number"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qFromLittleEndian<quint16>",
          "args": [
            "d->number"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quint16",
          "args": [
            "-1"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quint8",
          "args": [
            "-1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quint8",
          "args": [
            "-1"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.squeeze",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.fill",
          "args": [
            "char(-1)",
            "d->pattern.size()"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->pattern.size",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char",
          "args": [
            "-1"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "d->mask.size() == d->pattern.size()"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->pattern.size",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.size",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray::fromHex",
          "args": [
            "QByteArray::fromRawData(d->mask.constData() + 2, d->mask.size() - 2)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray::fromRawData",
          "args": [
            "d->mask.constData() + 2",
            "d->mask.size() - 2"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.size",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.constData",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "d->mask.size() >= 4 && d->mask.startsWith(\"0x\")"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.startsWith",
          "args": [
            "\"0x\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.size",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.isEmpty",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->pattern.squeeze",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makePattern",
          "args": [
            "d->value"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "makePattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "191-236",
          "snippet": "static inline QByteArray makePattern(const QByteArray &value)\n{\n    QByteArray pattern(value.size(), Qt::Uninitialized);\n    char *data = pattern.data();\n\n    const char *p = value.constData();\n    const char *e = p + value.size();\n    for ( ; p < e; ++p) {\n        if (*p == '\\\\' && ++p < e) {\n            if (*p == 'x') { // hex (\\\\xff)\n                char c = 0;\n                for (int i = 0; i < 2 && p + 1 < e; ++i) {\n                    ++p;\n                    if (*p >= '0' && *p <= '9')\n                        c = (c << 4) + *p - '0';\n                    else if (*p >= 'a' && *p <= 'f')\n                        c = (c << 4) + *p - 'a' + 10;\n                    else if (*p >= 'A' && *p <= 'F')\n                        c = (c << 4) + *p - 'A' + 10;\n                    else\n                        continue;\n                }\n                *data++ = c;\n            } else if (*p >= '0' && *p <= '7') { // oct (\\\\7, or \\\\77, or \\\\377)\n                char c = *p - '0';\n                if (p + 1 < e && p[1] >= '0' && p[1] <= '7') {\n                    c = (c << 3) + *(++p) - '0';\n                    if (p + 1 < e && p[1] >= '0' && p[1] <= '7' && p[-1] <= '3')\n                        c = (c << 3) + *(++p) - '0';\n                }\n                *data++ = c;\n            } else if (*p == 'n') {\n                *data++ = '\\n';\n            } else if (*p == 'r') {\n                *data++ = '\\r';\n            } else { // escaped\n                *data++ = *p;\n            }\n        } else {\n            *data++ = *p;\n        }\n    }\n    pattern.truncate(data - pattern.data());\n\n    return pattern;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nstatic inline QByteArray makePattern(const QByteArray &value)\n{\n    QByteArray pattern(value.size(), Qt::Uninitialized);\n    char *data = pattern.data();\n\n    const char *p = value.constData();\n    const char *e = p + value.size();\n    for ( ; p < e; ++p) {\n        if (*p == '\\\\' && ++p < e) {\n            if (*p == 'x') { // hex (\\\\xff)\n                char c = 0;\n                for (int i = 0; i < 2 && p + 1 < e; ++i) {\n                    ++p;\n                    if (*p >= '0' && *p <= '9')\n                        c = (c << 4) + *p - '0';\n                    else if (*p >= 'a' && *p <= 'f')\n                        c = (c << 4) + *p - 'a' + 10;\n                    else if (*p >= 'A' && *p <= 'F')\n                        c = (c << 4) + *p - 'A' + 10;\n                    else\n                        continue;\n                }\n                *data++ = c;\n            } else if (*p >= '0' && *p <= '7') { // oct (\\\\7, or \\\\77, or \\\\377)\n                char c = *p - '0';\n                if (p + 1 < e && p[1] >= '0' && p[1] <= '7') {\n                    c = (c << 3) + *(++p) - '0';\n                    if (p + 1 < e && p[1] >= '0' && p[1] <= '7' && p[-1] <= '3')\n                        c = (c << 3) + *(++p) - '0';\n                }\n                *data++ = c;\n            } else if (*p == 'n') {\n                *data++ = '\\n';\n            } else if (*p == 'r') {\n                *data++ = '\\r';\n            } else { // escaped\n                *data++ = *p;\n            }\n        } else {\n            *data++ = *p;\n        }\n    }\n    pattern.truncate(data - pattern.data());\n\n    return pattern;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->mask.toUInt",
          "args": [
            "&ok",
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mask.isEmpty",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "ok"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->value.toUInt",
          "args": [
            "&ok",
            "0"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "!theValue.isEmpty()"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "theValue.isEmpty",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::QMimeMagicRule(QMimeMagicRule::Type theType,\n                                 const QByteArray &theValue,\n                                 int theStartPos,\n                                 int theEndPos,\n                                 const QByteArray &theMask) :\n      d(new QMimeMagicRulePrivate)\n  {\n      Q_ASSERT(!theValue.isEmpty());\n  \n      d->type = theType;\n      d->value = theValue;\n      d->startPos = theStartPos;\n      d->endPos = theEndPos;\n      d->mask = theMask;\n      d->matchFunction = 0;\n  \n      if (d->type >= Host16 && d->type <= Byte) {\n          bool ok;\n          d->number = d->value.toUInt(&ok, 0); // autodetect\n          Q_ASSERT(ok);\n          d->numberMask = !d->mask.isEmpty() ? d->mask.toUInt(&ok, 0) : 0; // autodetect\n      }\n  \n      switch (d->type) {\n      case String:\n          d->pattern = makePattern(d->value);\n          d->pattern.squeeze();\n          if (!d->mask.isEmpty()) {\n              Q_ASSERT(d->mask.size() >= 4 && d->mask.startsWith(\"0x\"));\n              d->mask = QByteArray::fromHex(QByteArray::fromRawData(d->mask.constData() + 2, d->mask.size() - 2));\n              Q_ASSERT(d->mask.size() == d->pattern.size());\n          } else {\n              d->mask.fill(char(-1), d->pattern.size());\n          }\n          d->mask.squeeze();\n          d->matchFunction = matchString;\n          break;\n      case Byte:\n          if (d->number <= quint8(-1)) {\n              if (d->numberMask == 0)\n                  d->numberMask = quint8(-1);\n              d->matchFunction = matchNumber<quint8>;\n          }\n          break;\n      case Big16:\n      case Host16:\n      case Little16:\n          if (d->number <= quint16(-1)) {\n              d->number = d->type == Little16 ? qFromLittleEndian<quint16>(d->number) : qFromBigEndian<quint16>(d->number);\n              if (d->numberMask == 0)\n                  d->numberMask = quint16(-1);\n              d->matchFunction = matchNumber<quint16>;\n          }\n          break;\n      case Big32:\n      case Host32:\n      case Little32:\n          if (d->number <= quint32(-1)) {\n              d->number = d->type == Little32 ? qFromLittleEndian<quint32>(d->number) : qFromBigEndian<quint32>(d->number);\n              if (d->numberMask == 0)\n                  d->numberMask = quint32(-1);\n              d->matchFunction = matchNumber<quint32>;\n          }\n          break;\n      default:\n          break;\n      }\n  }\n}"
  },
  {
    "function_name": "makePattern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "191-236",
    "snippet": "static inline QByteArray makePattern(const QByteArray &value)\n{\n    QByteArray pattern(value.size(), Qt::Uninitialized);\n    char *data = pattern.data();\n\n    const char *p = value.constData();\n    const char *e = p + value.size();\n    for ( ; p < e; ++p) {\n        if (*p == '\\\\' && ++p < e) {\n            if (*p == 'x') { // hex (\\\\xff)\n                char c = 0;\n                for (int i = 0; i < 2 && p + 1 < e; ++i) {\n                    ++p;\n                    if (*p >= '0' && *p <= '9')\n                        c = (c << 4) + *p - '0';\n                    else if (*p >= 'a' && *p <= 'f')\n                        c = (c << 4) + *p - 'a' + 10;\n                    else if (*p >= 'A' && *p <= 'F')\n                        c = (c << 4) + *p - 'A' + 10;\n                    else\n                        continue;\n                }\n                *data++ = c;\n            } else if (*p >= '0' && *p <= '7') { // oct (\\\\7, or \\\\77, or \\\\377)\n                char c = *p - '0';\n                if (p + 1 < e && p[1] >= '0' && p[1] <= '7') {\n                    c = (c << 3) + *(++p) - '0';\n                    if (p + 1 < e && p[1] >= '0' && p[1] <= '7' && p[-1] <= '3')\n                        c = (c << 3) + *(++p) - '0';\n                }\n                *data++ = c;\n            } else if (*p == 'n') {\n                *data++ = '\\n';\n            } else if (*p == 'r') {\n                *data++ = '\\r';\n            } else { // escaped\n                *data++ = *p;\n            }\n        } else {\n            *data++ = *p;\n        }\n    }\n    pattern.truncate(data - pattern.data());\n\n    return pattern;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pattern.truncate",
          "args": [
            "data - pattern.data()"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern.data",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.constData",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nstatic inline QByteArray makePattern(const QByteArray &value)\n{\n    QByteArray pattern(value.size(), Qt::Uninitialized);\n    char *data = pattern.data();\n\n    const char *p = value.constData();\n    const char *e = p + value.size();\n    for ( ; p < e; ++p) {\n        if (*p == '\\\\' && ++p < e) {\n            if (*p == 'x') { // hex (\\\\xff)\n                char c = 0;\n                for (int i = 0; i < 2 && p + 1 < e; ++i) {\n                    ++p;\n                    if (*p >= '0' && *p <= '9')\n                        c = (c << 4) + *p - '0';\n                    else if (*p >= 'a' && *p <= 'f')\n                        c = (c << 4) + *p - 'a' + 10;\n                    else if (*p >= 'A' && *p <= 'F')\n                        c = (c << 4) + *p - 'A' + 10;\n                    else\n                        continue;\n                }\n                *data++ = c;\n            } else if (*p >= '0' && *p <= '7') { // oct (\\\\7, or \\\\77, or \\\\377)\n                char c = *p - '0';\n                if (p + 1 < e && p[1] >= '0' && p[1] <= '7') {\n                    c = (c << 3) + *(++p) - '0';\n                    if (p + 1 < e && p[1] >= '0' && p[1] <= '7' && p[-1] <= '3')\n                        c = (c << 3) + *(++p) - '0';\n                }\n                *data++ = c;\n            } else if (*p == 'n') {\n                *data++ = '\\n';\n            } else if (*p == 'r') {\n                *data++ = '\\r';\n            } else { // escaped\n                *data++ = *p;\n            }\n        } else {\n            *data++ = *p;\n        }\n    }\n    pattern.truncate(data - pattern.data());\n\n    return pattern;\n}"
  },
  {
    "function_name": "matchNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "173-189",
    "snippet": "static bool matchNumber(const QMimeMagicRulePrivate *d, const QByteArray &data)\n{\n    const T value(d->number);\n    const T mask(d->numberMask);\n\n    //qDebug() << \"matchNumber\" << \"0x\" << QString::number(d->number, 16) << \"size\" << sizeof(T);\n    //qDebug() << \"mask\" << QString::number(d->numberMask, 16);\n\n    const char *p = data.constData() + d->startPos;\n    const char *e = data.constData() + qMin(data.size() - int(sizeof(T)), d->endPos + 1);\n    for ( ; p <= e; ++p) {\n        if ((*reinterpret_cast<const T*>(p) & mask) == (value & mask))\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<const T*>",
          "args": [
            "p"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qMin",
          "args": [
            "data.size() - int(sizeof(T))",
            "d->endPos + 1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "sizeof(T)"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.constData",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.constData",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nstatic bool matchNumber(const QMimeMagicRulePrivate *d, const QByteArray &data)\n{\n    const T value(d->number);\n    const T mask(d->numberMask);\n\n    //qDebug() << \"matchNumber\" << \"0x\" << QString::number(d->number, 16) << \"size\" << sizeof(T);\n    //qDebug() << \"mask\" << QString::number(d->numberMask, 16);\n\n    const char *p = data.constData() + d->startPos;\n    const char *e = data.constData() + qMin(data.size() - int(sizeof(T)), d->endPos + 1);\n    for ( ; p <= e; ++p) {\n        if ((*reinterpret_cast<const T*>(p) & mask) == (value & mask))\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "matchString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "166-170",
    "snippet": "static bool matchString(const QMimeMagicRulePrivate *d, const QByteArray &data)\n{\n    const int rangeLength = d->endPos - d->startPos + 1;\n    return QMimeMagicRule::matchSubstring(data.constData(), data.size(), d->startPos, rangeLength, d->pattern.size(), d->pattern.constData(), d->mask.constData());\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QMimeMagicRule::matchSubstring",
          "args": [
            "data.constData()",
            "data.size()",
            "d->startPos",
            "rangeLength",
            "d->pattern.size()",
            "d->pattern.constData()",
            "d->mask.constData()"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "matchSubstring",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "117-164",
          "snippet": "bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                    int valueLength, const char *valueData, const char *mask)\n{\n    // Size of searched data.\n    // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n    const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n\n    if (!mask) {\n        // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n        // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n        bool found = false;\n        for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n            if (i + valueLength > dataSize)\n                break;\n\n            if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            return false;\n    } else {\n        bool found = false;\n        const char *readDataBase = dataPtr + rangeStart;\n        // Example (continued from above):\n        // deviceSize is 4, so dataNeeded was max'ed to 4.\n        // maxStartPos = 4 - 3 + 1 = 2, and indeed\n        // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n        const int maxStartPos = dataNeeded - valueLength + 1;\n        for (int i = 0; i < maxStartPos; ++i) {\n            const char *d = readDataBase + i;\n            bool valid = true;\n            for (int idx = 0; idx < valueLength; ++idx) {\n                if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n                found = true;\n        }\n        if (!found)\n            return false;\n    }\n    //qDebug() << \"Found\" << value << \"in\" << searchedData;\n    return true;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                      int valueLength, const char *valueData, const char *mask)\n  {\n      // Size of searched data.\n      // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n      const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n  \n      if (!mask) {\n          // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n          // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n          bool found = false;\n          for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n              if (i + valueLength > dataSize)\n                  break;\n  \n              if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                  found = true;\n                  break;\n              }\n          }\n          if (!found)\n              return false;\n      } else {\n          bool found = false;\n          const char *readDataBase = dataPtr + rangeStart;\n          // Example (continued from above):\n          // deviceSize is 4, so dataNeeded was max'ed to 4.\n          // maxStartPos = 4 - 3 + 1 = 2, and indeed\n          // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n          const int maxStartPos = dataNeeded - valueLength + 1;\n          for (int i = 0; i < maxStartPos; ++i) {\n              const char *d = readDataBase + i;\n              bool valid = true;\n              for (int idx = 0; idx < valueLength; ++idx) {\n                  if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                      valid = false;\n                      break;\n                  }\n              }\n              if (valid)\n                  found = true;\n          }\n          if (!found)\n              return false;\n      }\n      //qDebug() << \"Found\" << value << \"in\" << searchedData;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->mask.constData",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->pattern.constData",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->pattern.size",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.constData",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nstatic bool matchString(const QMimeMagicRulePrivate *d, const QByteArray &data)\n{\n    const int rangeLength = d->endPos - d->startPos + 1;\n    return QMimeMagicRule::matchSubstring(data.constData(), data.size(), d->startPos, rangeLength, d->pattern.size(), d->pattern.constData(), d->mask.constData());\n}"
  },
  {
    "function_name": "matchSubstring",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "117-164",
    "snippet": "bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                    int valueLength, const char *valueData, const char *mask)\n{\n    // Size of searched data.\n    // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n    const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n\n    if (!mask) {\n        // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n        // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n        bool found = false;\n        for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n            if (i + valueLength > dataSize)\n                break;\n\n            if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            return false;\n    } else {\n        bool found = false;\n        const char *readDataBase = dataPtr + rangeStart;\n        // Example (continued from above):\n        // deviceSize is 4, so dataNeeded was max'ed to 4.\n        // maxStartPos = 4 - 3 + 1 = 2, and indeed\n        // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n        const int maxStartPos = dataNeeded - valueLength + 1;\n        for (int i = 0; i < maxStartPos; ++i) {\n            const char *d = readDataBase + i;\n            bool valid = true;\n            for (int idx = 0; idx < valueLength; ++idx) {\n                if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n                found = true;\n        }\n        if (!found)\n            return false;\n    }\n    //qDebug() << \"Found\" << value << \"in\" << searchedData;\n    return true;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "valueData",
            "dataPtr + i",
            "valueLength"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qMin",
          "args": [
            "rangeLength + valueLength - 1",
            "dataSize - rangeStart"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                      int valueLength, const char *valueData, const char *mask)\n  {\n      // Size of searched data.\n      // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n      const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n  \n      if (!mask) {\n          // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n          // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n          bool found = false;\n          for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n              if (i + valueLength > dataSize)\n                  break;\n  \n              if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                  found = true;\n                  break;\n              }\n          }\n          if (!found)\n              return false;\n      } else {\n          bool found = false;\n          const char *readDataBase = dataPtr + rangeStart;\n          // Example (continued from above):\n          // deviceSize is 4, so dataNeeded was max'ed to 4.\n          // maxStartPos = 4 - 3 + 1 = 2, and indeed\n          // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n          const int maxStartPos = dataNeeded - valueLength + 1;\n          for (int i = 0; i < maxStartPos; ++i) {\n              const char *d = readDataBase + i;\n              bool valid = true;\n              for (int idx = 0; idx < valueLength; ++idx) {\n                  if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                      valid = false;\n                      break;\n                  }\n              }\n              if (valid)\n                  found = true;\n          }\n          if (!found)\n              return false;\n      }\n      //qDebug() << \"Found\" << value << \"in\" << searchedData;\n      return true;\n  }\n}"
  },
  {
    "function_name": "operator==",
    "container": "QMimeMagicRulePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "103-114",
    "snippet": "bool QMimeMagicRulePrivate::operator==(const QMimeMagicRulePrivate &other) const\n{\n    return type == other.type &&\n           value == other.value &&\n           startPos == other.startPos &&\n           endPos == other.endPos &&\n           mask == other.mask &&\n           pattern == other.pattern &&\n           number == other.number &&\n           numberMask == other.numberMask &&\n           matchFunction == other.matchFunction;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRulePrivate {\n  bool QMimeMagicRulePrivate::operator==(const QMimeMagicRulePrivate &other) const\n  {\n      return type == other.type &&\n             value == other.value &&\n             startPos == other.startPos &&\n             endPos == other.endPos &&\n             mask == other.mask &&\n             pattern == other.pattern &&\n             number == other.number &&\n             numberMask == other.numberMask &&\n             matchFunction == other.matchFunction;\n  }\n}"
  },
  {
    "function_name": "typeName",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "79-82",
    "snippet": "QByteArray QMimeMagicRule::typeName(QMimeMagicRule::Type theType)\n{\n    return magicRuleTypes_string + magicRuleTypes_indices[theType];\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "QT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";",
      "static const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";\nstatic const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::typeName(QMimeMagicRule::Type theType)\n  {\n      return magicRuleTypes_string + magicRuleTypes_indices[theType];\n  }\n}"
  },
  {
    "function_name": "type",
    "container": "QMimeMagicRule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
    "lines": "70-77",
    "snippet": "QMimeMagicRule::Type QMimeMagicRule::type(const QByteArray &theTypeName)\n{\n    for (int i = String; i <= Byte; ++i) {\n        if (theTypeName == magicRuleTypes_string + magicRuleTypes_indices[i])\n            return Type(i);\n    }\n    return Invalid;\n}",
    "includes": [
      "#include <qendian.h>",
      "#include <QDebug>",
      "#include <QList>",
      "#include \"qmimemagicrule_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "QT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";",
      "static const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Type",
          "args": [
            "i"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "addMimeType",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "791-794",
          "snippet": "void QMimeXMLProvider::addMimeType(const QMimeType &mt)\n{\n    m_nameMimeTypeMap.insert(mt.name(), mt);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addMimeType(const QMimeType &mt)\n  {\n      m_nameMimeTypeMap.insert(mt.name(), mt);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";\nstatic const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type(const QByteArray &theTypeName)\n  {\n      for (int i = String; i <= Byte; ++i) {\n          if (theTypeName == magicRuleTypes_string + magicRuleTypes_indices[i])\n              return Type(i);\n      }\n      return Invalid;\n  }\n}"
  }
]