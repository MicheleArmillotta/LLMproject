[
  {
    "function_name": "taskData(",
    "container": "etAnyConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/GetAnyConnectionTask.cpp",
    "lines": "107-111",
    "snippet": "Variant GetAnyConnectionTask::taskData(const int role) const\n{\n    Q_UNUSED(role);\n    return QVariant();\n}",
    "includes": [
      "include \"OpenConnectionTask.h\"",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include <QTimer>\n#",
      "include \"GetAnyConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ole)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"OpenConnectionTask.h\"\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude <QTimer>\n#\ninclude \"GetAnyConnectionTask.h\"\n#\n\netAnyConnectionTask {\n  Variant GetAnyConnectionTask::taskData(const int role) const\n  {\n      Q_UNUSED(role);\n      return QVariant();\n  }\n}"
  },
  {
    "function_name": "isReadyToRun(",
    "container": "etAnyConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/GetAnyConnectionTask.cpp",
    "lines": "101-104",
    "snippet": "ool GetAnyConnectionTask::isReadyToRun() const\n{\n    return ! isFinished() && ! newConn;\n}",
    "includes": [
      "include \"OpenConnectionTask.h\"",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include <QTimer>\n#",
      "include \"GetAnyConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sFinished(",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "sFinished(",
          "container": "mapTask ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.h",
          "lines": "117-117",
          "snippet": "ool isFinished() const { return _finished; }",
          "includes": [
            "include \"../Model/FlagsOperation.h\"",
            "include \"../Parser/Parser.h\"\n#",
            "include \"Common/Logging.h\"\n#",
            "include <QPointer>\n#",
            "include <QObject>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/FlagsOperation.h\"\ninclude \"../Parser/Parser.h\"\n#\ninclude \"Common/Logging.h\"\n#\ninclude <QPointer>\n#\ninclude <QObject>\n#\n\nmapTask  {\n  ool isFinished() const { return _finished; }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"OpenConnectionTask.h\"\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude <QTimer>\n#\ninclude \"GetAnyConnectionTask.h\"\n#\n\netAnyConnectionTask {\n  ool GetAnyConnectionTask::isReadyToRun() const\n  {\n      return ! isFinished() && ! newConn;\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "etAnyConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/GetAnyConnectionTask.cpp",
    "lines": "85-99",
    "snippet": "oid GetAnyConnectionTask::perform()\n{\n    // This is special from most ImapTasks' perform(), because the activeTasks could have already been updated\n    if (newConn) {\n        // We're \"dependent\" on some connection, so we should update our parser (even though\n        // it could be already set), and also register ourselves with the Model\n        parser = newConn->parser;\n        markAsActiveTask();\n    }\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    // ... we don't really have to do any work here, just declare ourselves completed\n    _completed();\n}",
    "includes": [
      "include \"OpenConnectionTask.h\"",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include <QTimer>\n#",
      "include \"GetAnyConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"OpenConnectionTask.h\"\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude <QTimer>\n#\ninclude \"GetAnyConnectionTask.h\"\n#\n\netAnyConnectionTask {\n  oid GetAnyConnectionTask::perform()\n  {\n      // This is special from most ImapTasks' perform(), because the activeTasks could have already been updated\n      if (newConn) {\n          // We're \"dependent\" on some connection, so we should update our parser (even though\n          // it could be already set), and also register ourselves with the Model\n          parser = newConn->parser;\n          markAsActiveTask();\n      }\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      // ... we don't really have to do any work here, just declare ourselves completed\n      _completed();\n  }\n}"
  },
  {
    "function_name": "GetAnyConnectionTask(",
    "container": "etAnyConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/GetAnyConnectionTask.cpp",
    "lines": "35-83",
    "snippet": "etAnyConnectionTask::GetAnyConnectionTask(Model *model) :\n    ImapTask(model), newConn(0)\n{\n    QMap<Parser *,ParserState>::iterator it = model->m_parsers.begin();\n    while (it != model->m_parsers.end()) {\n        if (it->connState == CONN_STATE_LOGOUT) {\n            // We cannot possibly use this connection\n            ++it;\n        } else {\n            // we've found it\n            break;\n        }\n    }\n\n    if (it == model->m_parsers.end()) {\n        // We're creating a completely new connection\n        if (model->networkPolicy() == NETWORK_OFFLINE) {\n            // ...but we're offline -> too bad, got to fail\n            newConn = new OfflineConnectionTask(model);\n            newConn->addDependentTask(this);\n        } else {\n            newConn = model->m_taskFactory->createOpenConnectionTask(model);\n            newConn->addDependentTask(this);\n        }\n    } else {\n        parser = it.key();\n        Q_ASSERT(parser);\n\n        if (it->maintainingTask) {\n            // The parser already has some maintaining task associated with it\n            // We can't ignore the maintaining task, if only because of the IDLE\n            newConn = it->maintainingTask;\n            newConn->addDependentTask(this);\n        } else {\n            if (!it->activeTasks.isEmpty() && dynamic_cast<OpenConnectionTask*>(it->activeTasks.front()) &&\n                   !it->activeTasks.front()->isFinished()) {\n                // The conneciton is still being set up so we cannot just jump to the middle of OpenConnectionTask's\n                // process (Redmine #499).\n                it->activeTasks.front()->addDependentTask(this);\n            } else {\n                // The parser doesn't have anything associated with it and it looks like\n                // the conneciton is already established, authenticated and what not.\n                // This means that we can go ahead and register ourselves as an active task, yay!\n                markAsActiveTask();\n                QTimer::singleShot(0, model, SLOT(runReadyTasks()));\n            }\n        }\n    }\n}",
    "includes": [
      "include \"OpenConnectionTask.h\"",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include <QTimer>\n#",
      "include \"GetAnyConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "odel,",
            "LOT(runReadyTasks()))"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "unReadyTasks())"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unReadyTasks(",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "runReadyTasks()",
          "container": "del",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1513-1541",
          "snippet": "id Model::runReadyTasks()\n{\n    for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n        bool runSomething = false;\n        do {\n            runSomething = false;\n            // See responseReceived() for more details about why we do need to iterate over a copy here.\n            // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n            QList<ImapTask *> origList = parserIt->activeTasks;\n            QList<ImapTask *> deletedList;\n            QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n            for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                ImapTask *task = *taskIt;\n                if (task->isReadyToRun()) {\n                    task->perform();\n                    runSomething = true;\n                }\n                if (task->isFinished()) {\n                    deletedList << task;\n                }\n            }\n            removeDeletedTasks(deletedList, parserIt->activeTasks);\n#ifdef TROJITA_DEBUG_TASK_TREE\n            if (!deletedList.isEmpty())\n                checkTaskTreeConsistency();\n#endif\n        } while (runSomething);\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\ndel {\n  id Model::runReadyTasks()\n  {\n      for (QMap<Parser *,ParserState>::iterator parserIt = m_parsers.begin(); parserIt != m_parsers.end(); ++parserIt) {\n          bool runSomething = false;\n          do {\n              runSomething = false;\n              // See responseReceived() for more details about why we do need to iterate over a copy here.\n              // Basically, calls to ImapTask::perform could invalidate our precious iterators.\n              QList<ImapTask *> origList = parserIt->activeTasks;\n              QList<ImapTask *> deletedList;\n              QList<ImapTask *>::const_iterator taskEnd = origList.constEnd();\n              for (QList<ImapTask *>::const_iterator taskIt = origList.constBegin(); taskIt != taskEnd; ++taskIt) {\n                  ImapTask *task = *taskIt;\n                  if (task->isReadyToRun()) {\n                      task->perform();\n                      runSomething = true;\n                  }\n                  if (task->isFinished()) {\n                      deletedList << task;\n                  }\n              }\n              removeDeletedTasks(deletedList, parserIt->activeTasks);\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              if (!deletedList.isEmpty())\n                  checkTaskTreeConsistency();\n  #endif\n          } while (runSomething);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.front",
          "args": [
            "his)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.front",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.front",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.front",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<OpenConnectionTask*>",
          "args": [
            "t->activeTasks.front())"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.front",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->activeTasks.isEmpty",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewConn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arser)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewConn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createOpenConnectionTask",
          "args": [
            "odel)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewConn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->networkPolicy",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_parsers.end",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_parsers.end",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_parsers.begin",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"OpenConnectionTask.h\"\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude <QTimer>\n#\ninclude \"GetAnyConnectionTask.h\"\n#\n\netAnyConnectionTask {\n  etAnyConnectionTask::GetAnyConnectionTask(Model *model) :\n      ImapTask(model), newConn(0)\n  {\n      QMap<Parser *,ParserState>::iterator it = model->m_parsers.begin();\n      while (it != model->m_parsers.end()) {\n          if (it->connState == CONN_STATE_LOGOUT) {\n              // We cannot possibly use this connection\n              ++it;\n          } else {\n              // we've found it\n              break;\n          }\n      }\n  \n      if (it == model->m_parsers.end()) {\n          // We're creating a completely new connection\n          if (model->networkPolicy() == NETWORK_OFFLINE) {\n              // ...but we're offline -> too bad, got to fail\n              newConn = new OfflineConnectionTask(model);\n              newConn->addDependentTask(this);\n          } else {\n              newConn = model->m_taskFactory->createOpenConnectionTask(model);\n              newConn->addDependentTask(this);\n          }\n      } else {\n          parser = it.key();\n          Q_ASSERT(parser);\n  \n          if (it->maintainingTask) {\n              // The parser already has some maintaining task associated with it\n              // We can't ignore the maintaining task, if only because of the IDLE\n              newConn = it->maintainingTask;\n              newConn->addDependentTask(this);\n          } else {\n              if (!it->activeTasks.isEmpty() && dynamic_cast<OpenConnectionTask*>(it->activeTasks.front()) &&\n                     !it->activeTasks.front()->isFinished()) {\n                  // The conneciton is still being set up so we cannot just jump to the middle of OpenConnectionTask's\n                  // process (Redmine #499).\n                  it->activeTasks.front()->addDependentTask(this);\n              } else {\n                  // The parser doesn't have anything associated with it and it looks like\n                  // the conneciton is already established, authenticated and what not.\n                  // This means that we can go ahead and register ourselves as an active task, yay!\n                  markAsActiveTask();\n                  QTimer::singleShot(0, model, SLOT(runReadyTasks()));\n              }\n          }\n      }\n  }\n}"
  }
]