[
  {
    "function_name": "slotPasteAsQuotation(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "195-221",
    "snippet": "oid ComposerTextEdit::slotPasteAsQuotation()\n{\n    QString text = qApp->clipboard()->text();\n    if (text.isEmpty())\n        return;\n\n    QStringList lines = text.split(QLatin1Char('\\n'));\n    for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n        it->remove(QLatin1Char('\\r'));\n        if (it->startsWith(QLatin1Char('>'))) {\n            *it = QLatin1Char('>') + *it;\n        } else {\n            *it = QLatin1String(\"> \") + *it;\n        }\n    }\n    text = lines.join(QLatin1String(\"\\n\"));\n    if (!text.endsWith(QLatin1Char('\\n'))) {\n        text += QLatin1Char('\\n');\n    }\n\n    QTextCursor cursor = textCursor();\n    cursor.beginEditBlock();\n    cursor.insertBlock();\n    cursor.insertText(text);\n    cursor.endEditBlock();\n    setTextCursor(cursor);\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etTextCursor(",
          "args": [
            "ursor)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.endEditBlock",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertText",
          "args": [
            "ext)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertBlock",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.beginEditBlock",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extCursor(",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "\\n')"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.endsWith",
          "args": [
            "Latin1Char('\\n'))"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "\\n')"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ines.join",
          "args": [
            "Latin1String(\"\\n\"))"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\n\")"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "> \")"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            ">')"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->startsWith",
          "args": [
            "Latin1Char('>'))"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            ">')"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->remove",
          "args": [
            "Latin1Char('\\r'))"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "removeRecipient(",
          "container": "omposeWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposeWidget.cpp",
          "lines": "611-644",
          "snippet": "oid ComposeWidget::removeRecipient(int pos)\n{\n    // removing the widgets from the layout is important\n    // a) not doing so leaks (minor)\n    // b) deleteLater() crosses the evenchain and so our actualRow function would be tricked\n    QWidget *formerFocus = QApplication::focusWidget();\n    if (!formerFocus)\n        formerFocus = m_lastFocusedRecipient;\n\n    if (pos + 1 < m_recipients.count()) {\n        if (m_recipients.at(pos).first == formerFocus) {\n            m_recipients.at(pos + 1).first->setFocus();\n            formerFocus = m_recipients.at(pos + 1).first;\n        } else if (m_recipients.at(pos).second == formerFocus) {\n            m_recipients.at(pos + 1).second->setFocus();\n            formerFocus = m_recipients.at(pos + 1).second;\n        }\n    } else if (m_recipients.at(pos).first == formerFocus || m_recipients.at(pos).second == formerFocus) {\n            formerFocus = 0;\n    }\n\n    ui->envelopeLayout->removeWidget(m_recipients.at(pos).first);\n    ui->envelopeLayout->removeWidget(m_recipients.at(pos).second);\n    m_recipients.at(pos).first->deleteLater();\n    m_recipients.at(pos).second->deleteLater();\n    m_recipients.removeAt(pos);\n    const int max = qMax(0, m_recipients.count() - m_maxVisibleRecipients);\n    ui->recipientSlider->setMaximum(max);\n    ui->recipientSlider->setVisible(max > 0);\n    if (formerFocus) {\n        // skip event loop, remove might be triggered by imminent focus loss\n        CALL_LATER_NOARG(formerFocus, setFocus);\n    }\n}",
          "includes": [
            "include \"Imap/Tasks/UidSubmitTask.h\"",
            "include \"Imap/Tasks/GenUrlAuthTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Gui/Window.h\"\n#",
            "include \"Gui/Util.h\"\n#",
            "include \"Gui/ProgressPopUp.h\"\n#",
            "include \"Gui/PasswordDialog.h\"\n#",
            "include \"Gui/OverlayWidget.h\"\n#",
            "include \"Gui/LineEdit.h\"\n#",
            "include \"Gui/IconLoader.h\"\n#",
            "include \"Gui/FromAddressProxyModel.h\"\n#",
            "include \"Gui/ComposeWidget.h\"\n#",
            "include \"Gui/AutoCompletion.h\"\n#",
            "include \"Gui/AbstractAddressbook.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Composer/Submission.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"Composer/ReplaceSignature.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"ui_ComposeWidget.h\"\n#",
            "include <QToolButton>",
            "include <QTimer>\n#",
            "include <QSettings>\n#",
            "include <QPushButton>\n#",
            "include <QPropertyAnimation>\n#",
            "include <QProgressDialog>\n#",
            "include <QMessageBox>\n#",
            "include <QMenu>\n#",
            "include <QKeyEvent>\n#",
            "include <QGraphicsOpacityEffect>\n#",
            "include <QFileDialog>\n#",
            "include <QBuffer>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Tasks/UidSubmitTask.h\"\ninclude \"Imap/Tasks/GenUrlAuthTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Gui/Window.h\"\n#\ninclude \"Gui/Util.h\"\n#\ninclude \"Gui/ProgressPopUp.h\"\n#\ninclude \"Gui/PasswordDialog.h\"\n#\ninclude \"Gui/OverlayWidget.h\"\n#\ninclude \"Gui/LineEdit.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Gui/FromAddressProxyModel.h\"\n#\ninclude \"Gui/ComposeWidget.h\"\n#\ninclude \"Gui/AutoCompletion.h\"\n#\ninclude \"Gui/AbstractAddressbook.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Composer/Submission.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"Composer/ReplaceSignature.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"ui_ComposeWidget.h\"\n#\ninclude <QToolButton>\ninclude <QTimer>\n#\ninclude <QSettings>\n#\ninclude <QPushButton>\n#\ninclude <QPropertyAnimation>\n#\ninclude <QProgressDialog>\n#\ninclude <QMessageBox>\n#\ninclude <QMenu>\n#\ninclude <QKeyEvent>\n#\ninclude <QGraphicsOpacityEffect>\n#\ninclude <QFileDialog>\n#\ninclude <QBuffer>\n#\ninclude <QAbstractProxyModel>\n#\n\nomposeWidget {\n  oid ComposeWidget::removeRecipient(int pos)\n  {\n      // removing the widgets from the layout is important\n      // a) not doing so leaks (minor)\n      // b) deleteLater() crosses the evenchain and so our actualRow function would be tricked\n      QWidget *formerFocus = QApplication::focusWidget();\n      if (!formerFocus)\n          formerFocus = m_lastFocusedRecipient;\n  \n      if (pos + 1 < m_recipients.count()) {\n          if (m_recipients.at(pos).first == formerFocus) {\n              m_recipients.at(pos + 1).first->setFocus();\n              formerFocus = m_recipients.at(pos + 1).first;\n          } else if (m_recipients.at(pos).second == formerFocus) {\n              m_recipients.at(pos + 1).second->setFocus();\n              formerFocus = m_recipients.at(pos + 1).second;\n          }\n      } else if (m_recipients.at(pos).first == formerFocus || m_recipients.at(pos).second == formerFocus) {\n              formerFocus = 0;\n      }\n  \n      ui->envelopeLayout->removeWidget(m_recipients.at(pos).first);\n      ui->envelopeLayout->removeWidget(m_recipients.at(pos).second);\n      m_recipients.at(pos).first->deleteLater();\n      m_recipients.at(pos).second->deleteLater();\n      m_recipients.removeAt(pos);\n      const int max = qMax(0, m_recipients.count() - m_maxVisibleRecipients);\n      ui->recipientSlider->setMaximum(max);\n      ui->recipientSlider->setVisible(max > 0);\n      if (formerFocus) {\n          // skip event loop, remove might be triggered by imminent focus loss\n          CALL_LATER_NOARG(formerFocus, setFocus);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "\\r')"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ines.end",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ines.begin",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.split",
          "args": [
            "Latin1Char('\\n'))"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "\\n')"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.isEmpty",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "App->clipboard",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "App->clipboard",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::slotPasteAsQuotation()\n  {\n      QString text = qApp->clipboard()->text();\n      if (text.isEmpty())\n          return;\n  \n      QStringList lines = text.split(QLatin1Char('\\n'));\n      for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n          it->remove(QLatin1Char('\\r'));\n          if (it->startsWith(QLatin1Char('>'))) {\n              *it = QLatin1Char('>') + *it;\n          } else {\n              *it = QLatin1String(\"> \") + *it;\n          }\n      }\n      text = lines.join(QLatin1String(\"\\n\"));\n      if (!text.endsWith(QLatin1Char('\\n'))) {\n          text += QLatin1Char('\\n');\n      }\n  \n      QTextCursor cursor = textCursor();\n      cursor.beginEditBlock();\n      cursor.insertBlock();\n      cursor.insertText(text);\n      cursor.endEditBlock();\n      setTextCursor(cursor);\n  }\n}"
  },
  {
    "function_name": "contextMenuEvent(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "148-193",
    "snippet": "oid ComposerTextEdit::contextMenuEvent(QContextMenuEvent *e)\n{\n    QScopedPointer<QMenu> menu(createStandardContextMenu(e->pos()));\n\n    // We would like to place the action next to the existing \"Paste\" item. How to find it? These actions are created\n    // in Qt4's src/gui/text/qtextcontrol.cpp, QTextControl::createStandardContextMenu.\n    //\n    // The first possibility is to take a look at where are these actions connected; we're looking for a connection\n    // between triggered() and SLOT(paste()). Unfortunately, it seems that these are only available via QObjectPrivate.\n    //\n    // Another possibility is to take a look at the shortcuts. Unfortunately, these \"shortcuts\" are not really \"shortcuts\"\n    // in the sense of \"being available via QAction::shortcuts or QAction::shortcuts; they are instead (at least in Qt4)\n    // handled via event handlers.\n    //\n    // Thomas suggested a nice hack, trying the QObject::disconnect. Unfortunately, the QAction is not connected to\n    // QTextEdit::paste but to a QTextControl/QWidgetTextControl::paste, and these are private classes, which makes it\n    // a tad complicated to find them via QObject::findChildren().\n    //\n    // The API of QWebView with its standard actions looks like heaven compared to this stuff.\n    //\n    // This is why we take a look at the action's text and look for a particular string. Yes, it's ugly; patches welcome.\n    QAction *pasteAction = 0;\n    QString candidateStringForPaste = QKeySequence(QKeySequence::Paste).toString();\n    // Finally, the API for adding functions leaves something to be desired; QMenu::insertAction takes a pointer to the\n    // \"before\" thing which is just... annoying here (even though it makes certain amount of sense with addAction which\n    // appends).\n    QAction *followingActionAfterPaste = 0;\n    QList<QAction*> actions = menu->actions();\n    for (QList<QAction*>::const_iterator it = actions.constBegin(); it != actions.constEnd() && !pasteAction; ++it) {\n        if (!candidateStringForPaste.isEmpty() && (*it)->text().contains(candidateStringForPaste)) {\n            pasteAction = *it;\n            if (it + 1 != actions.constEnd()) {\n                followingActionAfterPaste = *(it + 1);\n            }\n            break;\n        }\n    }\n\n    menu->insertAction(followingActionAfterPaste, m_pasteQuoted);\n    if (pasteAction) {\n        m_pasteQuoted->setEnabled(pasteAction->isEnabled());\n    } else {\n        m_pasteQuoted->setEnabled(true);\n    }\n    menu->exec(e->globalPos());\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enu->exec",
          "args": [
            "->globalPos())"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "244-255",
          "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec(const QString &pSql)\n  {\n    bool returnValue = QSqlQuery::exec(pSql);\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->globalPos",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pasteQuoted->setEnabled",
          "args": [
            "rue)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pasteQuoted->setEnabled",
          "args": [
            "asteAction->isEnabled())"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asteAction->isEnabled",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enu->insertAction",
          "args": [
            "ollowingActionAfterPaste,",
            "_pasteQuoted)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctions.constEnd",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*it)->text",
          "args": [
            "andidateStringForPaste)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*it)->text",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andidateStringForPaste.isEmpty",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctions.constEnd",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctions.constBegin",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enu->actions",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeySequence",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeySequence(",
          "args": [
            "KeySequence::Paste)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateStandardContextMenu(",
          "args": [
            "->pos())"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->pos",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "slotPasteAsQuotation(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "195-221",
          "snippet": "oid ComposerTextEdit::slotPasteAsQuotation()\n{\n    QString text = qApp->clipboard()->text();\n    if (text.isEmpty())\n        return;\n\n    QStringList lines = text.split(QLatin1Char('\\n'));\n    for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n        it->remove(QLatin1Char('\\r'));\n        if (it->startsWith(QLatin1Char('>'))) {\n            *it = QLatin1Char('>') + *it;\n        } else {\n            *it = QLatin1String(\"> \") + *it;\n        }\n    }\n    text = lines.join(QLatin1String(\"\\n\"));\n    if (!text.endsWith(QLatin1Char('\\n'))) {\n        text += QLatin1Char('\\n');\n    }\n\n    QTextCursor cursor = textCursor();\n    cursor.beginEditBlock();\n    cursor.insertBlock();\n    cursor.insertText(text);\n    cursor.endEditBlock();\n    setTextCursor(cursor);\n}",
          "includes": [
            "include <QUrl>",
            "include <QTimer>\n#",
            "include <QPaintEvent>\n#",
            "include <QPainter>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QClipboard>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"ComposerTextEdit.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::slotPasteAsQuotation()\n  {\n      QString text = qApp->clipboard()->text();\n      if (text.isEmpty())\n          return;\n  \n      QStringList lines = text.split(QLatin1Char('\\n'));\n      for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n          it->remove(QLatin1Char('\\r'));\n          if (it->startsWith(QLatin1Char('>'))) {\n              *it = QLatin1Char('>') + *it;\n          } else {\n              *it = QLatin1String(\"> \") + *it;\n          }\n      }\n      text = lines.join(QLatin1String(\"\\n\"));\n      if (!text.endsWith(QLatin1Char('\\n'))) {\n          text += QLatin1Char('\\n');\n      }\n  \n      QTextCursor cursor = textCursor();\n      cursor.beginEditBlock();\n      cursor.insertBlock();\n      cursor.insertText(text);\n      cursor.endEditBlock();\n      setTextCursor(cursor);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::contextMenuEvent(QContextMenuEvent *e)\n  {\n      QScopedPointer<QMenu> menu(createStandardContextMenu(e->pos()));\n  \n      // We would like to place the action next to the existing \"Paste\" item. How to find it? These actions are created\n      // in Qt4's src/gui/text/qtextcontrol.cpp, QTextControl::createStandardContextMenu.\n      //\n      // The first possibility is to take a look at where are these actions connected; we're looking for a connection\n      // between triggered() and SLOT(paste()). Unfortunately, it seems that these are only available via QObjectPrivate.\n      //\n      // Another possibility is to take a look at the shortcuts. Unfortunately, these \"shortcuts\" are not really \"shortcuts\"\n      // in the sense of \"being available via QAction::shortcuts or QAction::shortcuts; they are instead (at least in Qt4)\n      // handled via event handlers.\n      //\n      // Thomas suggested a nice hack, trying the QObject::disconnect. Unfortunately, the QAction is not connected to\n      // QTextEdit::paste but to a QTextControl/QWidgetTextControl::paste, and these are private classes, which makes it\n      // a tad complicated to find them via QObject::findChildren().\n      //\n      // The API of QWebView with its standard actions looks like heaven compared to this stuff.\n      //\n      // This is why we take a look at the action's text and look for a particular string. Yes, it's ugly; patches welcome.\n      QAction *pasteAction = 0;\n      QString candidateStringForPaste = QKeySequence(QKeySequence::Paste).toString();\n      // Finally, the API for adding functions leaves something to be desired; QMenu::insertAction takes a pointer to the\n      // \"before\" thing which is just... annoying here (even though it makes certain amount of sense with addAction which\n      // appends).\n      QAction *followingActionAfterPaste = 0;\n      QList<QAction*> actions = menu->actions();\n      for (QList<QAction*>::const_iterator it = actions.constBegin(); it != actions.constEnd() && !pasteAction; ++it) {\n          if (!candidateStringForPaste.isEmpty() && (*it)->text().contains(candidateStringForPaste)) {\n              pasteAction = *it;\n              if (it + 1 != actions.constEnd()) {\n                  followingActionAfterPaste = *(it + 1);\n              }\n              break;\n          }\n      }\n  \n      menu->insertAction(followingActionAfterPaste, m_pasteQuoted);\n      if (pasteAction) {\n          m_pasteQuoted->setEnabled(pasteAction->isEnabled());\n      } else {\n          m_pasteQuoted->setEnabled(true);\n      }\n      menu->exec(e->globalPos());\n  }\n}"
  },
  {
    "function_name": "paintEvent(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "119-146",
    "snippet": "oid ComposerTextEdit::paintEvent(QPaintEvent *pe)\n{\n    QTextEdit::paintEvent(pe);\n    if ( !m_notification.isEmpty() )\n    {\n        const int s = width()/5;\n        QRect r(s, 0, width()-2*s, height());\n        QPainter p(viewport());\n        p.setRenderHint(QPainter::Antialiasing);\n        p.setClipRegion(pe->region());\n        QFont fnt = font();\n        fnt.setBold(true);\n        fnt.setPointSize( fnt.pointSize()*2*r.width()/(3*QFontMetrics(fnt).width(m_notification)) );\n        r.setHeight( QFontMetrics(fnt).height() + 16 );\n        r.moveCenter( rect().center() );\n\n        QColor c = palette().color(viewport()->foregroundRole());\n        c.setAlpha( 2 * c.alpha() / 3 );\n        p.setBrush( c );\n        p.setPen( Qt::NoPen );\n        p.drawRoundedRect( r, 8,8 );\n\n        p.setPen( palette().color(viewport()->backgroundRole()) );\n        p.setFont( fnt );\n        p.drawText(r, Qt::AlignCenter|Qt::TextDontClip, m_notification );\n        p.end();\n    }\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ".end",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "send(",
          "container": "omposeWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposeWidget.cpp",
          "lines": "338-370",
          "snippet": "oid ComposeWidget::send()\n{\n    // Well, Trojita is of course rock solid and will never ever crash :), but experience has shown that every now and then,\n    // there is a subtle issue $somewhere. This means that it's probably a good idea to save the draft explicitly -- better\n    // than losing some work. It's cheap anyway.\n    saveDraft(m_autoSavePath);\n\n    if (!buildMessageData())\n        return;\n\n    m_submission->setImapOptions(m_settings->value(Common::SettingsNames::composerSaveToImapKey, true).toBool(),\n                                 m_settings->value(Common::SettingsNames::composerImapSentKey, tr(\"Sent\")).toString(),\n                                 m_settings->value(Common::SettingsNames::imapHostKey).toString(),\n                                 m_settings->value(Common::SettingsNames::imapUserKey).toString(),\n                                 m_settings->value(Common::SettingsNames::msaMethodKey).toString() == Common::SettingsNames::methodImapSendmail);\n    m_submission->setSmtpOptions(m_settings->value(Common::SettingsNames::smtpUseBurlKey, false).toBool(),\n                                 m_settings->value(Common::SettingsNames::smtpUserKey).toString());\n\n\n    ProgressPopUp *progress = new ProgressPopUp();\n    OverlayWidget *overlay = new OverlayWidget(progress, this);\n    overlay->show();\n    setUiWidgetsEnabled(false);\n\n    connect(m_submission, SIGNAL(progressMin(int)), progress, SLOT(setMinimum(int)));\n    connect(m_submission, SIGNAL(progressMax(int)), progress, SLOT(setMaximum(int)));\n    connect(m_submission, SIGNAL(progress(int)), progress, SLOT(setValue(int)));\n    connect(m_submission, SIGNAL(updateStatusMessage(QString)), progress, SLOT(setLabelText(QString)));\n    connect(m_submission, SIGNAL(succeeded()), overlay, SLOT(deleteLater()));\n    connect(m_submission, SIGNAL(failed(QString)), overlay, SLOT(deleteLater()));\n\n    m_submission->send();\n}",
          "includes": [
            "include \"Imap/Tasks/UidSubmitTask.h\"",
            "include \"Imap/Tasks/GenUrlAuthTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Gui/Window.h\"\n#",
            "include \"Gui/Util.h\"\n#",
            "include \"Gui/ProgressPopUp.h\"\n#",
            "include \"Gui/PasswordDialog.h\"\n#",
            "include \"Gui/OverlayWidget.h\"\n#",
            "include \"Gui/LineEdit.h\"\n#",
            "include \"Gui/IconLoader.h\"\n#",
            "include \"Gui/FromAddressProxyModel.h\"\n#",
            "include \"Gui/ComposeWidget.h\"\n#",
            "include \"Gui/AutoCompletion.h\"\n#",
            "include \"Gui/AbstractAddressbook.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Composer/Submission.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"Composer/ReplaceSignature.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"ui_ComposeWidget.h\"\n#",
            "include <QToolButton>",
            "include <QTimer>\n#",
            "include <QSettings>\n#",
            "include <QPushButton>\n#",
            "include <QPropertyAnimation>\n#",
            "include <QProgressDialog>\n#",
            "include <QMessageBox>\n#",
            "include <QMenu>\n#",
            "include <QKeyEvent>\n#",
            "include <QGraphicsOpacityEffect>\n#",
            "include <QFileDialog>\n#",
            "include <QBuffer>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Tasks/UidSubmitTask.h\"\ninclude \"Imap/Tasks/GenUrlAuthTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Gui/Window.h\"\n#\ninclude \"Gui/Util.h\"\n#\ninclude \"Gui/ProgressPopUp.h\"\n#\ninclude \"Gui/PasswordDialog.h\"\n#\ninclude \"Gui/OverlayWidget.h\"\n#\ninclude \"Gui/LineEdit.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Gui/FromAddressProxyModel.h\"\n#\ninclude \"Gui/ComposeWidget.h\"\n#\ninclude \"Gui/AutoCompletion.h\"\n#\ninclude \"Gui/AbstractAddressbook.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Composer/Submission.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"Composer/ReplaceSignature.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"ui_ComposeWidget.h\"\n#\ninclude <QToolButton>\ninclude <QTimer>\n#\ninclude <QSettings>\n#\ninclude <QPushButton>\n#\ninclude <QPropertyAnimation>\n#\ninclude <QProgressDialog>\n#\ninclude <QMessageBox>\n#\ninclude <QMenu>\n#\ninclude <QKeyEvent>\n#\ninclude <QGraphicsOpacityEffect>\n#\ninclude <QFileDialog>\n#\ninclude <QBuffer>\n#\ninclude <QAbstractProxyModel>\n#\n\nomposeWidget {\n  oid ComposeWidget::send()\n  {\n      // Well, Trojita is of course rock solid and will never ever crash :), but experience has shown that every now and then,\n      // there is a subtle issue $somewhere. This means that it's probably a good idea to save the draft explicitly -- better\n      // than losing some work. It's cheap anyway.\n      saveDraft(m_autoSavePath);\n  \n      if (!buildMessageData())\n          return;\n  \n      m_submission->setImapOptions(m_settings->value(Common::SettingsNames::composerSaveToImapKey, true).toBool(),\n                                   m_settings->value(Common::SettingsNames::composerImapSentKey, tr(\"Sent\")).toString(),\n                                   m_settings->value(Common::SettingsNames::imapHostKey).toString(),\n                                   m_settings->value(Common::SettingsNames::imapUserKey).toString(),\n                                   m_settings->value(Common::SettingsNames::msaMethodKey).toString() == Common::SettingsNames::methodImapSendmail);\n      m_submission->setSmtpOptions(m_settings->value(Common::SettingsNames::smtpUseBurlKey, false).toBool(),\n                                   m_settings->value(Common::SettingsNames::smtpUserKey).toString());\n  \n  \n      ProgressPopUp *progress = new ProgressPopUp();\n      OverlayWidget *overlay = new OverlayWidget(progress, this);\n      overlay->show();\n      setUiWidgetsEnabled(false);\n  \n      connect(m_submission, SIGNAL(progressMin(int)), progress, SLOT(setMinimum(int)));\n      connect(m_submission, SIGNAL(progressMax(int)), progress, SLOT(setMaximum(int)));\n      connect(m_submission, SIGNAL(progress(int)), progress, SLOT(setValue(int)));\n      connect(m_submission, SIGNAL(updateStatusMessage(QString)), progress, SLOT(setLabelText(QString)));\n      connect(m_submission, SIGNAL(succeeded()), overlay, SLOT(deleteLater()));\n      connect(m_submission, SIGNAL(failed(QString)), overlay, SLOT(deleteLater()));\n  \n      m_submission->send();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".drawText",
          "args": [
            ",",
            "t::AlignCenter|Qt::TextDontClip,",
            "_notification"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setFont",
          "args": [
            "nt"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setPen",
          "args": [
            "alette().color(viewport()->backgroundRole())"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alette",
          "args": [
            "iewport()->backgroundRole())"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iewport",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iewport(",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alette(",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".drawRoundedRect",
          "args": [
            ",",
            ","
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setPen",
          "args": [
            "t::NoPen"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setBrush",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setAlpha",
          "args": [
            "* c.alpha() / 3"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".alpha",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alette",
          "args": [
            "iewport()->foregroundRole())"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iewport",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iewport(",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alette(",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".moveCenter",
          "args": [
            "ect().center()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ect",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "expandingDirections",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "109-112",
          "snippet": "Qt::Orientations FlowLayout::expandingDirections() const\n{\n    return 0;\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  Qt::Orientations FlowLayout::expandingDirections() const\n  {\n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ect(",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "runXtConnect()",
          "container": "onnectPage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/SettingsDialog.cpp",
          "lines": "860-901",
          "snippet": "d XtConnectPage::runXtConnect()\n{\n    // First of all, let's save the XTuple-specific configuration to save useless debugging\n    saveXtConfig();\n\n    QString path = QCoreApplication::applicationFilePath();\n    QStringList args;\n\n#ifdef Q_OS_WIN\n    path = path.replace(\n               QLatin1String(\"Gui/debug/trojita\"),\n               QLatin1String(\"XtConnect/debug/xtconnect-trojita\")).replace(\n               QLatin1String(\"Gui/release/trojita\"),\n               QLatin1String(\"XtConnect/release/xtconnect-trojita\"));\n    QString cmd = path;\n#else\n    path = path.replace(QLatin1String(\"src/Gui/trojita\"),\n                        QLatin1String(\"src/XtConnect/xtconnect-trojita\"));\n    args << QLatin1String(\"-e\") << path;\n    QString cmd = QLatin1String(\"xterm\");\n#endif\n\n    if (! hostName->text().isEmpty())\n        args << QLatin1String(\"-h\") << hostName->text();\n\n    if (port->value() != 5432)\n        args << QLatin1String(\"-p\") << QString::number(port->value());\n\n    if (! dbName->text().isEmpty())\n        args << QLatin1String(\"-d\") << dbName->text();\n\n    if (! username->text().isEmpty())\n        args << QLatin1String(\"-U\") << username->text();\n\n    QString password = QInputDialog::getText(this, tr(\"Database Connection\"), tr(\"Password\"), QLineEdit::Password);\n    args << QLatin1String(\"-w\") << password;\n\n    if (debugLog->isChecked())\n        args << QLatin1String(\"--log\") << cacheDir->text() + QLatin1String(\"/xt-trojita-log\");\n\n    QProcess::startDetached(cmd, args);\n}\n\nv",
          "includes": [
            "include \"Gui/Util.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include <QDataWidgetMapper>\n#",
            "include <QMessageBox>\n#",
            "include <QToolTip>\n#",
            "include <QStandardItemModel>\n#",
            "include <QDebug>\n#",
            "include <QResizeEvent>\n#",
            "include <QPushButton>\n#",
            "include <QProcess>\n#",
            "include <QVBoxLayout>\n#",
            "include <QTabWidget>\n#",
            "include <QSpinBox>\n#",
            "include <QRadioButton>\n#",
            "include <QListWidget>\n#",
            "include <QLineEdit>\n#",
            "include <QInputDialog>\n#",
            "include <QGroupBox>\n#",
            "include <QFormLayout>\n#",
            "include <QDir>\n#",
            "include <QDialogButtonBox>\n#",
            "include <QComboBox>\n#",
            "include <QCheckBox>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Gui/Util.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude <QDataWidgetMapper>\n#\ninclude <QMessageBox>\n#\ninclude <QToolTip>\n#\ninclude <QStandardItemModel>\n#\ninclude <QDebug>\n#\ninclude <QResizeEvent>\n#\ninclude <QPushButton>\n#\ninclude <QProcess>\n#\ninclude <QVBoxLayout>\n#\ninclude <QTabWidget>\n#\ninclude <QSpinBox>\n#\ninclude <QRadioButton>\n#\ninclude <QListWidget>\n#\ninclude <QLineEdit>\n#\ninclude <QInputDialog>\n#\ninclude <QGroupBox>\n#\ninclude <QFormLayout>\n#\ninclude <QDir>\n#\ninclude <QDialogButtonBox>\n#\ninclude <QComboBox>\n#\ninclude <QCheckBox>\n#\n\nonnectPage {\n  d XtConnectPage::runXtConnect()\n  {\n      // First of all, let's save the XTuple-specific configuration to save useless debugging\n      saveXtConfig();\n  \n      QString path = QCoreApplication::applicationFilePath();\n      QStringList args;\n  \n  #ifdef Q_OS_WIN\n      path = path.replace(\n                 QLatin1String(\"Gui/debug/trojita\"),\n                 QLatin1String(\"XtConnect/debug/xtconnect-trojita\")).replace(\n                 QLatin1String(\"Gui/release/trojita\"),\n                 QLatin1String(\"XtConnect/release/xtconnect-trojita\"));\n      QString cmd = path;\n  #else\n      path = path.replace(QLatin1String(\"src/Gui/trojita\"),\n                          QLatin1String(\"src/XtConnect/xtconnect-trojita\"));\n      args << QLatin1String(\"-e\") << path;\n      QString cmd = QLatin1String(\"xterm\");\n  #endif\n  \n      if (! hostName->text().isEmpty())\n          args << QLatin1String(\"-h\") << hostName->text();\n  \n      if (port->value() != 5432)\n          args << QLatin1String(\"-p\") << QString::number(port->value());\n  \n      if (! dbName->text().isEmpty())\n          args << QLatin1String(\"-d\") << dbName->text();\n  \n      if (! username->text().isEmpty())\n          args << QLatin1String(\"-U\") << username->text();\n  \n      QString password = QInputDialog::getText(this, tr(\"Database Connection\"), tr(\"Password\"), QLineEdit::Password);\n      args << QLatin1String(\"-w\") << password;\n  \n      if (debugLog->isChecked())\n          args << QLatin1String(\"--log\") << cacheDir->text() + QLatin1String(\"/xt-trojita-log\");\n  \n      QProcess::startDetached(cmd, args);\n  }\n  \n  v\n}"
        }
      },
      {
        "call_info": {
          "callee": ".setHeight",
          "args": [
            "FontMetrics(fnt).height() + 16"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FontMetrics",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FontMetrics(",
          "args": [
            "nt)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt.setPointSize",
          "args": [
            "nt.pointSize()*2*r.width()/(3*QFontMetrics(fnt).width(m_notification))"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FontMetrics",
          "args": [
            "_notification)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FontMetrics(",
          "args": [
            "nt)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".width",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt.pointSize",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt.setBold",
          "args": [
            "rue)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ont(",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ystemMonospaceFont(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Util.cpp",
          "lines": "148-214",
          "snippet": "Font systemMonospaceFont()\n{\n    static bool initialized = false;\n    static QFont font;\n\n    if (!initialized) {\n        if (isRunningKde4()) {\n            // This part was shamelessly inspired by Qt4's src/gui/kernel/qapplication_x11.cpp\n            QSettings kdeSettings(::kdeHome() + QLatin1String(\"/share/config/kdeglobals\"), QSettings::IniFormat);\n            QLatin1String confKey(\"fixed\");\n            QString fontDescription = kdeSettings.value(confKey).toStringList().join(QLatin1String(\",\"));\n            if (fontDescription.isEmpty())\n                fontDescription = kdeSettings.value(confKey).toString();\n            initialized = !fontDescription.isEmpty() && font.fromString(fontDescription);\n        } else if (isRunningGnome() || isRunningXfce()) {\n            // Under Gnome and Xfce, we can read the preferred font in yet another format via gconftool-2\n            QByteArray fontDescription;\n            do {\n                QProcess gconf;\n                gconf.start(QLatin1String(\"gconftool-2\"),\n                            QStringList() << QLatin1String(\"--get\") << QLatin1String(\"/desktop/gnome/interface/monospace_font_name\"));\n                if (!gconf.waitForStarted())\n                    break;\n                gconf.closeWriteChannel();\n                if (!gconf.waitForFinished())\n                    break;\n                fontDescription = gconf.readAllStandardOutput();\n                fontDescription = fontDescription.trimmed();\n            } while (0);\n\n            // This value is apparently supposed to be parsed via the pango_font_description_from_string function. We, of course,\n            // do not link with Pango, so we attempt to do a very crude parsing experiment by hand.\n            // This code does *not* handle many fancy options like specifying the font size in pixels, parsing the bold/italics\n            // options etc. It will also very likely break when the user has specified preefrences for more than one font family.\n            // However, I hope it's better to try to do something than ignoring the problem altogether.\n            int lastSpace = fontDescription.lastIndexOf(' ');\n            bool ok;\n            double size = fontDescription.mid(lastSpace).toDouble(&ok);\n            if (lastSpace > 0 && ok) {\n                font = QFont(fontDescription.left(lastSpace), size);\n                initialized = true;\n            }\n        }\n    }\n\n    if (!initialized) {\n        // Ok, that failed, let's create some fallback font.\n        // The problem is that these names wary acros platforms,\n        // but the following works well -- at first, we come up with a made-up name, and then\n        // let the Qt font substitution algorithm do its magic.\n        font = QFont(QLatin1String(\"x-trojita-terminus-like-fixed-width\"));\n        // Using QFont::Monospace results in a proportional font on jkt's system\n        font.setStyleHint(QFont::TypeWriter);\n\n        // Gnome, Mac and perhaps everyone else uses 10pt as the default font size, so let's use that as well\n        int defaultPointSize = 10;\n        if (isRunningKde4()) {\n            // kdeui/kernel/kglobalsettings.cpp from KDELIBS sets default fixed font size to 9 on X11. Let's hope nobody runs\n            // this desktop-GUI-specific code *with KDE* under Harmattan or Mac. Seriously.\n            defaultPointSize = 9;\n\n        }\n        font.setPointSize(defaultPointSize);\n    }\n\n    return font;\n}",
          "includes": [
            "include \"Window.h\"",
            "include \"Util.h\"\n#",
            "include \"configure.cmake.h\"\n#",
            "include <QSettings>",
            "include <QProcess>\n#",
            "include <QIcon>\n#",
            "include <QGridLayout>\n#",
            "include <QDir>\n#",
            "include <QDesktopWidget> // for Util::centerWidgetOnScreen\n#",
            "include <QCursor> // for Util::centerWidgetOnScreen\n#",
            "include <QCheckBox>\n#",
            "include <QBuffer>\n#",
            "include <QApplication>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Window.h\"\ninclude \"Util.h\"\n#\ninclude \"configure.cmake.h\"\n#\ninclude <QSettings>\ninclude <QProcess>\n#\ninclude <QIcon>\n#\ninclude <QGridLayout>\n#\ninclude <QDir>\n#\ninclude <QDesktopWidget> // for Util::centerWidgetOnScreen\n#\ninclude <QCursor> // for Util::centerWidgetOnScreen\n#\ninclude <QCheckBox>\n#\ninclude <QBuffer>\n#\ninclude <QApplication>\n#\n\nFont systemMonospaceFont()\n{\n    static bool initialized = false;\n    static QFont font;\n\n    if (!initialized) {\n        if (isRunningKde4()) {\n            // This part was shamelessly inspired by Qt4's src/gui/kernel/qapplication_x11.cpp\n            QSettings kdeSettings(::kdeHome() + QLatin1String(\"/share/config/kdeglobals\"), QSettings::IniFormat);\n            QLatin1String confKey(\"fixed\");\n            QString fontDescription = kdeSettings.value(confKey).toStringList().join(QLatin1String(\",\"));\n            if (fontDescription.isEmpty())\n                fontDescription = kdeSettings.value(confKey).toString();\n            initialized = !fontDescription.isEmpty() && font.fromString(fontDescription);\n        } else if (isRunningGnome() || isRunningXfce()) {\n            // Under Gnome and Xfce, we can read the preferred font in yet another format via gconftool-2\n            QByteArray fontDescription;\n            do {\n                QProcess gconf;\n                gconf.start(QLatin1String(\"gconftool-2\"),\n                            QStringList() << QLatin1String(\"--get\") << QLatin1String(\"/desktop/gnome/interface/monospace_font_name\"));\n                if (!gconf.waitForStarted())\n                    break;\n                gconf.closeWriteChannel();\n                if (!gconf.waitForFinished())\n                    break;\n                fontDescription = gconf.readAllStandardOutput();\n                fontDescription = fontDescription.trimmed();\n            } while (0);\n\n            // This value is apparently supposed to be parsed via the pango_font_description_from_string function. We, of course,\n            // do not link with Pango, so we attempt to do a very crude parsing experiment by hand.\n            // This code does *not* handle many fancy options like specifying the font size in pixels, parsing the bold/italics\n            // options etc. It will also very likely break when the user has specified preefrences for more than one font family.\n            // However, I hope it's better to try to do something than ignoring the problem altogether.\n            int lastSpace = fontDescription.lastIndexOf(' ');\n            bool ok;\n            double size = fontDescription.mid(lastSpace).toDouble(&ok);\n            if (lastSpace > 0 && ok) {\n                font = QFont(fontDescription.left(lastSpace), size);\n                initialized = true;\n            }\n        }\n    }\n\n    if (!initialized) {\n        // Ok, that failed, let's create some fallback font.\n        // The problem is that these names wary acros platforms,\n        // but the following works well -- at first, we come up with a made-up name, and then\n        // let the Qt font substitution algorithm do its magic.\n        font = QFont(QLatin1String(\"x-trojita-terminus-like-fixed-width\"));\n        // Using QFont::Monospace results in a proportional font on jkt's system\n        font.setStyleHint(QFont::TypeWriter);\n\n        // Gnome, Mac and perhaps everyone else uses 10pt as the default font size, so let's use that as well\n        int defaultPointSize = 10;\n        if (isRunningKde4()) {\n            // kdeui/kernel/kglobalsettings.cpp from KDELIBS sets default fixed font size to 9 on X11. Let's hope nobody runs\n            // this desktop-GUI-specific code *with KDE* under Harmattan or Mac. Seriously.\n            defaultPointSize = 9;\n\n        }\n        font.setPointSize(defaultPointSize);\n    }\n\n    return font;\n}"
        }
      },
      {
        "call_info": {
          "callee": ".setClipRegion",
          "args": [
            "e->region())"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->region",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".setRenderHint",
          "args": [
            "Painter::Antialiasing)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eight(",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idth(",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idth(",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notification.isEmpty",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextEdit::paintEvent(",
          "args": [
            "e)"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "paintEvent(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "119-146",
          "snippet": "oid ComposerTextEdit::paintEvent(QPaintEvent *pe)\n{\n    QTextEdit::paintEvent(pe);\n    if ( !m_notification.isEmpty() )\n    {\n        const int s = width()/5;\n        QRect r(s, 0, width()-2*s, height());\n        QPainter p(viewport());\n        p.setRenderHint(QPainter::Antialiasing);\n        p.setClipRegion(pe->region());\n        QFont fnt = font();\n        fnt.setBold(true);\n        fnt.setPointSize( fnt.pointSize()*2*r.width()/(3*QFontMetrics(fnt).width(m_notification)) );\n        r.setHeight( QFontMetrics(fnt).height() + 16 );\n        r.moveCenter( rect().center() );\n\n        QColor c = palette().color(viewport()->foregroundRole());\n        c.setAlpha( 2 * c.alpha() / 3 );\n        p.setBrush( c );\n        p.setPen( Qt::NoPen );\n        p.drawRoundedRect( r, 8,8 );\n\n        p.setPen( palette().color(viewport()->backgroundRole()) );\n        p.setFont( fnt );\n        p.drawText(r, Qt::AlignCenter|Qt::TextDontClip, m_notification );\n        p.end();\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::paintEvent(QPaintEvent *pe)\n  {\n      QTextEdit::paintEvent(pe);\n      if ( !m_notification.isEmpty() )\n      {\n          const int s = width()/5;\n          QRect r(s, 0, width()-2*s, height());\n          QPainter p(viewport());\n          p.setRenderHint(QPainter::Antialiasing);\n          p.setClipRegion(pe->region());\n          QFont fnt = font();\n          fnt.setBold(true);\n          fnt.setPointSize( fnt.pointSize()*2*r.width()/(3*QFontMetrics(fnt).width(m_notification)) );\n          r.setHeight( QFontMetrics(fnt).height() + 16 );\n          r.moveCenter( rect().center() );\n  \n          QColor c = palette().color(viewport()->foregroundRole());\n          c.setAlpha( 2 * c.alpha() / 3 );\n          p.setBrush( c );\n          p.setPen( Qt::NoPen );\n          p.drawRoundedRect( r, 8,8 );\n  \n          p.setPen( palette().color(viewport()->backgroundRole()) );\n          p.setFont( fnt );\n          p.drawText(r, Qt::AlignCenter|Qt::TextDontClip, m_notification );\n          p.end();\n      }\n  }\n}"
  },
  {
    "function_name": "keyReleaseEvent(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "108-117",
    "snippet": "oid ComposerTextEdit::keyReleaseEvent(QKeyEvent *ke)\n{\n    if (m_couldBeSendRequest && isSendCombo(ke)) {\n        m_couldBeSendRequest = false;\n        emit sendRequest();\n        return;\n    }\n    m_couldBeSendRequest = false;\n    QTextEdit::keyReleaseEvent(ke);\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TextEdit::keyReleaseEvent(",
          "args": [
            "e)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "keyReleaseEvent(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "108-117",
          "snippet": "oid ComposerTextEdit::keyReleaseEvent(QKeyEvent *ke)\n{\n    if (m_couldBeSendRequest && isSendCombo(ke)) {\n        m_couldBeSendRequest = false;\n        emit sendRequest();\n        return;\n    }\n    m_couldBeSendRequest = false;\n    QTextEdit::keyReleaseEvent(ke);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sSendCombo(",
          "args": [
            "e)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "sSendCombo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "96-98",
          "snippet": "tatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}",
          "includes": [
            "include <QUrl>",
            "include <QTimer>\n#",
            "include <QPaintEvent>\n#",
            "include <QPainter>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QClipboard>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"ComposerTextEdit.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\ntatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}"
        }
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::keyReleaseEvent(QKeyEvent *ke)\n  {\n      if (m_couldBeSendRequest && isSendCombo(ke)) {\n          m_couldBeSendRequest = false;\n          emit sendRequest();\n          return;\n      }\n      m_couldBeSendRequest = false;\n      QTextEdit::keyReleaseEvent(ke);\n  }\n}"
  },
  {
    "function_name": "keyPressEvent(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "100-106",
    "snippet": "oid ComposerTextEdit::keyPressEvent(QKeyEvent *ke) {\n    m_couldBeSendRequest = false;\n    if (isSendCombo(ke)) {\n        m_couldBeSendRequest = true;\n    }\n    QTextEdit::keyPressEvent(ke);\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TextEdit::keyPressEvent(",
          "args": [
            "e)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "keyPressEvent(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "100-106",
          "snippet": "oid ComposerTextEdit::keyPressEvent(QKeyEvent *ke) {\n    m_couldBeSendRequest = false;\n    if (isSendCombo(ke)) {\n        m_couldBeSendRequest = true;\n    }\n    QTextEdit::keyPressEvent(ke);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sSendCombo(",
          "args": [
            "e)"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "sSendCombo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "96-98",
          "snippet": "tatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}",
          "includes": [
            "include <QUrl>",
            "include <QTimer>\n#",
            "include <QPaintEvent>\n#",
            "include <QPainter>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QClipboard>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"ComposerTextEdit.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\ntatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}"
        }
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::keyPressEvent(QKeyEvent *ke) {\n      m_couldBeSendRequest = false;\n      if (isSendCombo(ke)) {\n          m_couldBeSendRequest = true;\n      }\n      QTextEdit::keyPressEvent(ke);\n  }\n}"
  },
  {
    "function_name": "sSendCombo(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "96-98",
    "snippet": "tatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e->modifiers",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->key",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->key",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\ntatic inline bool isSendCombo(QKeyEvent *ke) {\n    return (ke->key() == Qt::Key_Return || ke->key() == Qt::Key_Enter) && ke->modifiers() == Qt::ControlModifier;\n}"
  },
  {
    "function_name": "canInsertFromMimeData(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "65-77",
    "snippet": "ool ComposerTextEdit::canInsertFromMimeData( const QMimeData * source ) const\n{\n    QList<QUrl> urls = source->urls();\n    foreach (const QUrl &url, urls) {\n#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n        if (url.isLocalFile())\n#else\n        if (url.scheme() == QLatin1String(\"file\"))\n#endif\n            return true;\n    }\n    return QTextEdit::canInsertFromMimeData(source);\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TextEdit::canInsertFromMimeData(",
          "args": [
            "ource)"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "canInsertFromMimeData(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "65-77",
          "snippet": "ool ComposerTextEdit::canInsertFromMimeData( const QMimeData * source ) const\n{\n    QList<QUrl> urls = source->urls();\n    foreach (const QUrl &url, urls) {\n#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n        if (url.isLocalFile())\n#else\n        if (url.scheme() == QLatin1String(\"file\"))\n#endif\n            return true;\n    }\n    return QTextEdit::canInsertFromMimeData(source);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "file\")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.isLocalFile",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ource->urls",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  ool ComposerTextEdit::canInsertFromMimeData( const QMimeData * source ) const\n  {\n      QList<QUrl> urls = source->urls();\n      foreach (const QUrl &url, urls) {\n  #if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n          if (url.isLocalFile())\n  #else\n          if (url.scheme() == QLatin1String(\"file\"))\n  #endif\n              return true;\n      }\n      return QTextEdit::canInsertFromMimeData(source);\n  }\n}"
  },
  {
    "function_name": "resetNotification(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "60-63",
    "snippet": "oid ComposerTextEdit::resetNotification()\n{\n    notify(QString());\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "otify(",
          "args": [
            "String())"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::resetNotification()\n  {\n      notify(QString());\n  }\n}"
  },
  {
    "function_name": "notify(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "49-58",
    "snippet": "oid ComposerTextEdit::notify(const QString &n, uint timeout)\n{\n    m_notification = n;\n    if (m_notification.isEmpty() || !timeout) {\n        m_notificationTimer->stop();\n    } else {\n        m_notificationTimer->start(timeout);\n    }\n    viewport()->update();\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iewport",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iewport(",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notificationTimer->start",
          "args": [
            "imeout)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notificationTimer->stop",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notification.isEmpty",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::notify(const QString &n, uint timeout)\n  {\n      m_notification = n;\n      if (m_notification.isEmpty() || !timeout) {\n          m_notificationTimer->stop();\n      } else {\n          m_notificationTimer->start(timeout);\n      }\n      viewport()->update();\n  }\n}"
  },
  {
    "function_name": "ComposerTextEdit(",
    "container": "omposerTextEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
    "lines": "34-47",
    "snippet": "omposerTextEdit::ComposerTextEdit(QWidget *parent) : QTextEdit(parent)\n, m_couldBeSendRequest(false)\n{\n    setAcceptRichText(false);\n    setLineWrapMode(QTextEdit::FixedColumnWidth);\n    setWordWrapMode(QTextOption::WordWrap);\n    setLineWrapColumnOrWidth(78);\n    m_notificationTimer = new QTimer(this);\n    m_notificationTimer->setSingleShot(true);\n    connect (m_notificationTimer, SIGNAL(timeout()), SLOT(resetNotification()));\n\n    m_pasteQuoted = new QAction(tr(\"Paste as Quoted Text\"), this);\n    connect(m_pasteQuoted, SIGNAL(triggered()), this, SLOT(slotPasteAsQuotation()));\n}",
    "includes": [
      "include <QUrl>",
      "include <QTimer>\n#",
      "include <QPaintEvent>\n#",
      "include <QPainter>\n#",
      "include <QMimeData>\n#",
      "include <QMenu>\n#",
      "include <QClipboard>\n#",
      "include <QApplication>\n#",
      "include <QAction>\n#",
      "include \"ComposerTextEdit.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_pasteQuoted,",
            "IGNAL(triggered()),",
            "his,",
            "LOT(slotPasteAsQuotation()))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotPasteAsQuotation())"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotPasteAsQuotation(",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "slotPasteAsQuotation(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "195-221",
          "snippet": "oid ComposerTextEdit::slotPasteAsQuotation()\n{\n    QString text = qApp->clipboard()->text();\n    if (text.isEmpty())\n        return;\n\n    QStringList lines = text.split(QLatin1Char('\\n'));\n    for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n        it->remove(QLatin1Char('\\r'));\n        if (it->startsWith(QLatin1Char('>'))) {\n            *it = QLatin1Char('>') + *it;\n        } else {\n            *it = QLatin1String(\"> \") + *it;\n        }\n    }\n    text = lines.join(QLatin1String(\"\\n\"));\n    if (!text.endsWith(QLatin1Char('\\n'))) {\n        text += QLatin1Char('\\n');\n    }\n\n    QTextCursor cursor = textCursor();\n    cursor.beginEditBlock();\n    cursor.insertBlock();\n    cursor.insertText(text);\n    cursor.endEditBlock();\n    setTextCursor(cursor);\n}",
          "includes": [
            "include <QUrl>",
            "include <QTimer>\n#",
            "include <QPaintEvent>\n#",
            "include <QPainter>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QClipboard>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"ComposerTextEdit.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::slotPasteAsQuotation()\n  {\n      QString text = qApp->clipboard()->text();\n      if (text.isEmpty())\n          return;\n  \n      QStringList lines = text.split(QLatin1Char('\\n'));\n      for (QStringList::iterator it = lines.begin(); it != lines.end(); ++it) {\n          it->remove(QLatin1Char('\\r'));\n          if (it->startsWith(QLatin1Char('>'))) {\n              *it = QLatin1Char('>') + *it;\n          } else {\n              *it = QLatin1String(\"> \") + *it;\n          }\n      }\n      text = lines.join(QLatin1String(\"\\n\"));\n      if (!text.endsWith(QLatin1Char('\\n'))) {\n          text += QLatin1Char('\\n');\n      }\n  \n      QTextCursor cursor = textCursor();\n      cursor.beginEditBlock();\n      cursor.insertBlock();\n      cursor.insertText(text);\n      cursor.endEditBlock();\n      setTextCursor(cursor);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "riggered())"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riggered(",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Paste as Quoted Text\")"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "Spinner(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "36-41",
          "snippet": "pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                    m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n{\n    updateAncestors();\n    hide();\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                      m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n  {\n      updateAncestors();\n      hide();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect",
          "args": [
            "_notificationTimer,",
            "IGNAL(timeout()),",
            "LOT(resetNotification()))"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "XtConnectPage(QW",
          "container": "onnectPage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/SettingsDialog.cpp",
          "lines": "767-826",
          "snippet": "onnectPage::XtConnectPage(QWidget *parent, QSettings &s, ImapPage *imapPage): QWidget(parent), imap(imapPage)\n{\n    // Take care not to clash with the cache of the GUI\n    QString cacheLocation = Common::writablePath(Common::LOCATION_CACHE) + QString::fromAscii(\"xtconnect-trojita\");\n    QFormLayout *layout = new QFormLayout(this);\n    cacheDir = new QLineEdit(s.value(Common::SettingsNames::xtConnectCacheDirectory, cacheLocation).toString(), this);\n    layout->addRow(tr(\"Cache Directory\"), cacheDir);\n\n    QGroupBox *box = new QGroupBox(tr(\"Mailboxes to synchronize\"), this);\n    QVBoxLayout *boxLayout = new QVBoxLayout(box);\n    QListWidget *mailboxes = new QListWidget(box);\n    mailboxes->addItems(s.value(Common::SettingsNames::xtSyncMailboxList).toStringList());\n    for (int i = 0; i < mailboxes->count(); ++i) {\n        mailboxes->item(i)->setFlags(Qt::ItemIsEnabled);\n    }\n    mailboxes->setToolTip(tr(\"Please use context menu inside the main application to select mailboxes to synchronize\"));\n    boxLayout->addWidget(mailboxes);\n    layout->addRow(box);\n\n    QString optionHost = s.value(Common::SettingsNames::xtDbHost).toString();\n    int optionPort = s.value(Common::SettingsNames::xtDbPort, QVariant(5432)).toInt();\n    QString optionDbname = s.value(Common::SettingsNames::xtDbDbName).toString();\n    QString optionUsername = s.value(Common::SettingsNames::xtDbUser).toString();\n\n    QStringList args = QCoreApplication::arguments();\n    for (int i = 1; i < args.length(); i++) {\n        if (args.at(i) == \"-h\" && args.length() > i)\n            optionHost = args.at(++i);\n        else if (args.at(i) == \"-d\" && args.length() > i)\n            optionDbname = args.at(++i);\n        else if (args.at(i) == \"-p\" && args.length() > i)\n            optionPort = args.at(++i).toInt();\n        else if (args.at(i) == \"-U\" && args.length() > i)\n            optionUsername = args.at(++i);\n    }\n\n\n    hostName = new QLineEdit(optionHost);\n    layout->addRow(tr(\"DB Hostname\"), hostName);\n    port = new QSpinBox();\n    port->setRange(1, 65535);\n    port->setValue(optionPort);\n    layout->addRow(tr(\"DB Port\"), port);\n    dbName = new QLineEdit(optionDbname);\n    layout->addRow(tr(\"DB Name\"), dbName);\n    username = new QLineEdit(optionUsername);\n    layout->addRow(tr(\"DB Username\"), username);\n\n    imapPasswordWarning = new QLabel(tr(\"Please fill in all IMAP options, including the password, at the IMAP page. \"\n                                        \"If you do not save the password, background synchronization will not run.\"), this);\n    imapPasswordWarning->setWordWrap(true);\n    imapPasswordWarning->setStyleSheet(SettingsDialog::warningStyleSheet);\n    layout->addRow(imapPasswordWarning);\n    debugLog = new QCheckBox();\n    layout->addRow(tr(\"Debugging\"), debugLog);\n\n    QPushButton *btn = new QPushButton(tr(\"Run xTuple Synchronization\"));\n    connect(btn, SIGNAL(clicked()), this, SLOT(runXtConnect()));\n    layout->addRow(btn);\n}\n\nv",
          "includes": [
            "include \"Gui/Util.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include <QDataWidgetMapper>\n#",
            "include <QMessageBox>\n#",
            "include <QToolTip>\n#",
            "include <QStandardItemModel>\n#",
            "include <QDebug>\n#",
            "include <QResizeEvent>\n#",
            "include <QPushButton>\n#",
            "include <QProcess>\n#",
            "include <QVBoxLayout>\n#",
            "include <QTabWidget>\n#",
            "include <QSpinBox>\n#",
            "include <QRadioButton>\n#",
            "include <QListWidget>\n#",
            "include <QLineEdit>\n#",
            "include <QInputDialog>\n#",
            "include <QGroupBox>\n#",
            "include <QFormLayout>\n#",
            "include <QDir>\n#",
            "include <QDialogButtonBox>\n#",
            "include <QComboBox>\n#",
            "include <QCheckBox>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Gui/Util.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude <QDataWidgetMapper>\n#\ninclude <QMessageBox>\n#\ninclude <QToolTip>\n#\ninclude <QStandardItemModel>\n#\ninclude <QDebug>\n#\ninclude <QResizeEvent>\n#\ninclude <QPushButton>\n#\ninclude <QProcess>\n#\ninclude <QVBoxLayout>\n#\ninclude <QTabWidget>\n#\ninclude <QSpinBox>\n#\ninclude <QRadioButton>\n#\ninclude <QListWidget>\n#\ninclude <QLineEdit>\n#\ninclude <QInputDialog>\n#\ninclude <QGroupBox>\n#\ninclude <QFormLayout>\n#\ninclude <QDir>\n#\ninclude <QDialogButtonBox>\n#\ninclude <QComboBox>\n#\ninclude <QCheckBox>\n#\n\nonnectPage {\n  onnectPage::XtConnectPage(QWidget *parent, QSettings &s, ImapPage *imapPage): QWidget(parent), imap(imapPage)\n  {\n      // Take care not to clash with the cache of the GUI\n      QString cacheLocation = Common::writablePath(Common::LOCATION_CACHE) + QString::fromAscii(\"xtconnect-trojita\");\n      QFormLayout *layout = new QFormLayout(this);\n      cacheDir = new QLineEdit(s.value(Common::SettingsNames::xtConnectCacheDirectory, cacheLocation).toString(), this);\n      layout->addRow(tr(\"Cache Directory\"), cacheDir);\n  \n      QGroupBox *box = new QGroupBox(tr(\"Mailboxes to synchronize\"), this);\n      QVBoxLayout *boxLayout = new QVBoxLayout(box);\n      QListWidget *mailboxes = new QListWidget(box);\n      mailboxes->addItems(s.value(Common::SettingsNames::xtSyncMailboxList).toStringList());\n      for (int i = 0; i < mailboxes->count(); ++i) {\n          mailboxes->item(i)->setFlags(Qt::ItemIsEnabled);\n      }\n      mailboxes->setToolTip(tr(\"Please use context menu inside the main application to select mailboxes to synchronize\"));\n      boxLayout->addWidget(mailboxes);\n      layout->addRow(box);\n  \n      QString optionHost = s.value(Common::SettingsNames::xtDbHost).toString();\n      int optionPort = s.value(Common::SettingsNames::xtDbPort, QVariant(5432)).toInt();\n      QString optionDbname = s.value(Common::SettingsNames::xtDbDbName).toString();\n      QString optionUsername = s.value(Common::SettingsNames::xtDbUser).toString();\n  \n      QStringList args = QCoreApplication::arguments();\n      for (int i = 1; i < args.length(); i++) {\n          if (args.at(i) == \"-h\" && args.length() > i)\n              optionHost = args.at(++i);\n          else if (args.at(i) == \"-d\" && args.length() > i)\n              optionDbname = args.at(++i);\n          else if (args.at(i) == \"-p\" && args.length() > i)\n              optionPort = args.at(++i).toInt();\n          else if (args.at(i) == \"-U\" && args.length() > i)\n              optionUsername = args.at(++i);\n      }\n  \n  \n      hostName = new QLineEdit(optionHost);\n      layout->addRow(tr(\"DB Hostname\"), hostName);\n      port = new QSpinBox();\n      port->setRange(1, 65535);\n      port->setValue(optionPort);\n      layout->addRow(tr(\"DB Port\"), port);\n      dbName = new QLineEdit(optionDbname);\n      layout->addRow(tr(\"DB Name\"), dbName);\n      username = new QLineEdit(optionUsername);\n      layout->addRow(tr(\"DB Username\"), username);\n  \n      imapPasswordWarning = new QLabel(tr(\"Please fill in all IMAP options, including the password, at the IMAP page. \"\n                                          \"If you do not save the password, background synchronization will not run.\"), this);\n      imapPasswordWarning->setWordWrap(true);\n      imapPasswordWarning->setStyleSheet(SettingsDialog::warningStyleSheet);\n      layout->addRow(imapPasswordWarning);\n      debugLog = new QCheckBox();\n      layout->addRow(tr(\"Debugging\"), debugLog);\n  \n      QPushButton *btn = new QPushButton(tr(\"Run xTuple Synchronization\"));\n      connect(btn, SIGNAL(clicked()), this, SLOT(runXtConnect()));\n      layout->addRow(btn);\n  }\n  \n  v\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "esetNotification())"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esetNotification(",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "resetNotification(",
          "container": "omposerTextEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ComposerTextEdit.cpp",
          "lines": "60-63",
          "snippet": "oid ComposerTextEdit::resetNotification()\n{\n    notify(QString());\n}",
          "includes": [
            "include <QUrl>",
            "include <QTimer>\n#",
            "include <QPaintEvent>\n#",
            "include <QPainter>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QClipboard>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"ComposerTextEdit.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  oid ComposerTextEdit::resetNotification()\n  {\n      notify(QString());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notificationTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etLineWrapColumnOrWidth(",
          "args": [
            "8)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etWordWrapMode(",
          "args": [
            "TextOption::WordWrap)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etLineWrapMode(",
          "args": [
            "TextEdit::FixedColumnWidth)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAcceptRichText(",
          "args": [
            "alse)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QUrl>\ninclude <QTimer>\n#\ninclude <QPaintEvent>\n#\ninclude <QPainter>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QClipboard>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"ComposerTextEdit.h\"\n#\n\nomposerTextEdit {\n  omposerTextEdit::ComposerTextEdit(QWidget *parent) : QTextEdit(parent)\n  , m_couldBeSendRequest(false)\n  {\n      setAcceptRichText(false);\n      setLineWrapMode(QTextEdit::FixedColumnWidth);\n      setWordWrapMode(QTextOption::WordWrap);\n      setLineWrapColumnOrWidth(78);\n      m_notificationTimer = new QTimer(this);\n      m_notificationTimer->setSingleShot(true);\n      connect (m_notificationTimer, SIGNAL(timeout()), SLOT(resetNotification()));\n  \n      m_pasteQuoted = new QAction(tr(\"Paste as Quoted Text\"), this);\n      connect(m_pasteQuoted, SIGNAL(triggered()), this, SLOT(slotPasteAsQuotation()));\n  }\n}"
  }
]