[
  {
    "function_name": "slotReconnect(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "187-200",
    "snippet": "oid SqlStorage::slotReconnect()\n{\n    qDebug() << \"Trying to reconnect to the database...\";\n    // Release all DB resources\n    _queryInsertAddress.clear();\n    _queryInsertMail.clear();\n    _queryMarkMailReady.clear();\n    db.close();\n\n    // Unregister the DB\n    QSqlDatabase::removeDatabase( QLatin1String(\"xtconnect-sqlstorage\") );\n\n    open();\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pen(",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "open(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "48-71",
          "snippet": "oid SqlStorage::open()\n{\n    db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n    if ( ! _host.isEmpty() )\n        db.setHostName(_host);\n\n    if ( _port != 5432 && _port > 0 && _port < 65536 )\n        db.setPort(_port);\n\n    if ( ! _dbname.isEmpty() )\n        db.setDatabaseName( _dbname );\n\n    if ( ! _username.isEmpty() )\n        db.setUserName( _username );\n\n    if ( ! _password.isEmpty() )\n        db.setPassword( _password );\n\n    if ( ! db.open() ) {\n        _fail( \"Failed to open database connection\", db );\n    }\n\n    _prepareStatements();\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::open()\n  {\n      db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n      if ( ! _host.isEmpty() )\n          db.setHostName(_host);\n  \n      if ( _port != 5432 && _port > 0 && _port < 65536 )\n          db.setPort(_port);\n  \n      if ( ! _dbname.isEmpty() )\n          db.setDatabaseName( _dbname );\n  \n      if ( ! _username.isEmpty() )\n          db.setUserName( _username );\n  \n      if ( ! _password.isEmpty() )\n          db.setPassword( _password );\n  \n      if ( ! db.open() ) {\n          _fail( \"Failed to open database connection\", db );\n      }\n  \n      _prepareStatements();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SqlDatabase::removeDatabase(",
          "args": [
            "Latin1String(\"xtconnect-sqlstorage\")"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "xtconnect-sqlstorage\")"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.close",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryMarkMailReady.clear",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::slotReconnect()\n  {\n      qDebug() << \"Trying to reconnect to the database...\";\n      // Release all DB resources\n      _queryInsertAddress.clear();\n      _queryInsertMail.clear();\n      _queryMarkMailReady.clear();\n      db.close();\n  \n      // Unregister the DB\n      QSqlDatabase::removeDatabase( QLatin1String(\"xtconnect-sqlstorage\") );\n  \n      open();\n  }\n}"
  },
  {
    "function_name": "markMailReady(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "175-185",
    "snippet": "qlStorage::ResultType SqlStorage::markMailReady( const quint64 emlId )\n{\n    _queryMarkMailReady.bindValue( 0, emlId );\n\n    if ( ! _queryMarkMailReady.exec() ) {\n        _fail( \"Query _queryMarkMailReady failed\", _queryMarkMailReady );\n        return RESULT_ERROR;\n    }\n\n    return RESULT_OK;\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "Query _queryMarkMailReady failed\",",
            "queryMarkMailReady"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryMarkMailReady.exec",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryMarkMailReady.bindValue",
          "args": [
            ",",
            "mlId"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  qlStorage::ResultType SqlStorage::markMailReady( const quint64 emlId )\n  {\n      _queryMarkMailReady.bindValue( 0, emlId );\n  \n      if ( ! _queryMarkMailReady.exec() ) {\n          _fail( \"Query _queryMarkMailReady failed\", _queryMarkMailReady );\n          return RESULT_ERROR;\n      }\n  \n      return RESULT_OK;\n  }\n}"
  },
  {
    "function_name": "insertAddress(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "160-173",
    "snippet": "qlStorage::ResultType SqlStorage::insertAddress( const quint64 emlId, const QString &name, const QString &address, const QLatin1String kind )\n{\n    _queryInsertAddress.bindValue( QLatin1String(\":emladdr_eml_id\"), emlId );\n    _queryInsertAddress.bindValue( QLatin1String(\":emladdr_type\"), kind );\n    _queryInsertAddress.bindValue( QLatin1String(\":emladdr_addr\"), address );\n    _queryInsertAddress.bindValue( QLatin1String(\":emladdr_name\"), name );\n\n    if ( ! _queryInsertAddress.exec() ) {\n        _fail( \"Query _queryInsertAddress failed\", _queryInsertAddress );\n        return RESULT_ERROR;\n    }\n\n    return RESULT_OK;\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "Query _queryInsertAddress failed\",",
            "queryInsertAddress"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryInsertAddress.exec",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryInsertAddress.bindValue",
          "args": [
            "Latin1String(\":emladdr_name\"),",
            "ame"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":emladdr_name\")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertAddress.bindValue",
          "args": [
            "Latin1String(\":emladdr_addr\"),",
            "ddress"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":emladdr_addr\")"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertAddress.bindValue",
          "args": [
            "Latin1String(\":emladdr_type\"),",
            "ind"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":emladdr_type\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertAddress.bindValue",
          "args": [
            "Latin1String(\":emladdr_eml_id\"),",
            "mlId"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":emladdr_eml_id\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  qlStorage::ResultType SqlStorage::insertAddress( const quint64 emlId, const QString &name, const QString &address, const QLatin1String kind )\n  {\n      _queryInsertAddress.bindValue( QLatin1String(\":emladdr_eml_id\"), emlId );\n      _queryInsertAddress.bindValue( QLatin1String(\":emladdr_type\"), kind );\n      _queryInsertAddress.bindValue( QLatin1String(\":emladdr_addr\"), address );\n      _queryInsertAddress.bindValue( QLatin1String(\":emladdr_name\"), name );\n  \n      if ( ! _queryInsertAddress.exec() ) {\n          _fail( \"Query _queryInsertAddress failed\", _queryInsertAddress );\n          return RESULT_ERROR;\n      }\n  \n      return RESULT_OK;\n  }\n}"
  },
  {
    "function_name": "transactionGuard(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "155-158",
    "snippet": "ommon::SqlTransactionAutoAborter SqlStorage::transactionGuard()\n{\n    return Common::SqlTransactionAutoAborter(&db);\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ommon::SqlTransactionAutoAborter(",
          "args": [
            "db)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  ommon::SqlTransactionAutoAborter SqlStorage::transactionGuard()\n  {\n      return Common::SqlTransactionAutoAborter(&db);\n  }\n}"
  },
  {
    "function_name": "fail(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "150-153",
    "snippet": "oid SqlStorage::fail(const QString &message)\n{\n    _fail(message, db);\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "essage,",
            "b)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::fail(const QString &message)\n  {\n      _fail(message, db);\n  }\n}"
  },
  {
    "function_name": "_fail(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "143-148",
    "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromAscii",
          "args": [
            "essage,",
            "atabase.lastError().text())"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atabase.lastError",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atabase.lastError",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromAscii(",
          "args": [
            "SqlStorage: Query Error: %1: %2\")"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "econnect->start",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.isOpen",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
  },
  {
    "function_name": "_fail(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "136-141",
    "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlQuery &query)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, query.lastError().text()));\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromAscii",
          "args": [
            "essage,",
            "uery.lastError().text())"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uery.lastError",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uery.lastError",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromAscii(",
          "args": [
            "SqlStorage: Query Error: %1: %2\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "econnect->start",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.isOpen",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlQuery &query)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, query.lastError().text()));\n  }\n}"
  },
  {
    "function_name": "insertMail(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "101-134",
    "snippet": "qlStorage::ResultType SqlStorage::insertMail( const QDateTime &dateTime, const QString &subject, const QString &readableText, const QByteArray &headers, const QByteArray &body, quint64 &emlId )\n{\n    QCryptographicHash hash( QCryptographicHash::Sha1 );\n    hash.addData( body );\n    QByteArray hashValue = hash.result();\n\n    _queryValidateMail.bindValue( \":eml_hash\", hashValue );\n    if ( ! _queryValidateMail.exec() ) {\n        _fail( \"Query _queryValidateMail failed\", _queryValidateMail );\n        return RESULT_ERROR;\n    } else if ( _queryValidateMail.first() ) {\n        return RESULT_DUPLICATE;\n    }\n\n    _queryInsertMail.bindValue( \":eml_hash\", hashValue );\n    // Use ISODate, because it will specify that the time is in UTC.\n    // Otherwise time is assumed to be local which would be bad\n    _queryInsertMail.bindValue( \":eml_date\", dateTime.toString(Qt::ISODate));\n    _queryInsertMail.bindValue( \":eml_subj\", subject );\n    _queryInsertMail.bindValue( \":eml_body\", readableText );\n    _queryInsertMail.bindValue( \":eml_msg\", headers + body);\n\n    if ( ! _queryInsertMail.exec() ) {\n        _fail( \"Query _queryInsertMail failed\", _queryInsertMail );\n        return RESULT_ERROR;\n    }\n\n    if ( _queryInsertMail.first() ) {\n        emlId = _queryInsertMail.value( 0 ).toULongLong();\n        return RESULT_OK;\n    } else {\n        return RESULT_ERROR;\n    }\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queryInsertMail.value",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryInsertMail.first",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "Query _queryInsertMail failed\",",
            "queryInsertMail"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryInsertMail.exec",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryInsertMail.bindValue",
          "args": [
            ":eml_msg\",",
            "eaders + body)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertMail.bindValue",
          "args": [
            ":eml_body\",",
            "eadableText"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertMail.bindValue",
          "args": [
            ":eml_subj\",",
            "ubject"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertMail.bindValue",
          "args": [
            ":eml_date\",",
            "ateTime.toString(Qt::ISODate))"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.toString",
          "args": [
            "t::ISODate)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryInsertMail.bindValue",
          "args": [
            ":eml_hash\",",
            "ashValue"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queryValidateMail.bindValue",
          "args": [
            ":eml_hash\",",
            "ashValue"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ash.result",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ash.addData",
          "args": [
            "ody"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  qlStorage::ResultType SqlStorage::insertMail( const QDateTime &dateTime, const QString &subject, const QString &readableText, const QByteArray &headers, const QByteArray &body, quint64 &emlId )\n  {\n      QCryptographicHash hash( QCryptographicHash::Sha1 );\n      hash.addData( body );\n      QByteArray hashValue = hash.result();\n  \n      _queryValidateMail.bindValue( \":eml_hash\", hashValue );\n      if ( ! _queryValidateMail.exec() ) {\n          _fail( \"Query _queryValidateMail failed\", _queryValidateMail );\n          return RESULT_ERROR;\n      } else if ( _queryValidateMail.first() ) {\n          return RESULT_DUPLICATE;\n      }\n  \n      _queryInsertMail.bindValue( \":eml_hash\", hashValue );\n      // Use ISODate, because it will specify that the time is in UTC.\n      // Otherwise time is assumed to be local which would be bad\n      _queryInsertMail.bindValue( \":eml_date\", dateTime.toString(Qt::ISODate));\n      _queryInsertMail.bindValue( \":eml_subj\", subject );\n      _queryInsertMail.bindValue( \":eml_body\", readableText );\n      _queryInsertMail.bindValue( \":eml_msg\", headers + body);\n  \n      if ( ! _queryInsertMail.exec() ) {\n          _fail( \"Query _queryInsertMail failed\", _queryInsertMail );\n          return RESULT_ERROR;\n      }\n  \n      if ( _queryInsertMail.first() ) {\n          emlId = _queryInsertMail.value( 0 ).toULongLong();\n          return RESULT_OK;\n      } else {\n          return RESULT_ERROR;\n      }\n  }\n}"
  },
  {
    "function_name": "_prepareStatements(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "73-99",
    "snippet": "oid SqlStorage::_prepareStatements()\n{\n    _queryValidateMail = XSqlQuery(db);\n    if ( ! _queryValidateMail.prepare( QLatin1String(\"SELECT eml_id FROM xtbatch.eml \"\n                                                     \" WHERE :eml_hash=eml_hash::bytea;\")) )\n                                                     _fail( \"Failed to prepare query _queryValidateMail\", _queryValidateMail );\n\n    _queryInsertMail = XSqlQuery(db);\n    if ( ! _queryInsertMail.prepare( QLatin1String(\"INSERT INTO xtbatch.eml \"\n                                                   \"(eml_hash, eml_date, eml_subj, eml_body, eml_msg, eml_status) \"\n                                                   \"VALUES \"\n                                                   \"(:eml_hash, :eml_date, :eml_subj, :eml_body,\"\n                                                   \" :eml_msg, 'I') \"\n                                                   \"returning eml_id;\")) )\n                                                    _fail( \"Failed to prepare query _queryInsertMail\", _queryInsertMail );\n\n    _queryInsertAddress = XSqlQuery(db);\n    if ( ! _queryInsertAddress.prepare( QLatin1String(\"INSERT INTO xtbatch.emladdr \"\n                                                      \"(emladdr_eml_id, emladdr_type, emladdr_addr, emladdr_name) \"\n                                                      \"VALUES (:emladdr_eml_id, :emladdr_type, :emladdr_addr, \"\n                                                      \":emladdr_name)\") ) )\n        _fail( \"Failed to prepare query _queryInsertAddress\", _queryInsertAddress );\n\n    _queryMarkMailReady = QSqlQuery(db);\n    if ( ! _queryMarkMailReady.prepare( QLatin1String(\"UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\") ) )\n        _fail( \"Failed to prepare query _queryMarkMailReady\", _queryMarkMailReady );\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "Failed to prepare query _queryMarkMailReady\",",
            "queryMarkMailReady"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queryMarkMailReady.prepare",
          "args": [
            "Latin1String(\"UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\")"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "prepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "257-291",
          "snippet": "bool XSqlQuery::prepare(const QString &pSql)\n{\n  bool ret;\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    ((XSqlResultHelper*)result())->setActive(false);\n    ((XSqlResultHelper*)result())->setLastError(QSqlError());\n    ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n    if (!driver()) {\n      qWarning(\"XSqlQuery::prepare: no driver\");\n      return false;\n    }\n    if (!driver()->isOpen() || driver()->isOpenError()) {\n      qWarning(\"XSqlQuery::prepare: database not open\");\n      return false;\n    }\n    if (pSql.isEmpty()) {\n      qWarning(\"XSqlQuery::prepare: empty query\");\n      return false;\n    }\n#ifdef QT_DEBUG_SQL\n    qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n#endif\n    ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n  }\n  else\n    ret = QSqlQuery::prepare(pSql);\n  if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n    bindValue(\":firstnullfix\", QVariant());\n  return ret;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::prepare(const QString &pSql)\n  {\n    bool ret;\n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      ((XSqlResultHelper*)result())->setActive(false);\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n      ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n      if (!driver()) {\n        qWarning(\"XSqlQuery::prepare: no driver\");\n        return false;\n      }\n      if (!driver()->isOpen() || driver()->isOpenError()) {\n        qWarning(\"XSqlQuery::prepare: database not open\");\n        return false;\n      }\n      if (pSql.isEmpty()) {\n        qWarning(\"XSqlQuery::prepare: empty query\");\n        return false;\n      }\n  #ifdef QT_DEBUG_SQL\n      qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n  #endif\n      ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n    }\n    else\n      ret = QSqlQuery::prepare(pSql);\n    if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n      bindValue(\":firstnullfix\", QVariant());\n    return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\")"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT INTO xtbatch.emladdr \"\n                                                      \"(emladdr_eml_id, emladdr_type, emladdr_addr, emladdr_name) \"\n                                                      \"VALUES (:emladdr_eml_id, :emladdr_type, :emladdr_addr, \"\n                                                      \":emladdr_name)\")"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT INTO xtbatch.eml \"\n                                                   \"(eml_hash, eml_date, eml_subj, eml_body, eml_msg, eml_status) \"\n                                                   \"VALUES \"\n                                                   \"(:eml_hash, :eml_date, :eml_subj, :eml_body,\"\n                                                   \" :eml_msg, 'I') \"\n                                                   \"returning eml_id;\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT eml_id FROM xtbatch.eml \"\n                                                     \" WHERE :eml_hash=eml_hash::bytea;\")"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_prepareStatements()\n  {\n      _queryValidateMail = XSqlQuery(db);\n      if ( ! _queryValidateMail.prepare( QLatin1String(\"SELECT eml_id FROM xtbatch.eml \"\n                                                       \" WHERE :eml_hash=eml_hash::bytea;\")) )\n                                                       _fail( \"Failed to prepare query _queryValidateMail\", _queryValidateMail );\n  \n      _queryInsertMail = XSqlQuery(db);\n      if ( ! _queryInsertMail.prepare( QLatin1String(\"INSERT INTO xtbatch.eml \"\n                                                     \"(eml_hash, eml_date, eml_subj, eml_body, eml_msg, eml_status) \"\n                                                     \"VALUES \"\n                                                     \"(:eml_hash, :eml_date, :eml_subj, :eml_body,\"\n                                                     \" :eml_msg, 'I') \"\n                                                     \"returning eml_id;\")) )\n                                                      _fail( \"Failed to prepare query _queryInsertMail\", _queryInsertMail );\n  \n      _queryInsertAddress = XSqlQuery(db);\n      if ( ! _queryInsertAddress.prepare( QLatin1String(\"INSERT INTO xtbatch.emladdr \"\n                                                        \"(emladdr_eml_id, emladdr_type, emladdr_addr, emladdr_name) \"\n                                                        \"VALUES (:emladdr_eml_id, :emladdr_type, :emladdr_addr, \"\n                                                        \":emladdr_name)\") ) )\n          _fail( \"Failed to prepare query _queryInsertAddress\", _queryInsertAddress );\n  \n      _queryMarkMailReady = QSqlQuery(db);\n      if ( ! _queryMarkMailReady.prepare( QLatin1String(\"UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\") ) )\n          _fail( \"Failed to prepare query _queryMarkMailReady\", _queryMarkMailReady );\n  }\n}"
  },
  {
    "function_name": "open(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "48-71",
    "snippet": "oid SqlStorage::open()\n{\n    db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n    if ( ! _host.isEmpty() )\n        db.setHostName(_host);\n\n    if ( _port != 5432 && _port > 0 && _port < 65536 )\n        db.setPort(_port);\n\n    if ( ! _dbname.isEmpty() )\n        db.setDatabaseName( _dbname );\n\n    if ( ! _username.isEmpty() )\n        db.setUserName( _username );\n\n    if ( ! _password.isEmpty() )\n        db.setPassword( _password );\n\n    if ( ! db.open() ) {\n        _fail( \"Failed to open database connection\", db );\n    }\n\n    _prepareStatements();\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepareStatements(",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "_prepareStatements(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "73-99",
          "snippet": "oid SqlStorage::_prepareStatements()\n{\n    _queryValidateMail = XSqlQuery(db);\n    if ( ! _queryValidateMail.prepare( QLatin1String(\"SELECT eml_id FROM xtbatch.eml \"\n                                                     \" WHERE :eml_hash=eml_hash::bytea;\")) )\n                                                     _fail( \"Failed to prepare query _queryValidateMail\", _queryValidateMail );\n\n    _queryInsertMail = XSqlQuery(db);\n    if ( ! _queryInsertMail.prepare( QLatin1String(\"INSERT INTO xtbatch.eml \"\n                                                   \"(eml_hash, eml_date, eml_subj, eml_body, eml_msg, eml_status) \"\n                                                   \"VALUES \"\n                                                   \"(:eml_hash, :eml_date, :eml_subj, :eml_body,\"\n                                                   \" :eml_msg, 'I') \"\n                                                   \"returning eml_id;\")) )\n                                                    _fail( \"Failed to prepare query _queryInsertMail\", _queryInsertMail );\n\n    _queryInsertAddress = XSqlQuery(db);\n    if ( ! _queryInsertAddress.prepare( QLatin1String(\"INSERT INTO xtbatch.emladdr \"\n                                                      \"(emladdr_eml_id, emladdr_type, emladdr_addr, emladdr_name) \"\n                                                      \"VALUES (:emladdr_eml_id, :emladdr_type, :emladdr_addr, \"\n                                                      \":emladdr_name)\") ) )\n        _fail( \"Failed to prepare query _queryInsertAddress\", _queryInsertAddress );\n\n    _queryMarkMailReady = QSqlQuery(db);\n    if ( ! _queryMarkMailReady.prepare( QLatin1String(\"UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\") ) )\n        _fail( \"Failed to prepare query _queryMarkMailReady\", _queryMarkMailReady );\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_prepareStatements()\n  {\n      _queryValidateMail = XSqlQuery(db);\n      if ( ! _queryValidateMail.prepare( QLatin1String(\"SELECT eml_id FROM xtbatch.eml \"\n                                                       \" WHERE :eml_hash=eml_hash::bytea;\")) )\n                                                       _fail( \"Failed to prepare query _queryValidateMail\", _queryValidateMail );\n  \n      _queryInsertMail = XSqlQuery(db);\n      if ( ! _queryInsertMail.prepare( QLatin1String(\"INSERT INTO xtbatch.eml \"\n                                                     \"(eml_hash, eml_date, eml_subj, eml_body, eml_msg, eml_status) \"\n                                                     \"VALUES \"\n                                                     \"(:eml_hash, :eml_date, :eml_subj, :eml_body,\"\n                                                     \" :eml_msg, 'I') \"\n                                                     \"returning eml_id;\")) )\n                                                      _fail( \"Failed to prepare query _queryInsertMail\", _queryInsertMail );\n  \n      _queryInsertAddress = XSqlQuery(db);\n      if ( ! _queryInsertAddress.prepare( QLatin1String(\"INSERT INTO xtbatch.emladdr \"\n                                                        \"(emladdr_eml_id, emladdr_type, emladdr_addr, emladdr_name) \"\n                                                        \"VALUES (:emladdr_eml_id, :emladdr_type, :emladdr_addr, \"\n                                                        \":emladdr_name)\") ) )\n          _fail( \"Failed to prepare query _queryInsertAddress\", _queryInsertAddress );\n  \n      _queryMarkMailReady = QSqlQuery(db);\n      if ( ! _queryMarkMailReady.prepare( QLatin1String(\"UPDATE xtbatch.eml SET eml_status = 'O' WHERE eml_id = ?\") ) )\n          _fail( \"Failed to prepare query _queryMarkMailReady\", _queryMarkMailReady );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fail(",
          "args": [
            "Failed to open database connection\",",
            "b"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "_fail(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "143-148",
          "snippet": "oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n{\n    if (!db.isOpen())\n        reconnect->start();\n    emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::_fail(const QString &message, const QSqlDatabase &database)\n  {\n      if (!db.isOpen())\n          reconnect->start();\n      emit encounteredError(QString::fromAscii(\"SqlStorage: Query Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b.open",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setPassword",
          "args": [
            "password"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "password.isEmpty",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setUserName",
          "args": [
            "username"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "username.isEmpty",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setDatabaseName",
          "args": [
            "dbname"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbname.isEmpty",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setPort",
          "args": [
            "port)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setHostName",
          "args": [
            "host)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host.isEmpty",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlDatabase::addDatabase(",
          "args": [
            "Latin1String(\"QPSQL\"),",
            "Latin1String(\"xtconnect-sqlstorage\")"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "xtconnect-sqlstorage\")"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "QPSQL\")"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::open()\n  {\n      db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n      if ( ! _host.isEmpty() )\n          db.setHostName(_host);\n  \n      if ( _port != 5432 && _port > 0 && _port < 65536 )\n          db.setPort(_port);\n  \n      if ( ! _dbname.isEmpty() )\n          db.setDatabaseName( _dbname );\n  \n      if ( ! _username.isEmpty() )\n          db.setUserName( _username );\n  \n      if ( ! _password.isEmpty() )\n          db.setPassword( _password );\n  \n      if ( ! db.open() ) {\n          _fail( \"Failed to open database connection\", db );\n      }\n  \n      _prepareStatements();\n  }\n}"
  },
  {
    "function_name": "SqlStorage(",
    "container": "qlStorage",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
    "lines": "39-46",
    "snippet": "qlStorage::SqlStorage(QObject *parent, const QString &host, const int port, const QString &dbname, const QString &username, const QString &password ) :\n    QObject(parent), _host(host), _port(port), _dbname(dbname), _username(username), _password(password)\n{\n    reconnect = new QTimer( this );\n    reconnect->setSingleShot( true );\n    reconnect->setInterval( 10 * 1000 );\n    connect( reconnect, SIGNAL(timeout()), this, SLOT(slotReconnect()) );\n}",
    "includes": [
      "include <QVariant>",
      "include <QTimer>\n#",
      "include <QSqlError>\n#",
      "include <QDebug>\n#",
      "include <QCryptographicHash>\n#",
      "include \"SqlStorage.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "econnect,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotReconnect())"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotReconnect())"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotReconnect(",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "slotReconnect(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "187-200",
          "snippet": "oid SqlStorage::slotReconnect()\n{\n    qDebug() << \"Trying to reconnect to the database...\";\n    // Release all DB resources\n    _queryInsertAddress.clear();\n    _queryInsertMail.clear();\n    _queryMarkMailReady.clear();\n    db.close();\n\n    // Unregister the DB\n    QSqlDatabase::removeDatabase( QLatin1String(\"xtconnect-sqlstorage\") );\n\n    open();\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::slotReconnect()\n  {\n      qDebug() << \"Trying to reconnect to the database...\";\n      // Release all DB resources\n      _queryInsertAddress.clear();\n      _queryInsertMail.clear();\n      _queryMarkMailReady.clear();\n      db.close();\n  \n      // Unregister the DB\n      QSqlDatabase::removeDatabase( QLatin1String(\"xtconnect-sqlstorage\") );\n  \n      open();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "econnect->setInterval",
          "args": [
            "0 * 1000"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "econnect->setSingleShot",
          "args": [
            "rue"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  qlStorage::SqlStorage(QObject *parent, const QString &host, const int port, const QString &dbname, const QString &username, const QString &password ) :\n      QObject(parent), _host(host), _port(port), _dbname(dbname), _username(username), _password(password)\n  {\n      reconnect = new QTimer( this );\n      reconnect->setSingleShot( true );\n      reconnect->setInterval( 10 * 1000 );\n      connect( reconnect, SIGNAL(timeout()), this, SLOT(slotReconnect()) );\n  }\n}"
  }
]