[
  {
    "function_name": "atSpaces(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "458-462",
    "snippet": "oid eatSpaces(const QByteArray &line, int &start)\n{\n    while (line.size() > start && line[start] == ' ')\n        ++start;\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\noid eatSpaces(const QByteArray &line, int &start)\n{\n    while (line.size() > start && line[start] == ' ')\n        ++start;\n}"
  },
  {
    "function_name": "arseRFC2822DateTime(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "391-456",
    "snippet": "DateTime parseRFC2822DateTime(const QString &string)\n{\n    QStringList monthNames = QStringList() << QLatin1String(\"jan\") << QLatin1String(\"feb\") << QLatin1String(\"mar\")\n                                           << QLatin1String(\"apr\") << QLatin1String(\"may\") << QLatin1String(\"jun\")\n                                           << QLatin1String(\"jul\") << QLatin1String(\"aug\") << QLatin1String(\"sep\")\n                                           << QLatin1String(\"oct\") << QLatin1String(\"nov\") << QLatin1String(\"dec\");\n\n    QRegExp rx(QString::fromUtf8(\"^(?:\\\\s*([A-Z][a-z]+)\\\\s*,\\\\s*)?\"   // date-of-week\n                                 \"(\\\\d{1,2})\\\\s+(%1)\\\\s+(\\\\d{2,4})\" // date\n                                 \"\\\\s+(\\\\d{1,2})\\\\s*:(\\\\d{1,2})\\\\s*(?::\\\\s*(\\\\d{1,2})\\\\s*)?\" // time\n                                 \"(\\\\s+(?:(?:([+-]?)(\\\\d{2})(\\\\d{2}))|(UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Za-ik-z])))?\" // timezone\n                                 ).arg(monthNames.join(QLatin1String(\"|\"))), Qt::CaseInsensitive);\n    int pos = rx.indexIn(string);\n\n    if (pos == -1)\n        throw ParseError(\"Date format not recognized\");\n\n    QStringList list = rx.capturedTexts();\n\n    if (list.size() != 13)\n        throw ParseError(\"Date regular expression returned weird data (internal error?)\");\n\n    int year = list[4].toInt();\n    int month = monthNames.indexOf(list[3].toLower()) + 1;\n    if (month == 0)\n        throw ParseError(\"Invalid month name\");\n    int day = list[2].toInt();\n    int hours = list[5].toInt();\n    int minutes = list[6].toInt();\n    int seconds = list[7].toInt();\n    int shift = list[10].toInt() * 60 + list[11].toInt();\n    if (list[9] == QLatin1String(\"-\"))\n        shift *= 60;\n    else\n        shift *= -60;\n    if (! list[12].isEmpty()) {\n        const QString tz = list[12].toUpper();\n        if (tz == QLatin1String(\"UT\") || tz == QLatin1String(\"GMT\"))\n            shift = 0;\n        else if (tz == QLatin1String(\"EST\"))\n            shift = 5 * 3600;\n        else if (tz == QLatin1String(\"EDT\"))\n            shift = 4 * 3600;\n        else if (tz == QLatin1String(\"CST\"))\n            shift = 6 * 3600;\n        else if (tz == QLatin1String(\"CDT\"))\n            shift = 5 * 3600;\n        else if (tz == QLatin1String(\"MST\"))\n            shift = 7 * 3600;\n        else if (tz == QLatin1String(\"MDT\"))\n            shift = 6 * 3600;\n        else if (tz == QLatin1String(\"PST\"))\n            shift = 8 * 3600;\n        else if (tz == QLatin1String(\"PDT\"))\n            shift = 7 * 3600;\n        else if (tz.size() == 1)\n            shift = 0;\n        else\n            throw ParseError(\"Invalid TZ specification\");\n    }\n\n    QDateTime date(QDate(year, month, day), QTime(hours, minutes, seconds), Qt::UTC);\n    date = date.addSecs(shift);\n\n    return date;\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ate.addSecs",
          "args": [
            "hift)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Invalid TZ specification\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z.size",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "PDT\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "PST\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "MDT\")"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "MST\")"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CDT\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CST\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "EDT\")"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "EST\")"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "GMT\")"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UT\")"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[12].toUpper",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[12].isEmpty",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "-\")"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[11].toInt",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[10].toInt",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[7].toInt",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[6].toInt",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[5].toInt",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[2].toInt",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Invalid month name\")"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onthNames.indexOf",
          "args": [
            "ist[3].toLower())"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[3].toLower",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[4].toInt",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Date regular expression returned weird data (internal error?)\")"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.size",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.capturedTexts",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Date format not recognized\")"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.indexIn",
          "args": [
            "tring)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "onthNames.join(QLatin1String(\"|\")))"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onthNames.join",
          "args": [
            "Latin1String(\"|\"))"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "|\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "^(?:\\\\s*([A-Z][a-z]+)\\\\s*,\\\\s*)?\"   // date-of-week\n                                 \"(\\\\d{1,2})\\\\s+(%1)\\\\s+(\\\\d{2,4})\" // date\n                                 \"\\\\s+(\\\\d{1,2})\\\\s*:(\\\\d{1,2})\\\\s*(?::\\\\s*(\\\\d{1,2})\\\\s*)?\" // time\n                                 \"(\\\\s+(?:(?:([+-]?)(\\\\d{2})(\\\\d{2}))|(UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Za-ik-z])))?\" / timezone"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "dec\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "nov\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "oct\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "sep\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "aug\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "jul\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "jun\")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "may\")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "apr\")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mar\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "feb\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "jan\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nDateTime parseRFC2822DateTime(const QString &string)\n{\n    QStringList monthNames = QStringList() << QLatin1String(\"jan\") << QLatin1String(\"feb\") << QLatin1String(\"mar\")\n                                           << QLatin1String(\"apr\") << QLatin1String(\"may\") << QLatin1String(\"jun\")\n                                           << QLatin1String(\"jul\") << QLatin1String(\"aug\") << QLatin1String(\"sep\")\n                                           << QLatin1String(\"oct\") << QLatin1String(\"nov\") << QLatin1String(\"dec\");\n\n    QRegExp rx(QString::fromUtf8(\"^(?:\\\\s*([A-Z][a-z]+)\\\\s*,\\\\s*)?\"   // date-of-week\n                                 \"(\\\\d{1,2})\\\\s+(%1)\\\\s+(\\\\d{2,4})\" // date\n                                 \"\\\\s+(\\\\d{1,2})\\\\s*:(\\\\d{1,2})\\\\s*(?::\\\\s*(\\\\d{1,2})\\\\s*)?\" // time\n                                 \"(\\\\s+(?:(?:([+-]?)(\\\\d{2})(\\\\d{2}))|(UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Za-ik-z])))?\" // timezone\n                                 ).arg(monthNames.join(QLatin1String(\"|\"))), Qt::CaseInsensitive);\n    int pos = rx.indexIn(string);\n\n    if (pos == -1)\n        throw ParseError(\"Date format not recognized\");\n\n    QStringList list = rx.capturedTexts();\n\n    if (list.size() != 13)\n        throw ParseError(\"Date regular expression returned weird data (internal error?)\");\n\n    int year = list[4].toInt();\n    int month = monthNames.indexOf(list[3].toLower()) + 1;\n    if (month == 0)\n        throw ParseError(\"Invalid month name\");\n    int day = list[2].toInt();\n    int hours = list[5].toInt();\n    int minutes = list[6].toInt();\n    int seconds = list[7].toInt();\n    int shift = list[10].toInt() * 60 + list[11].toInt();\n    if (list[9] == QLatin1String(\"-\"))\n        shift *= 60;\n    else\n        shift *= -60;\n    if (! list[12].isEmpty()) {\n        const QString tz = list[12].toUpper();\n        if (tz == QLatin1String(\"UT\") || tz == QLatin1String(\"GMT\"))\n            shift = 0;\n        else if (tz == QLatin1String(\"EST\"))\n            shift = 5 * 3600;\n        else if (tz == QLatin1String(\"EDT\"))\n            shift = 4 * 3600;\n        else if (tz == QLatin1String(\"CST\"))\n            shift = 6 * 3600;\n        else if (tz == QLatin1String(\"CDT\"))\n            shift = 5 * 3600;\n        else if (tz == QLatin1String(\"MST\"))\n            shift = 7 * 3600;\n        else if (tz == QLatin1String(\"MDT\"))\n            shift = 6 * 3600;\n        else if (tz == QLatin1String(\"PST\"))\n            shift = 8 * 3600;\n        else if (tz == QLatin1String(\"PDT\"))\n            shift = 7 * 3600;\n        else if (tz.size() == 1)\n            shift = 0;\n        else\n            throw ParseError(\"Invalid TZ specification\");\n    }\n\n    QDateTime date(QDate(year, month, day), QTime(hours, minutes, seconds), Qt::UTC);\n    date = date.addSecs(shift);\n\n    return date;\n}"
  },
  {
    "function_name": "etSequence(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "344-389",
    "snippet": "List<uint> getSequence(const QByteArray &line, int &start)\n{\n    uint num = LowLevelParser::getUInt(line, start);\n    if (start >= line.size() - 2) {\n        // It's definitely just a number because there's no more data in here\n        return QList<uint>() << num;\n    } else {\n        QList<uint> numbers;\n        numbers << num;\n\n        enum {COMMA, RANGE} currentType = COMMA;\n\n        // Try to find further items in the sequence set\n        while (line[start] == ':' || line[start] == ',') {\n            // it's a sequence set\n\n            if (line[start] == ':') {\n                if (currentType == RANGE) {\n                    // Now \"x:y:z\" is a funny syntax\n                    throw UnexpectedHere(\"Sequence set: range cannot me defined by three numbers\", line, start);\n                }\n                currentType = RANGE;\n            } else {\n                currentType = COMMA;\n            }\n\n            ++start;\n            if (start >= line.size() - 2) throw NoData(\"Truncated sequence set\", line, start);\n\n            uint num = LowLevelParser::getUInt(line, start);\n            if (currentType == COMMA) {\n                // just adding one more to the set\n                numbers << num;\n            } else {\n                // working with a range\n                if (numbers.last() >= num)\n                    throw UnexpectedHere(\"Sequence set contains an invalid range. \"\n                                         \"First item of a range must always be smaller than the second item.\", line, start);\n\n                for (uint i = numbers.last() + 1; i <= num; ++i)\n                    numbers << i;\n            }\n        }\n        return numbers;\n    }\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umbers.last",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "Sequence set contains an invalid range. \"\n                                         \"First item of a range must always be smaller than the second item.\",",
            "ine,",
            "tart)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umbers.last",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getUInt(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "Truncated sequence set\",",
            "ine,",
            "tart)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "Sequence set: range cannot me defined by three numbers\",",
            "ine,",
            "tart)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<uint>",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "toList(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "81-103",
          "snippet": "List<uint> Sequence::toList() const\n{\n    switch (kind) {\n    case DISTINCT:\n        Q_ASSERT(!list.isEmpty());\n        return list;\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi) {\n            return QList<uint>() << lo;\n        } else {\n            QList<uint> res;\n            for (uint i = lo; i < hi; ++i)\n                res << i;\n            return res;\n        }\n    case UNLIMITED:\n        Q_ASSERT(false);\n        return QList<uint>();\n    }\n    Q_ASSERT(false);\n    return QList<uint>();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  List<uint> Sequence::toList() const\n  {\n      switch (kind) {\n      case DISTINCT:\n          Q_ASSERT(!list.isEmpty());\n          return list;\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi) {\n              return QList<uint>() << lo;\n          } else {\n              QList<uint> res;\n              for (uint i = lo; i < hi; ++i)\n                  res << i;\n              return res;\n          }\n      case UNLIMITED:\n          Q_ASSERT(false);\n          return QList<uint>();\n      }\n      Q_ASSERT(false);\n      return QList<uint>();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getUInt(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nList<uint> getSequence(const QByteArray &line, int &start)\n{\n    uint num = LowLevelParser::getUInt(line, start);\n    if (start >= line.size() - 2) {\n        // It's definitely just a number because there's no more data in here\n        return QList<uint>() << num;\n    } else {\n        QList<uint> numbers;\n        numbers << num;\n\n        enum {COMMA, RANGE} currentType = COMMA;\n\n        // Try to find further items in the sequence set\n        while (line[start] == ':' || line[start] == ',') {\n            // it's a sequence set\n\n            if (line[start] == ':') {\n                if (currentType == RANGE) {\n                    // Now \"x:y:z\" is a funny syntax\n                    throw UnexpectedHere(\"Sequence set: range cannot me defined by three numbers\", line, start);\n                }\n                currentType = RANGE;\n            } else {\n                currentType = COMMA;\n            }\n\n            ++start;\n            if (start >= line.size() - 2) throw NoData(\"Truncated sequence set\", line, start);\n\n            uint num = LowLevelParser::getUInt(line, start);\n            if (currentType == COMMA) {\n                // just adding one more to the set\n                numbers << num;\n            } else {\n                // working with a range\n                if (numbers.last() >= num)\n                    throw UnexpectedHere(\"Sequence set contains an invalid range. \"\n                                         \"First item of a range must always be smaller than the second item.\", line, start);\n\n                for (uint i = numbers.last() + 1; i <= num; ++i)\n                    numbers << i;\n            }\n        }\n        return numbers;\n    }\n}"
  },
  {
    "function_name": "etAnything(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "286-342",
    "snippet": "Variant getAnything(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAnything: no data\", line, start);\n\n    if (line[start] == '[') {\n        QVariant res = parseList('[', ']', line, start);\n        return res;\n    } else if (line[start] == '(') {\n        QVariant res = parseList('(', ')', line, start);\n        return res;\n    } else if (line[start] == '\"' || line[start] == '{' || line[start] == '~') {\n        QPair<QByteArray,ParsedAs> res = getString(line, start);\n        return res.first;\n    } else if (startsWithNil(line, start)) {\n        start += 3;\n        return QByteArray();\n    } else if (line[start] == '\\\\') {\n        // valid for \"flag\"\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"getAnything: backslash-nothing is invalid\", line, start);\n        if (line[start] == '*') {\n            ++start;\n            return QByteArray(\"\\\\*\");\n        }\n        return QByteArray(1, '\\\\') + getAtom(line, start);\n    } else if (line[start] >= '0' && line[start] <= '9') {\n        quint64 res = getUInt64(line, start);\n        if (res <= std::numeric_limits<quint32>::max())\n            return static_cast<quint32>(res);\n        else\n            return res;\n    } else {\n        QByteArray atom = getAtom(line, start);\n        if (atom.indexOf('[', 0) != -1) {\n            // \"BODY[something]\" -- there's no whitespace between \"[\" and\n            // next atom...\n            int pos = line.indexOf(']', start);\n            if (pos == -1)\n                throw ParseError(\"getAnything: can't find ']' for the '['\", line, start);\n            ++pos;\n            atom += line.mid(start, pos - start);\n            start = pos;\n            if (start < line.size() && line[start] == '<') {\n                // Let's check if it continues with \"<range>\"\n                pos = line.indexOf('>', start);\n                if (pos == -1)\n                    throw ParseError(\"getAnything: can't find proper <range>\", line, start);\n                ++pos;\n                atom += line.mid(start, pos - start);\n                start = pos;\n            }\n        }\n        return atom;\n    }\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart,",
            "os - start)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getAnything: can't find proper <range>\",",
            "ine,",
            "tart)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.indexOf",
          "args": [
            ">',",
            "tart)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart,",
            "os - start)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getAnything: can't find ']' for the '['\",",
            "ine,",
            "tart)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.indexOf",
          "args": [
            "]',",
            "tart)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tom.indexOf",
          "args": [
            "[',",
            ")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAtom(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "etAtom(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "109-127",
          "snippet": "ByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<quint32>",
          "args": [
            "es)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::numeric_limits<quint32>::max(",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etUInt64(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "etUInt64(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "76-79",
          "snippet": "uint64 getUInt64(const QByteArray &line, int &start)\n{\n    return extractNumber<quint64>(line, start);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nuint64 getUInt64(const QByteArray &line, int &start)\n{\n    return extractNumber<quint64>(line, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            ",",
            "\\\\')"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "\\\\*\")"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getAnything: backslash-nothing is invalid\",",
            "ine,",
            "tart)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tartsWithNil(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "tartsWithNil(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "88-107",
          "snippet": "ool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "etString(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "etString(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "153-217",
          "snippet": "Pair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arseList(",
          "args": [
            "(',",
            ")',",
            "ine,",
            "tart)"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "arseList(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "250-284",
          "snippet": "VariantList parseList(const char open, const char close, const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"Could not parse list: no more data\", line, start);\n\n    if (line[start] == open) {\n        // found the opening parenthesis\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"Could not parse list: just the opening bracket\", line, start);\n\n        QVariantList res;\n        if (line[start] == close) {\n            ++start;\n            return res;\n        }\n        while (line[start] != close) {\n            // We want to be benevolent here and eat extra whitespace\n            eatSpaces(line, start);\n            res.append(getAnything(line, start));\n            if (start >= line.size())\n                throw NoData(\"Could not parse list: truncated data\", line, start);\n            // Eat whitespace after each token, too\n            eatSpaces(line, start);\n            if (line[start] == close) {\n                ++start;\n                return res;\n            }\n        }\n        return res;\n    } else {\n        throw UnexpectedHere(std::string(\"Could not parse list: expected a list enclosed in \")\n                             + open + close + \", but got something else instead\", line, start);\n    }\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nVariantList parseList(const char open, const char close, const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"Could not parse list: no more data\", line, start);\n\n    if (line[start] == open) {\n        // found the opening parenthesis\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"Could not parse list: just the opening bracket\", line, start);\n\n        QVariantList res;\n        if (line[start] == close) {\n            ++start;\n            return res;\n        }\n        while (line[start] != close) {\n            // We want to be benevolent here and eat extra whitespace\n            eatSpaces(line, start);\n            res.append(getAnything(line, start));\n            if (start >= line.size())\n                throw NoData(\"Could not parse list: truncated data\", line, start);\n            // Eat whitespace after each token, too\n            eatSpaces(line, start);\n            if (line[start] == close) {\n                ++start;\n                return res;\n            }\n        }\n        return res;\n    } else {\n        throw UnexpectedHere(std::string(\"Could not parse list: expected a list enclosed in \")\n                             + open + close + \", but got something else instead\", line, start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getAnything: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nVariant getAnything(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAnything: no data\", line, start);\n\n    if (line[start] == '[') {\n        QVariant res = parseList('[', ']', line, start);\n        return res;\n    } else if (line[start] == '(') {\n        QVariant res = parseList('(', ')', line, start);\n        return res;\n    } else if (line[start] == '\"' || line[start] == '{' || line[start] == '~') {\n        QPair<QByteArray,ParsedAs> res = getString(line, start);\n        return res.first;\n    } else if (startsWithNil(line, start)) {\n        start += 3;\n        return QByteArray();\n    } else if (line[start] == '\\\\') {\n        // valid for \"flag\"\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"getAnything: backslash-nothing is invalid\", line, start);\n        if (line[start] == '*') {\n            ++start;\n            return QByteArray(\"\\\\*\");\n        }\n        return QByteArray(1, '\\\\') + getAtom(line, start);\n    } else if (line[start] >= '0' && line[start] <= '9') {\n        quint64 res = getUInt64(line, start);\n        if (res <= std::numeric_limits<quint32>::max())\n            return static_cast<quint32>(res);\n        else\n            return res;\n    } else {\n        QByteArray atom = getAtom(line, start);\n        if (atom.indexOf('[', 0) != -1) {\n            // \"BODY[something]\" -- there's no whitespace between \"[\" and\n            // next atom...\n            int pos = line.indexOf(']', start);\n            if (pos == -1)\n                throw ParseError(\"getAnything: can't find ']' for the '['\", line, start);\n            ++pos;\n            atom += line.mid(start, pos - start);\n            start = pos;\n            if (start < line.size() && line[start] == '<') {\n                // Let's check if it continues with \"<range>\"\n                pos = line.indexOf('>', start);\n                if (pos == -1)\n                    throw ParseError(\"getAnything: can't find proper <range>\", line, start);\n                ++pos;\n                atom += line.mid(start, pos - start);\n                start = pos;\n            }\n        }\n        return atom;\n    }\n}"
  },
  {
    "function_name": "arseList(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "250-284",
    "snippet": "VariantList parseList(const char open, const char close, const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"Could not parse list: no more data\", line, start);\n\n    if (line[start] == open) {\n        // found the opening parenthesis\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"Could not parse list: just the opening bracket\", line, start);\n\n        QVariantList res;\n        if (line[start] == close) {\n            ++start;\n            return res;\n        }\n        while (line[start] != close) {\n            // We want to be benevolent here and eat extra whitespace\n            eatSpaces(line, start);\n            res.append(getAnything(line, start));\n            if (start >= line.size())\n                throw NoData(\"Could not parse list: truncated data\", line, start);\n            // Eat whitespace after each token, too\n            eatSpaces(line, start);\n            if (line[start] == close) {\n                ++start;\n                return res;\n            }\n        }\n        return res;\n    } else {\n        throw UnexpectedHere(std::string(\"Could not parse list: expected a list enclosed in \")\n                             + open + close + \", but got something else instead\", line, start);\n    }\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "td::string(\"Could not parse list: expected a list enclosed in \")\n                             + open + close + \", but got something else instead\",",
            "ine,",
            "tart)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::string(",
          "args": [
            "Could not parse list: expected a list enclosed in \")"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atSpaces(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "atSpaces(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "458-462",
          "snippet": "oid eatSpaces(const QByteArray &line, int &start)\n{\n    while (line.size() > start && line[start] == ' ')\n        ++start;\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\noid eatSpaces(const QByteArray &line, int &start)\n{\n    while (line.size() > start && line[start] == ' ')\n        ++start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "Could not parse list: truncated data\",",
            "ine,",
            "tart)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.append",
          "args": [
            "etAnything(line, start))"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAnything(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "etAnything(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "286-342",
          "snippet": "Variant getAnything(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAnything: no data\", line, start);\n\n    if (line[start] == '[') {\n        QVariant res = parseList('[', ']', line, start);\n        return res;\n    } else if (line[start] == '(') {\n        QVariant res = parseList('(', ')', line, start);\n        return res;\n    } else if (line[start] == '\"' || line[start] == '{' || line[start] == '~') {\n        QPair<QByteArray,ParsedAs> res = getString(line, start);\n        return res.first;\n    } else if (startsWithNil(line, start)) {\n        start += 3;\n        return QByteArray();\n    } else if (line[start] == '\\\\') {\n        // valid for \"flag\"\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"getAnything: backslash-nothing is invalid\", line, start);\n        if (line[start] == '*') {\n            ++start;\n            return QByteArray(\"\\\\*\");\n        }\n        return QByteArray(1, '\\\\') + getAtom(line, start);\n    } else if (line[start] >= '0' && line[start] <= '9') {\n        quint64 res = getUInt64(line, start);\n        if (res <= std::numeric_limits<quint32>::max())\n            return static_cast<quint32>(res);\n        else\n            return res;\n    } else {\n        QByteArray atom = getAtom(line, start);\n        if (atom.indexOf('[', 0) != -1) {\n            // \"BODY[something]\" -- there's no whitespace between \"[\" and\n            // next atom...\n            int pos = line.indexOf(']', start);\n            if (pos == -1)\n                throw ParseError(\"getAnything: can't find ']' for the '['\", line, start);\n            ++pos;\n            atom += line.mid(start, pos - start);\n            start = pos;\n            if (start < line.size() && line[start] == '<') {\n                // Let's check if it continues with \"<range>\"\n                pos = line.indexOf('>', start);\n                if (pos == -1)\n                    throw ParseError(\"getAnything: can't find proper <range>\", line, start);\n                ++pos;\n                atom += line.mid(start, pos - start);\n                start = pos;\n            }\n        }\n        return atom;\n    }\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nVariant getAnything(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAnything: no data\", line, start);\n\n    if (line[start] == '[') {\n        QVariant res = parseList('[', ']', line, start);\n        return res;\n    } else if (line[start] == '(') {\n        QVariant res = parseList('(', ')', line, start);\n        return res;\n    } else if (line[start] == '\"' || line[start] == '{' || line[start] == '~') {\n        QPair<QByteArray,ParsedAs> res = getString(line, start);\n        return res.first;\n    } else if (startsWithNil(line, start)) {\n        start += 3;\n        return QByteArray();\n    } else if (line[start] == '\\\\') {\n        // valid for \"flag\"\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"getAnything: backslash-nothing is invalid\", line, start);\n        if (line[start] == '*') {\n            ++start;\n            return QByteArray(\"\\\\*\");\n        }\n        return QByteArray(1, '\\\\') + getAtom(line, start);\n    } else if (line[start] >= '0' && line[start] <= '9') {\n        quint64 res = getUInt64(line, start);\n        if (res <= std::numeric_limits<quint32>::max())\n            return static_cast<quint32>(res);\n        else\n            return res;\n    } else {\n        QByteArray atom = getAtom(line, start);\n        if (atom.indexOf('[', 0) != -1) {\n            // \"BODY[something]\" -- there's no whitespace between \"[\" and\n            // next atom...\n            int pos = line.indexOf(']', start);\n            if (pos == -1)\n                throw ParseError(\"getAnything: can't find ']' for the '['\", line, start);\n            ++pos;\n            atom += line.mid(start, pos - start);\n            start = pos;\n            if (start < line.size() && line[start] == '<') {\n                // Let's check if it continues with \"<range>\"\n                pos = line.indexOf('>', start);\n                if (pos == -1)\n                    throw ParseError(\"getAnything: can't find proper <range>\", line, start);\n                ++pos;\n                atom += line.mid(start, pos - start);\n                start = pos;\n            }\n        }\n        return atom;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "Could not parse list: just the opening bracket\",",
            "ine,",
            "tart)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "Could not parse list: no more data\",",
            "ine,",
            "tart)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nVariantList parseList(const char open, const char close, const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"Could not parse list: no more data\", line, start);\n\n    if (line[start] == open) {\n        // found the opening parenthesis\n        ++start;\n        if (start >= line.size())\n            throw NoData(\"Could not parse list: just the opening bracket\", line, start);\n\n        QVariantList res;\n        if (line[start] == close) {\n            ++start;\n            return res;\n        }\n        while (line[start] != close) {\n            // We want to be benevolent here and eat extra whitespace\n            eatSpaces(line, start);\n            res.append(getAnything(line, start));\n            if (start >= line.size())\n                throw NoData(\"Could not parse list: truncated data\", line, start);\n            // Eat whitespace after each token, too\n            eatSpaces(line, start);\n            if (line[start] == close) {\n                ++start;\n                return res;\n            }\n        }\n        return res;\n    } else {\n        throw UnexpectedHere(std::string(\"Could not parse list: expected a list enclosed in \")\n                             + open + close + \", but got something else instead\", line, start);\n    }\n}"
  },
  {
    "function_name": "etMailbox(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "240-248",
    "snippet": "String getMailbox(const QByteArray &line, int &start)\n{\n    QPair<QByteArray,ParsedAs> r = getAString(line, start);\n    if (r.first.toUpper() == \"INBOX\")\n        return QLatin1String(\"INBOX\");\n    else\n        return decodeImapFolderName(r.first);\n\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecodeImapFolderName(",
          "args": [
            ".first)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "382-385",
          "snippet": "String decodeImapFolderName( const QByteArray& raw )\n{\n    return KIMAP::decodeImapFolderName( raw );\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeImapFolderName( const QByteArray& raw )\n{\n    return KIMAP::decodeImapFolderName( raw );\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INBOX\")"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".first.toUpper",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAString(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "etAString(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "219-228",
          "snippet": "Pair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nString getMailbox(const QByteArray &line, int &start)\n{\n    QPair<QByteArray,ParsedAs> r = getAString(line, start);\n    if (r.first.toUpper() == \"INBOX\")\n        return QLatin1String(\"INBOX\");\n    else\n        return decodeImapFolderName(r.first);\n\n}"
  },
  {
    "function_name": "etNString(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "230-238",
    "snippet": "Pair<QByteArray,ParsedAs> getNString(const QByteArray &line, int &start)\n{\n    if (startsWithNil(line, start)) {\n        start += 3;\n        return qMakePair<>(QByteArray(), NIL);\n    } else {\n        return getAString(line, start);\n    }\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etAString(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "etAString(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "219-228",
          "snippet": "Pair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakePair<>",
          "args": [
            "ByteArray(),",
            "IL)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tartsWithNil(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "tartsWithNil(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "88-107",
          "snippet": "ool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getNString(const QByteArray &line, int &start)\n{\n    if (startsWithNil(line, start)) {\n        start += 3;\n        return qMakePair<>(QByteArray(), NIL);\n    } else {\n        return getAString(line, start);\n    }\n}"
  },
  {
    "function_name": "etAString(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "219-228",
    "snippet": "Pair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "etAtom(line, start),",
            "TOM)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAtom(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "etAtom(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "109-127",
          "snippet": "ByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "etString(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "etString(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "153-217",
          "snippet": "Pair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getAString: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getAString(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"getAString: no data\", line, start);\n\n    if (line[start] == '{' || line[start] == '\"' || line[start] == '~')\n        return getString(line, start);\n    else\n        return qMakePair(getAtom(line, start), ATOM);\n}"
  },
  {
    "function_name": "etString(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "153-217",
    "snippet": "Pair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "getString: did not get quoted string or literal\",",
            "ine,",
            "tart)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ine.mid(old, size),",
            "ITERAL8)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "ld,",
            "ize)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getString: literal8: run out of data\",",
            "ine,",
            "tart)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getString: malformed literal8 specification\",",
            "ine,",
            "tart)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart,",
            ")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etUInt(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "etUInt(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "71-74",
          "snippet": "int getUInt(const QByteArray &line, int &start)\n{\n    return extractNumber<uint>(line, start);\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nint getUInt(const QByteArray &line, int &start)\n{\n    return extractNumber<uint>(line, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ine.mid(old, size),",
            "ITERAL)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "ld,",
            "ize)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getString: run out of data\",",
            "ine,",
            "tart)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getString: malformed literal specification\",",
            "ine,",
            "tart)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart,",
            ")"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "es,",
            "UOTED)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getString: unterminated quoted string\",",
            "ine,",
            "tart)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.append",
          "args": [
            "ine[start])"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getString: premature end of quoted string\",",
            "ine,",
            "tart)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "getString: escaping invalid character\",",
            "ine,",
            "tart)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.append",
          "args": [
            "ine[start])"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getString: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nPair<QByteArray,ParsedAs> getString(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getString: no data\", line, start);\n\n    if (line[start] == '\"') {\n        // quoted string\n        ++start;\n        bool escaping = false;\n        QByteArray res;\n        bool terminated = false;\n        while (start != line.size() && !terminated) {\n            if (escaping) {\n                escaping = false;\n                if (line[start] == '\"' || line[start] == '\\\\')\n                    res.append(line[start]);\n                else\n                    throw UnexpectedHere(\"getString: escaping invalid character\", line, start);\n            } else {\n                switch (line[start]) {\n                case '\"':\n                    terminated = true;\n                    break;\n                case '\\\\':\n                    escaping = true;\n                    break;\n                case '\\r': case '\\n':\n                    throw ParseError(\"getString: premature end of quoted string\", line, start);\n                default:\n                    res.append(line[start]);\n                }\n            }\n            ++start;\n        }\n        if (!terminated)\n            throw NoData(\"getString: unterminated quoted string\", line, start);\n        return qMakePair(res, QUOTED);\n    } else if (line[start] == '{') {\n        // literal\n        ++start;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL);\n    } else if (start < line.size() - 3 && line[start] == '~' && line[start + 1] == '{' ) {\n        // literal8\n        start += 2;\n        int size = getUInt(line, start);\n        if (line.mid(start, 3) != \"}\\r\\n\")\n            throw ParseError(\"getString: malformed literal8 specification\", line, start);\n        start += 3;\n        if (start + size > line.size())\n            throw NoData(\"getString: literal8: run out of data\", line, start);\n        int old(start);\n        start += size;\n        return qMakePair(line.mid(old, size), LITERAL8);\n    } else {\n        throw UnexpectedHere(\"getString: did not get quoted string or literal\", line, start);\n    }\n}"
  },
  {
    "function_name": "etPossiblyBackslashedAtom(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "130-151",
    "snippet": "ByteArray getPossiblyBackslashedAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getPossiblyBackslashedAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    if (*c_str == '\\\\')\n        ++c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getPossiblyBackslashedAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "ld_str,",
            "ize)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getPossiblyBackslashedAtom: did not read anything\",",
            "ine,",
            "tart)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getPossiblyBackslashedAtom: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nByteArray getPossiblyBackslashedAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getPossiblyBackslashedAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    if (*c_str == '\\\\')\n        ++c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getPossiblyBackslashedAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}"
  },
  {
    "function_name": "etAtom(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "109-127",
    "snippet": "ByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "ld_str,",
            "ize)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "getAtom: did not read anything\",",
            "ine,",
            "tart)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "getAtom: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nByteArray getAtom(const QByteArray &line, int &start)\n{\n    if (start == line.size())\n        throw NoData(\"getAtom: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n    const char * const old_str = c_str;\n\n    while (C_STR_CHECK_FOR_ATOM_CHARS) {\n        ++c_str;\n    }\n\n    auto size = c_str - old_str;\n    if (!size)\n        throw ParseError(\"getAtom: did not read anything\", line, start);\n    start += size;\n    return QByteArray(old_str, size);\n}"
  },
  {
    "function_name": "tartsWithNil(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "88-107",
    "snippet": "ool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nool startsWithNil(const QByteArray &line, int start)\n{\n    const char *c_str = line.constData();\n    c_str += start;\n    // Case-insensitive NIL. We cannot use strncasecmp because that function respects locale settings which\n    // is absolutely not something we want to do here.\n    if (!(start <= line.size() + 3 && (*c_str == 'N' || *c_str == 'n') && (*(c_str+1) == 'I' || *(c_str+1) == 'i')\n            && (*(c_str+2) == 'L' || *(c_str+2) == 'l'))) {\n        return false;\n    }\n    // At this point we know that it starts with a NIL. To prevent parsing ambiguity with atoms, we have to\n    // check the next character.\n    c_str += 3;\n    // That macro already checks for NULL bytes and the input is guaranteed to be null-terminated, so we're safe here\n    if (C_STR_CHECK_FOR_ATOM_CHARS) {\n        // The next character is apparently a valid atom-char, so this cannot possibly be a NIL\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "etUInt64(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "76-79",
    "snippet": "uint64 getUInt64(const QByteArray &line, int &start)\n{\n    return extractNumber<quint64>(line, start);\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtractNumber<quint64>",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "xtractNumber(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "37-69",
          "snippet": "extractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nextractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nuint64 getUInt64(const QByteArray &line, int &start)\n{\n    return extractNumber<quint64>(line, start);\n}"
  },
  {
    "function_name": "etUInt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "71-74",
    "snippet": "int getUInt(const QByteArray &line, int &start)\n{\n    return extractNumber<uint>(line, start);\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtractNumber<uint>",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xtractNumber(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "37-69",
          "snippet": "extractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nextractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nint getUInt(const QByteArray &line, int &start)\n{\n    return extractNumber<uint>(line, start);\n}"
  },
  {
    "function_name": "xtractNumber(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
    "lines": "37-69",
    "snippet": "extractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}",
    "includes": [
      "include \"Imap/Encoders.h\"",
      "include \"../Exceptions.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include <QDateTime>\n#",
      "include <QVariant>\n#",
      "include <QStringList>\n#",
      "include <QPair>\n#",
      "include <limits>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "extractNumber: out of range\",",
            "ine,",
            "tart)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "extractNumber: out of range\",",
            "ine,",
            "tart)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::numeric_limits<T>::max(",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "extractNumber: not a number\",",
            "ine,",
            "tart)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "extractNumber: no data\",",
            "ine,",
            "tart)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nextractNumber(const QByteArray &line, int &start)\n{\n    if (start >= line.size())\n        throw NoData(\"extractNumber: no data\", line, start);\n\n    const char *c_str = line.constData();\n    c_str += start;\n\n    if (*c_str < '0' || *c_str > '9')\n        throw ParseError(\"extractNumber: not a number\", line, start);\n\n    T res = 0;\n    // well, it's an inline function, but clang still won't cache its result by default\n    const T absoluteMax = std::numeric_limits<T>::max();\n    const T softLimit = (absoluteMax - 10) / 10;\n    while (*c_str >= '0' && *c_str <= '9') {\n        auto digit = *c_str - '0';\n        if (res <= softLimit) {\n            res *= 10;\n            res += digit;\n        } else {\n            if (res > absoluteMax / 10)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res *= 10;\n            if (res > absoluteMax - digit)\n                throw ParseError(\"extractNumber: out of range\", line, start);\n            res += digit;\n        }\n        ++c_str;\n        ++start;\n    }\n    return res;\n}"
  }
]