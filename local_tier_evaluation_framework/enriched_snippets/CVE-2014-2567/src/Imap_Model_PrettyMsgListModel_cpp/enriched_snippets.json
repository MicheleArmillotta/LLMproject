[
  {
    "function_name": "sort(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "248-292",
    "snippet": "oid PrettyMsgListModel::sort(int column, Qt::SortOrder order)\n{\n    ThreadingMsgListModel *threadingModel = qobject_cast<ThreadingMsgListModel*>(sourceModel());\n    Q_ASSERT(threadingModel);\n\n    ThreadingMsgListModel::SortCriterium criterium = ThreadingMsgListModel::SORT_NONE;\n    switch (column) {\n    case MsgListModel::SEEN:\n    case MsgListModel::COLUMN_COUNT:\n    case MsgListModel::BCC:\n    case -1:\n        criterium = ThreadingMsgListModel::SORT_NONE;\n        break;\n    case MsgListModel::SUBJECT:\n        criterium = ThreadingMsgListModel::SORT_SUBJECT;\n        break;\n    case MsgListModel::FROM:\n        criterium = ThreadingMsgListModel::SORT_FROM;\n        break;\n    case MsgListModel::TO:\n        criterium = ThreadingMsgListModel::SORT_TO;\n        break;\n    case MsgListModel::CC:\n        criterium = ThreadingMsgListModel::SORT_CC;\n        break;\n    case MsgListModel::DATE:\n        criterium = ThreadingMsgListModel::SORT_DATE;\n        break;\n    case MsgListModel::RECEIVED_DATE:\n        criterium = ThreadingMsgListModel::SORT_ARRIVAL;\n        break;\n    case MsgListModel::SIZE:\n        criterium = ThreadingMsgListModel::SORT_SIZE;\n        break;\n    }\n\n    bool willSort = threadingModel->setUserSearchingSortingPreference(threadingModel->currentSearchCondition(), criterium, order);\n\n    // Now let the view know about whether we accept such a sorting criteria.\n    // This is needed because the QHeaderView doesn't offer a way to say \"hey, you cannot sort in columns XYZ, only on ABC\".\n    if (criterium != ThreadingMsgListModel::SORT_NONE && willSort)\n        emit sortingPreferenceChanged(column, order);\n    else\n        emit sortingPreferenceChanged(-1, order);\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ortingPreferenceChanged(",
          "args": [
            "1,",
            "rder)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortingPreferenceChanged(",
          "args": [
            "olumn,",
            "rder)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadingModel->setUserSearchingSortingPreference",
          "args": [
            "hreadingModel->currentSearchCondition(),",
            "riterium,",
            "rder)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadingModel->currentSearchCondition",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hreadingModel)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<ThreadingMsgListModel*>",
          "args": [
            "ourceModel())"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  oid PrettyMsgListModel::sort(int column, Qt::SortOrder order)\n  {\n      ThreadingMsgListModel *threadingModel = qobject_cast<ThreadingMsgListModel*>(sourceModel());\n      Q_ASSERT(threadingModel);\n  \n      ThreadingMsgListModel::SortCriterium criterium = ThreadingMsgListModel::SORT_NONE;\n      switch (column) {\n      case MsgListModel::SEEN:\n      case MsgListModel::COLUMN_COUNT:\n      case MsgListModel::BCC:\n      case -1:\n          criterium = ThreadingMsgListModel::SORT_NONE;\n          break;\n      case MsgListModel::SUBJECT:\n          criterium = ThreadingMsgListModel::SORT_SUBJECT;\n          break;\n      case MsgListModel::FROM:\n          criterium = ThreadingMsgListModel::SORT_FROM;\n          break;\n      case MsgListModel::TO:\n          criterium = ThreadingMsgListModel::SORT_TO;\n          break;\n      case MsgListModel::CC:\n          criterium = ThreadingMsgListModel::SORT_CC;\n          break;\n      case MsgListModel::DATE:\n          criterium = ThreadingMsgListModel::SORT_DATE;\n          break;\n      case MsgListModel::RECEIVED_DATE:\n          criterium = ThreadingMsgListModel::SORT_ARRIVAL;\n          break;\n      case MsgListModel::SIZE:\n          criterium = ThreadingMsgListModel::SORT_SIZE;\n          break;\n      }\n  \n      bool willSort = threadingModel->setUserSearchingSortingPreference(threadingModel->currentSearchCondition(), criterium, order);\n  \n      // Now let the view know about whether we accept such a sorting criteria.\n      // This is needed because the QHeaderView doesn't offer a way to say \"hey, you cannot sort in columns XYZ, only on ABC\".\n      if (criterium != ThreadingMsgListModel::SORT_NONE && willSort)\n          emit sortingPreferenceChanged(column, order);\n      else\n          emit sortingPreferenceChanged(-1, order);\n  }\n}"
  },
  {
    "function_name": "filterAcceptsRow(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "233-245",
    "snippet": "ool PrettyMsgListModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n{\n    if (!m_hideRead)\n        return true;\n\n    QModelIndex source_index = sourceModel()->index(source_row, 0, source_parent);\n\n    for (QModelIndex test = source_index; test.isValid(); test = test.parent())\n        if (test.data(RoleThreadRootWithUnreadMessages).toBool() || test.data(RoleMessageWasUnread).toBool())\n            return true;\n\n    return false;\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "est.data",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "est.data",
          "args": [
            "oleMessageWasUnread)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est.data",
          "args": [
            "oleThreadRootWithUnreadMessages)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est.parent",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "est.isValid",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            "ource_row,",
            ",",
            "ource_parent)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  ool PrettyMsgListModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n  {\n      if (!m_hideRead)\n          return true;\n  \n      QModelIndex source_index = sourceModel()->index(source_row, 0, source_parent);\n  \n      for (QModelIndex test = source_index; test.isValid(); test = test.parent())\n          if (test.data(RoleThreadRootWithUnreadMessages).toBool() || test.data(RoleMessageWasUnread).toBool())\n              return true;\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "setHideRead(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "227-231",
    "snippet": "oid PrettyMsgListModel::setHideRead(bool value)\n{\n    m_hideRead = value;\n    invalidateFilter();\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvalidateFilter(",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  oid PrettyMsgListModel::setHideRead(bool value)\n  {\n      m_hideRead = value;\n      invalidateFilter();\n  }\n}"
  },
  {
    "function_name": "prettyFormatDate(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "193-225",
    "snippet": "String PrettyMsgListModel::prettyFormatDate(const QDateTime &dateTime) const\n{\n    // The time is not always synced properly, so better accept even slightly too new messages as \"from today\"\n    QDateTime now = QDateTime::currentDateTime().addSecs(15*60);\n    if (dateTime >= now) {\n        // Messages from future shall always be shown using full format to prevent nasty surprises.\n        return dateTime.toString(Qt::DefaultLocaleShortDate);\n    } else if (dateTime.date() == now.date() || dateTime > now.addSecs(-6 * 3600)) {\n        // It's a \"today's message\", i.e. something which is either literally from today or at least something not older than\n        // six hours (an arbitraty magic number).\n        // Originally, the cut-off time interval was set to 24 hours, but it led to weird things in the GUI like showing mails\n        // from yesterday's 18:33 just as \"18:33\" even though the local time was \"18:20\" already. In a perfect world, we would\n        // also periodically emit dataChanged() in order to force a wrap once the view has been open for too long, but that will\n        // have to wait a bit.\n        // The time is displayed without seconds to conserve space as well.\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.time().toString(tr(\"hh:mm\"));\n    } else if (dateTime > now.addDays(-7)) {\n        // Messages from the last seven days can be formatted just with the weekday name\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.toString(tr(\"ddd hh:mm\"));\n    } else if (dateTime > now.addYears(-1)) {\n        // Messages newer than one year don't have to show year\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.toString(tr(\"d MMM hh:mm\"));\n    } else {\n        // Old messagees shall have a full date\n        return dateTime.toString(Qt::DefaultLocaleShortDate);\n    }\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ateTime.toString",
          "args": [
            "t::DefaultLocaleShortDate)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.toString",
          "args": [
            "r(\"d MMM hh:mm\"))"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "d MMM hh:mm\")"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ow.addYears",
          "args": [
            "1)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.toString",
          "args": [
            "r(\"ddd hh:mm\"))"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ow.addDays",
          "args": [
            "7)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.time",
          "args": [
            "r(\"hh:mm\"))"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.time",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ow.addSecs",
          "args": [
            "6 * 3600)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ow.date",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.date",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ateTime.toString",
          "args": [
            "t::DefaultLocaleShortDate)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTime::currentDateTime",
          "args": [
            "5*60)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTime::currentDateTime(",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  String PrettyMsgListModel::prettyFormatDate(const QDateTime &dateTime) const\n  {\n      // The time is not always synced properly, so better accept even slightly too new messages as \"from today\"\n      QDateTime now = QDateTime::currentDateTime().addSecs(15*60);\n      if (dateTime >= now) {\n          // Messages from future shall always be shown using full format to prevent nasty surprises.\n          return dateTime.toString(Qt::DefaultLocaleShortDate);\n      } else if (dateTime.date() == now.date() || dateTime > now.addSecs(-6 * 3600)) {\n          // It's a \"today's message\", i.e. something which is either literally from today or at least something not older than\n          // six hours (an arbitraty magic number).\n          // Originally, the cut-off time interval was set to 24 hours, but it led to weird things in the GUI like showing mails\n          // from yesterday's 18:33 just as \"18:33\" even though the local time was \"18:20\" already. In a perfect world, we would\n          // also periodically emit dataChanged() in order to force a wrap once the view has been open for too long, but that will\n          // have to wait a bit.\n          // The time is displayed without seconds to conserve space as well.\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.time().toString(tr(\"hh:mm\"));\n      } else if (dateTime > now.addDays(-7)) {\n          // Messages from the last seven days can be formatted just with the weekday name\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.toString(tr(\"ddd hh:mm\"));\n      } else if (dateTime > now.addYears(-1)) {\n          // Messages newer than one year don't have to show year\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.toString(tr(\"d MMM hh:mm\"));\n      } else {\n          // Old messagees shall have a full date\n          return dateTime.toString(Qt::DefaultLocaleShortDate);\n      }\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "42-190",
    "snippet": "Variant PrettyMsgListModel::data(const QModelIndex &index, int role) const\n{\n    if (! index.isValid() || index.model() != this)\n        return QVariant();\n\n    if (index.column() < 0 || index.column() >= columnCount(index.parent()))\n        return QVariant();\n\n    if (index.row() < 0 || index.row() >= rowCount(index.parent()))\n        return QVariant();\n\n    QModelIndex translated = mapToSource(index);\n\n    switch (role) {\n\n    case Qt::DisplayRole:\n    case Qt::ToolTipRole:\n        switch (index.column()) {\n        case MsgListModel::TO:\n        case MsgListModel::FROM:\n        case MsgListModel::CC:\n        case MsgListModel::BCC:\n        {\n            int backendRole = 0;\n            switch (index.column()) {\n            case MsgListModel::FROM:\n                backendRole = RoleMessageFrom;\n                break;\n            case MsgListModel::TO:\n                backendRole = RoleMessageTo;\n                break;\n            case MsgListModel::CC:\n                backendRole = RoleMessageCc;\n                break;\n            case MsgListModel::BCC:\n                backendRole = RoleMessageBcc;\n                break;\n            }\n            QVariantList items = translated.data(backendRole).toList();\n            return Imap::Message::MailAddress::prettyList(items, role == Qt::DisplayRole ?\n                    Imap::Message::MailAddress::FORMAT_JUST_NAME :\n                    Imap::Message::MailAddress::FORMAT_READABLE);\n        }\n        case MsgListModel::DATE:\n        case MsgListModel::RECEIVED_DATE:\n        {\n            QDateTime res = translated.data(RoleMessageDate).toDateTime();\n            if (role == Qt::ToolTipRole) {\n                // tooltips shall always show the full and complete data\n                return res.toLocalTime().toString(Qt::DefaultLocaleLongDate);\n            }\n            return prettyFormatDate(res.toLocalTime());\n        }\n        case MsgListModel::SIZE:\n        {\n            QVariant size = translated.data(RoleMessageSize);\n            if (!size.isValid()) {\n                return QVariant();\n            }\n            return PrettySize::prettySize(size.toUInt());\n        }\n        case MsgListModel::SUBJECT:\n        {\n            if (!translated.data(RoleIsFetched).toBool())\n                return tr(\"Loading...\");\n            QString subject = translated.data(RoleMessageSubject).toString();\n            return subject.isEmpty() ? tr(\"(no subject)\") : subject;\n        }\n        }\n        break;\n\n\n    case Qt::TextAlignmentRole:\n        switch (index.column()) {\n        case MsgListModel::SIZE:\n            return Qt::AlignRight;\n        default:\n            return QVariant();\n        }\n\n    case Qt::DecorationRole:\n        // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n        translated.data(RoleMessageSubject);\n\n        switch (index.column()) {\n        case MsgListModel::SUBJECT:\n        {\n            if (! translated.data(RoleIsFetched).toBool())\n                return QVariant();\n\n            bool isForwarded = translated.data(RoleMessageIsMarkedForwarded).toBool();\n            bool isReplied = translated.data(RoleMessageIsMarkedReplied).toBool();\n\n            if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n                return Gui::loadIcon(QLatin1String(\"mail-deleted\"));\n            else if (isForwarded && isReplied)\n                return Gui::loadIcon(QLatin1String(\"mail-replied-forw\"));\n            else if (isReplied)\n                return Gui::loadIcon(QLatin1String(\"mail-replied\"));\n            else if (isForwarded)\n                return Gui::loadIcon(QLatin1String(\"mail-forwarded\"));\n            else if (translated.data(RoleMessageIsMarkedRecent).toBool())\n                return Gui::loadIcon(QLatin1String(\"mail-recent\"));\n            else\n                return QIcon(QLatin1String(\":/icons/transparent.png\"));\n        }\n        case MsgListModel::SEEN:\n            if (! translated.data(RoleIsFetched).toBool())\n                return QVariant();\n            if (! translated.data(RoleMessageIsMarkedRead).toBool())\n                return QIcon(QLatin1String(\":/icons/mail-unread.png\"));\n            else\n                return QIcon(QLatin1String(\":/icons/mail-read.png\"));\n        default:\n            return QVariant();\n        }\n\n    case Qt::FontRole: {\n        // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n        translated.data(RoleMessageSubject);\n\n        // These items should definitely *not* be rendered in bold\n        if (!translated.data(RoleIsFetched).toBool())\n            return QVariant();\n\n        QFont font;\n        if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n            font.setStrikeOut(true);\n\n        if (! translated.data(RoleMessageIsMarkedRead).toBool()) {\n            // If any message is marked as unread, show it in bold and be done with it\n            font.setBold(true);\n        } else if (translated.model()->hasChildren(translated.sibling(translated.row(), 0)) &&\n                   translated.data(RoleThreadRootWithUnreadMessages).toBool()) {\n            // If this node is not marked as read, is a root of some thread and that thread\n            // contains unread messages, display the thread's root underlined\n            font.setUnderline(true);\n        }\n\n        if (index.column() == MsgListModel::SUBJECT && translated.data(RoleMessageSubject).toString().isEmpty()) {\n            font.setItalic(true);\n        }\n\n        return font;\n    }\n    }\n\n    return QSortFilterProxyModel::data(index, role);\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SortFilterProxyModel::data(",
          "args": [
            "ndex,",
            "ole)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "data(",
          "container": "rettyMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
          "lines": "42-190",
          "snippet": "Variant PrettyMsgListModel::data(const QModelIndex &index, int role) const\n{\n    if (! index.isValid() || index.model() != this)\n        return QVariant();\n\n    if (index.column() < 0 || index.column() >= columnCount(index.parent()))\n        return QVariant();\n\n    if (index.row() < 0 || index.row() >= rowCount(index.parent()))\n        return QVariant();\n\n    QModelIndex translated = mapToSource(index);\n\n    switch (role) {\n\n    case Qt::DisplayRole:\n    case Qt::ToolTipRole:\n        switch (index.column()) {\n        case MsgListModel::TO:\n        case MsgListModel::FROM:\n        case MsgListModel::CC:\n        case MsgListModel::BCC:\n        {\n            int backendRole = 0;\n            switch (index.column()) {\n            case MsgListModel::FROM:\n                backendRole = RoleMessageFrom;\n                break;\n            case MsgListModel::TO:\n                backendRole = RoleMessageTo;\n                break;\n            case MsgListModel::CC:\n                backendRole = RoleMessageCc;\n                break;\n            case MsgListModel::BCC:\n                backendRole = RoleMessageBcc;\n                break;\n            }\n            QVariantList items = translated.data(backendRole).toList();\n            return Imap::Message::MailAddress::prettyList(items, role == Qt::DisplayRole ?\n                    Imap::Message::MailAddress::FORMAT_JUST_NAME :\n                    Imap::Message::MailAddress::FORMAT_READABLE);\n        }\n        case MsgListModel::DATE:\n        case MsgListModel::RECEIVED_DATE:\n        {\n            QDateTime res = translated.data(RoleMessageDate).toDateTime();\n            if (role == Qt::ToolTipRole) {\n                // tooltips shall always show the full and complete data\n                return res.toLocalTime().toString(Qt::DefaultLocaleLongDate);\n            }\n            return prettyFormatDate(res.toLocalTime());\n        }\n        case MsgListModel::SIZE:\n        {\n            QVariant size = translated.data(RoleMessageSize);\n            if (!size.isValid()) {\n                return QVariant();\n            }\n            return PrettySize::prettySize(size.toUInt());\n        }\n        case MsgListModel::SUBJECT:\n        {\n            if (!translated.data(RoleIsFetched).toBool())\n                return tr(\"Loading...\");\n            QString subject = translated.data(RoleMessageSubject).toString();\n            return subject.isEmpty() ? tr(\"(no subject)\") : subject;\n        }\n        }\n        break;\n\n\n    case Qt::TextAlignmentRole:\n        switch (index.column()) {\n        case MsgListModel::SIZE:\n            return Qt::AlignRight;\n        default:\n            return QVariant();\n        }\n\n    case Qt::DecorationRole:\n        // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n        translated.data(RoleMessageSubject);\n\n        switch (index.column()) {\n        case MsgListModel::SUBJECT:\n        {\n            if (! translated.data(RoleIsFetched).toBool())\n                return QVariant();\n\n            bool isForwarded = translated.data(RoleMessageIsMarkedForwarded).toBool();\n            bool isReplied = translated.data(RoleMessageIsMarkedReplied).toBool();\n\n            if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n                return Gui::loadIcon(QLatin1String(\"mail-deleted\"));\n            else if (isForwarded && isReplied)\n                return Gui::loadIcon(QLatin1String(\"mail-replied-forw\"));\n            else if (isReplied)\n                return Gui::loadIcon(QLatin1String(\"mail-replied\"));\n            else if (isForwarded)\n                return Gui::loadIcon(QLatin1String(\"mail-forwarded\"));\n            else if (translated.data(RoleMessageIsMarkedRecent).toBool())\n                return Gui::loadIcon(QLatin1String(\"mail-recent\"));\n            else\n                return QIcon(QLatin1String(\":/icons/transparent.png\"));\n        }\n        case MsgListModel::SEEN:\n            if (! translated.data(RoleIsFetched).toBool())\n                return QVariant();\n            if (! translated.data(RoleMessageIsMarkedRead).toBool())\n                return QIcon(QLatin1String(\":/icons/mail-unread.png\"));\n            else\n                return QIcon(QLatin1String(\":/icons/mail-read.png\"));\n        default:\n            return QVariant();\n        }\n\n    case Qt::FontRole: {\n        // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n        translated.data(RoleMessageSubject);\n\n        // These items should definitely *not* be rendered in bold\n        if (!translated.data(RoleIsFetched).toBool())\n            return QVariant();\n\n        QFont font;\n        if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n            font.setStrikeOut(true);\n\n        if (! translated.data(RoleMessageIsMarkedRead).toBool()) {\n            // If any message is marked as unread, show it in bold and be done with it\n            font.setBold(true);\n        } else if (translated.model()->hasChildren(translated.sibling(translated.row(), 0)) &&\n                   translated.data(RoleThreadRootWithUnreadMessages).toBool()) {\n            // If this node is not marked as read, is a root of some thread and that thread\n            // contains unread messages, display the thread's root underlined\n            font.setUnderline(true);\n        }\n\n        if (index.column() == MsgListModel::SUBJECT && translated.data(RoleMessageSubject).toString().isEmpty()) {\n            font.setItalic(true);\n        }\n\n        return font;\n    }\n    }\n\n    return QSortFilterProxyModel::data(index, role);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ont.setItalic",
          "args": [
            "rue)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ont.setUnderline",
          "args": [
            "rue)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleThreadRootWithUnreadMessages)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.model",
          "args": [
            "ranslated.sibling(translated.row(), 0))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.sibling",
          "args": [
            "ranslated.row(),",
            ")"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.row",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.model",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ont.setBold",
          "args": [
            "rue)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedRead)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ont.setStrikeOut",
          "args": [
            "rue)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedDeleted)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Icon(",
          "args": [
            "Latin1String(\":/icons/mail-read.png\"))"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "adIcon(c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/IconLoader.h",
          "lines": "42-55",
          "snippet": "line QIcon loadIcon(const QString &name)\n{\n    // A QIcon(QString) constructor creates non-null QIcons, even though the resulting icon will\n    // not ever return a valid and usable pixmap. This means that we have to actually look at the\n    // icon's pixmap to find out what to return.\n    // If we do not do that, the GUI shows empty pixmaps instead of a text fallback, which is\n    // clearly suboptimal.\n    QIcon res = QIcon::fromTheme(name, QIcon(QString::fromUtf8(\":/icons/%1\").arg(name)));\n    if (res.pixmap(QSize(16, 16)).isNull()) {\n        return QIcon();\n    } else {\n        return res;\n    }\n}",
          "includes": [
            "include <QIcon>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QIcon>\n\nline QIcon loadIcon(const QString &name)\n{\n    // A QIcon(QString) constructor creates non-null QIcons, even though the resulting icon will\n    // not ever return a valid and usable pixmap. This means that we have to actually look at the\n    // icon's pixmap to find out what to return.\n    // If we do not do that, the GUI shows empty pixmaps instead of a text fallback, which is\n    // clearly suboptimal.\n    QIcon res = QIcon::fromTheme(name, QIcon(QString::fromUtf8(\":/icons/%1\").arg(name)));\n    if (res.pixmap(QSize(16, 16)).isNull()) {\n        return QIcon();\n    } else {\n        return res;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":/icons/mail-read.png\")"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":/icons/mail-unread.png\")"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedRead)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":/icons/transparent.png\")"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-recent\"))"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-recent\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedRecent)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-forwarded\"))"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-forwarded\")"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-replied\"))"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-replied\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-replied-forw\"))"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-replied-forw\")"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-deleted\"))"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-deleted\")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedDeleted)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedReplied)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageIsMarkedForwarded)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "(no subject)\")"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubject.isEmpty",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rettySize::prettySize(",
          "args": [
            "ize.toUInt())"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "prettySize(",
          "container": "mapAccess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ImapAccess.cpp",
          "lines": "382-385",
          "snippet": "String ImapAccess::prettySize(const uint bytes) const\n{\n    return Imap::Mailbox::PrettySize::prettySize(bytes, Imap::Mailbox::PrettySize::WITH_BYTES_SUFFIX);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Network/MsgPartNetAccessManager.h\"\n#",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/SystemNetworkWatcher.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/DummyNetworkWatcher.h\"\n#",
            "include \"Imap/Model/CombinedCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include <QSettings>\n#",
            "include <QSslKey>\n#",
            "include <QFileInfo>\n#",
            "include <QDir>\n#",
            "include \"ImapAccess.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Network/MsgPartNetAccessManager.h\"\n#\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/SystemNetworkWatcher.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/DummyNetworkWatcher.h\"\n#\ninclude \"Imap/Model/CombinedCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude <QSettings>\n#\ninclude <QSslKey>\n#\ninclude <QFileInfo>\n#\ninclude <QDir>\n#\ninclude \"ImapAccess.h\"\n#\n\nmapAccess {\n  String ImapAccess::prettySize(const uint bytes) const\n  {\n      return Imap::Mailbox::PrettySize::prettySize(bytes, Imap::Mailbox::PrettySize::WITH_BYTES_SUFFIX);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ize.toUInt",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize.isValid",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageSize)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rettyFormatDate(",
          "args": [
            "es.toLocalTime())"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "prettyFormatDate(",
          "container": "rettyMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
          "lines": "193-225",
          "snippet": "String PrettyMsgListModel::prettyFormatDate(const QDateTime &dateTime) const\n{\n    // The time is not always synced properly, so better accept even slightly too new messages as \"from today\"\n    QDateTime now = QDateTime::currentDateTime().addSecs(15*60);\n    if (dateTime >= now) {\n        // Messages from future shall always be shown using full format to prevent nasty surprises.\n        return dateTime.toString(Qt::DefaultLocaleShortDate);\n    } else if (dateTime.date() == now.date() || dateTime > now.addSecs(-6 * 3600)) {\n        // It's a \"today's message\", i.e. something which is either literally from today or at least something not older than\n        // six hours (an arbitraty magic number).\n        // Originally, the cut-off time interval was set to 24 hours, but it led to weird things in the GUI like showing mails\n        // from yesterday's 18:33 just as \"18:33\" even though the local time was \"18:20\" already. In a perfect world, we would\n        // also periodically emit dataChanged() in order to force a wrap once the view has been open for too long, but that will\n        // have to wait a bit.\n        // The time is displayed without seconds to conserve space as well.\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.time().toString(tr(\"hh:mm\"));\n    } else if (dateTime > now.addDays(-7)) {\n        // Messages from the last seven days can be formatted just with the weekday name\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.toString(tr(\"ddd hh:mm\"));\n    } else if (dateTime > now.addYears(-1)) {\n        // Messages newer than one year don't have to show year\n        //: please do not translate the format specifier (you can change their order\n        //: or the separator to follow the local conventions)\n        return dateTime.toString(tr(\"d MMM hh:mm\"));\n    } else {\n        // Old messagees shall have a full date\n        return dateTime.toString(Qt::DefaultLocaleShortDate);\n    }\n}",
          "includes": [
            "include \"Utils.h\"",
            "include \"ThreadingMsgListModel.h\"\n#",
            "include \"MsgListModel.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Gui/IconLoader.h\"\n#",
            "include <QFont>\n#",
            "include \"PrettyMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  String PrettyMsgListModel::prettyFormatDate(const QDateTime &dateTime) const\n  {\n      // The time is not always synced properly, so better accept even slightly too new messages as \"from today\"\n      QDateTime now = QDateTime::currentDateTime().addSecs(15*60);\n      if (dateTime >= now) {\n          // Messages from future shall always be shown using full format to prevent nasty surprises.\n          return dateTime.toString(Qt::DefaultLocaleShortDate);\n      } else if (dateTime.date() == now.date() || dateTime > now.addSecs(-6 * 3600)) {\n          // It's a \"today's message\", i.e. something which is either literally from today or at least something not older than\n          // six hours (an arbitraty magic number).\n          // Originally, the cut-off time interval was set to 24 hours, but it led to weird things in the GUI like showing mails\n          // from yesterday's 18:33 just as \"18:33\" even though the local time was \"18:20\" already. In a perfect world, we would\n          // also periodically emit dataChanged() in order to force a wrap once the view has been open for too long, but that will\n          // have to wait a bit.\n          // The time is displayed without seconds to conserve space as well.\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.time().toString(tr(\"hh:mm\"));\n      } else if (dateTime > now.addDays(-7)) {\n          // Messages from the last seven days can be formatted just with the weekday name\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.toString(tr(\"ddd hh:mm\"));\n      } else if (dateTime > now.addYears(-1)) {\n          // Messages newer than one year don't have to show year\n          //: please do not translate the format specifier (you can change their order\n          //: or the separator to follow the local conventions)\n          return dateTime.toString(tr(\"d MMM hh:mm\"));\n      } else {\n          // Old messagees shall have a full date\n          return dateTime.toString(Qt::DefaultLocaleShortDate);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "es.toLocalTime",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.toLocalTime",
          "args": [
            "t::DefaultLocaleLongDate)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.toLocalTime",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMessageDate)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddress::prettyList(",
          "args": [
            "tems,",
            "ole == Qt::DisplayRole ?\n                    Imap::Message::MailAddress::FORMAT_JUST_NAME :\n                    Imap::Message::MailAddress::FORMAT_READABLE)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "prettyList(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "174-185",
          "snippet": "String MailAddress::prettyList(const QVariantList &list, FormattingMode mode)\n{\n    QStringList buf;\n    for (QVariantList::const_iterator it = list.begin(); it != list.end(); ++it) {\n        Q_ASSERT(it->type() == QVariant::StringList);\n        QStringList item = it->toStringList();\n        Q_ASSERT(item.size() == 4);\n        MailAddress a(item[0], item[1], item[2], item[3]);\n        buf << a.prettyName(mode);\n    }\n    return buf.join(QLatin1String(\", \"));\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::prettyList(const QVariantList &list, FormattingMode mode)\n  {\n      QStringList buf;\n      for (QVariantList::const_iterator it = list.begin(); it != list.end(); ++it) {\n          Q_ASSERT(it->type() == QVariant::StringList);\n          QStringList item = it->toStringList();\n          Q_ASSERT(item.size() == 4);\n          MailAddress a(item[0], item[1], item[2], item[3]);\n          buf << a.prettyName(mode);\n      }\n      return buf.join(QLatin1String(\", \"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "ackendRole)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apToSource(",
          "args": [
            "ndex)"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "mapToSource(",
          "container": "ailboxModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxModel.cpp",
          "lines": "175-182",
          "snippet": "ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n{\n    int row = proxyIndex.row();\n    if (row < 0 || proxyIndex.column() != 0)\n        return QModelIndex();\n    ++row;\n    return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n}",
          "includes": [
            "include <QMimeData>",
            "include <QDebug>\n#",
            "include \"ItemRoles.h\"",
            "include \"MailboxTree.h\"\n#",
            "include \"MailboxModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QMimeData>\ninclude <QDebug>\n#\ninclude \"ItemRoles.h\"\ninclude \"MailboxTree.h\"\n#\ninclude \"MailboxModel.h\"\n#\n\nailboxModel {\n  ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n  {\n      int row = proxyIndex.row();\n      if (row < 0 || proxyIndex.column() != 0)\n          return QModelIndex();\n      ++row;\n      return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owCount(",
          "args": [
            "ndex.parent())"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "134-153",
          "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.parent",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "olumnCount(",
          "args": [
            "ndex.parent())"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "columnCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "155-158",
          "snippet": "nt TaskPresentationModel::columnCount(const QModelIndex &parent) const\n{\n    return (rowCount(parent) > 0) ? 1 : 0;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::columnCount(const QModelIndex &parent) const\n  {\n      return (rowCount(parent) > 0) ? 1 : 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  Variant PrettyMsgListModel::data(const QModelIndex &index, int role) const\n  {\n      if (! index.isValid() || index.model() != this)\n          return QVariant();\n  \n      if (index.column() < 0 || index.column() >= columnCount(index.parent()))\n          return QVariant();\n  \n      if (index.row() < 0 || index.row() >= rowCount(index.parent()))\n          return QVariant();\n  \n      QModelIndex translated = mapToSource(index);\n  \n      switch (role) {\n  \n      case Qt::DisplayRole:\n      case Qt::ToolTipRole:\n          switch (index.column()) {\n          case MsgListModel::TO:\n          case MsgListModel::FROM:\n          case MsgListModel::CC:\n          case MsgListModel::BCC:\n          {\n              int backendRole = 0;\n              switch (index.column()) {\n              case MsgListModel::FROM:\n                  backendRole = RoleMessageFrom;\n                  break;\n              case MsgListModel::TO:\n                  backendRole = RoleMessageTo;\n                  break;\n              case MsgListModel::CC:\n                  backendRole = RoleMessageCc;\n                  break;\n              case MsgListModel::BCC:\n                  backendRole = RoleMessageBcc;\n                  break;\n              }\n              QVariantList items = translated.data(backendRole).toList();\n              return Imap::Message::MailAddress::prettyList(items, role == Qt::DisplayRole ?\n                      Imap::Message::MailAddress::FORMAT_JUST_NAME :\n                      Imap::Message::MailAddress::FORMAT_READABLE);\n          }\n          case MsgListModel::DATE:\n          case MsgListModel::RECEIVED_DATE:\n          {\n              QDateTime res = translated.data(RoleMessageDate).toDateTime();\n              if (role == Qt::ToolTipRole) {\n                  // tooltips shall always show the full and complete data\n                  return res.toLocalTime().toString(Qt::DefaultLocaleLongDate);\n              }\n              return prettyFormatDate(res.toLocalTime());\n          }\n          case MsgListModel::SIZE:\n          {\n              QVariant size = translated.data(RoleMessageSize);\n              if (!size.isValid()) {\n                  return QVariant();\n              }\n              return PrettySize::prettySize(size.toUInt());\n          }\n          case MsgListModel::SUBJECT:\n          {\n              if (!translated.data(RoleIsFetched).toBool())\n                  return tr(\"Loading...\");\n              QString subject = translated.data(RoleMessageSubject).toString();\n              return subject.isEmpty() ? tr(\"(no subject)\") : subject;\n          }\n          }\n          break;\n  \n  \n      case Qt::TextAlignmentRole:\n          switch (index.column()) {\n          case MsgListModel::SIZE:\n              return Qt::AlignRight;\n          default:\n              return QVariant();\n          }\n  \n      case Qt::DecorationRole:\n          // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n          translated.data(RoleMessageSubject);\n  \n          switch (index.column()) {\n          case MsgListModel::SUBJECT:\n          {\n              if (! translated.data(RoleIsFetched).toBool())\n                  return QVariant();\n  \n              bool isForwarded = translated.data(RoleMessageIsMarkedForwarded).toBool();\n              bool isReplied = translated.data(RoleMessageIsMarkedReplied).toBool();\n  \n              if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n                  return Gui::loadIcon(QLatin1String(\"mail-deleted\"));\n              else if (isForwarded && isReplied)\n                  return Gui::loadIcon(QLatin1String(\"mail-replied-forw\"));\n              else if (isReplied)\n                  return Gui::loadIcon(QLatin1String(\"mail-replied\"));\n              else if (isForwarded)\n                  return Gui::loadIcon(QLatin1String(\"mail-forwarded\"));\n              else if (translated.data(RoleMessageIsMarkedRecent).toBool())\n                  return Gui::loadIcon(QLatin1String(\"mail-recent\"));\n              else\n                  return QIcon(QLatin1String(\":/icons/transparent.png\"));\n          }\n          case MsgListModel::SEEN:\n              if (! translated.data(RoleIsFetched).toBool())\n                  return QVariant();\n              if (! translated.data(RoleMessageIsMarkedRead).toBool())\n                  return QIcon(QLatin1String(\":/icons/mail-unread.png\"));\n              else\n                  return QIcon(QLatin1String(\":/icons/mail-read.png\"));\n          default:\n              return QVariant();\n          }\n  \n      case Qt::FontRole: {\n          // We will need the data, but asking for Flags or IsMarkedXYZ doesn't cause a fetch\n          translated.data(RoleMessageSubject);\n  \n          // These items should definitely *not* be rendered in bold\n          if (!translated.data(RoleIsFetched).toBool())\n              return QVariant();\n  \n          QFont font;\n          if (translated.data(RoleMessageIsMarkedDeleted).toBool())\n              font.setStrikeOut(true);\n  \n          if (! translated.data(RoleMessageIsMarkedRead).toBool()) {\n              // If any message is marked as unread, show it in bold and be done with it\n              font.setBold(true);\n          } else if (translated.model()->hasChildren(translated.sibling(translated.row(), 0)) &&\n                     translated.data(RoleThreadRootWithUnreadMessages).toBool()) {\n              // If this node is not marked as read, is a root of some thread and that thread\n              // contains unread messages, display the thread's root underlined\n              font.setUnderline(true);\n          }\n  \n          if (index.column() == MsgListModel::SUBJECT && translated.data(RoleMessageSubject).toString().isEmpty()) {\n              font.setItalic(true);\n          }\n  \n          return font;\n      }\n      }\n  \n      return QSortFilterProxyModel::data(index, role);\n  }\n}"
  },
  {
    "function_name": "PrettyMsgListModel(",
    "container": "rettyMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMsgListModel.cpp",
    "lines": "37-40",
    "snippet": "rettyMsgListModel::PrettyMsgListModel(QObject *parent): QSortFilterProxyModel(parent), m_hideRead(false)\n{\n    setDynamicSortFilter(true);\n}",
    "includes": [
      "include \"Utils.h\"",
      "include \"ThreadingMsgListModel.h\"\n#",
      "include \"MsgListModel.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include <QFont>\n#",
      "include \"PrettyMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etDynamicSortFilter(",
          "args": [
            "rue)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Utils.h\"\ninclude \"ThreadingMsgListModel.h\"\n#\ninclude \"MsgListModel.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude <QFont>\n#\ninclude \"PrettyMsgListModel.h\"\n#\n\nrettyMsgListModel {\n  rettyMsgListModel::PrettyMsgListModel(QObject *parent): QSortFilterProxyModel(parent), m_hideRead(false)\n  {\n      setDynamicSortFilter(true);\n  }\n}"
  }
]