[
  {
    "function_name": "isLoaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qsystemlibrary_p.h",
    "lines": "76-79",
    "snippet": "bool isLoaded()\n    {\n        return (m_handle != 0);\n    }",
    "includes": [
      "#include <QtCore/qstring.h>",
      "#include <qt_windows.h>",
      "#include <QtCore/qglobal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtCore/qstring.h>\n#include <qt_windows.h>\n#include <QtCore/qglobal.h>\n\nbool isLoaded()\n    {\n        return (m_handle != 0);\n    }"
  },
  {
    "function_name": "load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qsystemlibrary_p.h",
    "lines": "69-74",
    "snippet": "bool load(bool onlySystemDirectory = true)\n    {\n        m_handle = load((const wchar_t *)m_libraryName.utf16(), onlySystemDirectory);\n        m_didLoad = true;\n        return (m_handle != 0);\n    }",
    "includes": [
      "#include <QtCore/qstring.h>",
      "#include <qt_windows.h>",
      "#include <QtCore/qglobal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load",
          "args": [
            "(const wchar_t *)m_libraryName.utf16()",
            "onlySystemDirectory"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "152-278",
          "snippet": "oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n{\n    if ( ! a.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( a != b ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n#endif\n        return;\n    }\n\n    QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n    if ( ! message.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                    message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n#endif\n        return;\n    }\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n    if ( it == m_parts.end() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"We are not interested in message with UID\" << uid;\n#endif\n        return;\n    }\n\n    const QAbstractItemModel *model = message.model();\n\n    // Find out whether the data is available already\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n\n    if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasHeader = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got header for\" << uid;\n#endif\n    }\n\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasBody = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got body for\" << uid;\n#endif\n    }\n\n    if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n            it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasMainPart = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got main part for\" << uid;\n#endif\n    }\n\n    if (a == message && !it->hasMessage) {\n\n        if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n            qDebug() << \"  Not loaded yet\";\n#endif\n            return;\n        }\n\n        it->hasMessage = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got message for\" << uid;\n#endif\n        requestDataDownload(message);\n\n    }\n\n    if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n        // Check message metadata\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n\n        // Check the main part\n        QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n        QString mainPart;\n        if (it->mainPartFailed) {\n            mainPart = it->partMessage;\n        } else {\n            Q_ASSERT(mainPartData.isValid());\n            mainPart = mainPartData.toString();\n        }\n\n        // The rest of the bulk data\n        QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(headerData.isValid());\n        QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(bodyData.isValid());\n\n        log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n        emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n        m_parts.erase(it);\n\n        m_messagesToBeFreed << message;\n        if (!m_releasingTimer->isActive())\n            m_releasingTimer->start();\n\n        if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n            m_queuedTimer->start();\n\n    } else {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n#endif\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n  {\n      if ( ! a.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( a != b ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n  #endif\n          return;\n      }\n  \n      QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n      if ( ! message.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                      message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n  #endif\n          return;\n      }\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n      if ( it == m_parts.end() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"We are not interested in message with UID\" << uid;\n  #endif\n          return;\n      }\n  \n      const QAbstractItemModel *model = message.model();\n  \n      // Find out whether the data is available already\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n  \n      if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasHeader = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got header for\" << uid;\n  #endif\n      }\n  \n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasBody = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got body for\" << uid;\n  #endif\n      }\n  \n      if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n              it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasMainPart = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got main part for\" << uid;\n  #endif\n      }\n  \n      if (a == message && !it->hasMessage) {\n  \n          if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n              qDebug() << \"  Not loaded yet\";\n  #endif\n              return;\n          }\n  \n          it->hasMessage = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got message for\" << uid;\n  #endif\n          requestDataDownload(message);\n  \n      }\n  \n      if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n          // Check message metadata\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n  \n          // Check the main part\n          QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n          QString mainPart;\n          if (it->mainPartFailed) {\n              mainPart = it->partMessage;\n          } else {\n              Q_ASSERT(mainPartData.isValid());\n              mainPart = mainPartData.toString();\n          }\n  \n          // The rest of the bulk data\n          QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(headerData.isValid());\n          QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(bodyData.isValid());\n  \n          log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n          emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n          m_parts.erase(it);\n  \n          m_messagesToBeFreed << message;\n          if (!m_releasingTimer->isActive())\n              m_releasingTimer->start();\n  \n          if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n              m_queuedTimer->start();\n  \n      } else {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n  #endif\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_libraryName.utf16",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtCore/qstring.h>\n#include <qt_windows.h>\n#include <QtCore/qglobal.h>\n\nbool load(bool onlySystemDirectory = true)\n    {\n        m_handle = load((const wchar_t *)m_libraryName.utf16(), onlySystemDirectory);\n        m_didLoad = true;\n        return (m_handle != 0);\n    }"
  },
  {
    "function_name": "QSystemLibrary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qsystemlibrary_p.h",
    "lines": "62-67",
    "snippet": "explicit QSystemLibrary(const wchar_t *libraryName)\n    {\n        m_libraryName = QString::fromWCharArray(libraryName);\n        m_handle = 0;\n        m_didLoad = false;\n    }",
    "includes": [
      "#include <QtCore/qstring.h>",
      "#include <qt_windows.h>",
      "#include <QtCore/qglobal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString::fromWCharArray",
          "args": [
            "libraryName"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtCore/qstring.h>\n#include <qt_windows.h>\n#include <QtCore/qglobal.h>\n\nexplicit QSystemLibrary(const wchar_t *libraryName)\n    {\n        m_libraryName = QString::fromWCharArray(libraryName);\n        m_handle = 0;\n        m_didLoad = false;\n    }"
  }
]