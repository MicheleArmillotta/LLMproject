[
  {
    "function_name": "setShowOnlySubscribed(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "166-170",
    "snippet": "oid PrettyMailboxModel::setShowOnlySubscribed(bool filterUnsubscribed)\n{\n    m_showOnlySubscribed = filterUnsubscribed;\n    invalidateFilter();\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvalidateFilter(",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  oid PrettyMailboxModel::setShowOnlySubscribed(bool filterUnsubscribed)\n  {\n      m_showOnlySubscribed = filterUnsubscribed;\n      invalidateFilter();\n  }\n}"
  },
  {
    "function_name": "xtConnectStatusChanged(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "159-163",
    "snippet": "oid PrettyMailboxModel::xtConnectStatusChanged(QModelIndex index)\n{\n    Q_ASSERT(index.model() == this);\n    emit dataChanged(index, index);\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.model() == this)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  oid PrettyMailboxModel::xtConnectStatusChanged(QModelIndex index)\n  {\n      Q_ASSERT(index.model() == this);\n      emit dataChanged(index, index);\n  }\n}"
  },
  {
    "function_name": "hasChildren(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "153-156",
    "snippet": "ool PrettyMailboxModel::hasChildren(const QModelIndex &parent) const\n{\n    return sourceModel()->hasChildren(mapToSource(parent));\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            "apToSource(parent))"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "setSourceModel(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "71-109",
          "snippet": "oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n{\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n\n    if (this->sourceModel()) {\n        // there's already something, so take care to disconnect all signals\n        this->sourceModel()->disconnect(this);\n    }\n\n    RESET_MODEL;\n\n    if (!sourceModel)\n        return;\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n    Q_ASSERT(msgList);\n    QAbstractProxyModel::setSourceModel(msgList);\n\n    // FIXME: will need to be expanded when Model supports more signals...\n    connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n    connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n    connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n            this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n    resetMe();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n  {\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n  \n      if (this->sourceModel()) {\n          // there's already something, so take care to disconnect all signals\n          this->sourceModel()->disconnect(this);\n      }\n  \n      RESET_MODEL;\n  \n      if (!sourceModel)\n          return;\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n      Q_ASSERT(msgList);\n      QAbstractProxyModel::setSourceModel(msgList);\n  \n      // FIXME: will need to be expanded when Model supports more signals...\n      connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n      connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n      connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n      connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n              this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n      resetMe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "apToSource(",
          "args": [
            "arent)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mapToSource(",
          "container": "ailboxModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxModel.cpp",
          "lines": "175-182",
          "snippet": "ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n{\n    int row = proxyIndex.row();\n    if (row < 0 || proxyIndex.column() != 0)\n        return QModelIndex();\n    ++row;\n    return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n}",
          "includes": [
            "include <QMimeData>",
            "include <QDebug>\n#",
            "include \"ItemRoles.h\"",
            "include \"MailboxTree.h\"\n#",
            "include \"MailboxModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QMimeData>\ninclude <QDebug>\n#\ninclude \"ItemRoles.h\"\ninclude \"MailboxTree.h\"\n#\ninclude \"MailboxModel.h\"\n#\n\nailboxModel {\n  ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n  {\n      int row = proxyIndex.row();\n      if (row < 0 || proxyIndex.column() != 0)\n          return QModelIndex();\n      ++row;\n      return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  ool PrettyMailboxModel::hasChildren(const QModelIndex &parent) const\n  {\n      return sourceModel()->hasChildren(mapToSource(parent));\n  }\n}"
  },
  {
    "function_name": "filterAcceptsRow(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "141-151",
    "snippet": "ool PrettyMailboxModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n{\n    if (!m_showOnlySubscribed)\n        return true;\n\n    QModelIndex index = sourceModel()->index(source_row, 0, source_parent);\n    Q_ASSERT(index.isValid());\n\n    // FIXME: walk the tree resursively from here instead of just checking for children\n    return index.data(RoleMailboxIsSubscribed).toBool() || sourceModel()->hasChildren(index);\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            "ndex)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "setSourceModel(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "71-109",
          "snippet": "oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n{\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n\n    if (this->sourceModel()) {\n        // there's already something, so take care to disconnect all signals\n        this->sourceModel()->disconnect(this);\n    }\n\n    RESET_MODEL;\n\n    if (!sourceModel)\n        return;\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n    Q_ASSERT(msgList);\n    QAbstractProxyModel::setSourceModel(msgList);\n\n    // FIXME: will need to be expanded when Model supports more signals...\n    connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n    connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n    connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n            this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n    resetMe();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n  {\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n  \n      if (this->sourceModel()) {\n          // there's already something, so take care to disconnect all signals\n          this->sourceModel()->disconnect(this);\n      }\n  \n      RESET_MODEL;\n  \n      if (!sourceModel)\n          return;\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n      Q_ASSERT(msgList);\n      QAbstractProxyModel::setSourceModel(msgList);\n  \n      // FIXME: will need to be expanded when Model supports more signals...\n      connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n      connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n      connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n      connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n              this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n      resetMe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxIsSubscribed)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.isValid())"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            "ource_row,",
            ",",
            "ource_parent)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  ool PrettyMailboxModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n  {\n      if (!m_showOnlySubscribed)\n          return true;\n  \n      QModelIndex index = sourceModel()->index(source_row, 0, source_parent);\n      Q_ASSERT(index.isValid());\n  \n      // FIXME: walk the tree resursively from here instead of just checking for children\n      return index.data(RoleMailboxIsSubscribed).toBool() || sourceModel()->hasChildren(index);\n  }\n}"
  },
  {
    "function_name": "filterAcceptsColumn(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "135-139",
    "snippet": "ool PrettyMailboxModel::filterAcceptsColumn(int source_column, const QModelIndex &source_parent) const\n{\n    Q_UNUSED(source_parent);\n    return source_column == 0;\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ource_parent)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  ool PrettyMailboxModel::filterAcceptsColumn(int source_column, const QModelIndex &source_parent) const\n  {\n      Q_UNUSED(source_parent);\n      return source_column == 0;\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "46-133",
    "snippet": "Variant PrettyMailboxModel::data(const QModelIndex &index, int role) const\n{\n    if (!index.isValid())\n        return QVariant();\n\n    if (index.column() != 0)\n        return QVariant();\n\n    if (index.row() < 0 || index.row() >= rowCount(index.parent()) || index.model() != this)\n        return QVariant();\n\n    switch (role) {\n    case Qt::DisplayRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        qlonglong unreadCount = translated.data(RoleUnreadMessageCount).toLongLong();\n        qlonglong recentCount = translated.data(RoleRecentMessageCount).toLongLong();\n        // The \"problem\" is that the \\Recent and (lack of) \\Seen flags are orthogonal states.\n        //\n        // There is no rule saying that a recent message is still unseen (trivial example: an already-read message being copied),\n        // or that an unread message is recent.\n        //\n        // That's not really so much of a problem after the mailbox has been synced because we have all flags for each and every\n        // message, and can therefore easily compute the difference. The problem, however, is that there is no such feature\n        // in the SELECT command (and before you ask, SEARCH requires a selected mailbox, and \"selected\" is very close to\n        // \"synchronized\" in Trojita). Trojita tries to satisfy all requests for \"message numbers\" at once, via the STATUS command\n        // for unselected mailboxes, or through the already-known and cached information in the message flags for the recently\n        // synchronized ones. In theory, it is possible to implement a workaround involving EXAMINE and (E)SEARCH, but even that\n        // has its drawbacks (like the necessary serialization of requests and the requirement for a ton of new code).\n        //\n        // So in short, this is why there's no \"(1 + 5)\" result with six unread an one recent message.\n        //\n        // We also deliberately put an emphasis on the \"unread count\", even to an extent where there's no special information\n        // for mailboxes with some recent, but no unread messages.\n        if (recentCount && unreadCount) {\n            return tr(\"%1 (%2/%3)\")\n                   .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                        QString::number(recentCount), QString::number(unreadCount));\n        } else if (unreadCount) {\n            return tr(\"%1 (%2)\")\n                   .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                        QString::number(unreadCount));\n        } else {\n            return QSortFilterProxyModel::data(index, RoleShortMailboxName);\n        }\n    }\n    case Qt::FontRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        if (translated.data(RoleMailboxNumbersFetched).toBool() &&\n            translated.data(RoleUnreadMessageCount).toULongLong() > 0) {\n            QFont font;\n            font.setBold(true);\n            return font;\n        } else {\n            return QVariant();\n        }\n    }\n    case Qt::DecorationRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        if (translated.data(RoleMailboxItemsAreLoading).toBool())\n            return Gui::loadIcon(QLatin1String(\"folder-grey\"));\n#ifdef XTUPLE_CONNECT\n        else if (QSettings().value(Common::SettingsNames::xtSyncMailboxList).toStringList().contains(\n                     translated.data(RoleMailboxName).toString()))\n            return Gui::loadIcon(QLatin1String(\"folder-xt-sync.png\"));\n#endif\n        else if (translated.data(RoleMailboxIsINBOX).toBool())\n            return Gui::loadIcon(QLatin1String(\"mail-folder-inbox\"));\n        else if (translated.data(RoleRecentMessageCount).toInt() > 0)\n            return Gui::loadIcon(QLatin1String(\"folder-bookmark\"));\n        else if (translated.data(RoleMailboxIsSelectable).toBool())\n            return Gui::loadIcon(QLatin1String(\"folder\"));\n        else\n            return Gui::loadIcon(QLatin1String(\"folder-open\"));\n    }\n    case Qt::ToolTipRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        return tr(\"<p>%1</p>\\n<p>%2 messages<br/>%3 unread<br/>%4 recent</p>\")\n               .arg(translated.data(RoleShortMailboxName).toString(), translated.data(RoleTotalMessageCount).toString(),\n                    translated.data(RoleUnreadMessageCount).toString(), translated.data(RoleRecentMessageCount).toString());\n    }\n    default:\n        return QSortFilterProxyModel::data(index, role);\n    }\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SortFilterProxyModel::data(",
          "args": [
            "ndex,",
            "ole)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "data(",
          "container": "rettyMailboxModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
          "lines": "46-133",
          "snippet": "Variant PrettyMailboxModel::data(const QModelIndex &index, int role) const\n{\n    if (!index.isValid())\n        return QVariant();\n\n    if (index.column() != 0)\n        return QVariant();\n\n    if (index.row() < 0 || index.row() >= rowCount(index.parent()) || index.model() != this)\n        return QVariant();\n\n    switch (role) {\n    case Qt::DisplayRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        qlonglong unreadCount = translated.data(RoleUnreadMessageCount).toLongLong();\n        qlonglong recentCount = translated.data(RoleRecentMessageCount).toLongLong();\n        // The \"problem\" is that the \\Recent and (lack of) \\Seen flags are orthogonal states.\n        //\n        // There is no rule saying that a recent message is still unseen (trivial example: an already-read message being copied),\n        // or that an unread message is recent.\n        //\n        // That's not really so much of a problem after the mailbox has been synced because we have all flags for each and every\n        // message, and can therefore easily compute the difference. The problem, however, is that there is no such feature\n        // in the SELECT command (and before you ask, SEARCH requires a selected mailbox, and \"selected\" is very close to\n        // \"synchronized\" in Trojita). Trojita tries to satisfy all requests for \"message numbers\" at once, via the STATUS command\n        // for unselected mailboxes, or through the already-known and cached information in the message flags for the recently\n        // synchronized ones. In theory, it is possible to implement a workaround involving EXAMINE and (E)SEARCH, but even that\n        // has its drawbacks (like the necessary serialization of requests and the requirement for a ton of new code).\n        //\n        // So in short, this is why there's no \"(1 + 5)\" result with six unread an one recent message.\n        //\n        // We also deliberately put an emphasis on the \"unread count\", even to an extent where there's no special information\n        // for mailboxes with some recent, but no unread messages.\n        if (recentCount && unreadCount) {\n            return tr(\"%1 (%2/%3)\")\n                   .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                        QString::number(recentCount), QString::number(unreadCount));\n        } else if (unreadCount) {\n            return tr(\"%1 (%2)\")\n                   .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                        QString::number(unreadCount));\n        } else {\n            return QSortFilterProxyModel::data(index, RoleShortMailboxName);\n        }\n    }\n    case Qt::FontRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        if (translated.data(RoleMailboxNumbersFetched).toBool() &&\n            translated.data(RoleUnreadMessageCount).toULongLong() > 0) {\n            QFont font;\n            font.setBold(true);\n            return font;\n        } else {\n            return QVariant();\n        }\n    }\n    case Qt::DecorationRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        if (translated.data(RoleMailboxItemsAreLoading).toBool())\n            return Gui::loadIcon(QLatin1String(\"folder-grey\"));\n#ifdef XTUPLE_CONNECT\n        else if (QSettings().value(Common::SettingsNames::xtSyncMailboxList).toStringList().contains(\n                     translated.data(RoleMailboxName).toString()))\n            return Gui::loadIcon(QLatin1String(\"folder-xt-sync.png\"));\n#endif\n        else if (translated.data(RoleMailboxIsINBOX).toBool())\n            return Gui::loadIcon(QLatin1String(\"mail-folder-inbox\"));\n        else if (translated.data(RoleRecentMessageCount).toInt() > 0)\n            return Gui::loadIcon(QLatin1String(\"folder-bookmark\"));\n        else if (translated.data(RoleMailboxIsSelectable).toBool())\n            return Gui::loadIcon(QLatin1String(\"folder\"));\n        else\n            return Gui::loadIcon(QLatin1String(\"folder-open\"));\n    }\n    case Qt::ToolTipRole:\n    {\n        QModelIndex translated = mapToSource(index);\n        return tr(\"<p>%1</p>\\n<p>%2 messages<br/>%3 unread<br/>%4 recent</p>\")\n               .arg(translated.data(RoleShortMailboxName).toString(), translated.data(RoleTotalMessageCount).toString(),\n                    translated.data(RoleUnreadMessageCount).toString(), translated.data(RoleRecentMessageCount).toString());\n    }\n    default:\n        return QSortFilterProxyModel::data(index, role);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ranslated.data(RoleShortMailboxName).toString(),",
            "ranslated.data(RoleTotalMessageCount).toString(),",
            "ranslated.data(RoleUnreadMessageCount).toString(),",
            "ranslated.data(RoleRecentMessageCount).toString())"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "findMainPartOfMessage(",
          "container": "indInterestingPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FindInterestingPart.cpp",
          "lines": "87-111",
          "snippet": "indInterestingPart::MainPartReturnCode FindInterestingPart::findMainPartOfMessage(\n        const QModelIndex &message, QModelIndex &mainPartIndex, QString &partMessage, QString *partData)\n{\n    mainPartIndex = message.child( 0, 0 );\n    if ( ! mainPartIndex.isValid() ) {\n        return MAINPART_MESSAGE_NOT_LOADED;\n    }\n\n    partMessage = findMainPart( mainPartIndex );\n    if ( ! mainPartIndex.isValid() ) {\n        return MAINPART_PART_CANNOT_DETERMINE;\n    }\n\n    if (partData) {\n        QVariant data = mainPartIndex.data( Imap::Mailbox::RolePartData );\n        if ( ! data.isValid() ) {\n            return MAINPART_PART_LOADING;\n        }\n\n        *partData = data.toString();\n        return MAINPART_FOUND;\n    } else {\n        return mainPartIndex.data(Imap::Mailbox::RoleIsFetched).toBool() ? MAINPART_FOUND : MAINPART_PART_LOADING;\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"FindInterestingPart.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FindInterestingPart.h\"\n#\n\nindInterestingPart {\n  indInterestingPart::MainPartReturnCode FindInterestingPart::findMainPartOfMessage(\n          const QModelIndex &message, QModelIndex &mainPartIndex, QString &partMessage, QString *partData)\n  {\n      mainPartIndex = message.child( 0, 0 );\n      if ( ! mainPartIndex.isValid() ) {\n          return MAINPART_MESSAGE_NOT_LOADED;\n      }\n  \n      partMessage = findMainPart( mainPartIndex );\n      if ( ! mainPartIndex.isValid() ) {\n          return MAINPART_PART_CANNOT_DETERMINE;\n      }\n  \n      if (partData) {\n          QVariant data = mainPartIndex.data( Imap::Mailbox::RolePartData );\n          if ( ! data.isValid() ) {\n              return MAINPART_PART_LOADING;\n          }\n  \n          *partData = data.toString();\n          return MAINPART_FOUND;\n      } else {\n          return mainPartIndex.data(Imap::Mailbox::RoleIsFetched).toBool() ? MAINPART_FOUND : MAINPART_PART_LOADING;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleRecentMessageCount)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleUnreadMessageCount)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleTotalMessageCount)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleShortMailboxName)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "<p>%1</p>\\n<p>%2 messages<br/>%3 unread<br/>%4 recent</p>\")"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "apToSource(",
          "args": [
            "ndex)"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "mapToSource(",
          "container": "ailboxModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxModel.cpp",
          "lines": "175-182",
          "snippet": "ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n{\n    int row = proxyIndex.row();\n    if (row < 0 || proxyIndex.column() != 0)\n        return QModelIndex();\n    ++row;\n    return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n}",
          "includes": [
            "include <QMimeData>",
            "include <QDebug>\n#",
            "include \"ItemRoles.h\"",
            "include \"MailboxTree.h\"\n#",
            "include \"MailboxModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QMimeData>\ninclude <QDebug>\n#\ninclude \"ItemRoles.h\"\ninclude \"MailboxTree.h\"\n#\ninclude \"MailboxModel.h\"\n#\n\nailboxModel {\n  ModelIndex MailboxModel::mapToSource(const QModelIndex &proxyIndex) const\n  {\n      int row = proxyIndex.row();\n      if (row < 0 || proxyIndex.column() != 0)\n          return QModelIndex();\n      ++row;\n      return static_cast<Imap::Mailbox::Model *>(sourceModel())->createIndex(row, 0, proxyIndex.internalPointer());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "folder-open\")"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"folder\"))"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "folder\")"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMailboxIsSelectable)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"folder-bookmark\"))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "folder-bookmark\")"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleRecentMessageCount)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-folder-inbox\"))"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-folder-inbox\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMailboxIsINBOX)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"folder-xt-sync.png\"))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "folder-xt-sync.png\")"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Settings",
          "args": [
            "ranslated.data(RoleMailboxName).toString())"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "igrateSettings(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "462-503",
          "snippet": "oid migrateSettings(QSettings *settings)\n{\n    using Common::SettingsNames;\n\n    // Process the obsolete settings about the \"cache backend\". This has been changed to \"offline stuff\" after v0.3.\n    if (settings->value(SettingsNames::cacheMetadataKey).toString() == SettingsNames::cacheMetadataMemory) {\n        settings->setValue(SettingsNames::cacheOfflineKey, SettingsNames::cacheOfflineNone);\n        settings->remove(SettingsNames::cacheMetadataKey);\n\n        // Also remove the older values used for cache lifetime management which were not used, but set to zero by default\n        settings->remove(QLatin1String(\"offline.sync\"));\n        settings->remove(QLatin1String(\"offline.sync.days\"));\n        settings->remove(QLatin1String(\"offline.sync.messages\"));\n    }\n\n    // Migrate the \"last known certificate\" from the full PEM format to just the pubkey\n    QByteArray lastKnownCertPem = settings->value(SettingsNames::obsImapSslPemCertificate).toByteArray();\n    if (!lastKnownCertPem.isEmpty()) {\n        QList<QSslCertificate> oldChain = QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n        if (!oldChain.isEmpty()) {\n            settings->setValue(SettingsNames::imapSslPemPubKey, oldChain[0].publicKey().toPem());\n        }\n    }\n    settings->remove(SettingsNames::obsImapSslPemCertificate);\n\n    // Migration of the sender identities\n    bool needsIdentityMigration = settings->beginReadArray(SettingsNames::identitiesKey) == 0;\n    settings->endArray();\n    if (needsIdentityMigration) {\n        QString realName = settings->value(SettingsNames::obsRealNameKey).toString();\n        QString email = settings->value(SettingsNames::obsAddressKey).toString();\n        if (!realName.isEmpty() || !email.isEmpty()) {\n            settings->beginWriteArray(SettingsNames::identitiesKey);\n            settings->setArrayIndex(0);\n            settings->setValue(SettingsNames::realNameKey, realName);\n            settings->setValue(SettingsNames::addressKey, email);\n            settings->endArray();\n            settings->remove(Common::SettingsNames::obsRealNameKey);\n            settings->remove(Common::SettingsNames::obsAddressKey);\n        }\n    }\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\noid migrateSettings(QSettings *settings)\n{\n    using Common::SettingsNames;\n\n    // Process the obsolete settings about the \"cache backend\". This has been changed to \"offline stuff\" after v0.3.\n    if (settings->value(SettingsNames::cacheMetadataKey).toString() == SettingsNames::cacheMetadataMemory) {\n        settings->setValue(SettingsNames::cacheOfflineKey, SettingsNames::cacheOfflineNone);\n        settings->remove(SettingsNames::cacheMetadataKey);\n\n        // Also remove the older values used for cache lifetime management which were not used, but set to zero by default\n        settings->remove(QLatin1String(\"offline.sync\"));\n        settings->remove(QLatin1String(\"offline.sync.days\"));\n        settings->remove(QLatin1String(\"offline.sync.messages\"));\n    }\n\n    // Migrate the \"last known certificate\" from the full PEM format to just the pubkey\n    QByteArray lastKnownCertPem = settings->value(SettingsNames::obsImapSslPemCertificate).toByteArray();\n    if (!lastKnownCertPem.isEmpty()) {\n        QList<QSslCertificate> oldChain = QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n        if (!oldChain.isEmpty()) {\n            settings->setValue(SettingsNames::imapSslPemPubKey, oldChain[0].publicKey().toPem());\n        }\n    }\n    settings->remove(SettingsNames::obsImapSslPemCertificate);\n\n    // Migration of the sender identities\n    bool needsIdentityMigration = settings->beginReadArray(SettingsNames::identitiesKey) == 0;\n    settings->endArray();\n    if (needsIdentityMigration) {\n        QString realName = settings->value(SettingsNames::obsRealNameKey).toString();\n        QString email = settings->value(SettingsNames::obsAddressKey).toString();\n        if (!realName.isEmpty() || !email.isEmpty()) {\n            settings->beginWriteArray(SettingsNames::identitiesKey);\n            settings->setArrayIndex(0);\n            settings->setValue(SettingsNames::realNameKey, realName);\n            settings->setValue(SettingsNames::addressKey, email);\n            settings->endArray();\n            settings->remove(Common::SettingsNames::obsRealNameKey);\n            settings->remove(Common::SettingsNames::obsAddressKey);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Settings",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "slotShowSettings()\n{",
          "container": "ow",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Window.cpp",
          "lines": "1055-1074",
          "snippet": "nWindow::slotShowSettings()\n{\n    SettingsDialog *dialog = new SettingsDialog(this, m_senderIdentities, m_settings);\n    if (dialog->exec() == QDialog::Accepted) {\n        // FIXME: wipe cache in case we're moving between servers\n        nukeModels();\n        setupModels();\n        connectModelActions();\n        // The systray is still connected to the old model -- got to make sure it's getting updated\n        removeSysTray();\n        slotToggleSysTray();\n    }\n    QString method = m_settings->value(Common::SettingsNames::imapMethodKey).toString();\n    if (method != Common::SettingsNames::methodTCP && method != Common::SettingsNames::methodSSL &&\n            method != Common::SettingsNames::methodProcess ) {\n        QMessageBox::critical(this, tr(\"No Configuration\"),\n                              trUtf8(\"No IMAP account is configured. Trojit cannot do much without one.\"));\n    }\n    applySizesAndState();\n}\n\nvoid Ma",
          "includes": [
            "include \"Imap/Model/ModelTest/modeltest.h\"",
            "include \"ui_AboutDialog.h\"",
            "include \"ui_CreateMailboxDialog.h\"\n#",
            "include \"ShortcutHandler/ShortcutHandler.h\"",
            "include \"Window.h\"\n#",
            "include \"Util.h\"\n#",
            "include \"TaskProgressIndicator.h\"\n#",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"SimplePartWidget.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include \"PasswordDialog.h\"\n#",
            "include \"OnePanelAtTimeWidget.h\"\n#",
            "include \"MsgListView.h\"\n#",
            "include \"MessageSourceWidget.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"MessageListWidget.h\"\n#",
            "include \"MailBoxTreeView.h\"\n#",
            "include \"IconLoader.h\"\n#",
            "include \"ComposeWidget.h\"\n#",
            "include \"CompleteMessageWidget.h\"\n#",
            "include \"Plugins/PluginManager.h\"\n#",
            "include \"MSA/SMTP.h\"\n#",
            "include \"MSA/Sendmail.h\"\n#",
            "include \"Imap/Network/FileDownloadManager.h\"\n#",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/ThreadingMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMailboxModel.h\"\n#",
            "include \"Imap/Model/NetworkWatcher.h\"\n#",
            "include \"Imap/Model/MsgListModel.h\"\n#",
            "include \"Imap/Model/ModelWatcher.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ImapAccess.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"Composer/Mailto.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/Application.h\"\n#",
            "include \"AbookAddressbook/be-contacts.h\"\n#",
            "include \"AbookAddressbook/AbookAddressbook.h\"\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QToolButton>\n#",
            "include <QToolBar>\n#",
            "include <QTextDocument>\n#",
            "include <QStatusBar>\n#",
            "include <QStackedWidget>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSplitter>\n#",
            "include <QProgressBar>\n#",
            "include <QMessageBox>\n#",
            "include <QMenuBar>\n#",
            "include <QItemSelectionModel>\n#",
            "include <QHeaderView>\n#",
            "include <QFileDialog>\n#",
            "include <QDockWidget>\n#",
            "include <QDir>\n#",
            "include <QDesktopWidget>\n#",
            "include <QDesktopServices>\n#",
            "include <QAuthenticator>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/ModelTest/modeltest.h\"\ninclude \"ui_AboutDialog.h\"\ninclude \"ui_CreateMailboxDialog.h\"\n#\ninclude \"ShortcutHandler/ShortcutHandler.h\"\ninclude \"Window.h\"\n#\ninclude \"Util.h\"\n#\ninclude \"TaskProgressIndicator.h\"\n#\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"SimplePartWidget.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude \"PasswordDialog.h\"\n#\ninclude \"OnePanelAtTimeWidget.h\"\n#\ninclude \"MsgListView.h\"\n#\ninclude \"MessageSourceWidget.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"MessageListWidget.h\"\n#\ninclude \"MailBoxTreeView.h\"\n#\ninclude \"IconLoader.h\"\n#\ninclude \"ComposeWidget.h\"\n#\ninclude \"CompleteMessageWidget.h\"\n#\ninclude \"Plugins/PluginManager.h\"\n#\ninclude \"MSA/SMTP.h\"\n#\ninclude \"MSA/Sendmail.h\"\n#\ninclude \"Imap/Network/FileDownloadManager.h\"\n#\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/ThreadingMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMailboxModel.h\"\n#\ninclude \"Imap/Model/NetworkWatcher.h\"\n#\ninclude \"Imap/Model/MsgListModel.h\"\n#\ninclude \"Imap/Model/ModelWatcher.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ImapAccess.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"Composer/Mailto.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude \"AbookAddressbook/be-contacts.h\"\n#\ninclude \"AbookAddressbook/AbookAddressbook.h\"\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QToolButton>\n#\ninclude <QToolBar>\n#\ninclude <QTextDocument>\n#\ninclude <QStatusBar>\n#\ninclude <QStackedWidget>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSplitter>\n#\ninclude <QProgressBar>\n#\ninclude <QMessageBox>\n#\ninclude <QMenuBar>\n#\ninclude <QItemSelectionModel>\n#\ninclude <QHeaderView>\n#\ninclude <QFileDialog>\n#\ninclude <QDockWidget>\n#\ninclude <QDir>\n#\ninclude <QDesktopWidget>\n#\ninclude <QDesktopServices>\n#\ninclude <QAuthenticator>\n#\n\now {\n  nWindow::slotShowSettings()\n  {\n      SettingsDialog *dialog = new SettingsDialog(this, m_senderIdentities, m_settings);\n      if (dialog->exec() == QDialog::Accepted) {\n          // FIXME: wipe cache in case we're moving between servers\n          nukeModels();\n          setupModels();\n          connectModelActions();\n          // The systray is still connected to the old model -- got to make sure it's getting updated\n          removeSysTray();\n          slotToggleSysTray();\n      }\n      QString method = m_settings->value(Common::SettingsNames::imapMethodKey).toString();\n      if (method != Common::SettingsNames::methodTCP && method != Common::SettingsNames::methodSSL &&\n              method != Common::SettingsNames::methodProcess ) {\n          QMessageBox::critical(this, tr(\"No Configuration\"),\n                                trUtf8(\"No IMAP account is configured. Trojit cannot do much without one.\"));\n      }\n      applySizesAndState();\n  }\n  \n  void Ma\n}"
        }
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"folder-grey\"))"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "folder-grey\")"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMailboxItemsAreLoading)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ont.setBold",
          "args": [
            "rue)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleUnreadMessageCount)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleMailboxNumbersFetched)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "SortFilterProxyModel::data(index, RoleShortMailboxName).toString(),",
            "String::number(unreadCount))"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "filterAcceptsRow(",
          "container": "rettyMailboxModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
          "lines": "141-151",
          "snippet": "ool PrettyMailboxModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n{\n    if (!m_showOnlySubscribed)\n        return true;\n\n    QModelIndex index = sourceModel()->index(source_row, 0, source_parent);\n    Q_ASSERT(index.isValid());\n\n    // FIXME: walk the tree resursively from here instead of just checking for children\n    return index.data(RoleMailboxIsSubscribed).toBool() || sourceModel()->hasChildren(index);\n}",
          "includes": [
            "include \"Gui/IconLoader.h\"",
            "include <QFont>\n#",
            "include <QSettings>\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"ItemRoles.h\"",
            "include \"PrettyMailboxModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  ool PrettyMailboxModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const\n  {\n      if (!m_showOnlySubscribed)\n          return true;\n  \n      QModelIndex index = sourceModel()->index(source_row, 0, source_parent);\n      Q_ASSERT(index.isValid());\n  \n      // FIXME: walk the tree resursively from here instead of just checking for children\n      return index.data(RoleMailboxIsSubscribed).toBool() || sourceModel()->hasChildren(index);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "nreadCount)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "SortFilterProxyModel::data(index, RoleShortMailboxName).toString(),",
            "String::number(recentCount),",
            "String::number(unreadCount))"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "forgetMessagePart(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "785-797",
          "snippet": "oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n#endif\n    touchingDB();\n    queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n    queryForgetMessagePart.bindValue(1, uid);\n    queryForgetMessagePart.bindValue(2, partId);\n    if (! queryForgetMessagePart.exec()) {\n        emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n  #endif\n      touchingDB();\n      queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n      queryForgetMessagePart.bindValue(1, uid);\n      queryForgetMessagePart.bindValue(2, partId);\n      if (! queryForgetMessagePart.exec()) {\n          emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "nreadCount)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ecentCount)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleRecentMessageCount)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.data",
          "args": [
            "oleUnreadMessageCount)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owCount(",
          "args": [
            "ndex.parent())"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "134-153",
          "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.parent",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  Variant PrettyMailboxModel::data(const QModelIndex &index, int role) const\n  {\n      if (!index.isValid())\n          return QVariant();\n  \n      if (index.column() != 0)\n          return QVariant();\n  \n      if (index.row() < 0 || index.row() >= rowCount(index.parent()) || index.model() != this)\n          return QVariant();\n  \n      switch (role) {\n      case Qt::DisplayRole:\n      {\n          QModelIndex translated = mapToSource(index);\n          qlonglong unreadCount = translated.data(RoleUnreadMessageCount).toLongLong();\n          qlonglong recentCount = translated.data(RoleRecentMessageCount).toLongLong();\n          // The \"problem\" is that the \\Recent and (lack of) \\Seen flags are orthogonal states.\n          //\n          // There is no rule saying that a recent message is still unseen (trivial example: an already-read message being copied),\n          // or that an unread message is recent.\n          //\n          // That's not really so much of a problem after the mailbox has been synced because we have all flags for each and every\n          // message, and can therefore easily compute the difference. The problem, however, is that there is no such feature\n          // in the SELECT command (and before you ask, SEARCH requires a selected mailbox, and \"selected\" is very close to\n          // \"synchronized\" in Trojita). Trojita tries to satisfy all requests for \"message numbers\" at once, via the STATUS command\n          // for unselected mailboxes, or through the already-known and cached information in the message flags for the recently\n          // synchronized ones. In theory, it is possible to implement a workaround involving EXAMINE and (E)SEARCH, but even that\n          // has its drawbacks (like the necessary serialization of requests and the requirement for a ton of new code).\n          //\n          // So in short, this is why there's no \"(1 + 5)\" result with six unread an one recent message.\n          //\n          // We also deliberately put an emphasis on the \"unread count\", even to an extent where there's no special information\n          // for mailboxes with some recent, but no unread messages.\n          if (recentCount && unreadCount) {\n              return tr(\"%1 (%2/%3)\")\n                     .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                          QString::number(recentCount), QString::number(unreadCount));\n          } else if (unreadCount) {\n              return tr(\"%1 (%2)\")\n                     .arg(QSortFilterProxyModel::data(index, RoleShortMailboxName).toString(),\n                          QString::number(unreadCount));\n          } else {\n              return QSortFilterProxyModel::data(index, RoleShortMailboxName);\n          }\n      }\n      case Qt::FontRole:\n      {\n          QModelIndex translated = mapToSource(index);\n          if (translated.data(RoleMailboxNumbersFetched).toBool() &&\n              translated.data(RoleUnreadMessageCount).toULongLong() > 0) {\n              QFont font;\n              font.setBold(true);\n              return font;\n          } else {\n              return QVariant();\n          }\n      }\n      case Qt::DecorationRole:\n      {\n          QModelIndex translated = mapToSource(index);\n          if (translated.data(RoleMailboxItemsAreLoading).toBool())\n              return Gui::loadIcon(QLatin1String(\"folder-grey\"));\n  #ifdef XTUPLE_CONNECT\n          else if (QSettings().value(Common::SettingsNames::xtSyncMailboxList).toStringList().contains(\n                       translated.data(RoleMailboxName).toString()))\n              return Gui::loadIcon(QLatin1String(\"folder-xt-sync.png\"));\n  #endif\n          else if (translated.data(RoleMailboxIsINBOX).toBool())\n              return Gui::loadIcon(QLatin1String(\"mail-folder-inbox\"));\n          else if (translated.data(RoleRecentMessageCount).toInt() > 0)\n              return Gui::loadIcon(QLatin1String(\"folder-bookmark\"));\n          else if (translated.data(RoleMailboxIsSelectable).toBool())\n              return Gui::loadIcon(QLatin1String(\"folder\"));\n          else\n              return Gui::loadIcon(QLatin1String(\"folder-open\"));\n      }\n      case Qt::ToolTipRole:\n      {\n          QModelIndex translated = mapToSource(index);\n          return tr(\"<p>%1</p>\\n<p>%2 messages<br/>%3 unread<br/>%4 recent</p>\")\n                 .arg(translated.data(RoleShortMailboxName).toString(), translated.data(RoleTotalMessageCount).toString(),\n                      translated.data(RoleUnreadMessageCount).toString(), translated.data(RoleRecentMessageCount).toString());\n      }\n      default:\n          return QSortFilterProxyModel::data(index, role);\n      }\n  }\n}"
  },
  {
    "function_name": "PrettyMailboxModel(",
    "container": "rettyMailboxModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/PrettyMailboxModel.cpp",
    "lines": "39-44",
    "snippet": "rettyMailboxModel::PrettyMailboxModel(QObject *parent, QAbstractItemModel *mailboxModel):\n    QSortFilterProxyModel(parent), m_showOnlySubscribed(false)\n{\n    setDynamicSortFilter(true);\n    setSourceModel(mailboxModel);\n}",
    "includes": [
      "include \"Gui/IconLoader.h\"",
      "include <QFont>\n#",
      "include <QSettings>\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"ItemRoles.h\"",
      "include \"PrettyMailboxModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etSourceModel(",
          "args": [
            "ailboxModel)"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "setSourceModel(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "71-109",
          "snippet": "oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n{\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n\n    if (this->sourceModel()) {\n        // there's already something, so take care to disconnect all signals\n        this->sourceModel()->disconnect(this);\n    }\n\n    RESET_MODEL;\n\n    if (!sourceModel)\n        return;\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n    Q_ASSERT(msgList);\n    QAbstractProxyModel::setSourceModel(msgList);\n\n    // FIXME: will need to be expanded when Model supports more signals...\n    connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n    connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n    connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n            this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n    resetMe();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n  {\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n  \n      if (this->sourceModel()) {\n          // there's already something, so take care to disconnect all signals\n          this->sourceModel()->disconnect(this);\n      }\n  \n      RESET_MODEL;\n  \n      if (!sourceModel)\n          return;\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n      Q_ASSERT(msgList);\n      QAbstractProxyModel::setSourceModel(msgList);\n  \n      // FIXME: will need to be expanded when Model supports more signals...\n      connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n      connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n      connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n      connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n              this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n      resetMe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etDynamicSortFilter(",
          "args": [
            "rue)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Gui/IconLoader.h\"\ninclude <QFont>\n#\ninclude <QSettings>\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"ItemRoles.h\"\ninclude \"PrettyMailboxModel.h\"\n#\n\nrettyMailboxModel {\n  rettyMailboxModel::PrettyMailboxModel(QObject *parent, QAbstractItemModel *mailboxModel):\n      QSortFilterProxyModel(parent), m_showOnlySubscribed(false)\n  {\n      setDynamicSortFilter(true);\n      setSourceModel(mailboxModel);\n  }\n}"
  }
]