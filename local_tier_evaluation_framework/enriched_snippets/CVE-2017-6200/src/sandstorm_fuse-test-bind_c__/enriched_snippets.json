[
  {
    "function_name": "run",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "71-106",
    "snippet": "kj::MainBuilder::Validity run() {\n    // Call fusermount to get the FD.\n\n    kj::UnixEventPort::captureSignal(SIGINT);\n    kj::UnixEventPort::captureSignal(SIGQUIT);\n    kj::UnixEventPort::captureSignal(SIGTERM);\n    kj::UnixEventPort::captureSignal(SIGHUP);\n\n    kj::UnixEventPort eventPort;\n    kj::EventLoop loop(eventPort);\n    kj::WaitScope waitScope(loop);\n\n    auto onSignal = eventPort.onSignal(SIGINT)\n        .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n        .exclusiveJoin(eventPort.onSignal(SIGTERM))\n        .exclusiveJoin(eventPort.onSignal(SIGHUP))\n        .then([this](siginfo_t&& sig) {\n      context.warning(kj::str(\"Shutting down due to signal: \", strsignal(sig.si_signo)));\n    });\n\n    auto root = newLoopbackFuseNode(bindTo, 1 * kj::SECONDS);\n\n    FuseMount mount(mountPoint, options);\n\n    context.warning(\"FUSE mirror mounted. Ctrl+C to unmount.\");\n\n    bindFuse(eventPort, mount.getFd(), kj::mv(root), bindOptions)\n        .then([&]() {\n          context.warning(\"Shutting down due to unmount.\");\n          mount.dontUnmount();\n        })\n        .exclusiveJoin(kj::mv(onSignal))\n        .wait(waitScope);\n\n    return true;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "waitScope"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "kj::mv(onSignal)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "onSignal"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "[&]() {\n          context.warning(\"Shutting down due to unmount.\");\n          mount.dontUnmount();\n        }"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount.dontUnmount",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dontUnmount",
          "container": "FuseMount",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.h",
          "lines": "153-153",
          "snippet": "void dontUnmount() { path = nullptr; }",
          "includes": [
            "#include <kj/refcount.h>",
            "#include <kj/function.h>",
            "#include <kj/io.h>",
            "#include <kj/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/refcount.h>\n#include <kj/function.h>\n#include <kj/io.h>\n#include <kj/time.h>\n\nFuseMount {\n  void dontUnmount() { path = nullptr; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"Shutting down due to unmount.\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "eventPort",
            "mount.getFd()",
            "kj::mv(root)",
            "bindOptions"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "bindFuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "833-838",
          "snippet": "kj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nkj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "root"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount.getFd",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "getFd",
          "container": "FuseMount",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.h",
          "lines": "150-150",
          "snippet": "inline int getFd() { return fd; }",
          "includes": [
            "#include <kj/refcount.h>",
            "#include <kj/function.h>",
            "#include <kj/io.h>",
            "#include <kj/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/refcount.h>\n#include <kj/function.h>\n#include <kj/io.h>\n#include <kj/time.h>\n\nFuseMount {\n  inline int getFd() { return fd; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"FUSE mirror mounted. Ctrl+C to unmount.\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newLoopbackFuseNode",
          "args": [
            "bindTo",
            "1 * kj::SECONDS"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "newLoopbackFuseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "1061-1063",
          "snippet": "kj::Own<fuse::Node> newLoopbackFuseNode(kj::StringPtr path, kj::Duration cacheTtl) {\n  return kj::refcounted<NodeImpl>(path, cacheTtl);\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nkj::Own<fuse::Node> newLoopbackFuseNode(kj::StringPtr path, kj::Duration cacheTtl) {\n  return kj::refcounted<NodeImpl>(path, cacheTtl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "[this](siginfo_t&& sig) {\n      context.warning(kj::str(\"Shutting down due to signal: \", strsignal(sig.si_signo)));\n    }"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\"Shutting down due to signal: \", strsignal(sig.si_signo))"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Shutting down due to signal: \"",
            "strsignal(sig.si_signo)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "sig.si_signo"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGHUP)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGHUP"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGTERM)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGTERM"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGQUIT)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGQUIT"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGINT"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGHUP"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGTERM"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGQUIT"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGINT"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainBuilder::Validity run() {\n      // Call fusermount to get the FD.\n  \n      kj::UnixEventPort::captureSignal(SIGINT);\n      kj::UnixEventPort::captureSignal(SIGQUIT);\n      kj::UnixEventPort::captureSignal(SIGTERM);\n      kj::UnixEventPort::captureSignal(SIGHUP);\n  \n      kj::UnixEventPort eventPort;\n      kj::EventLoop loop(eventPort);\n      kj::WaitScope waitScope(loop);\n  \n      auto onSignal = eventPort.onSignal(SIGINT)\n          .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n          .exclusiveJoin(eventPort.onSignal(SIGTERM))\n          .exclusiveJoin(eventPort.onSignal(SIGHUP))\n          .then([this](siginfo_t&& sig) {\n        context.warning(kj::str(\"Shutting down due to signal: \", strsignal(sig.si_signo)));\n      });\n  \n      auto root = newLoopbackFuseNode(bindTo, 1 * kj::SECONDS);\n  \n      FuseMount mount(mountPoint, options);\n  \n      context.warning(\"FUSE mirror mounted. Ctrl+C to unmount.\");\n  \n      bindFuse(eventPort, mount.getFd(), kj::mv(root), bindOptions)\n          .then([&]() {\n            context.warning(\"Shutting down due to unmount.\");\n            mount.dontUnmount();\n          })\n          .exclusiveJoin(kj::mv(onSignal))\n          .wait(waitScope);\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "setBindTo",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "66-69",
    "snippet": "kj::MainBuilder::Validity setBindTo(kj::StringPtr arg) {\n    bindTo = arg;\n    return true;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainBuilder::Validity setBindTo(kj::StringPtr arg) {\n      bindTo = arg;\n      return true;\n    }\n}"
  },
  {
    "function_name": "setMountPoint",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "61-64",
    "snippet": "kj::MainBuilder::Validity setMountPoint(kj::StringPtr arg) {\n    mountPoint = arg;\n    return true;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainBuilder::Validity setMountPoint(kj::StringPtr arg) {\n      mountPoint = arg;\n      return true;\n    }\n}"
  },
  {
    "function_name": "setCacheForever",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "56-59",
    "snippet": "kj::MainBuilder::Validity setCacheForever() {\n    bindOptions.cacheForever = true;\n    return true;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainBuilder::Validity setCacheForever() {\n      bindOptions.cacheForever = true;\n      return true;\n    }\n}"
  },
  {
    "function_name": "setOptions",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "51-54",
    "snippet": "kj::MainBuilder::Validity setOptions(kj::StringPtr arg) {\n    options = arg;\n    return true;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainBuilder::Validity setOptions(kj::StringPtr arg) {\n      options = arg;\n      return true;\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "31-42",
    "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Fuse test, unknown version\",\n          \"Mounts a fuse filesystem at <mount-point> which mirrors <source-dir>.\")\n        .addOptionWithArg({'o', \"options\"}, KJ_BIND_METHOD(*this, setOptions), \"<options>\",\n                          \"Set mount options.\")\n        .addOption({'c', \"cache-forever\"}, KJ_BIND_METHOD(*this, setCacheForever),\n                   \"Assume for caching purposes that the source directory never changes.\")\n        .expectArg(\"<mount-point>\", KJ_BIND_METHOD(*this, setMountPoint))\n        .expectArg(\"<soure-dir>\", KJ_BIND_METHOD(*this, setBindTo))\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<soure-dir>\"",
            "KJ_BIND_METHOD(*this, setBindTo)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setBindTo"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<mount-point>\"",
            "KJ_BIND_METHOD(*this, setMountPoint)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setMountPoint"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'c', \"cache-forever\"}",
            "KJ_BIND_METHOD(*this, setCacheForever)",
            "\"Assume for caching purposes that the source directory never changes.\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setCacheForever"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'o', \"options\"}",
            "KJ_BIND_METHOD(*this, setOptions)",
            "\"<options>\"",
            "\"Set mount options.\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setOptions"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Fuse test, unknown version\"",
            "\"Mounts a fuse filesystem at <mount-point> which mirrors <source-dir>.\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Fuse test, unknown version\",\n            \"Mounts a fuse filesystem at <mount-point> which mirrors <source-dir>.\")\n          .addOptionWithArg({'o', \"options\"}, KJ_BIND_METHOD(*this, setOptions), \"<options>\",\n                            \"Set mount options.\")\n          .addOption({'c', \"cache-forever\"}, KJ_BIND_METHOD(*this, setCacheForever),\n                     \"Assume for caching purposes that the source directory never changes.\")\n          .expectArg(\"<mount-point>\", KJ_BIND_METHOD(*this, setMountPoint))\n          .expectArg(\"<soure-dir>\", KJ_BIND_METHOD(*this, setBindTo))\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
  },
  {
    "function_name": "FuseTest",
    "container": "FuseTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse-test-bind.c++",
    "lines": "29-29",
    "snippet": "FuseTest(kj::ProcessContext& context): context(context) {}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include \"fuse.h\"\n\nFuseTest {\n  FuseTest(kj::ProcessContext& context): context(context) {}\n}"
  }
]