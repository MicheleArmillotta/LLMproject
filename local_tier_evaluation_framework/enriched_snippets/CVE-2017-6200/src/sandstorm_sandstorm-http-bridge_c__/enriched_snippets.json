[
  {
    "function_name": "onChildExit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2621-2632",
    "snippet": "kj::Promise<int> onChildExit(pid_t pid) {\n    int status;\n    int waitResult;\n    KJ_SYSCALL(waitResult = waitpid(pid, &status, WNOHANG));\n    if (waitResult == 0) {\n      return ioContext.unixEventPort.onSignal(SIGCHLD).then([this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      });\n    } else {\n      return status;\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::AsyncIoContext ioContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioContext.unixEventPort.onSignal",
          "args": [
            "[this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      }"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onChildExit",
          "args": [
            "pid"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "onChildExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2621-2632",
          "snippet": "kj::Promise<int> onChildExit(pid_t pid) {\n    int status;\n    int waitResult;\n    KJ_SYSCALL(waitResult = waitpid(pid, &status, WNOHANG));\n    if (waitResult == 0) {\n      return ioContext.unixEventPort.onSignal(SIGCHLD).then([this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      });\n    } else {\n      return status;\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.unixEventPort.onSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitResult = waitpid(pid, &status, WNOHANG)"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::AsyncIoContext ioContext;\n\nkj::Promise<int> onChildExit(pid_t pid) {\n    int status;\n    int waitResult;\n    KJ_SYSCALL(waitResult = waitpid(pid, &status, WNOHANG));\n    if (waitResult == 0) {\n      return ioContext.unixEventPort.onSignal(SIGCHLD).then([this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      });\n    } else {\n      return status;\n    }\n  }"
  },
  {
    "function_name": "run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2498-2613",
    "snippet": "kj::MainBuilder::Validity run() {\n    static constexpr uint PROXY_PORT = 15239;  // random; hopefully doesn't conflict with anything\n\n    auto proxyEnv = kj::str(\"http://127.0.0.1:\", PROXY_PORT, \"/\");\n    KJ_SYSCALL(setenv(\"http_proxy\", proxyEnv.cStr(), true));\n    KJ_SYSCALL(setenv(\"HTTP_PROXY\", proxyEnv.cStr(), true));\n\n    pid_t child;\n    KJ_SYSCALL(child = fork());\n    if (child == 0) {\n      // We're in the child.\n      close(3);  // Close Supervisor's Cap'n Proto socket to avoid confusion.\n\n      // Clear signal mask and reset signal disposition.\n      // TODO(cleanup): This is kind of dependent on implementation details of kj/async-unix.c++,\n      //   especially the part about SIGPIPE. It belongs in the KJ library.\n      sigset_t sigset;\n      KJ_SYSCALL(sigemptyset(&sigset));\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigset, nullptr));\n      KJ_SYSCALL(signal(SIGPIPE, SIG_DFL));\n\n      char* argv[command.size() + 1];\n      for (uint i: kj::indices(command)) {\n        argv[i] = const_cast<char*>(command[i].cStr());\n      }\n      argv[command.size()] = nullptr;\n\n      char** argvp = argv;  // work-around Clang not liking lambda + vararray\n\n      KJ_SYSCALL(execvp(argvp[0], argvp), argvp[0]);\n      KJ_UNREACHABLE;\n    } else {\n      // We're in the parent.\n\n      auto exitPromise = onChildExit(child).then([this](int status) {\n        KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n        if (WIFSIGNALED(status)) {\n          context.exitError(kj::str(\n              \"** HTTP-BRIDGE: App server exited due to signal \", WTERMSIG(status),\n              \" (\", strsignal(WTERMSIG(status)), \").\"));\n        } else {\n          context.exitError(kj::str(\n              \"** HTTP-BRIDGE: App server exited with status code: \", WEXITSTATUS(status)));\n        }\n      }).eagerlyEvaluate([this](kj::Exception&& e) {\n        context.exitError(kj::str(\n            \"** HTTP-BRIDGE: Uncaught exception waiting for child process:\\n\", e));\n      });\n\n      auto connectPromise =\n        connectLoop(address->clone(), ioContext.provider->getTimer(), false, 0);\n\n      // We potentially re-traverse the BridgeConfig on every request, so make sure to max out the\n      // traversal limit.\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = kj::maxValue;\n      capnp::StreamFdMessageReader reader(\n          raiiOpen(\"/sandstorm-http-bridge-config\", O_RDONLY), options);\n      auto config = reader.getRoot<spk::BridgeConfig>();\n\n      auto apiPaf = kj::newPromiseAndFulfiller<SandstormApi<BridgeObjectId>::Client>();\n      BridgeContext bridgeContext(kj::mv(apiPaf.promise), config);\n\n      // Set up the Supervisor API socket.\n      auto stream = ioContext.lowLevelProvider->wrapSocketFd(3);\n      capnp::TwoPartyVatNetwork network(*stream, capnp::rpc::twoparty::Side::CLIENT);\n      auto rpcSystem = capnp::makeRpcServer(\n        network,\n        kj::heap<UiViewImpl>(*address, bridgeContext, config, kj::mv(connectPromise)));\n\n      // Get the SandstormApi by restoring a null SturdyRef.\n      capnp::MallocMessageBuilder message;\n      auto vatId = message.initRoot<capnp::rpc::twoparty::VatId>();\n      vatId.setSide(capnp::rpc::twoparty::Side::SERVER);\n      SandstormApi<BridgeObjectId>::Client api = rpcSystem.bootstrap(vatId)\n          .castAs<SandstormApi<BridgeObjectId>>();\n      apiPaf.fulfiller->fulfill(kj::cp(api));\n\n      // Export a Unix socket on which the application can connect and make calls directly to the\n      // Sandstorm API.\n      SandstormHttpBridge::Client sandstormHttpBridge =\n          kj::heap<SandstormHttpBridgeImpl>(kj::cp(api), bridgeContext);\n      ErrorHandlerImpl errorHandler;\n      kj::TaskSet tasks(errorHandler);\n      unlink(\"/tmp/sandstorm-api\");  // Clear stale socket, if any.\n      auto acceptTask = ioContext.provider->getNetwork()\n          .parseAddress(\"unix:/tmp/sandstorm-api\", 0)\n          .then([&, sandstormHttpBridge](kj::Own<kj::NetworkAddress>&& addr) mutable {\n        auto serverPort = addr->listen();\n        auto promise = acceptLoop(*serverPort, kj::mv(sandstormHttpBridge), tasks);\n        return promise.attach(kj::mv(serverPort));\n      });\n\n      // Export an HTTP proxy which the app can use to make HTTP API requests.\n      kj::HttpHeaderTable::Builder headerTableBuilder;\n      auto bridgeProxy = newBridgeProxy(api, sandstormHttpBridge, config, headerTableBuilder);\n      auto headerTable = headerTableBuilder.build();\n\n      // No need for request timeouts on this proxy. We trust the app.\n      kj::HttpServer::Settings settings;\n      settings.headerTimeout = 1 * kj::DAYS;\n      settings.pipelineTimeout = 1 * kj::DAYS;\n      kj::HttpServer server(ioContext.provider->getTimer(), *headerTable, *bridgeProxy, settings);\n\n      auto proxyAddress = ioContext.provider->getNetwork()\n          .parseAddress(\"127.0.0.1\", PROXY_PORT).wait(ioContext.waitScope);\n      auto proxyListener = proxyAddress->listen();\n      auto listenTask = server.listenHttp(*proxyListener)\n          .eagerlyEvaluate([this](kj::Exception&& e) {\n        context.exitError(kj::str(\"** HTTP-BRIDGE: Outgoing HTTP proxy died; aborting:\\n\", e));\n      });\n\n      exitPromise.wait(ioContext.waitScope);\n      KJ_UNREACHABLE;  // exitPromise always exits before completing\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "spk::BridgeConfig::Reader config;",
      "kj::AsyncIoContext ioContext;",
      "kj::Own<kj::NetworkAddress> address;",
      "kj::Vector<kj::String> command;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exitPromise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.listenHttp",
          "args": [
            "[this](kj::Exception&& e) {\n        context.exitError(kj::str(\"** HTTP-BRIDGE: Outgoing HTTP proxy died; aborting:\\n\", e));\n      }"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"** HTTP-BRIDGE: Outgoing HTTP proxy died; aborting:\\n\", e)"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** HTTP-BRIDGE: Outgoing HTTP proxy died; aborting:\\n\"",
            "e"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.listenHttp",
          "args": [
            "*proxyListener"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proxyAddress->listen",
          "args": [],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"127.0.0.1\"",
            "PROXY_PORT"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headerTableBuilder.build",
          "args": [],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBridgeProxy",
          "args": [
            "api",
            "sandstormHttpBridge",
            "config",
            "headerTableBuilder"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "newBridgeProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "763-769",
          "snippet": "kj::Own<kj::HttpService> newBridgeProxy(\n    SandstormApi<BridgeObjectId>::Client sandstormApi,\n    SandstormHttpBridge::Client bridge,\n    spk::BridgeConfig::Reader config,\n    kj::HttpHeaderTable::Builder& requestHeaders) {\n  return kj::heap<BridgeProxy>(kj::mv(sandstormApi), kj::mv(bridge), config, requestHeaders);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Own<kj::HttpService> newBridgeProxy(\n    SandstormApi<BridgeObjectId>::Client sandstormApi,\n    SandstormHttpBridge::Client bridge,\n    spk::BridgeConfig::Reader config,\n    kj::HttpHeaderTable::Builder& requestHeaders) {\n  return kj::heap<BridgeProxy>(kj::mv(sandstormApi), kj::mv(bridge), config, requestHeaders);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "[&, sandstormHttpBridge](kj::Own<kj::NetworkAddress>&& addr) mutable {\n        auto serverPort = addr->listen();\n        auto promise = acceptLoop(*serverPort, kj::mv(sandstormHttpBridge), tasks);\n        return promise.attach(kj::mv(serverPort));\n      }"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(serverPort)"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "serverPort"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "*serverPort",
            "kj::mv(sandstormHttpBridge)",
            "tasks"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sandstormHttpBridge"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->listen",
          "args": [],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"unix:/tmp/sandstorm-api\"",
            "0"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "\"/tmp/sandstorm-api\""
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<SandstormHttpBridgeImpl>",
          "args": [
            "kj::cp(api)",
            "bridgeContext"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "api"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apiPaf.fulfiller->fulfill",
          "args": [
            "kj::cp(api)"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "api"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcSystem.bootstrap",
          "args": [],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcSystem.bootstrap",
          "args": [
            "vatId"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vatId.setSide",
          "args": [
            "capnp::rpc::twoparty::Side::SERVER"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.initRoot<capnp::rpc::twoparty::VatId>",
          "args": [],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::makeRpcServer",
          "args": [
            "network",
            "kj::heap<UiViewImpl>(*address, bridgeContext, config, kj::mv(connectPromise))"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<UiViewImpl>",
          "args": [
            "*address",
            "bridgeContext",
            "config",
            "kj::mv(connectPromise)"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectPromise"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.lowLevelProvider->wrapSocketFd",
          "args": [
            "3"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "apiPaf.promise"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<SandstormApi<BridgeObjectId>::Client>",
          "args": [],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<spk::BridgeConfig>",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/sandstorm-http-bridge-config\"",
            "O_RDONLY"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectLoop",
          "args": [
            "address->clone()",
            "ioContext.provider->getTimer()",
            "false",
            "0"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<void> connectLoop",
          "container": "kj",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2396-2489",
          "snippet": "class SandstormHttpBridgeMain {\n  // Main class for the Sandstorm HTTP bridge. This program is meant to run inside an\n  // application sandbox where it translates incoming requests back from HTTP-over-RPC to regular\n  // HTTP.  This is a shim meant to make it easy to port existing web frameworks into Sandstorm,\n  // but long-term apps should seek to drop this binary and instead speak Cap'n Proto directly.\n  // It is up to the app to include this binary in their package if they want it.\n\npublic:\n  SandstormHttpBridgeMain(kj::ProcessContext& context)\n      : context(context),\n        ioContext(kj::setupAsyncIo()) {\n    kj::UnixEventPort::captureSignal(SIGCHLD);\n  }\n\n  kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                           \"connect to it as an HTTP server at the given address (typically, \"\n                           \"'127.0.0.1:<port>') in order to handle incoming requests.\")\n        .expectArg(\"<port>\", KJ_BIND_METHOD(*this, setPort))\n        .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }\n\n  kj::MainBuilder::Validity setPort(kj::StringPtr port) {\n    return ioContext.provider->getNetwork().parseAddress(kj::str(\"127.0.0.1:\", port))\n        .then([this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n      this->address = kj::mv(parsedAddr);\n      return true;\n    }, [](kj::Exception&& e) -> kj::MainBuilder::Validity {\n      return \"invalid port\";\n    }).wait(ioContext.waitScope);\n  }\n\n  kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n    command.add(kj::heapString(arg));\n    return true;\n  }\n\n  struct AcceptedConnection {\n    kj::Own<kj::AsyncIoStream> connection;\n    capnp::TwoPartyVatNetwork network;\n    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcSystem;\n\n    explicit AcceptedConnection(SandstormHttpBridge::Client bridge,\n                                kj::Own<kj::AsyncIoStream>&& connectionParam)\n      : connection(kj::mv(connectionParam)),\n        network(*connection, capnp::rpc::twoparty::Side::SERVER),\n        rpcSystem(capnp::makeRpcServer(network, bridge)) {}\n  };\n\n  kj::Promise<void> acceptLoop(kj::ConnectionReceiver& serverPort,\n                               SandstormHttpBridge::Client bridge,\n                               kj::TaskSet& taskSet) {\n    return serverPort.accept().then(\n        [&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      auto connectionState = kj::heap<AcceptedConnection>(bridge, kj::mv(connection));\n      auto promise = connectionState->network.onDisconnect();\n      taskSet.add(promise.attach(kj::mv(connectionState)));\n      return acceptLoop(serverPort, kj::mv(bridge), taskSet);\n    });\n  }\n\n  kj::Promise<void> connectLoop(kj::Own<kj::NetworkAddress>&& address,\n                                kj::Timer& timer,\n                                bool loggedSlowStartupMessage,\n                                int numTriesSoFar) {\n    return address->connect().then([this, loggedSlowStartupMessage](auto x) -> void {\n      if (loggedSlowStartupMessage) {\n        KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n      }\n    }).catch_(\n        [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n        (kj::Exception&& e) mutable {\n      if (!loggedSlowStartupMessage) {\n        numTriesSoFar++;\n      }\n      if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n        // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n        KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n               \"to attempt to connect\",\n               address->toString());\n        loggedSlowStartupMessage = true;\n      }\n      // Wait 10ms and try again.\n      return timer.afterDelay(10 * kj::MILLISECONDS).then(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          () mutable -> kj::Promise<void> {\n        return connectLoop(kj::mv(address), timer,\n                           loggedSlowStartupMessage, numTriesSoFar);\n      });\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::AsyncIoContext ioContext;",
            "kj::Own<kj::NetworkAddress> address;",
            "kj::Vector<kj::String> command;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::AsyncIoContext ioContext;\nkj::Own<kj::NetworkAddress> address;\nkj::Vector<kj::String> command;\n\nkj {\n  class SandstormHttpBridgeMain {\n    // Main class for the Sandstorm HTTP bridge. This program is meant to run inside an\n    // application sandbox where it translates incoming requests back from HTTP-over-RPC to regular\n    // HTTP.  This is a shim meant to make it easy to port existing web frameworks into Sandstorm,\n    // but long-term apps should seek to drop this binary and instead speak Cap'n Proto directly.\n    // It is up to the app to include this binary in their package if they want it.\n  \n  public:\n    SandstormHttpBridgeMain(kj::ProcessContext& context)\n        : context(context),\n          ioContext(kj::setupAsyncIo()) {\n      kj::UnixEventPort::captureSignal(SIGCHLD);\n    }\n  \n    kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                             \"connect to it as an HTTP server at the given address (typically, \"\n                             \"'127.0.0.1:<port>') in order to handle incoming requests.\")\n          .expectArg(\"<port>\", KJ_BIND_METHOD(*this, setPort))\n          .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n  \n    kj::MainBuilder::Validity setPort(kj::StringPtr port) {\n      return ioContext.provider->getNetwork().parseAddress(kj::str(\"127.0.0.1:\", port))\n          .then([this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n        this->address = kj::mv(parsedAddr);\n        return true;\n      }, [](kj::Exception&& e) -> kj::MainBuilder::Validity {\n        return \"invalid port\";\n      }).wait(ioContext.waitScope);\n    }\n  \n    kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n      command.add(kj::heapString(arg));\n      return true;\n    }\n  \n    struct AcceptedConnection {\n      kj::Own<kj::AsyncIoStream> connection;\n      capnp::TwoPartyVatNetwork network;\n      capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcSystem;\n  \n      explicit AcceptedConnection(SandstormHttpBridge::Client bridge,\n                                  kj::Own<kj::AsyncIoStream>&& connectionParam)\n        : connection(kj::mv(connectionParam)),\n          network(*connection, capnp::rpc::twoparty::Side::SERVER),\n          rpcSystem(capnp::makeRpcServer(network, bridge)) {}\n    };\n  \n    kj::Promise<void> acceptLoop(kj::ConnectionReceiver& serverPort,\n                                 SandstormHttpBridge::Client bridge,\n                                 kj::TaskSet& taskSet) {\n      return serverPort.accept().then(\n          [&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n        auto connectionState = kj::heap<AcceptedConnection>(bridge, kj::mv(connection));\n        auto promise = connectionState->network.onDisconnect();\n        taskSet.add(promise.attach(kj::mv(connectionState)));\n        return acceptLoop(serverPort, kj::mv(bridge), taskSet);\n      });\n    }\n  \n    kj::Promise<void> connectLoop(kj::Own<kj::NetworkAddress>&& address,\n                                  kj::Timer& timer,\n                                  bool loggedSlowStartupMessage,\n                                  int numTriesSoFar) {\n      return address->connect().then([this, loggedSlowStartupMessage](auto x) -> void {\n        if (loggedSlowStartupMessage) {\n          KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n        }\n      }).catch_(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          (kj::Exception&& e) mutable {\n        if (!loggedSlowStartupMessage) {\n          numTriesSoFar++;\n        }\n        if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n          // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n          KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n                 \"to attempt to connect\",\n                 address->toString());\n          loggedSlowStartupMessage = true;\n        }\n        // Wait 10ms and try again.\n        return timer.afterDelay(10 * kj::MILLISECONDS).then(\n            [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n            () mutable -> kj::Promise<void> {\n          return connectLoop(kj::mv(address), timer,\n                             loggedSlowStartupMessage, numTriesSoFar);\n        });\n      });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address->clone",
          "args": [],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onChildExit",
          "args": [
            "[this](kj::Exception&& e) {\n        context.exitError(kj::str(\n            \"** HTTP-BRIDGE: Uncaught exception waiting for child process:\\n\", e));\n      }"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "onChildExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2621-2632",
          "snippet": "kj::Promise<int> onChildExit(pid_t pid) {\n    int status;\n    int waitResult;\n    KJ_SYSCALL(waitResult = waitpid(pid, &status, WNOHANG));\n    if (waitResult == 0) {\n      return ioContext.unixEventPort.onSignal(SIGCHLD).then([this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      });\n    } else {\n      return status;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::AsyncIoContext ioContext;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::AsyncIoContext ioContext;\n\nkj::Promise<int> onChildExit(pid_t pid) {\n    int status;\n    int waitResult;\n    KJ_SYSCALL(waitResult = waitpid(pid, &status, WNOHANG));\n    if (waitResult == 0) {\n      return ioContext.unixEventPort.onSignal(SIGCHLD).then([this,pid](siginfo_t&& info) {\n        return onChildExit(pid);\n      });\n    } else {\n      return status;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n            \"** HTTP-BRIDGE: Uncaught exception waiting for child process:\\n\", e)"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** HTTP-BRIDGE: Uncaught exception waiting for child process:\\n\"",
            "e"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n              \"** HTTP-BRIDGE: App server exited with status code: \", WEXITSTATUS(status))"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** HTTP-BRIDGE: App server exited with status code: \"",
            "WEXITSTATUS(status)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n              \"** HTTP-BRIDGE: App server exited due to signal \", WTERMSIG(status),\n              \" (\", strsignal(WTERMSIG(status)), \").\")"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** HTTP-BRIDGE: App server exited due to signal \"",
            "WTERMSIG(status)",
            "\" (\"",
            "strsignal(WTERMSIG(status))",
            "\").\""
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "WTERMSIG(status)"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "WIFEXITED(status) || WIFSIGNALED(status)"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execvp(argvp[0], argvp)",
            "argvp[0]"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argvp[0]",
            "argvp"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.size",
          "args": [],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "command[i].cStr()"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command[i].cStr",
          "args": [],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "command"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "signal(SIGPIPE, SIG_DFL)"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_DFL"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &sigset, nullptr)"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigset",
            "nullptr"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&sigset)"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sigset"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "3"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "child = fork()"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setenv(\"HTTP_PROXY\", proxyEnv.cStr(), true)"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"HTTP_PROXY\"",
            "proxyEnv.cStr()",
            "true"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proxyEnv.cStr",
          "args": [],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setenv(\"http_proxy\", proxyEnv.cStr(), true)"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"http_proxy\"",
            "proxyEnv.cStr()",
            "true"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proxyEnv.cStr",
          "args": [],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"http://127.0.0.1:\"",
            "PROXY_PORT",
            "\"/\""
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nspk::BridgeConfig::Reader config;\nkj::AsyncIoContext ioContext;\nkj::Own<kj::NetworkAddress> address;\nkj::Vector<kj::String> command;\n\nkj::MainBuilder::Validity run() {\n    static constexpr uint PROXY_PORT = 15239;  // random; hopefully doesn't conflict with anything\n\n    auto proxyEnv = kj::str(\"http://127.0.0.1:\", PROXY_PORT, \"/\");\n    KJ_SYSCALL(setenv(\"http_proxy\", proxyEnv.cStr(), true));\n    KJ_SYSCALL(setenv(\"HTTP_PROXY\", proxyEnv.cStr(), true));\n\n    pid_t child;\n    KJ_SYSCALL(child = fork());\n    if (child == 0) {\n      // We're in the child.\n      close(3);  // Close Supervisor's Cap'n Proto socket to avoid confusion.\n\n      // Clear signal mask and reset signal disposition.\n      // TODO(cleanup): This is kind of dependent on implementation details of kj/async-unix.c++,\n      //   especially the part about SIGPIPE. It belongs in the KJ library.\n      sigset_t sigset;\n      KJ_SYSCALL(sigemptyset(&sigset));\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigset, nullptr));\n      KJ_SYSCALL(signal(SIGPIPE, SIG_DFL));\n\n      char* argv[command.size() + 1];\n      for (uint i: kj::indices(command)) {\n        argv[i] = const_cast<char*>(command[i].cStr());\n      }\n      argv[command.size()] = nullptr;\n\n      char** argvp = argv;  // work-around Clang not liking lambda + vararray\n\n      KJ_SYSCALL(execvp(argvp[0], argvp), argvp[0]);\n      KJ_UNREACHABLE;\n    } else {\n      // We're in the parent.\n\n      auto exitPromise = onChildExit(child).then([this](int status) {\n        KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n        if (WIFSIGNALED(status)) {\n          context.exitError(kj::str(\n              \"** HTTP-BRIDGE: App server exited due to signal \", WTERMSIG(status),\n              \" (\", strsignal(WTERMSIG(status)), \").\"));\n        } else {\n          context.exitError(kj::str(\n              \"** HTTP-BRIDGE: App server exited with status code: \", WEXITSTATUS(status)));\n        }\n      }).eagerlyEvaluate([this](kj::Exception&& e) {\n        context.exitError(kj::str(\n            \"** HTTP-BRIDGE: Uncaught exception waiting for child process:\\n\", e));\n      });\n\n      auto connectPromise =\n        connectLoop(address->clone(), ioContext.provider->getTimer(), false, 0);\n\n      // We potentially re-traverse the BridgeConfig on every request, so make sure to max out the\n      // traversal limit.\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = kj::maxValue;\n      capnp::StreamFdMessageReader reader(\n          raiiOpen(\"/sandstorm-http-bridge-config\", O_RDONLY), options);\n      auto config = reader.getRoot<spk::BridgeConfig>();\n\n      auto apiPaf = kj::newPromiseAndFulfiller<SandstormApi<BridgeObjectId>::Client>();\n      BridgeContext bridgeContext(kj::mv(apiPaf.promise), config);\n\n      // Set up the Supervisor API socket.\n      auto stream = ioContext.lowLevelProvider->wrapSocketFd(3);\n      capnp::TwoPartyVatNetwork network(*stream, capnp::rpc::twoparty::Side::CLIENT);\n      auto rpcSystem = capnp::makeRpcServer(\n        network,\n        kj::heap<UiViewImpl>(*address, bridgeContext, config, kj::mv(connectPromise)));\n\n      // Get the SandstormApi by restoring a null SturdyRef.\n      capnp::MallocMessageBuilder message;\n      auto vatId = message.initRoot<capnp::rpc::twoparty::VatId>();\n      vatId.setSide(capnp::rpc::twoparty::Side::SERVER);\n      SandstormApi<BridgeObjectId>::Client api = rpcSystem.bootstrap(vatId)\n          .castAs<SandstormApi<BridgeObjectId>>();\n      apiPaf.fulfiller->fulfill(kj::cp(api));\n\n      // Export a Unix socket on which the application can connect and make calls directly to the\n      // Sandstorm API.\n      SandstormHttpBridge::Client sandstormHttpBridge =\n          kj::heap<SandstormHttpBridgeImpl>(kj::cp(api), bridgeContext);\n      ErrorHandlerImpl errorHandler;\n      kj::TaskSet tasks(errorHandler);\n      unlink(\"/tmp/sandstorm-api\");  // Clear stale socket, if any.\n      auto acceptTask = ioContext.provider->getNetwork()\n          .parseAddress(\"unix:/tmp/sandstorm-api\", 0)\n          .then([&, sandstormHttpBridge](kj::Own<kj::NetworkAddress>&& addr) mutable {\n        auto serverPort = addr->listen();\n        auto promise = acceptLoop(*serverPort, kj::mv(sandstormHttpBridge), tasks);\n        return promise.attach(kj::mv(serverPort));\n      });\n\n      // Export an HTTP proxy which the app can use to make HTTP API requests.\n      kj::HttpHeaderTable::Builder headerTableBuilder;\n      auto bridgeProxy = newBridgeProxy(api, sandstormHttpBridge, config, headerTableBuilder);\n      auto headerTable = headerTableBuilder.build();\n\n      // No need for request timeouts on this proxy. We trust the app.\n      kj::HttpServer::Settings settings;\n      settings.headerTimeout = 1 * kj::DAYS;\n      settings.pipelineTimeout = 1 * kj::DAYS;\n      kj::HttpServer server(ioContext.provider->getTimer(), *headerTable, *bridgeProxy, settings);\n\n      auto proxyAddress = ioContext.provider->getNetwork()\n          .parseAddress(\"127.0.0.1\", PROXY_PORT).wait(ioContext.waitScope);\n      auto proxyListener = proxyAddress->listen();\n      auto listenTask = server.listenHttp(*proxyListener)\n          .eagerlyEvaluate([this](kj::Exception&& e) {\n        context.exitError(kj::str(\"** HTTP-BRIDGE: Outgoing HTTP proxy died; aborting:\\n\", e));\n      });\n\n      exitPromise.wait(ioContext.waitScope);\n      KJ_UNREACHABLE;  // exitPromise always exits before completing\n    }\n  }"
  },
  {
    "function_name": "taskFailed",
    "container": "ErrorHandlerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2493-2495",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, \"connection failed\", exception);\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"connection failed\"",
            "exception"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nErrorHandlerImpl {\n  void taskFailed(kj::Exception&& exception) override {\n        KJ_LOG(ERROR, \"connection failed\", exception);\n      }\n}"
  },
  {
    "function_name": "Promise<void> connectLoop",
    "container": "kj",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2396-2489",
    "snippet": "class SandstormHttpBridgeMain {\n  // Main class for the Sandstorm HTTP bridge. This program is meant to run inside an\n  // application sandbox where it translates incoming requests back from HTTP-over-RPC to regular\n  // HTTP.  This is a shim meant to make it easy to port existing web frameworks into Sandstorm,\n  // but long-term apps should seek to drop this binary and instead speak Cap'n Proto directly.\n  // It is up to the app to include this binary in their package if they want it.\n\npublic:\n  SandstormHttpBridgeMain(kj::ProcessContext& context)\n      : context(context),\n        ioContext(kj::setupAsyncIo()) {\n    kj::UnixEventPort::captureSignal(SIGCHLD);\n  }\n\n  kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                           \"connect to it as an HTTP server at the given address (typically, \"\n                           \"'127.0.0.1:<port>') in order to handle incoming requests.\")\n        .expectArg(\"<port>\", KJ_BIND_METHOD(*this, setPort))\n        .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }\n\n  kj::MainBuilder::Validity setPort(kj::StringPtr port) {\n    return ioContext.provider->getNetwork().parseAddress(kj::str(\"127.0.0.1:\", port))\n        .then([this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n      this->address = kj::mv(parsedAddr);\n      return true;\n    }, [](kj::Exception&& e) -> kj::MainBuilder::Validity {\n      return \"invalid port\";\n    }).wait(ioContext.waitScope);\n  }\n\n  kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n    command.add(kj::heapString(arg));\n    return true;\n  }\n\n  struct AcceptedConnection {\n    kj::Own<kj::AsyncIoStream> connection;\n    capnp::TwoPartyVatNetwork network;\n    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcSystem;\n\n    explicit AcceptedConnection(SandstormHttpBridge::Client bridge,\n                                kj::Own<kj::AsyncIoStream>&& connectionParam)\n      : connection(kj::mv(connectionParam)),\n        network(*connection, capnp::rpc::twoparty::Side::SERVER),\n        rpcSystem(capnp::makeRpcServer(network, bridge)) {}\n  };\n\n  kj::Promise<void> acceptLoop(kj::ConnectionReceiver& serverPort,\n                               SandstormHttpBridge::Client bridge,\n                               kj::TaskSet& taskSet) {\n    return serverPort.accept().then(\n        [&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      auto connectionState = kj::heap<AcceptedConnection>(bridge, kj::mv(connection));\n      auto promise = connectionState->network.onDisconnect();\n      taskSet.add(promise.attach(kj::mv(connectionState)));\n      return acceptLoop(serverPort, kj::mv(bridge), taskSet);\n    });\n  }\n\n  kj::Promise<void> connectLoop(kj::Own<kj::NetworkAddress>&& address,\n                                kj::Timer& timer,\n                                bool loggedSlowStartupMessage,\n                                int numTriesSoFar) {\n    return address->connect().then([this, loggedSlowStartupMessage](auto x) -> void {\n      if (loggedSlowStartupMessage) {\n        KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n      }\n    }).catch_(\n        [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n        (kj::Exception&& e) mutable {\n      if (!loggedSlowStartupMessage) {\n        numTriesSoFar++;\n      }\n      if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n        // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n        KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n               \"to attempt to connect\",\n               address->toString());\n        loggedSlowStartupMessage = true;\n      }\n      // Wait 10ms and try again.\n      return timer.afterDelay(10 * kj::MILLISECONDS).then(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          () mutable -> kj::Promise<void> {\n        return connectLoop(kj::mv(address), timer,\n                           loggedSlowStartupMessage, numTriesSoFar);\n      });\n    });\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::AsyncIoContext ioContext;",
      "kj::Own<kj::NetworkAddress> address;",
      "kj::Vector<kj::String> command;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "address->connect",
          "args": [
            "[KJ_MVCAP(address)",
            "&timer",
            "loggedSlowStartupMessage",
            "numTriesSoFar",
            "this]\n        (kj::Exception&& e) mutable{\n      if (!loggedSlowStartupMessage) {\n        numTriesSoFar++;\n      }\n      if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n        // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n        KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n               \"to attempt to connect\",\n               address->toString());\n        loggedSlowStartupMessage = true;\n      }\n      // Wait 10ms and try again.\n      return timer.afterDelay(10 * kj::MILLISECONDS).then(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          () mutable -> kj::Promise<void> {\n        return connectLoop(kj::mv(address), timer,\n                           loggedSlowStartupMessage, numTriesSoFar);\n      });\n    }"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "[KJ_MVCAP(address)",
            "&timer",
            "loggedSlowStartupMessage",
            "numTriesSoFar",
            "this]\n          () mutable -> kj::Promise<void>{\n        return connectLoop(kj::mv(address), timer,\n                           loggedSlowStartupMessage, numTriesSoFar);\n      }"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectLoop",
          "args": [
            "kj::mv(address)",
            "timer",
            "loggedSlowStartupMessage",
            "numTriesSoFar"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<void> connectLoop",
          "container": "kj",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2396-2489",
          "snippet": "class SandstormHttpBridgeMain {\n  // Main class for the Sandstorm HTTP bridge. This program is meant to run inside an\n  // application sandbox where it translates incoming requests back from HTTP-over-RPC to regular\n  // HTTP.  This is a shim meant to make it easy to port existing web frameworks into Sandstorm,\n  // but long-term apps should seek to drop this binary and instead speak Cap'n Proto directly.\n  // It is up to the app to include this binary in their package if they want it.\n\npublic:\n  SandstormHttpBridgeMain(kj::ProcessContext& context)\n      : context(context),\n        ioContext(kj::setupAsyncIo()) {\n    kj::UnixEventPort::captureSignal(SIGCHLD);\n  }\n\n  kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                           \"connect to it as an HTTP server at the given address (typically, \"\n                           \"'127.0.0.1:<port>') in order to handle incoming requests.\")\n        .expectArg(\"<port>\", KJ_BIND_METHOD(*this, setPort))\n        .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }\n\n  kj::MainBuilder::Validity setPort(kj::StringPtr port) {\n    return ioContext.provider->getNetwork().parseAddress(kj::str(\"127.0.0.1:\", port))\n        .then([this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n      this->address = kj::mv(parsedAddr);\n      return true;\n    }, [](kj::Exception&& e) -> kj::MainBuilder::Validity {\n      return \"invalid port\";\n    }).wait(ioContext.waitScope);\n  }\n\n  kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n    command.add(kj::heapString(arg));\n    return true;\n  }\n\n  struct AcceptedConnection {\n    kj::Own<kj::AsyncIoStream> connection;\n    capnp::TwoPartyVatNetwork network;\n    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcSystem;\n\n    explicit AcceptedConnection(SandstormHttpBridge::Client bridge,\n                                kj::Own<kj::AsyncIoStream>&& connectionParam)\n      : connection(kj::mv(connectionParam)),\n        network(*connection, capnp::rpc::twoparty::Side::SERVER),\n        rpcSystem(capnp::makeRpcServer(network, bridge)) {}\n  };\n\n  kj::Promise<void> acceptLoop(kj::ConnectionReceiver& serverPort,\n                               SandstormHttpBridge::Client bridge,\n                               kj::TaskSet& taskSet) {\n    return serverPort.accept().then(\n        [&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      auto connectionState = kj::heap<AcceptedConnection>(bridge, kj::mv(connection));\n      auto promise = connectionState->network.onDisconnect();\n      taskSet.add(promise.attach(kj::mv(connectionState)));\n      return acceptLoop(serverPort, kj::mv(bridge), taskSet);\n    });\n  }\n\n  kj::Promise<void> connectLoop(kj::Own<kj::NetworkAddress>&& address,\n                                kj::Timer& timer,\n                                bool loggedSlowStartupMessage,\n                                int numTriesSoFar) {\n    return address->connect().then([this, loggedSlowStartupMessage](auto x) -> void {\n      if (loggedSlowStartupMessage) {\n        KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n      }\n    }).catch_(\n        [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n        (kj::Exception&& e) mutable {\n      if (!loggedSlowStartupMessage) {\n        numTriesSoFar++;\n      }\n      if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n        // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n        KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n               \"to attempt to connect\",\n               address->toString());\n        loggedSlowStartupMessage = true;\n      }\n      // Wait 10ms and try again.\n      return timer.afterDelay(10 * kj::MILLISECONDS).then(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          () mutable -> kj::Promise<void> {\n        return connectLoop(kj::mv(address), timer,\n                           loggedSlowStartupMessage, numTriesSoFar);\n      });\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "address"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "]",
          "args": [],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "10 * kj::MILLISECONDS"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"App isn't listening for TCP connections after 30 seconds. Continuing \"\n               \"to attempt to connect\"",
            "address->toString()"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address->toString",
          "args": [],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "]",
          "args": [
            "kj::Exception&& e"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address->connect",
          "args": [
            "[this, loggedSlowStartupMessage](auto x) -> void {\n      if (loggedSlowStartupMessage) {\n        KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n      }\n    }"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"App successfully started listening for TCP connections!\""
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address->connect",
          "args": [],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "serverPort",
            "kj::mv(bridge)",
            "taskSet"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bridge"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.add",
          "args": [
            "promise.attach(kj::mv(connectionState))"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(connectionState)"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionState"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->network.onDisconnect",
          "args": [],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "70-70",
          "snippet": "inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<AcceptedConnection>",
          "args": [
            "bridge",
            "kj::mv(connection)"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connection"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverPort.accept",
          "args": [
            "[&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverPort.accept",
          "args": [],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::makeRpcServer",
          "args": [
            "network",
            "bridge"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionParam"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.add",
          "args": [
            "kj::heapString(arg)"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "arg"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "[this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n      this->address = kj::mv(parsedAddr);\n      return true;\n    }",
            "[](kj::Exception&& e) -> kj::MainBuilder::Validity {\n      return \"invalid port\";\n    }"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "parsedAddr"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "kj::str(\"127.0.0.1:\", port)"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"127.0.0.1:\"",
            "port"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<command>\"",
            "KJ_BIND_METHOD(*this, addCommandArg)"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addCommandArg"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<port>\"",
            "KJ_BIND_METHOD(*this, setPort)"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setPort"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                           \"connect to it as an HTTP server at the given address (typically, \"\n                           \"'127.0.0.1:<port>') in order to handle incoming requests.\""
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::AsyncIoContext ioContext;\nkj::Own<kj::NetworkAddress> address;\nkj::Vector<kj::String> command;\n\nkj {\n  class SandstormHttpBridgeMain {\n    // Main class for the Sandstorm HTTP bridge. This program is meant to run inside an\n    // application sandbox where it translates incoming requests back from HTTP-over-RPC to regular\n    // HTTP.  This is a shim meant to make it easy to port existing web frameworks into Sandstorm,\n    // but long-term apps should seek to drop this binary and instead speak Cap'n Proto directly.\n    // It is up to the app to include this binary in their package if they want it.\n  \n  public:\n    SandstormHttpBridgeMain(kj::ProcessContext& context)\n        : context(context),\n          ioContext(kj::setupAsyncIo()) {\n      kj::UnixEventPort::captureSignal(SIGCHLD);\n    }\n  \n    kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Acts as a Sandstorm init application.  Runs <command>, then tries to \"\n                             \"connect to it as an HTTP server at the given address (typically, \"\n                             \"'127.0.0.1:<port>') in order to handle incoming requests.\")\n          .expectArg(\"<port>\", KJ_BIND_METHOD(*this, setPort))\n          .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n  \n    kj::MainBuilder::Validity setPort(kj::StringPtr port) {\n      return ioContext.provider->getNetwork().parseAddress(kj::str(\"127.0.0.1:\", port))\n          .then([this](kj::Own<kj::NetworkAddress>&& parsedAddr) -> kj::MainBuilder::Validity {\n        this->address = kj::mv(parsedAddr);\n        return true;\n      }, [](kj::Exception&& e) -> kj::MainBuilder::Validity {\n        return \"invalid port\";\n      }).wait(ioContext.waitScope);\n    }\n  \n    kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n      command.add(kj::heapString(arg));\n      return true;\n    }\n  \n    struct AcceptedConnection {\n      kj::Own<kj::AsyncIoStream> connection;\n      capnp::TwoPartyVatNetwork network;\n      capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcSystem;\n  \n      explicit AcceptedConnection(SandstormHttpBridge::Client bridge,\n                                  kj::Own<kj::AsyncIoStream>&& connectionParam)\n        : connection(kj::mv(connectionParam)),\n          network(*connection, capnp::rpc::twoparty::Side::SERVER),\n          rpcSystem(capnp::makeRpcServer(network, bridge)) {}\n    };\n  \n    kj::Promise<void> acceptLoop(kj::ConnectionReceiver& serverPort,\n                                 SandstormHttpBridge::Client bridge,\n                                 kj::TaskSet& taskSet) {\n      return serverPort.accept().then(\n          [&, KJ_MVCAP(bridge)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n        auto connectionState = kj::heap<AcceptedConnection>(bridge, kj::mv(connection));\n        auto promise = connectionState->network.onDisconnect();\n        taskSet.add(promise.attach(kj::mv(connectionState)));\n        return acceptLoop(serverPort, kj::mv(bridge), taskSet);\n      });\n    }\n  \n    kj::Promise<void> connectLoop(kj::Own<kj::NetworkAddress>&& address,\n                                  kj::Timer& timer,\n                                  bool loggedSlowStartupMessage,\n                                  int numTriesSoFar) {\n      return address->connect().then([this, loggedSlowStartupMessage](auto x) -> void {\n        if (loggedSlowStartupMessage) {\n          KJ_LOG(WARNING, \"App successfully started listening for TCP connections!\");\n        }\n      }).catch_(\n          [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n          (kj::Exception&& e) mutable {\n        if (!loggedSlowStartupMessage) {\n          numTriesSoFar++;\n        }\n        if (!loggedSlowStartupMessage && numTriesSoFar == (30 * 100)) {\n          // After 30 seconds (30 * 100 centiseconds) of failure, log a message once.\n          KJ_LOG(WARNING, \"App isn't listening for TCP connections after 30 seconds. Continuing \"\n                 \"to attempt to connect\",\n                 address->toString());\n          loggedSlowStartupMessage = true;\n        }\n        // Wait 10ms and try again.\n        return timer.afterDelay(10 * kj::MILLISECONDS).then(\n            [KJ_MVCAP(address), &timer, loggedSlowStartupMessage, numTriesSoFar, this]\n            () mutable -> kj::Promise<void> {\n          return connectLoop(kj::mv(address), timer,\n                             loggedSlowStartupMessage, numTriesSoFar);\n        });\n      });\n    }\n}"
  },
  {
    "function_name": "addressToString",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2340-2380",
    "snippet": "inline kj::String addressToString(::sandstorm::IpAddress::Reader&& address) {\n    uint64_t lower64 = address.getLower64();\n    uint64_t upper64 = address.getUpper64();\n    if (upper64 == 0 && ((lower64 >> 32) == 0xffff)) {\n      // This is an IPv4 address.\n      char buf[INET_ADDRSTRLEN];\n      memset(buf, 0, INET_ADDRSTRLEN);\n      lower64 &= 0xffffffff;\n      struct in_addr ipv4;\n      ipv4.s_addr = ntohl(uint32_t(lower64));\n      const char* ok = inet_ntop(AF_INET, &ipv4, buf, INET_ADDRSTRLEN);\n      KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n      kj::String s = kj::heapString(buf);\n      return kj::mv(s);\n    } else {\n      // This is an IPv6 address.\n      char buf[INET6_ADDRSTRLEN];\n      memset(buf, 0, INET6_ADDRSTRLEN);\n      struct in6_addr ipv6;\n      ipv6.s6_addr[0]  = ((upper64 >> 56) & 0xff);\n      ipv6.s6_addr[1]  = ((upper64 >> 48) & 0xff);\n      ipv6.s6_addr[2]  = ((upper64 >> 40) & 0xff);\n      ipv6.s6_addr[3]  = ((upper64 >> 32) & 0xff);\n      ipv6.s6_addr[4]  = ((upper64 >> 24) & 0xff);\n      ipv6.s6_addr[5]  = ((upper64 >> 16) & 0xff);\n      ipv6.s6_addr[6]  = ((upper64 >>  8) & 0xff);\n      ipv6.s6_addr[7]  = ((upper64      ) & 0xff);\n      ipv6.s6_addr[8]  = ((lower64 >> 56) & 0xff);\n      ipv6.s6_addr[9]  = ((lower64 >> 48) & 0xff);\n      ipv6.s6_addr[10] = ((lower64 >> 40) & 0xff);\n      ipv6.s6_addr[11] = ((lower64 >> 32) & 0xff);\n      ipv6.s6_addr[12] = ((lower64 >> 24) & 0xff);\n      ipv6.s6_addr[13] = ((lower64 >> 16) & 0xff);\n      ipv6.s6_addr[14] = ((lower64 >>  8) & 0xff);\n      ipv6.s6_addr[15] = ((lower64      ) & 0xff);\n      const char* ok = inet_ntop(AF_INET6, &ipv6, buf, INET6_ADDRSTRLEN);\n      KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n      kj::String s = kj::heapString(buf);\n      return kj::mv(s);\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<kj::NetworkAddress> address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "s"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "buf"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ok != NULL",
            "\"inet_ntop() failed\""
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET6",
            "&ipv6",
            "buf",
            "INET6_ADDRSTRLEN"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "INET6_ADDRSTRLEN"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "s"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "buf"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ok != NULL",
            "\"inet_ntop() failed\""
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "&ipv4",
            "buf",
            "INET_ADDRSTRLEN"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "uint32_t(lower64)"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "lower64"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "INET_ADDRSTRLEN"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address.getUpper64",
          "args": [],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address.getLower64",
          "args": [],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Own<kj::NetworkAddress> address;\n\nUiViewImpl {\n  inline kj::String addressToString(::sandstorm::IpAddress::Reader&& address) {\n      uint64_t lower64 = address.getLower64();\n      uint64_t upper64 = address.getUpper64();\n      if (upper64 == 0 && ((lower64 >> 32) == 0xffff)) {\n        // This is an IPv4 address.\n        char buf[INET_ADDRSTRLEN];\n        memset(buf, 0, INET_ADDRSTRLEN);\n        lower64 &= 0xffffffff;\n        struct in_addr ipv4;\n        ipv4.s_addr = ntohl(uint32_t(lower64));\n        const char* ok = inet_ntop(AF_INET, &ipv4, buf, INET_ADDRSTRLEN);\n        KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n        kj::String s = kj::heapString(buf);\n        return kj::mv(s);\n      } else {\n        // This is an IPv6 address.\n        char buf[INET6_ADDRSTRLEN];\n        memset(buf, 0, INET6_ADDRSTRLEN);\n        struct in6_addr ipv6;\n        ipv6.s6_addr[0]  = ((upper64 >> 56) & 0xff);\n        ipv6.s6_addr[1]  = ((upper64 >> 48) & 0xff);\n        ipv6.s6_addr[2]  = ((upper64 >> 40) & 0xff);\n        ipv6.s6_addr[3]  = ((upper64 >> 32) & 0xff);\n        ipv6.s6_addr[4]  = ((upper64 >> 24) & 0xff);\n        ipv6.s6_addr[5]  = ((upper64 >> 16) & 0xff);\n        ipv6.s6_addr[6]  = ((upper64 >>  8) & 0xff);\n        ipv6.s6_addr[7]  = ((upper64      ) & 0xff);\n        ipv6.s6_addr[8]  = ((lower64 >> 56) & 0xff);\n        ipv6.s6_addr[9]  = ((lower64 >> 48) & 0xff);\n        ipv6.s6_addr[10] = ((lower64 >> 40) & 0xff);\n        ipv6.s6_addr[11] = ((lower64 >> 32) & 0xff);\n        ipv6.s6_addr[12] = ((lower64 >> 24) & 0xff);\n        ipv6.s6_addr[13] = ((lower64 >> 16) & 0xff);\n        ipv6.s6_addr[14] = ((lower64 >>  8) & 0xff);\n        ipv6.s6_addr[15] = ((lower64      ) & 0xff);\n        const char* ok = inet_ntop(AF_INET6, &ipv6, buf, INET6_ADDRSTRLEN);\n        KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n        kj::String s = kj::heapString(buf);\n        return kj::mv(s);\n      }\n    }\n}"
  },
  {
    "function_name": "drop",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2334-2337",
    "snippet": "kj::Promise<void> drop(DropContext context) override {\n    // We ignore drops, because our ObjectId format is too ambiguous for it to be useful.\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nUiViewImpl {\n  kj::Promise<void> drop(DropContext context) override {\n      // We ignore drops, because our ObjectId format is too ambiguous for it to be useful.\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "restore",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2320-2332",
    "snippet": "kj::Promise<void> restore(RestoreContext context) override {\n    auto objectId = context.getParams().getObjectId();\n\n    if (objectId.isApplication()) {\n      KJ_UNIMPLEMENTED(\"application-defined object IDs not implemented\");\n    }\n\n    KJ_REQUIRE(objectId.isHttpApi(), \"unrecognized object ID type\");\n\n    context.getResults().setCap(\n        newPowerboxApiSession(serverAddress, bridgeContext, newOwnCapnp(objectId.getHttpApi())));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "newPowerboxApiSession(serverAddress, bridgeContext, newOwnCapnp(objectId.getHttpApi()))"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPowerboxApiSession",
          "args": [
            "serverAddress",
            "bridgeContext",
            "newOwnCapnp(objectId.getHttpApi())"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "newPowerboxApiSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1838-1879",
          "snippet": "WebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nWebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "newOwnCapnp",
          "args": [
            "objectId.getHttpApi()"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "newOwnCapnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "532-537",
          "snippet": "OwnCapnp<capnp::FromReader<Reader>> newOwnCapnp(Reader value) {\n  auto words = kj::heapArray<capnp::word>(value.totalSize().wordCount + 1);\n  memset(words.asBytes().begin(), 0, words.asBytes().size());\n  capnp::copyToUnchecked(value, words);\n  return OwnCapnp<capnp::FromReader<Reader>>(kj::mv(words));\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nOwnCapnp<capnp::FromReader<Reader>> newOwnCapnp(Reader value) {\n  auto words = kj::heapArray<capnp::word>(value.totalSize().wordCount + 1);\n  memset(words.asBytes().begin(), 0, words.asBytes().size());\n  capnp::copyToUnchecked(value, words);\n  return OwnCapnp<capnp::FromReader<Reader>>(kj::mv(words));\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getHttpApi",
          "args": [],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "objectId.isHttpApi()",
            "\"unrecognized object ID type\""
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.isHttpApi",
          "args": [],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"application-defined object IDs not implemented\""
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.isApplication",
          "args": [],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nUiViewImpl {\n  kj::Promise<void> restore(RestoreContext context) override {\n      auto objectId = context.getParams().getObjectId();\n  \n      if (objectId.isApplication()) {\n        KJ_UNIMPLEMENTED(\"application-defined object IDs not implemented\");\n      }\n  \n      KJ_REQUIRE(objectId.isHttpApi(), \"unrecognized object ID type\");\n  \n      context.getResults().setCap(\n          newPowerboxApiSession(serverAddress, bridgeContext, newOwnCapnp(objectId.getHttpApi())));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "newRequestSession",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2295-2318",
    "snippet": "kj::Promise<void> newRequestSession(NewRequestSessionContext context) override {\n    auto params = context.getParams();\n\n    KJ_REQUIRE(params.getSessionType() == capnp::typeId<WebSession>(),\n               \"Unsupported request session type.\");\n\n    auto userInfo = params.getUserInfo();\n    if (userInfo.hasIdentity() && config.getSaveIdentityCaps()) {\n      bridgeContext.saveIdentity(userInfo.getIdentityId(), userInfo.getIdentity());\n    }\n\n    auto permissions = kj::heapArrayFromIterable<bool>(userInfo.getPermissions());\n\n    UiSession::Client session =\n        kj::heap<RequestSessionImpl>(\n            serverAddress, bridgeContext, params.getContext(),\n            kj::heapArray(userInfo.getIdentityId()), kj::mv(permissions));\n\n    context.getResults(capnp::MessageSize {2, 1}).setSession(\n        connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "kj::String permissions;",
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        })"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [
            "[KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "session"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {2, 1}"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<RequestSessionImpl>",
          "args": [
            "serverAddress",
            "bridgeContext",
            "params.getContext()",
            "kj::heapArray(userInfo.getIdentityId())",
            "kj::mv(permissions)"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "permissions"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "userInfo.getIdentityId()"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentityId",
          "args": [],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayFromIterable<bool>",
          "args": [
            "userInfo.getPermissions()"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPermissions",
          "args": [],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.saveIdentity",
          "args": [
            "userInfo.getIdentityId()",
            "userInfo.getIdentity()"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "saveIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1082-1107",
          "snippet": "void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n    if (!config.getSaveIdentityCaps()) return;\n\n    auto textId = textIdentityId(identityId);\n\n    kj::StringPtr textIdRef = textId;\n    if(liveIdentities.insert(std::make_pair(\n        textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n      // Newly-added to the map. Check if it's on disk.\n\n      // Note that we know now that textIdRef will live forever, since it's in the map.\n\n      if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n        // Not yet recorded to disk. Need to save a SturdyRef.\n        saveIdentityInternal(textIdRef, kj::mv(identity));\n      } else {\n        // Try restoring the existing SturdyRef and re-save on failure.\n        tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n            [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        }));\n      }\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n      if (!config.getSaveIdentityCaps()) return;\n  \n      auto textId = textIdentityId(identityId);\n  \n      kj::StringPtr textIdRef = textId;\n      if(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n        // Newly-added to the map. Check if it's on disk.\n  \n        // Note that we know now that textIdRef will live forever, since it's in the map.\n  \n        if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n          // Not yet recorded to disk. Need to save a SturdyRef.\n          saveIdentityInternal(textIdRef, kj::mv(identity));\n        } else {\n          // Try restoring the existing SturdyRef and re-save on failure.\n          tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n              [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n            if (error.getType() == kj::Exception::Type::FAILED) {\n              saveIdentityInternal(textIdRef, kj::mv(identity));\n            }\n          }));\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentity",
          "args": [],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentityId",
          "args": [],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.hasIdentity",
          "args": [],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getUserInfo",
          "args": [],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.getSessionType() == capnp::typeId<WebSession>()",
            "\"Unsupported request session type.\""
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<WebSession>",
          "args": [],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionType",
          "args": [],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nUiViewImpl {\n  kj::Promise<void> newRequestSession(NewRequestSessionContext context) override {\n      auto params = context.getParams();\n  \n      KJ_REQUIRE(params.getSessionType() == capnp::typeId<WebSession>(),\n                 \"Unsupported request session type.\");\n  \n      auto userInfo = params.getUserInfo();\n      if (userInfo.hasIdentity() && config.getSaveIdentityCaps()) {\n        bridgeContext.saveIdentity(userInfo.getIdentityId(), userInfo.getIdentity());\n      }\n  \n      auto permissions = kj::heapArrayFromIterable<bool>(userInfo.getPermissions());\n  \n      UiSession::Client session =\n          kj::heap<RequestSessionImpl>(\n              serverAddress, bridgeContext, params.getContext(),\n              kj::heapArray(userInfo.getIdentityId()), kj::mv(permissions));\n  \n      context.getResults(capnp::MessageSize {2, 1}).setSession(\n          connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n            return kj::mv(session);\n          }));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "newSession",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2234-2293",
    "snippet": "kj::Promise<void> newSession(NewSessionContext context) override {\n    auto params = context.getParams();\n    auto sessionType = params.getSessionType();\n\n    KJ_REQUIRE(sessionType == capnp::typeId<WebSession>() ||\n               sessionType == capnp::typeId<HackEmailSession>() ||\n               (config.getApiPath().size() > 0 && sessionType == capnp::typeId<ApiSession>()),\n               \"Unsupported session type.\");\n\n    auto userInfo = params.getUserInfo();\n    if (userInfo.hasIdentity() && config.getSaveIdentityCaps()) {\n      bridgeContext.saveIdentity(userInfo.getIdentityId(), userInfo.getIdentity());\n    }\n\n    if (sessionType == capnp::typeId<WebSession>()) {\n      auto userPermissions = userInfo.getPermissions();\n      auto sessionParams = params.getSessionParams().getAs<WebSession::Params>();\n\n      UiSession::Client session =\n        kj::heap<WebSessionImpl>(serverAddress, userInfo, params.getContext(),\n                                 bridgeContext, kj::str(sessionIdCounter++),\n                                 hexEncode(params.getTabId()),\n                                 kj::heapString(sessionParams.getBasePath()),\n                                 kj::heapString(sessionParams.getUserAgent()),\n                                 kj::strArray(sessionParams.getAcceptableLanguages(), \",\"),\n                                 kj::heapString(\"/\"),\n                                 bridgeContext.formatPermissions(userPermissions),\n                                 nullptr, nullptr);\n\n      context.getResults(capnp::MessageSize {2, 1}).setSession(\n        connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }));\n    } else if (sessionType == capnp::typeId<ApiSession>()) {\n      auto userPermissions = userInfo.getPermissions();\n      auto sessionParams = params.getSessionParams().getAs<ApiSession::Params>();\n      kj::Maybe<kj::String> addr = nullptr;\n      if (sessionParams.hasRemoteAddress()) {\n        addr = addressToString(sessionParams.getRemoteAddress());\n      }\n\n      UiSession::Client session =\n        kj::heap<WebSessionImpl>(serverAddress, userInfo, params.getContext(),\n                                 bridgeContext, kj::str(sessionIdCounter++),\n                                 hexEncode(params.getTabId()),\n                                 kj::heapString(\"\"), kj::heapString(\"\"), kj::heapString(\"\"),\n                                 kj::heapString(config.getApiPath()),\n                                 bridgeContext.formatPermissions(userPermissions),\n                                 kj::mv(addr), nullptr);\n\n      context.getResults(capnp::MessageSize {2, 1}).setSession(\n        connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }));\n    } else if (sessionType == capnp::typeId<HackEmailSession>()) {\n      context.getResults(capnp::MessageSize {2, 1}).setSession(kj::heap<EmailSessionImpl>());\n    }\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<EmailSessionImpl>()"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<EmailSessionImpl>",
          "args": [],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {2, 1}"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<HackEmailSession>",
          "args": [],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        })"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [
            "[KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "session"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {2, 1}"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSessionImpl>",
          "args": [
            "serverAddress",
            "userInfo",
            "params.getContext()",
            "bridgeContext",
            "kj::str(sessionIdCounter++)",
            "hexEncode(params.getTabId())",
            "kj::heapString(\"\")",
            "kj::heapString(\"\")",
            "kj::heapString(\"\")",
            "kj::heapString(config.getApiPath())",
            "bridgeContext.formatPermissions(userPermissions)",
            "kj::mv(addr)",
            "nullptr"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addr"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.formatPermissions",
          "args": [
            "userPermissions"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "formatPermissions",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1066-1076",
          "snippet": "kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n    auto configPermissions = config.getViewInfo().getPermissions();\n    kj::Vector<kj::String> permissionVec(configPermissions.size());\n\n    for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n      if (userPermissions[i]) {\n        permissionVec.add(kj::str(configPermissions[i].getName()));\n      }\n    }\n    return kj::strArray(permissionVec, \",\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n      auto configPermissions = config.getViewInfo().getPermissions();\n      kj::Vector<kj::String> permissionVec(configPermissions.size());\n  \n      for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n        if (userPermissions[i]) {\n          permissionVec.add(kj::str(configPermissions[i].getName()));\n        }\n      }\n      return kj::strArray(permissionVec, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "config.getApiPath()"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getApiPath",
          "args": [],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"\""
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"\""
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"\""
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hexEncode",
          "args": [
            "params.getTabId()"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "hexEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "784-787",
          "snippet": "kj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getTabId",
          "args": [],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "sessionIdCounter++"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressToString",
          "args": [
            "sessionParams.getRemoteAddress()"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "addressToString",
          "container": "UiViewImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2340-2380",
          "snippet": "inline kj::String addressToString(::sandstorm::IpAddress::Reader&& address) {\n    uint64_t lower64 = address.getLower64();\n    uint64_t upper64 = address.getUpper64();\n    if (upper64 == 0 && ((lower64 >> 32) == 0xffff)) {\n      // This is an IPv4 address.\n      char buf[INET_ADDRSTRLEN];\n      memset(buf, 0, INET_ADDRSTRLEN);\n      lower64 &= 0xffffffff;\n      struct in_addr ipv4;\n      ipv4.s_addr = ntohl(uint32_t(lower64));\n      const char* ok = inet_ntop(AF_INET, &ipv4, buf, INET_ADDRSTRLEN);\n      KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n      kj::String s = kj::heapString(buf);\n      return kj::mv(s);\n    } else {\n      // This is an IPv6 address.\n      char buf[INET6_ADDRSTRLEN];\n      memset(buf, 0, INET6_ADDRSTRLEN);\n      struct in6_addr ipv6;\n      ipv6.s6_addr[0]  = ((upper64 >> 56) & 0xff);\n      ipv6.s6_addr[1]  = ((upper64 >> 48) & 0xff);\n      ipv6.s6_addr[2]  = ((upper64 >> 40) & 0xff);\n      ipv6.s6_addr[3]  = ((upper64 >> 32) & 0xff);\n      ipv6.s6_addr[4]  = ((upper64 >> 24) & 0xff);\n      ipv6.s6_addr[5]  = ((upper64 >> 16) & 0xff);\n      ipv6.s6_addr[6]  = ((upper64 >>  8) & 0xff);\n      ipv6.s6_addr[7]  = ((upper64      ) & 0xff);\n      ipv6.s6_addr[8]  = ((lower64 >> 56) & 0xff);\n      ipv6.s6_addr[9]  = ((lower64 >> 48) & 0xff);\n      ipv6.s6_addr[10] = ((lower64 >> 40) & 0xff);\n      ipv6.s6_addr[11] = ((lower64 >> 32) & 0xff);\n      ipv6.s6_addr[12] = ((lower64 >> 24) & 0xff);\n      ipv6.s6_addr[13] = ((lower64 >> 16) & 0xff);\n      ipv6.s6_addr[14] = ((lower64 >>  8) & 0xff);\n      ipv6.s6_addr[15] = ((lower64      ) & 0xff);\n      const char* ok = inet_ntop(AF_INET6, &ipv6, buf, INET6_ADDRSTRLEN);\n      KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n      kj::String s = kj::heapString(buf);\n      return kj::mv(s);\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<kj::NetworkAddress> address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Own<kj::NetworkAddress> address;\n\nUiViewImpl {\n  inline kj::String addressToString(::sandstorm::IpAddress::Reader&& address) {\n      uint64_t lower64 = address.getLower64();\n      uint64_t upper64 = address.getUpper64();\n      if (upper64 == 0 && ((lower64 >> 32) == 0xffff)) {\n        // This is an IPv4 address.\n        char buf[INET_ADDRSTRLEN];\n        memset(buf, 0, INET_ADDRSTRLEN);\n        lower64 &= 0xffffffff;\n        struct in_addr ipv4;\n        ipv4.s_addr = ntohl(uint32_t(lower64));\n        const char* ok = inet_ntop(AF_INET, &ipv4, buf, INET_ADDRSTRLEN);\n        KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n        kj::String s = kj::heapString(buf);\n        return kj::mv(s);\n      } else {\n        // This is an IPv6 address.\n        char buf[INET6_ADDRSTRLEN];\n        memset(buf, 0, INET6_ADDRSTRLEN);\n        struct in6_addr ipv6;\n        ipv6.s6_addr[0]  = ((upper64 >> 56) & 0xff);\n        ipv6.s6_addr[1]  = ((upper64 >> 48) & 0xff);\n        ipv6.s6_addr[2]  = ((upper64 >> 40) & 0xff);\n        ipv6.s6_addr[3]  = ((upper64 >> 32) & 0xff);\n        ipv6.s6_addr[4]  = ((upper64 >> 24) & 0xff);\n        ipv6.s6_addr[5]  = ((upper64 >> 16) & 0xff);\n        ipv6.s6_addr[6]  = ((upper64 >>  8) & 0xff);\n        ipv6.s6_addr[7]  = ((upper64      ) & 0xff);\n        ipv6.s6_addr[8]  = ((lower64 >> 56) & 0xff);\n        ipv6.s6_addr[9]  = ((lower64 >> 48) & 0xff);\n        ipv6.s6_addr[10] = ((lower64 >> 40) & 0xff);\n        ipv6.s6_addr[11] = ((lower64 >> 32) & 0xff);\n        ipv6.s6_addr[12] = ((lower64 >> 24) & 0xff);\n        ipv6.s6_addr[13] = ((lower64 >> 16) & 0xff);\n        ipv6.s6_addr[14] = ((lower64 >>  8) & 0xff);\n        ipv6.s6_addr[15] = ((lower64      ) & 0xff);\n        const char* ok = inet_ntop(AF_INET6, &ipv6, buf, INET6_ADDRSTRLEN);\n        KJ_REQUIRE(ok != NULL, \"inet_ntop() failed\");\n        kj::String s = kj::heapString(buf);\n        return kj::mv(s);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sessionParams.getRemoteAddress",
          "args": [],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionParams.hasRemoteAddress",
          "args": [],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPermissions",
          "args": [],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<ApiSession>",
          "args": [],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        })"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [
            "[KJ_MVCAP(session)]() mutable {\n          return kj::mv(session);\n        }"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "session"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectPromise.addBranch",
          "args": [],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {2, 1}"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSessionImpl>",
          "args": [
            "serverAddress",
            "userInfo",
            "params.getContext()",
            "bridgeContext",
            "kj::str(sessionIdCounter++)",
            "hexEncode(params.getTabId())",
            "kj::heapString(sessionParams.getBasePath())",
            "kj::heapString(sessionParams.getUserAgent())",
            "kj::strArray(sessionParams.getAcceptableLanguages(), \",\")",
            "kj::heapString(\"/\")",
            "bridgeContext.formatPermissions(userPermissions)",
            "nullptr",
            "nullptr"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"/\""
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "sessionParams.getAcceptableLanguages()",
            "\",\""
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionParams.getAcceptableLanguages",
          "args": [],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "sessionParams.getUserAgent()"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionParams.getUserAgent",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "sessionParams.getBasePath()"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionParams.getBasePath",
          "args": [],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getTabId",
          "args": [],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "sessionIdCounter++"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPermissions",
          "args": [],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<WebSession>",
          "args": [],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.saveIdentity",
          "args": [
            "userInfo.getIdentityId()",
            "userInfo.getIdentity()"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "saveIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1082-1107",
          "snippet": "void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n    if (!config.getSaveIdentityCaps()) return;\n\n    auto textId = textIdentityId(identityId);\n\n    kj::StringPtr textIdRef = textId;\n    if(liveIdentities.insert(std::make_pair(\n        textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n      // Newly-added to the map. Check if it's on disk.\n\n      // Note that we know now that textIdRef will live forever, since it's in the map.\n\n      if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n        // Not yet recorded to disk. Need to save a SturdyRef.\n        saveIdentityInternal(textIdRef, kj::mv(identity));\n      } else {\n        // Try restoring the existing SturdyRef and re-save on failure.\n        tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n            [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        }));\n      }\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n      if (!config.getSaveIdentityCaps()) return;\n  \n      auto textId = textIdentityId(identityId);\n  \n      kj::StringPtr textIdRef = textId;\n      if(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n        // Newly-added to the map. Check if it's on disk.\n  \n        // Note that we know now that textIdRef will live forever, since it's in the map.\n  \n        if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n          // Not yet recorded to disk. Need to save a SturdyRef.\n          saveIdentityInternal(textIdRef, kj::mv(identity));\n        } else {\n          // Try restoring the existing SturdyRef and re-save on failure.\n          tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n              [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n            if (error.getType() == kj::Exception::Type::FAILED) {\n              saveIdentityInternal(textIdRef, kj::mv(identity));\n            }\n          }));\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentity",
          "args": [],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentityId",
          "args": [],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.hasIdentity",
          "args": [],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getUserInfo",
          "args": [],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "sessionType == capnp::typeId<WebSession>() ||\n               sessionType == capnp::typeId<HackEmailSession>() ||\n               (config.getApiPath().size() > 0 && sessionType == capnp::typeId<ApiSession>())",
            "\"Unsupported session type.\""
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<ApiSession>",
          "args": [],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getApiPath",
          "args": [],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getApiPath",
          "args": [],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<HackEmailSession>",
          "args": [],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<WebSession>",
          "args": [],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionType",
          "args": [],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nspk::BridgeConfig::Reader config;\n\nUiViewImpl {\n  kj::Promise<void> newSession(NewSessionContext context) override {\n      auto params = context.getParams();\n      auto sessionType = params.getSessionType();\n  \n      KJ_REQUIRE(sessionType == capnp::typeId<WebSession>() ||\n                 sessionType == capnp::typeId<HackEmailSession>() ||\n                 (config.getApiPath().size() > 0 && sessionType == capnp::typeId<ApiSession>()),\n                 \"Unsupported session type.\");\n  \n      auto userInfo = params.getUserInfo();\n      if (userInfo.hasIdentity() && config.getSaveIdentityCaps()) {\n        bridgeContext.saveIdentity(userInfo.getIdentityId(), userInfo.getIdentity());\n      }\n  \n      if (sessionType == capnp::typeId<WebSession>()) {\n        auto userPermissions = userInfo.getPermissions();\n        auto sessionParams = params.getSessionParams().getAs<WebSession::Params>();\n  \n        UiSession::Client session =\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, params.getContext(),\n                                   bridgeContext, kj::str(sessionIdCounter++),\n                                   hexEncode(params.getTabId()),\n                                   kj::heapString(sessionParams.getBasePath()),\n                                   kj::heapString(sessionParams.getUserAgent()),\n                                   kj::strArray(sessionParams.getAcceptableLanguages(), \",\"),\n                                   kj::heapString(\"/\"),\n                                   bridgeContext.formatPermissions(userPermissions),\n                                   nullptr, nullptr);\n  \n        context.getResults(capnp::MessageSize {2, 1}).setSession(\n          connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n            return kj::mv(session);\n          }));\n      } else if (sessionType == capnp::typeId<ApiSession>()) {\n        auto userPermissions = userInfo.getPermissions();\n        auto sessionParams = params.getSessionParams().getAs<ApiSession::Params>();\n        kj::Maybe<kj::String> addr = nullptr;\n        if (sessionParams.hasRemoteAddress()) {\n          addr = addressToString(sessionParams.getRemoteAddress());\n        }\n  \n        UiSession::Client session =\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, params.getContext(),\n                                   bridgeContext, kj::str(sessionIdCounter++),\n                                   hexEncode(params.getTabId()),\n                                   kj::heapString(\"\"), kj::heapString(\"\"), kj::heapString(\"\"),\n                                   kj::heapString(config.getApiPath()),\n                                   bridgeContext.formatPermissions(userPermissions),\n                                   kj::mv(addr), nullptr);\n  \n        context.getResults(capnp::MessageSize {2, 1}).setSession(\n          connectPromise.addBranch().then([KJ_MVCAP(session)]() mutable {\n            return kj::mv(session);\n          }));\n      } else if (sessionType == capnp::typeId<HackEmailSession>()) {\n        context.getResults(capnp::MessageSize {2, 1}).setSession(kj::heap<EmailSessionImpl>());\n      }\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "getViewInfo",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2216-2232",
    "snippet": "kj::Promise<void> getViewInfo(GetViewInfoContext context) override {\n    context.setResults(config.getViewInfo());\n\n    // Copy in powerbox API descriptors.\n    auto apis = config.getPowerboxApis();\n    if (apis.size() > 0) {\n      auto viewInfo = context.getResults();\n      auto descriptors = viewInfo.initMatchRequests(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        auto tag = descriptors[i].initTags(1)[0];\n        tag.setId(capnp::typeId<ApiSession>());\n        tag.getValue().setAs<ApiSession::PowerboxTag>(apis[i].getTag());\n      }\n    }\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tag.getValue",
          "args": [
            "apis[i].getTag()"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apis[i].getTag",
          "args": [],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.getValue",
          "args": [],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.setId",
          "args": [
            "capnp::typeId<ApiSession>()"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<ApiSession>",
          "args": [],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptors[i].initTags",
          "args": [
            "1"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "apis"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "viewInfo.initMatchRequests",
          "args": [
            "apis.size()"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apis.size",
          "args": [],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getPowerboxApis",
          "args": [],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "getPowerboxApis",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1078-1080",
          "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n      return config.getPowerboxApis();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.setResults",
          "args": [
            "config.getViewInfo()"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getViewInfo",
          "args": [],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nUiViewImpl {\n  kj::Promise<void> getViewInfo(GetViewInfoContext context) override {\n      context.setResults(config.getViewInfo());\n  \n      // Copy in powerbox API descriptors.\n      auto apis = config.getPowerboxApis();\n      if (apis.size() > 0) {\n        auto viewInfo = context.getResults();\n        auto descriptors = viewInfo.initMatchRequests(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          auto tag = descriptors[i].initTags(1)[0];\n          tag.setId(capnp::typeId<ApiSession>());\n          tag.getValue().setAs<ApiSession::PowerboxTag>(apis[i].getTag());\n        }\n      }\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "UiViewImpl",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2207-2214",
    "snippet": "explicit UiViewImpl(kj::NetworkAddress& serverAddress,\n                      BridgeContext& bridgeContext,\n                      spk::BridgeConfig::Reader config,\n                      kj::Promise<void>&& connectPromise)\n      : serverAddress(serverAddress),\n        bridgeContext(bridgeContext),\n        config(config),\n        connectPromise(connectPromise.fork()) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "connectPromise.fork",
          "args": [],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nspk::BridgeConfig::Reader config;\n\nUiViewImpl {\n  explicit UiViewImpl(kj::NetworkAddress& serverAddress,\n                        BridgeContext& bridgeContext,\n                        spk::BridgeConfig::Reader config,\n                        kj::Promise<void>&& connectPromise)\n        : serverAddress(serverAddress),\n          bridgeContext(bridgeContext),\n          config(config),\n          connectPromise(connectPromise.fork()) {}\n}"
  },
  {
    "function_name": "saveIdentity",
    "container": "SandstormHttpBridgeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2190-2198",
    "snippet": "kj::Promise<void> saveIdentity(SaveIdentityContext context) override {\n    auto identity = context.getParams().getIdentity();\n    context.releaseParams();\n    auto request = apiCap.getIdentityIdRequest();\n    request.setIdentity(identity);\n    return request.send().then([this, KJ_MVCAP(identity)](auto response) mutable -> void {\n      bridgeContext.saveIdentity(response.getId(), kj::mv(identity));\n    });\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "[this, KJ_MVCAP(identity)](auto response) mutable -> void {\n      bridgeContext.saveIdentity(response.getId(), kj::mv(identity));\n    }"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bridgeContext.saveIdentity",
          "args": [
            "response.getId()",
            "kj::mv(identity)"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "saveIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1082-1107",
          "snippet": "void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n    if (!config.getSaveIdentityCaps()) return;\n\n    auto textId = textIdentityId(identityId);\n\n    kj::StringPtr textIdRef = textId;\n    if(liveIdentities.insert(std::make_pair(\n        textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n      // Newly-added to the map. Check if it's on disk.\n\n      // Note that we know now that textIdRef will live forever, since it's in the map.\n\n      if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n        // Not yet recorded to disk. Need to save a SturdyRef.\n        saveIdentityInternal(textIdRef, kj::mv(identity));\n      } else {\n        // Try restoring the existing SturdyRef and re-save on failure.\n        tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n            [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        }));\n      }\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n      if (!config.getSaveIdentityCaps()) return;\n  \n      auto textId = textIdentityId(identityId);\n  \n      kj::StringPtr textIdRef = textId;\n      if(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n        // Newly-added to the map. Check if it's on disk.\n  \n        // Note that we know now that textIdRef will live forever, since it's in the map.\n  \n        if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n          // Not yet recorded to disk. Need to save a SturdyRef.\n          saveIdentityInternal(textIdRef, kj::mv(identity));\n        } else {\n          // Try restoring the existing SturdyRef and re-save on failure.\n          tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n              [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n            if (error.getType() == kj::Exception::Type::FAILED) {\n              saveIdentityInternal(textIdRef, kj::mv(identity));\n            }\n          }));\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getId",
          "args": [],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setIdentity",
          "args": [
            "identity"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apiCap.getIdentityIdRequest",
          "args": [],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nSandstormHttpBridgeImpl {\n  kj::Promise<void> saveIdentity(SaveIdentityContext context) override {\n      auto identity = context.getParams().getIdentity();\n      context.releaseParams();\n      auto request = apiCap.getIdentityIdRequest();\n      request.setIdentity(identity);\n      return request.send().then([this, KJ_MVCAP(identity)](auto response) mutable -> void {\n        bridgeContext.saveIdentity(response.getId(), kj::mv(identity));\n      });\n    }\n}"
  },
  {
    "function_name": "getSavedIdentity",
    "container": "SandstormHttpBridgeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2184-2188",
    "snippet": "kj::Promise<void> getSavedIdentity(GetSavedIdentityContext context) override {\n    context.getResults().setIdentity(\n        bridgeContext.loadIdentity(context.getParams().getIdentityId()));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "bridgeContext.loadIdentity(context.getParams().getIdentityId())"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.loadIdentity",
          "args": [
            "context.getParams().getIdentityId()"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "loadIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1109-1169",
          "snippet": "Identity::Client loadIdentity(kj::StringPtr origId) {\n    // Obtain the identity capability for the given identity ID.\n\n    KJ_REQUIRE(config.getSaveIdentityCaps(),\n        \"sandstorm-http-bridge is not configured to save identity capabilities\",\n        \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n\n    // Copy string to use as map key.\n    auto textId = kj::heapString(origId);\n\n    auto iter = liveIdentities.find(textId);\n    if (iter == liveIdentities.end()) {\n      // Not in the map. Load from disk.\n      Identity::Client identity = loadIdentityFromDisk(textId);\n\n      tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n        // Successfully resolved. Add to map.\n        kj::StringPtr textIdRef = textId;\n        KJ_ASSERT(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n      }, [] (auto e) {\n        // Ignore the error here because the returned capability will report it upon use.\n      }));\n\n      return kj::mv(identity);\n    } else {\n      // Identity is in the map.\n      Identity::Client identity = iter->second.identity;\n\n      // We need to verify the capability is still connected. Send a dummy call to check. We'll\n      // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n      auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n      ping.initAsAnyStruct(0, 0);\n      return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n        // Weird, we shouldn't get here.\n        KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n\n        // But clearly we are still connected, so continue.\n        return kj::mv(identity);\n      }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                      -> kj::Promise<Identity::Client> {\n        if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Disconnected. We'll need to reload from disk.\n          Identity::Client newIdentity = loadIdentityFromDisk(textId);\n          tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n            // Save the new identity to the map so that we don't have to reload it again.\n            auto iter = liveIdentities.find(textId);\n            KJ_ASSERT(iter != liveIdentities.end());\n            iter->second.identity = kj::mv(newIdentity);\n          }, [] (auto e) {\n            // Ignore the error here because the returned capability will report it upon use.\n          }));\n\n          return kj::mv(newIdentity);\n        } else {\n          // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n          return kj::mv(identity);\n        }\n      });\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  Identity::Client loadIdentity(kj::StringPtr origId) {\n      // Obtain the identity capability for the given identity ID.\n  \n      KJ_REQUIRE(config.getSaveIdentityCaps(),\n          \"sandstorm-http-bridge is not configured to save identity capabilities\",\n          \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n  \n      // Copy string to use as map key.\n      auto textId = kj::heapString(origId);\n  \n      auto iter = liveIdentities.find(textId);\n      if (iter == liveIdentities.end()) {\n        // Not in the map. Load from disk.\n        Identity::Client identity = loadIdentityFromDisk(textId);\n  \n        tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n          // Successfully resolved. Add to map.\n          kj::StringPtr textIdRef = textId;\n          KJ_ASSERT(liveIdentities.insert(std::make_pair(\n            textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n        }, [] (auto e) {\n          // Ignore the error here because the returned capability will report it upon use.\n        }));\n  \n        return kj::mv(identity);\n      } else {\n        // Identity is in the map.\n        Identity::Client identity = iter->second.identity;\n  \n        // We need to verify the capability is still connected. Send a dummy call to check. We'll\n        // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n        auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n        ping.initAsAnyStruct(0, 0);\n        return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n          // Weird, we shouldn't get here.\n          KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n  \n          // But clearly we are still connected, so continue.\n          return kj::mv(identity);\n        }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                        -> kj::Promise<Identity::Client> {\n          if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n            // Disconnected. We'll need to reload from disk.\n            Identity::Client newIdentity = loadIdentityFromDisk(textId);\n            tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n              // Save the new identity to the map so that we don't have to reload it again.\n              auto iter = liveIdentities.find(textId);\n              KJ_ASSERT(iter != liveIdentities.end());\n              iter->second.identity = kj::mv(newIdentity);\n            }, [] (auto e) {\n              // Ignore the error here because the returned capability will report it upon use.\n            }));\n  \n            return kj::mv(newIdentity);\n          } else {\n            // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n            return kj::mv(identity);\n          }\n        });\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nSandstormHttpBridgeImpl {\n  kj::Promise<void> getSavedIdentity(GetSavedIdentityContext context) override {\n      context.getResults().setIdentity(\n          bridgeContext.loadIdentity(context.getParams().getIdentityId()));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "getSessionContext",
    "container": "SandstormHttpBridgeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2176-2182",
    "snippet": "kj::Promise<void> getSessionContext(GetSessionContextContext context) override {\n    auto id = context.getParams().getId();\n    auto iter = bridgeContext.sessions.find(id);\n    KJ_ASSERT(iter != bridgeContext.sessions.end(), \"Session ID not found\", id);\n    context.getResults().setContext(iter->second);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "iter->second"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != bridgeContext.sessions.end()",
            "\"Session ID not found\"",
            "id"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.sessions.end",
          "args": [],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.sessions.find",
          "args": [
            "id"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nSandstormHttpBridgeImpl {\n  kj::Promise<void> getSessionContext(GetSessionContextContext context) override {\n      auto id = context.getParams().getId();\n      auto iter = bridgeContext.sessions.find(id);\n      KJ_ASSERT(iter != bridgeContext.sessions.end(), \"Session ID not found\", id);\n      context.getResults().setContext(iter->second);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "getSandstormApi",
    "container": "SandstormHttpBridgeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2171-2174",
    "snippet": "kj::Promise<void> getSandstormApi(GetSandstormApiContext context) override {\n    context.getResults().setApi(apiCap.castAs<SandstormApi<>>());\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "apiCap.castAs<SandstormApi<>>()"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apiCap.castAs<SandstormApi<>>",
          "args": [],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nSandstormHttpBridgeImpl {\n  kj::Promise<void> getSandstormApi(GetSandstormApiContext context) override {\n      context.getResults().setApi(apiCap.castAs<SandstormApi<>>());\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "SandstormHttpBridgeImpl",
    "container": "SandstormHttpBridgeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2166-2169",
    "snippet": "explicit SandstormHttpBridgeImpl(SandstormApi<BridgeObjectId>::Client&& apiCap,\n                                   BridgeContext& bridgeContext)\n      : apiCap(kj::mv(apiCap)),\n        bridgeContext(bridgeContext) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "apiCap"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nSandstormHttpBridgeImpl {\n  explicit SandstormHttpBridgeImpl(SandstormApi<BridgeObjectId>::Client&& apiCap,\n                                     BridgeContext& bridgeContext)\n        : apiCap(kj::mv(apiCap)),\n          bridgeContext(bridgeContext) {}\n}"
  },
  {
    "function_name": "post",
    "container": "RequestSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2109-2151",
    "snippet": "kj::Promise<void> post(PostContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      auto name = kj::str(params.getContent().getContent().asChars());\n\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        if (api.getName() == name) {\n          auto req = sessionContext.fulfillRequestRequest();\n\n          auto tag = req.initDescriptor().initTags(1)[0];\n          tag.setId(capnp::typeId<ApiSession>());\n          tag.initValue().setAs<ApiSession::PowerboxTag>(api.getTag());\n\n          req.setRequiredPermissions(api.getPermissions());\n          req.setDisplayInfo(api.getDisplayInfo());\n\n          capnp::MallocMessageBuilder message(32);\n          auto httpApi = message.getRoot<BridgeObjectId::HttpApi>();\n          httpApi.setIdentityId(identityId);\n          httpApi.setName(name);\n          httpApi.setPath(api.getPath());\n          httpApi.setPermissions(api.getPermissions());\n\n          req.setCap(newPowerboxApiSession(serverAddress, bridgeContext,\n              newOwnCapnp(httpApi.asReader())));\n\n          results.initNoContent();\n          return req.send().ignoreResult();\n        }\n      }\n\n      KJ_FAIL_REQUIRE(\"unknown API\", name);\n\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "SessionContext::Client sessionContext;",
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error.setDescriptionHtml",
          "args": [
            "\"404 not found\""
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.setStatusCode",
          "args": [
            "WebSession::Response::ClientErrorCode::NOT_FOUND"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initClientError",
          "args": [],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"unknown API\"",
            "name"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initNoContent",
          "args": [],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setCap",
          "args": [
            "newPowerboxApiSession(serverAddress, bridgeContext,\n              newOwnCapnp(httpApi.asReader()))"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPowerboxApiSession",
          "args": [
            "serverAddress",
            "bridgeContext",
            "newOwnCapnp(httpApi.asReader())"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "newPowerboxApiSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1838-1879",
          "snippet": "WebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nWebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "newOwnCapnp",
          "args": [
            "httpApi.asReader()"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "newOwnCapnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "532-537",
          "snippet": "OwnCapnp<capnp::FromReader<Reader>> newOwnCapnp(Reader value) {\n  auto words = kj::heapArray<capnp::word>(value.totalSize().wordCount + 1);\n  memset(words.asBytes().begin(), 0, words.asBytes().size());\n  capnp::copyToUnchecked(value, words);\n  return OwnCapnp<capnp::FromReader<Reader>>(kj::mv(words));\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nOwnCapnp<capnp::FromReader<Reader>> newOwnCapnp(Reader value) {\n  auto words = kj::heapArray<capnp::word>(value.totalSize().wordCount + 1);\n  memset(words.asBytes().begin(), 0, words.asBytes().size());\n  capnp::copyToUnchecked(value, words);\n  return OwnCapnp<capnp::FromReader<Reader>>(kj::mv(words));\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpApi.asReader",
          "args": [],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.setPermissions",
          "args": [
            "api.getPermissions()"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getPermissions",
          "args": [],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.setPath",
          "args": [
            "api.getPath()"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getPath",
          "args": [],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.setName",
          "args": [
            "name"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.setIdentityId",
          "args": [
            "identityId"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<BridgeObjectId::HttpApi>",
          "args": [],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setDisplayInfo",
          "args": [
            "api.getDisplayInfo()"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getDisplayInfo",
          "args": [],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setRequiredPermissions",
          "args": [
            "api.getPermissions()"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getPermissions",
          "args": [],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.initValue",
          "args": [
            "api.getTag()"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getTag",
          "args": [],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.initValue",
          "args": [],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.setId",
          "args": [
            "capnp::typeId<ApiSession>()"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<ApiSession>",
          "args": [],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initDescriptor",
          "args": [
            "1"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initDescriptor",
          "args": [],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionContext.fulfillRequestRequest",
          "args": [],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getName",
          "args": [],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.getPowerboxApis",
          "args": [],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "getPowerboxApis",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1078-1080",
          "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n      return config.getPowerboxApis();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "params.getContent().getContent().asChars()"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nSessionContext::Client sessionContext;\nBridgeContext& bridgeContext;\n\nRequestSessionImpl {\n  kj::Promise<void> post(PostContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        auto name = kj::str(params.getContent().getContent().asChars());\n  \n        for (auto api: bridgeContext.getPowerboxApis()) {\n          if (api.getName() == name) {\n            auto req = sessionContext.fulfillRequestRequest();\n  \n            auto tag = req.initDescriptor().initTags(1)[0];\n            tag.setId(capnp::typeId<ApiSession>());\n            tag.initValue().setAs<ApiSession::PowerboxTag>(api.getTag());\n  \n            req.setRequiredPermissions(api.getPermissions());\n            req.setDisplayInfo(api.getDisplayInfo());\n  \n            capnp::MallocMessageBuilder message(32);\n            auto httpApi = message.getRoot<BridgeObjectId::HttpApi>();\n            httpApi.setIdentityId(identityId);\n            httpApi.setName(name);\n            httpApi.setPath(api.getPath());\n            httpApi.setPermissions(api.getPermissions());\n  \n            req.setCap(newPowerboxApiSession(serverAddress, bridgeContext,\n                newOwnCapnp(httpApi.asReader())));\n  \n            results.initNoContent();\n            return req.send().ignoreResult();\n          }\n        }\n  \n        KJ_FAIL_REQUIRE(\"unknown API\", name);\n  \n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
  },
  {
    "function_name": "get",
    "container": "RequestSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2053-2107",
    "snippet": "kj::Promise<void> get(GetContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      // Determine the subset of PowerboxApis which the user has permission to choose.\n      //\n      // TODO(soon): Also match against descriptors.\n      kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        bool requirementsMet = true;\n\n        if (api.hasPermissions()) {\n          auto requiredPermissions = api.getPermissions();\n          for (size_t i: kj::indices(requiredPermissions)) {\n            if (requiredPermissions[i]) {\n              if (permissions.size() <= i || !permissions[i]) {\n                requirementsMet = false;\n                break;\n              }\n            }\n          }\n        }\n\n        if (requirementsMet) {\n          apis.add(api);\n        }\n      }\n\n      // JSON-ify that list as the config blob.\n      capnp::MallocMessageBuilder filteredConfig;\n      auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        list.setWithCaveats(i, apis[i]);\n      }\n\n      capnp::JsonCodec codec;\n      auto config = codec.encode(list);\n\n      // Send back our static HTML with the config blob injected into it.\n      auto content = results.initContent();\n      content.setMimeType(\"text/html; charset=UTF-8\");\n      auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n      memcpy(body.begin(), prefix.begin(), prefix.size());\n      memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n      memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n      return kj::READY_NOW;\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "kj::String permissions;",
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error.setDescriptionHtml",
          "args": [
            "\"404 not found\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.setStatusCode",
          "args": [
            "WebSession::Response::ClientErrorCode::NOT_FOUND"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initClientError",
          "args": [],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body.begin() + prefix.size() + config.size()",
            "suffix.begin()",
            "suffix.size()"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suffix.size",
          "args": [],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "suffix.begin",
          "args": [],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body.begin() + prefix.size()",
            "config.begin()",
            "config.size()"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.begin",
          "args": [],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "body.begin()",
            "prefix.begin()",
            "prefix.size()"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefix.begin",
          "args": [],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [
            "prefix.size() + config.size() + suffix.size()"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.setMimeType",
          "args": [
            "\"text/html; charset=UTF-8\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initContent",
          "args": [],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "codec.encode",
          "args": [
            "list"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.setWithCaveats",
          "args": [
            "i",
            "apis[i]"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "apis"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filteredConfig.getRoot<spk::BridgeConfig>",
          "args": [
            "apis.size()"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filteredConfig.getRoot<spk::BridgeConfig>",
          "args": [],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apis.add",
          "args": [
            "api"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "requiredPermissions"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.getPermissions",
          "args": [],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "api.hasPermissions",
          "args": [],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.getPowerboxApis",
          "args": [],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "getPowerboxApis",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1078-1080",
          "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n      return config.getPowerboxApis();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        // Determine the subset of PowerboxApis which the user has permission to choose.\n        //\n        // TODO(soon): Also match against descriptors.\n        kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n        for (auto api: bridgeContext.getPowerboxApis()) {\n          bool requirementsMet = true;\n  \n          if (api.hasPermissions()) {\n            auto requiredPermissions = api.getPermissions();\n            for (size_t i: kj::indices(requiredPermissions)) {\n              if (requiredPermissions[i]) {\n                if (permissions.size() <= i || !permissions[i]) {\n                  requirementsMet = false;\n                  break;\n                }\n              }\n            }\n          }\n  \n          if (requirementsMet) {\n            apis.add(api);\n          }\n        }\n  \n        // JSON-ify that list as the config blob.\n        capnp::MallocMessageBuilder filteredConfig;\n        auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          list.setWithCaveats(i, apis[i]);\n        }\n  \n        capnp::JsonCodec codec;\n        auto config = codec.encode(list);\n  \n        // Send back our static HTML with the config blob injected into it.\n        auto content = results.initContent();\n        content.setMimeType(\"text/html; charset=UTF-8\");\n        auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n        memcpy(body.begin(), prefix.begin(), prefix.size());\n        memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n        memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n        return kj::READY_NOW;\n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
  },
  {
    "function_name": "RequestSessionImpl",
    "container": "RequestSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "2034-2051",
    "snippet": "RequestSessionImpl(kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n                     SessionContext::Client sessionContext,\n                     kj::Array<byte>&& identityId, kj::Array<bool>&& permissions)\n      : serverAddress(serverAddress),\n        bridgeContext(bridgeContext),\n        sessionContext(kj::mv(sessionContext)),\n        identityId(kj::mv(identityId)),\n        permissions(kj::mv(permissions)) {\n    // Find where we're supposed to inject the config blob into the HTML.\n    kj::StringPtr html = *BRIDGE_REQUEST_SESSION_HTML;\n\n    static char MARKER[] = \"@CONFIG@\";\n    const char* configPos = strstr(html.begin(), MARKER);\n    KJ_ASSERT(configPos != nullptr);\n\n    prefix = html.slice(0, configPos - html.begin());\n    suffix = html.slice(configPos - html.begin() + strlen(MARKER), html.size());\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "SessionContext::Client sessionContext;",
      "BridgeContext& bridgeContext;",
      "kj::String permissions;",
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "html.slice",
          "args": [
            "configPos - html.begin() + strlen(MARKER)",
            "html.size()"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "html.size",
          "args": [],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "MARKER"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "html.begin",
          "args": [],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "html.slice",
          "args": [
            "0",
            "configPos - html.begin()"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "html.begin",
          "args": [],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "configPos != nullptr"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "html.begin()",
            "MARKER"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "html.begin",
          "args": [],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "permissions"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identityId"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sessionContext"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nSessionContext::Client sessionContext;\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  RequestSessionImpl(kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n                       SessionContext::Client sessionContext,\n                       kj::Array<byte>&& identityId, kj::Array<bool>&& permissions)\n        : serverAddress(serverAddress),\n          bridgeContext(bridgeContext),\n          sessionContext(kj::mv(sessionContext)),\n          identityId(kj::mv(identityId)),\n          permissions(kj::mv(permissions)) {\n      // Find where we're supposed to inject the config blob into the HTML.\n      kj::StringPtr html = *BRIDGE_REQUEST_SESSION_HTML;\n  \n      static char MARKER[] = \"@CONFIG@\";\n      const char* configPos = strstr(html.begin(), MARKER);\n      KJ_ASSERT(configPos != nullptr);\n  \n      prefix = html.slice(0, configPos - html.begin());\n      suffix = html.slice(configPos - html.begin() + strlen(MARKER), html.size());\n    }\n}"
  },
  {
    "function_name": "addHeader",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1999-2029",
    "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<EmailAddress>::Reader emails) {\n    addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n  }\n\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<capnp::Text>::Reader items) {\n    // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n    // with <>.\n    addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n  }\n\n  static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n    time_t seconds(nanoseconds / 1000000000u);\n    struct tm *tm = gmtime(&seconds);\n    char date[40];\n    strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n\n    addHeader(lines, \"Date\", date);\n  }\n\n  static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n    lines.add(kj::str(\"--\", boundaryId));\n    addHeader(lines, \"Content-Type\", attachment.getContentType());\n    addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n    addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n    addHeader(lines, \"Content-Id\", attachment.getContentId());\n    lines.add(nullptr);\n\n    lines.add(base64Encode(attachment.getContent(), true));\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "base64Encode(attachment.getContent(), true)"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64Encode",
          "args": [
            "attachment.getContent()",
            "true"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "base64Encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "630-670",
          "snippet": "kj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attachment.getContent",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "nullptr"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addHeader",
          "args": [
            "lines",
            "\"Content-Id\"",
            "attachment.getContentId()"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "addHeader",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1999-2029",
          "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<EmailAddress>::Reader emails) {\n    addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n  }\n\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<capnp::Text>::Reader items) {\n    // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n    // with <>.\n    addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n  }\n\n  static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n    time_t seconds(nanoseconds / 1000000000u);\n    struct tm *tm = gmtime(&seconds);\n    char date[40];\n    strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n\n    addHeader(lines, \"Date\", date);\n  }\n\n  static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n    lines.add(kj::str(\"--\", boundaryId));\n    addHeader(lines, \"Content-Type\", attachment.getContentType());\n    addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n    addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n    addHeader(lines, \"Content-Id\", attachment.getContentId());\n    lines.add(nullptr);\n\n    lines.add(base64Encode(attachment.getContent(), true));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "attachment.getContentId",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attachment.getContentDisposition",
          "args": [],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attachment.getContentType",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "date",
            "sizeof(date)",
            "\"%a, %d %b %Y %H:%M:%S %z\"",
            "tm"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmtime",
          "args": [
            "&seconds"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                          capnp::List<EmailAddress>::Reader emails) {\n      addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n    }\n  \n    static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                          capnp::List<capnp::Text>::Reader items) {\n      // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n      // with <>.\n      addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n    }\n  \n    static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n      time_t seconds(nanoseconds / 1000000000u);\n      struct tm *tm = gmtime(&seconds);\n      char date[40];\n      strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n  \n      addHeader(lines, \"Date\", date);\n    }\n  \n    static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n      lines.add(kj::str(\"--\", boundaryId));\n      addHeader(lines, \"Content-Type\", attachment.getContentType());\n      addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n      addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n      addHeader(lines, \"Content-Id\", attachment.getContentId());\n      lines.add(nullptr);\n  \n      lines.add(base64Encode(attachment.getContent(), true));\n    }\n}"
  },
  {
    "function_name": "addHeader",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1994-1997",
    "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        EmailAddress::Reader email) {\n    addHeader(lines, name, formatAddress(email));\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addHeader",
          "args": [
            "lines",
            "name",
            "formatAddress(email)"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "addHeader",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1999-2029",
          "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<EmailAddress>::Reader emails) {\n    addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n  }\n\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<capnp::Text>::Reader items) {\n    // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n    // with <>.\n    addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n  }\n\n  static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n    time_t seconds(nanoseconds / 1000000000u);\n    struct tm *tm = gmtime(&seconds);\n    char date[40];\n    strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n\n    addHeader(lines, \"Date\", date);\n  }\n\n  static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n    lines.add(kj::str(\"--\", boundaryId));\n    addHeader(lines, \"Content-Type\", attachment.getContentType());\n    addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n    addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n    addHeader(lines, \"Content-Id\", attachment.getContentId());\n    lines.add(nullptr);\n\n    lines.add(base64Encode(attachment.getContent(), true));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "formatAddress",
          "args": [
            "email"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "formatAddress",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1984-1992",
          "snippet": "static kj::String formatAddress(EmailAddress::Reader email) {\n    auto name = email.getName();\n    auto address = email.getAddress();\n    if (name.size() == 0) {\n      return kj::str(address);\n    } else {\n      return kj::str(name, \" <\", address, \">\");\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<kj::NetworkAddress> address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Own<kj::NetworkAddress> address;\n\nEmailSessionImpl {\n  static kj::String formatAddress(EmailAddress::Reader email) {\n      auto name = email.getName();\n      auto address = email.getAddress();\n      if (name.size() == 0) {\n        return kj::str(address);\n      } else {\n        return kj::str(name, \" <\", address, \">\");\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                          EmailAddress::Reader email) {\n      addHeader(lines, name, formatAddress(email));\n    }\n}"
  },
  {
    "function_name": "formatAddress",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1984-1992",
    "snippet": "static kj::String formatAddress(EmailAddress::Reader email) {\n    auto name = email.getName();\n    auto address = email.getAddress();\n    if (name.size() == 0) {\n      return kj::str(address);\n    } else {\n      return kj::str(name, \" <\", address, \">\");\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<kj::NetworkAddress> address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name",
            "\" <\"",
            "address",
            "\">\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "address"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.size",
          "args": [],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "email.getAddress",
          "args": [],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getName",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Own<kj::NetworkAddress> address;\n\nEmailSessionImpl {\n  static kj::String formatAddress(EmailAddress::Reader email) {\n      auto name = email.getName();\n      auto address = email.getAddress();\n      if (name.size() == 0) {\n        return kj::str(address);\n      } else {\n        return kj::str(name, \" <\", address, \">\");\n      }\n    }\n}"
  },
  {
    "function_name": "addHeader",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1978-1982",
    "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name, kj::StringPtr value) {\n    if (value.size() > 0) {\n      lines.add(kj::str(name, \": \", value));\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(name, \": \", value)"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name",
            "\": \"",
            "value"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name, kj::StringPtr value) {\n      if (value.size() > 0) {\n        lines.add(kj::str(name, \": \", value));\n      }\n    }\n}"
  },
  {
    "function_name": "genRandomString",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1947-1976",
    "snippet": "static kj::String genRandomString() {\n    // Generate a unique random string.\n\n    // Get 16 random bytes.\n    kj::byte bytes[16];\n    kj::FdInputStream(raiiOpen(\"/dev/urandom\", O_RDONLY)).read(bytes, sizeof(bytes));\n\n    // Base64 encode, using digits safe for MIME boundary or a filename.\n    static const char DIGITS[65] =\n        \"0123456789\"\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz_.\";\n    uint buffer = 0;\n    uint bufBits = 0;\n    auto chars = kj::heapArrayBuilder<char>(23);\n    for (kj::byte b: bytes) {\n      buffer |= b << bufBits;\n      bufBits += 8;\n\n      while (bufBits >= 6) {\n        chars.add(DIGITS[buffer & 63]);\n        buffer >>= 6;\n        bufBits -= 6;\n      }\n    }\n    chars.add(DIGITS[buffer & 63]);\n    chars.add('\\0');\n\n    return kj::String(chars.finish());\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "chars.finish()"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.finish",
          "args": [],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "'\\0'"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "DIGITS[buffer & 63]"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "DIGITS[buffer & 63]"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<char>",
          "args": [
            "23"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "bytes",
            "sizeof(bytes)"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "raiiOpen(\"/dev/urandom\", O_RDONLY)"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static kj::String genRandomString() {\n      // Generate a unique random string.\n  \n      // Get 16 random bytes.\n      kj::byte bytes[16];\n      kj::FdInputStream(raiiOpen(\"/dev/urandom\", O_RDONLY)).read(bytes, sizeof(bytes));\n  \n      // Base64 encode, using digits safe for MIME boundary or a filename.\n      static const char DIGITS[65] =\n          \"0123456789\"\n          \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n          \"abcdefghijklmnopqrstuvwxyz_.\";\n      uint buffer = 0;\n      uint bufBits = 0;\n      auto chars = kj::heapArrayBuilder<char>(23);\n      for (kj::byte b: bytes) {\n        buffer |= b << bufBits;\n        bufBits += 8;\n  \n        while (bufBits >= 6) {\n          chars.add(DIGITS[buffer & 63]);\n          buffer >>= 6;\n          bufBits -= 6;\n        }\n      }\n      chars.add(DIGITS[buffer & 63]);\n      chars.add('\\0');\n  \n      return kj::String(chars.finish());\n    }\n}"
  },
  {
    "function_name": "send",
    "container": "EmailSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1885-1944",
    "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr())"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tmpFilename.cStr()",
            "kj::str(\"/var/mail/new/_\", id).cStr()"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/mail/new/_\"",
            "id"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpFilename.cStr",
          "args": [],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "(int)mailFd"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "tmpFilename",
            "O_WRONLY | O_CREAT | O_EXCL"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/mail/tmp/_\"",
            "id"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "lines",
            "\"\\n\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "nullptr"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"--\", id, \"--\")"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"--\"",
            "id",
            "\"--\""
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addAttachment",
          "args": [
            "lines",
            "id",
            "attachment"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getAttachments",
          "args": [],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(email.getHtml())"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "email.getHtml()"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getHtml",
          "args": [],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "nullptr"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addHeader",
          "args": [
            "lines",
            "\"Content-Type\"",
            "kj::str(\"text/html; charset=UTF-8\")"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "addHeader",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1999-2029",
          "snippet": "static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<EmailAddress>::Reader emails) {\n    addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n  }\n\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                        capnp::List<capnp::Text>::Reader items) {\n    // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n    // with <>.\n    addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n  }\n\n  static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n    time_t seconds(nanoseconds / 1000000000u);\n    struct tm *tm = gmtime(&seconds);\n    char date[40];\n    strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n\n    addHeader(lines, \"Date\", date);\n  }\n\n  static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n    lines.add(kj::str(\"--\", boundaryId));\n    addHeader(lines, \"Content-Type\", attachment.getContentType());\n    addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n    addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n    addHeader(lines, \"Content-Id\", attachment.getContentId());\n    lines.add(nullptr);\n\n    lines.add(base64Encode(attachment.getContent(), true));\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                          capnp::List<EmailAddress>::Reader emails) {\n      addHeader(lines, name, kj::strArray(KJ_MAP(e, emails) { return formatAddress(e); }, \", \"));\n    }\n  \n    static void addHeader(kj::Vector<kj::String>& lines, kj::StringPtr name,\n                          capnp::List<capnp::Text>::Reader items) {\n      // Used for lists of message IDs (e.g. References an In-Reply-To). Each ID should be \"quoted\"\n      // with <>.\n      addHeader(lines, name, kj::strArray(KJ_MAP(i, items) { return kj::str('<', i, '>'); }, \" \"));\n    }\n  \n    static void addDateHeader(kj::Vector<kj::String>& lines, int64_t nanoseconds) {\n      time_t seconds(nanoseconds / 1000000000u);\n      struct tm *tm = gmtime(&seconds);\n      char date[40];\n      strftime(date, sizeof(date), \"%a, %d %b %Y %H:%M:%S %z\", tm);\n  \n      addHeader(lines, \"Date\", date);\n    }\n  \n    static void addAttachment(kj::Vector<kj::String>& lines, kj::StringPtr boundaryId, EmailAttachment::Reader & attachment) {\n      lines.add(kj::str(\"--\", boundaryId));\n      addHeader(lines, \"Content-Type\", attachment.getContentType());\n      addHeader(lines, \"Content-Disposition\", attachment.getContentDisposition());\n      addHeader(lines, \"Content-Transfer-Encoding\", \"base64\");\n      addHeader(lines, \"Content-Id\", attachment.getContentId());\n      lines.add(nullptr);\n  \n      lines.add(base64Encode(attachment.getContent(), true));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"text/html; charset=UTF-8\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"--\", id)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"--\"",
            "id"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.hasHtml",
          "args": [],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(email.getText())"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "email.getText()"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getText",
          "args": [],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "nullptr"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"text/plain; charset=UTF-8\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"--\", id)"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"--\"",
            "id"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.hasText",
          "args": [],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "nullptr"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"multipart/alternative; boundary=\"",
            "id"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getInReplyTo",
          "args": [],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getReferences",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getMessageId",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getSubject",
          "args": [],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getBcc",
          "args": [],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getCc",
          "args": [],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getReplyTo",
          "args": [],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getFrom",
          "args": [],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getTo",
          "args": [],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addDateHeader",
          "args": [
            "lines",
            "email.getDate()"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "email.getDate",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genRandomString",
          "args": [],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "genRandomString",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1947-1976",
          "snippet": "static kj::String genRandomString() {\n    // Generate a unique random string.\n\n    // Get 16 random bytes.\n    kj::byte bytes[16];\n    kj::FdInputStream(raiiOpen(\"/dev/urandom\", O_RDONLY)).read(bytes, sizeof(bytes));\n\n    // Base64 encode, using digits safe for MIME boundary or a filename.\n    static const char DIGITS[65] =\n        \"0123456789\"\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz_.\";\n    uint buffer = 0;\n    uint bufBits = 0;\n    auto chars = kj::heapArrayBuilder<char>(23);\n    for (kj::byte b: bytes) {\n      buffer |= b << bufBits;\n      bufBits += 8;\n\n      while (bufBits >= 6) {\n        chars.add(DIGITS[buffer & 63]);\n        buffer >>= 6;\n        bufBits -= 6;\n      }\n    }\n    chars.add(DIGITS[buffer & 63]);\n    chars.add('\\0');\n\n    return kj::String(chars.finish());\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  static kj::String genRandomString() {\n      // Generate a unique random string.\n  \n      // Get 16 random bytes.\n      kj::byte bytes[16];\n      kj::FdInputStream(raiiOpen(\"/dev/urandom\", O_RDONLY)).read(bytes, sizeof(bytes));\n  \n      // Base64 encode, using digits safe for MIME boundary or a filename.\n      static const char DIGITS[65] =\n          \"0123456789\"\n          \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n          \"abcdefghijklmnopqrstuvwxyz_.\";\n      uint buffer = 0;\n      uint bufBits = 0;\n      auto chars = kj::heapArrayBuilder<char>(23);\n      for (kj::byte b: bytes) {\n        buffer |= b << bufBits;\n        bufBits += 8;\n  \n        while (bufBits >= 6) {\n          chars.add(DIGITS[buffer & 63]);\n          buffer >>= 6;\n          bufBits -= 6;\n        }\n      }\n      chars.add(DIGITS[buffer & 63]);\n      chars.add('\\0');\n  \n      return kj::String(chars.finish());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "newPowerboxApiSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1838-1879",
    "snippet": "WebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WebSession::Client",
          "args": [
            "kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi))"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSessionImpl>",
          "args": [
            "serverAddress",
            "userInfo",
            "nullptr",
            "bridgeContext",
            "nullptr",
            "nullptr",
            "nullptr",
            "nullptr",
            "nullptr",
            "kj::str(httpApi.getPath(), '/')",
            "bridgeContext.formatPermissions(httpApi.getPermissions())",
            "nullptr",
            "kj::mv(httpApi)"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpApi"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.formatPermissions",
          "args": [
            "httpApi.getPermissions()"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "formatPermissions",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1066-1076",
          "snippet": "kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n    auto configPermissions = config.getViewInfo().getPermissions();\n    kj::Vector<kj::String> permissionVec(configPermissions.size());\n\n    for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n      if (userPermissions[i]) {\n        permissionVec.add(kj::str(configPermissions[i].getName()));\n      }\n    }\n    return kj::strArray(permissionVec, \",\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n      auto configPermissions = config.getViewInfo().getPermissions();\n      kj::Vector<kj::String> permissionVec(configPermissions.size());\n  \n      for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n        if (userPermissions[i]) {\n          permissionVec.add(kj::str(configPermissions[i].getName()));\n        }\n      }\n      return kj::strArray(permissionVec, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpApi.getPermissions",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "httpApi.getPath()",
            "'/'"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.getPath",
          "args": [],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setIdentity",
          "args": [
            "kj::mv(identity)"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setIdentityId",
          "args": [
            "httpApi.getIdentityId()"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.getIdentityId",
          "args": [],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setPermissions",
          "args": [
            "httpApi.getPermissions()"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpApi.getPermissions",
          "args": [],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setPronouns",
          "args": [
            "profile.getPronouns()"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile.getPronouns",
          "args": [],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setPictureUrl",
          "args": [
            "kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath())"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "pictureResponse.getProtocol()",
            "\"://\"",
            "pictureResponse.getHostPath()"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pictureResponse.getHostPath",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pictureResponse.getProtocol",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setPreferredHandle",
          "args": [
            "profile.getPreferredHandle()"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile.getPreferredHandle",
          "args": [],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.setDisplayName",
          "args": [
            "profile.getDisplayName()"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile.getDisplayName",
          "args": [],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfoBuilder.getRoot<UserInfo>",
          "args": [],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profileResponse.getProfile",
          "args": [],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "identity"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "profileResponse"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "identity"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "pictureRequest"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profileRequest.getProfile",
          "args": [],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profileRequest.getProfile",
          "args": [],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profileRequest.getProfile",
          "args": [],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profileRequest.getProfile",
          "args": [],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identity.getProfileRequest",
          "args": [],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identity.getProfileRequest",
          "args": [],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.loadIdentity",
          "args": [
            "textIdentityId(httpApi.getIdentityId())"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "loadIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1109-1169",
          "snippet": "Identity::Client loadIdentity(kj::StringPtr origId) {\n    // Obtain the identity capability for the given identity ID.\n\n    KJ_REQUIRE(config.getSaveIdentityCaps(),\n        \"sandstorm-http-bridge is not configured to save identity capabilities\",\n        \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n\n    // Copy string to use as map key.\n    auto textId = kj::heapString(origId);\n\n    auto iter = liveIdentities.find(textId);\n    if (iter == liveIdentities.end()) {\n      // Not in the map. Load from disk.\n      Identity::Client identity = loadIdentityFromDisk(textId);\n\n      tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n        // Successfully resolved. Add to map.\n        kj::StringPtr textIdRef = textId;\n        KJ_ASSERT(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n      }, [] (auto e) {\n        // Ignore the error here because the returned capability will report it upon use.\n      }));\n\n      return kj::mv(identity);\n    } else {\n      // Identity is in the map.\n      Identity::Client identity = iter->second.identity;\n\n      // We need to verify the capability is still connected. Send a dummy call to check. We'll\n      // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n      auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n      ping.initAsAnyStruct(0, 0);\n      return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n        // Weird, we shouldn't get here.\n        KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n\n        // But clearly we are still connected, so continue.\n        return kj::mv(identity);\n      }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                      -> kj::Promise<Identity::Client> {\n        if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Disconnected. We'll need to reload from disk.\n          Identity::Client newIdentity = loadIdentityFromDisk(textId);\n          tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n            // Save the new identity to the map so that we don't have to reload it again.\n            auto iter = liveIdentities.find(textId);\n            KJ_ASSERT(iter != liveIdentities.end());\n            iter->second.identity = kj::mv(newIdentity);\n          }, [] (auto e) {\n            // Ignore the error here because the returned capability will report it upon use.\n          }));\n\n          return kj::mv(newIdentity);\n        } else {\n          // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n          return kj::mv(identity);\n        }\n      });\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  Identity::Client loadIdentity(kj::StringPtr origId) {\n      // Obtain the identity capability for the given identity ID.\n  \n      KJ_REQUIRE(config.getSaveIdentityCaps(),\n          \"sandstorm-http-bridge is not configured to save identity capabilities\",\n          \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n  \n      // Copy string to use as map key.\n      auto textId = kj::heapString(origId);\n  \n      auto iter = liveIdentities.find(textId);\n      if (iter == liveIdentities.end()) {\n        // Not in the map. Load from disk.\n        Identity::Client identity = loadIdentityFromDisk(textId);\n  \n        tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n          // Successfully resolved. Add to map.\n          kj::StringPtr textIdRef = textId;\n          KJ_ASSERT(liveIdentities.insert(std::make_pair(\n            textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n        }, [] (auto e) {\n          // Ignore the error here because the returned capability will report it upon use.\n        }));\n  \n        return kj::mv(identity);\n      } else {\n        // Identity is in the map.\n        Identity::Client identity = iter->second.identity;\n  \n        // We need to verify the capability is still connected. Send a dummy call to check. We'll\n        // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n        auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n        ping.initAsAnyStruct(0, 0);\n        return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n          // Weird, we shouldn't get here.\n          KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n  \n          // But clearly we are still connected, so continue.\n          return kj::mv(identity);\n        }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                        -> kj::Promise<Identity::Client> {\n          if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n            // Disconnected. We'll need to reload from disk.\n            Identity::Client newIdentity = loadIdentityFromDisk(textId);\n            tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n              // Save the new identity to the map so that we don't have to reload it again.\n              auto iter = liveIdentities.find(textId);\n              KJ_ASSERT(iter != liveIdentities.end());\n              iter->second.identity = kj::mv(newIdentity);\n            }, [] (auto e) {\n              // Ignore the error here because the returned capability will report it upon use.\n            }));\n  \n            return kj::mv(newIdentity);\n          } else {\n            // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n            return kj::mv(identity);\n          }\n        });\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "textIdentityId",
          "args": [
            "httpApi.getIdentityId()"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "textIdentityId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "70-74",
          "snippet": "kj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpApi.getIdentityId",
          "args": [],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\n\nWebSession::Client newPowerboxApiSession(\n    kj::NetworkAddress& serverAddress, BridgeContext& bridgeContext,\n    OwnCapnp<BridgeObjectId::HttpApi>&& httpApi) {\n  // We need to fetch the user's profile information.\n  //\n  // TODO(someday): The restore() method should be extended to take profile information as a\n  //   parameter, passed from Sandstorm. The profile information should allow for representing\n  //   the client grain as if it were an identity, so that when one grain changes another through\n  //   an API, the changes are attributed to the calling grain, not to the user who connected the\n  //   grains. (Of course, the \"who has access\" tree can indicate who gave that grain\n  //   permission.)\n  auto identity = bridgeContext.loadIdentity(textIdentityId(httpApi.getIdentityId()));\n  auto profileRequest = identity.getProfileRequest().send();\n  auto pictureRequest = profileRequest.getProfile().getPicture().getUrlRequest().send();\n\n  return profileRequest\n      .then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n             KJ_MVCAP(pictureRequest),KJ_MVCAP(identity)](\n          capnp::Response<Identity::GetProfileResults> profileResponse) mutable {\n    return pictureRequest.then([&serverAddress,&bridgeContext,KJ_MVCAP(httpApi),\n                                KJ_MVCAP(profileResponse),KJ_MVCAP(identity)](\n        capnp::Response<StaticAsset::GetUrlResults> pictureResponse) mutable {\n      auto profile = profileResponse.getProfile();\n      capnp::MallocMessageBuilder userInfoBuilder;\n      auto userInfo = userInfoBuilder.getRoot<UserInfo>();\n      userInfo.setDisplayName(profile.getDisplayName());\n      userInfo.setPreferredHandle(profile.getPreferredHandle());\n      userInfo.setPictureUrl(\n          kj::str(pictureResponse.getProtocol(), \"://\", pictureResponse.getHostPath()));\n      userInfo.setPronouns(profile.getPronouns());\n      userInfo.setPermissions(httpApi.getPermissions());\n      userInfo.setIdentityId(httpApi.getIdentityId());\n      userInfo.setIdentity(kj::mv(identity));\n\n      return WebSession::Client(\n          kj::heap<WebSessionImpl>(serverAddress, userInfo, nullptr,\n                                   bridgeContext, nullptr, nullptr,\n                                   nullptr, nullptr, nullptr,\n                                   kj::str(httpApi.getPath(), '/'),\n                                   bridgeContext.formatPermissions(httpApi.getPermissions()),\n                                   nullptr, kj::mv(httpApi)));\n    }"
  },
  {
    "function_name": "makeDepthHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1832-1835",
    "snippet": "kj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"Depth: infinity\""
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"Depth: 0\""
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }"
  },
  {
    "function_name": "makeOverwriteHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1827-1830",
    "snippet": "kj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"Overwrite: T\""
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"Overwrite: F\""
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }"
  },
  {
    "function_name": "makeDestinationHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1820-1825",
    "snippet": "kj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String basePath;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Destination: \"",
            "basePath",
            "destination"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "c > ' ' && c != ','",
            "\"invalid destination\"",
            "destination"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String basePath;\n\nkj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }"
  },
  {
    "function_name": "expectSize",
    "container": "IgnoreStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1817-1817",
    "snippet": "kj::Promise<void> expectSize(ExpectSizeContext context) override { return kj::READY_NOW; }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> expectSize(ExpectSizeContext context) override { return kj::READY_NOW; }\n}"
  },
  {
    "function_name": "done",
    "container": "IgnoreStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1816-1816",
    "snippet": "kj::Promise<void> done(DoneContext context) override { return kj::READY_NOW; }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> done(DoneContext context) override { return kj::READY_NOW; }\n}"
  },
  {
    "function_name": "write",
    "container": "IgnoreStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1815-1815",
    "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
  },
  {
    "function_name": "sendOptionsRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1786-1810",
    "snippet": "kj::Promise<void> sendOptionsRequest(kj::String httpRequest, OptionsContext& context) {\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::StringPtr httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(kj::heap<IgnoreStream>());\n\n        return parser->readResponse(*stream).then(\n            [context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        });\n      });\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [
            "[KJ_MVCAP(httpRequest)",
            "context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable{\n      kj::StringPtr httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(kj::heap<IgnoreStream>());\n\n        return parser->readResponse(*stream).then(\n            [context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        });\n      }"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "[context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder)mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        }"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parserRef.buildOptions",
          "args": [
            "context.getResults()"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->pumpStream",
          "args": [
            "kj::mv(stream)"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "remainder.size() == 0"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remainder.size",
          "args": [],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "]",
          "args": [
            "kj::ArrayPtr<byte> remainder"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "parser"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "*stream"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<HttpParser>",
          "args": [
            "kj::heap<IgnoreStream>()"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<IgnoreStream>",
          "args": [],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "[KJ_MVCAP(stream)",
            "context]("
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "kj::mv(httpRequest)"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpRequestRef.begin",
          "args": [],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context",
          "args": [
            "kj::Own<kj::AsyncIoStream>&& stream"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendOptionsRequest(kj::String httpRequest, OptionsContext& context) {\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::StringPtr httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(kj::heap<IgnoreStream>());\n\n        return parser->readResponse(*stream).then(\n            [context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        });\n      });\n    }"
  },
  {
    "function_name": "sendRequestStreaming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1773-1784",
    "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [
            "[KJ_MVCAP(httpRequest)",
            "responseStream",
            "context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable{\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    }"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::mv(requestStream)"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "requestStream"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<RequestStreamImpl>",
          "args": [
            "kj::mv(httpRequest)",
            "kj::mv(stream)",
            "responseStream"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context",
          "args": [
            "kj::Own<kj::AsyncIoStream>&& stream"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
  },
  {
    "function_name": "sendRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1741-1769",
    "snippet": "kj::Promise<void> sendRequest(kj::Array<byte> httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), responseStream, context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(responseStream);\n        auto results = context.getResults();\n\n        return parser->readResponse(*stream).then(\n            [results, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          sandstorm::Handle::Client handle = kj::mv(parser);\n          parserRef.build(results, handle);\n        });\n      });\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [
            "[KJ_MVCAP(httpRequest)",
            "responseStream",
            "context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable{\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), responseStream, context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(responseStream);\n        auto results = context.getResults();\n\n        return parser->readResponse(*stream).then(\n            [results, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          sandstorm::Handle::Client handle = kj::mv(parser);\n          parserRef.build(results, handle);\n        });\n      }"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "[results, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder)mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          sandstorm::Handle::Client handle = kj::mv(parser);\n          parserRef.build(results, handle);\n        }"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parserRef.build",
          "args": [
            "results",
            "handle"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "parser"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->pumpStream",
          "args": [
            "kj::mv(stream)"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "remainder.size() == 0"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remainder.size",
          "args": [],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "]",
          "args": [
            "kj::ArrayPtr<byte> remainder"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "parser"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "*stream"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<HttpParser>",
          "args": [
            "responseStream"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "[KJ_MVCAP(stream)",
            "responseStream",
            "context]("
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "kj::mv(httpRequest)"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "httpRequestRef.begin()",
            "httpRequestRef.size()"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpRequestRef.begin",
          "args": [],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context",
          "args": [
            "kj::Own<kj::AsyncIoStream>&& stream"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequest(kj::Array<byte> httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), responseStream, context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(responseStream);\n        auto results = context.getResults();\n\n        return parser->readResponse(*stream).then(\n            [results, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          sandstorm::Handle::Client handle = kj::mv(parser);\n          parserRef.build(results, handle);\n        });\n      });\n    }"
  },
  {
    "function_name": "addCommonHeaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1614-1738",
    "snippet": "void addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "class WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;",
      "kj::String sessionId;",
      "kj::String tabId;",
      "kj::String userDisplayName;",
      "kj::String userHandle;",
      "kj::String userPicture;",
      "Profile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;",
      "kj::Maybe<kj::String> userId;",
      "kj::String permissions;",
      "kj::String basePath;",
      "kj::String userAgent;",
      "kj::Maybe<kj::String> remoteAddress;",
      "kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"\")"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\""
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"\")"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\""
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \"))"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"If-None-Match: \"",
            "kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()){\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }",
            "\", \""
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "'\"'",
            "e.getValue()",
            "'\"'"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getValue",
          "args": [],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"W/\\\"\"",
            "e.getValue()",
            "'\"'"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getValue",
          "args": [],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getWeak",
          "args": [],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "e",
            "eTagPrecondition.getMatchesNoneOf()"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eTagPrecondition.getMatchesNoneOf",
          "args": [],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \"))"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"If-Match: \"",
            "kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(e, eTagPrecondition.getMatchesOneOf()){\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }",
            "\", \""
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "'\"'",
            "e.getValue()",
            "'\"'"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getValue",
          "args": [],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"W/\\\"\"",
            "e.getValue()",
            "'\"'"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getValue",
          "args": [],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getWeak",
          "args": [],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "e",
            "eTagPrecondition.getMatchesOneOf()"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eTagPrecondition.getMatchesOneOf",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"If-None-Match: *\")"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"If-None-Match: *\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"If-Match: *\")"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"If-Match: *\""
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eTagPrecondition.which",
          "args": [],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(headerName, \": \", headerValue)"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "headerName",
            "\": \"",
            "headerValue"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REQUEST_HEADER_WHITELIST.matches",
          "args": [
            "headerName"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "matches",
          "container": "HeaderWhitelist",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "842-869",
          "snippet": "bool HeaderWhitelist::matches(kj::StringPtr header) const {\n  // Convert to lower-case on stack.\n  KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n  memcpy(buffer.begin(), header.begin(), buffer.size());\n  toLower(buffer);\n  header = kj::StringPtr(buffer.begin(), header.size());\n\n  auto iter = patterns.lower_bound(header);\n  if (iter != patterns.end() && *iter == header) {\n    return true;\n  }\n\n  if (iter == patterns.begin()) return false;\n\n  // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n  // because the character '*' sorts before all characters that are valid inside headers.\n  --iter;\n  if (iter->endsWith(\"*\")) {\n    // Check if prefix matches.\n    auto prefix = iter->slice(0, iter->size() - 1);\n    if (header.size() >= prefix.size() &&\n        memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nHeaderWhitelist {\n  bool HeaderWhitelist::matches(kj::StringPtr header) const {\n    // Convert to lower-case on stack.\n    KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n    memcpy(buffer.begin(), header.begin(), buffer.size());\n    toLower(buffer);\n    header = kj::StringPtr(buffer.begin(), header.size());\n  \n    auto iter = patterns.lower_bound(header);\n    if (iter != patterns.end() && *iter == header) {\n      return true;\n    }\n  \n    if (iter == patterns.begin()) return false;\n  \n    // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n    // because the character '*' sorts before all characters that are valid inside headers.\n    --iter;\n    if (iter->endsWith(\"*\")) {\n      // Check if prefix matches.\n      auto prefix = iter->slice(0, iter->size() - 1);\n      if (header.size() >= prefix.size() &&\n          memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "header.getValue",
          "args": [],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header.getName",
          "args": [],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "additionalHeaderList.size",
          "args": [],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getAdditionalHeaders",
          "args": [],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \"))"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Accept-Encoding: \"",
            "kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(c, acceptEncodingList){\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }",
            "\", \""
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "c.getContentCoding()",
            "\"; q=\"",
            "c.getQValue()"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getQValue",
          "args": [],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getContentCoding",
          "args": [],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "c.getContentCoding()"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getContentCoding",
          "args": [],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getQValue",
          "args": [],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "c",
            "acceptEncodingList"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getAcceptEncoding",
          "args": [],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Accept: */*\")"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Accept: */*\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \"))"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Accept: \"",
            "kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(c, acceptList){\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }",
            "\", \""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "c.getMimeType()",
            "\"; q=\"",
            "c.getQValue()"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getQValue",
          "args": [],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getMimeType",
          "args": [],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "c.getMimeType()"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getMimeType",
          "args": [],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getQValue",
          "args": [],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "c",
            "acceptList"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getAccept",
          "args": [],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \"))"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Cookie: \"",
            "kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(c, cookies){\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }",
            "\"; \""
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "c.getKey()",
            "\"=\"",
            "c.getValue()"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getValue",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c.getKey",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "c",
            "cookies"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getCookies",
          "args": [],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Api: \", i->getName())"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Api: \"",
            "i->getName()"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->getName",
          "args": [],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Real-IP: \", *addr)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Real-IP: \"",
            "*addr"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Session-Id: \", sessionId)"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Session-Id: \"",
            "sessionId"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Host: sandbox\")"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Host: sandbox\""
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath))"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Forwarded-Proto: \"",
            "extractProtocolFromUrl(basePath)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extractProtocolFromUrl",
          "args": [
            "basePath"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "extractProtocolFromUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "472-477",
          "snippet": "kj::ArrayPtr<const char> extractProtocolFromUrl(kj::StringPtr url) {\n  KJ_IF_MAYBE(colonPos, url.findFirst(':')) {\n    return url.slice(0, *colonPos);\n  } else {\n    KJ_FAIL_REQUIRE(\"Base URL does not have a protocol scheme.\", url);\n  }",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> extractProtocolFromUrl(kj::StringPtr url) {\n  KJ_IF_MAYBE(colonPos, url.findFirst(':')) {\n    return url.slice(0, *colonPos);\n  } else {\n    KJ_FAIL_REQUIRE(\"Base URL does not have a protocol scheme.\", url);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Host: \", extractHostFromUrl(basePath))"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Host: \"",
            "extractHostFromUrl(basePath)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extractHostFromUrl",
          "args": [
            "basePath"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "extractHostFromUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "459-470",
          "snippet": "kj::ArrayPtr<const char> extractHostFromUrl(kj::StringPtr url) {\n  while (url.size() > 0 && 'a' <= url[0] && url[0] <= 'z') {\n    url = url.slice(1);\n  }\n  KJ_REQUIRE(url.startsWith(\"://\"), \"Base URL does not have a protocol scheme?\");\n  url = url.slice(3);\n  KJ_IF_MAYBE(slashPos, url.findFirst('/')) {\n    return url.slice(0, *slashPos);\n  } else {\n    return url;\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> extractHostFromUrl(kj::StringPtr url) {\n  while (url.size() > 0 && 'a' <= url[0] && url[0] <= 'z') {\n    url = url.slice(1);\n  }\n  KJ_REQUIRE(url.startsWith(\"://\"), \"Base URL does not have a protocol scheme?\");\n  url = url.slice(3);\n  KJ_IF_MAYBE(slashPos, url.findFirst('/')) {\n    return url.slice(0, *slashPos);\n  } else {\n    return url;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Base-Path: \", basePath)"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Base-Path: \"",
            "basePath"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Permissions: \", permissions)"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Permissions: \"",
            "permissions"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName())"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-User-Pronouns: \"",
            "enumerants[pronounValue].getProto().getName()"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants[pronounValue].getProto",
          "args": [],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants[pronounValue].getProto",
          "args": [],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getEnumerants",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "userPronouns"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<Profile::Pronouns>",
          "args": [],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-User-Picture: \", userPicture)"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-User-Picture: \"",
            "userPicture"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle)"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Preferred-Handle: \"",
            "userHandle"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-User-Id: \", *u)"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-User-Id: \"",
            "*u"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Username: \", userDisplayName)"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Username: \"",
            "userDisplayName"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"X-Sandstorm-Tab-Id: \", tabId)"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"X-Sandstorm-Tab-Id: \"",
            "tabId"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"User-Agent: \", userAgent)"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"User-Agent: \"",
            "userAgent"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nclass WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;\nkj::String sessionId;\nkj::String tabId;\nkj::String userDisplayName;\nkj::String userHandle;\nkj::String userPicture;\nProfile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;\nkj::Maybe<kj::String> userId;\nkj::String permissions;\nkj::String basePath;\nkj::String userAgent;\nkj::Maybe<kj::String> remoteAddress;\nkj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;\n\nvoid addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }"
  },
  {
    "function_name": "catHeaderLines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1605-1612",
    "snippet": "static kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "lines",
            "\"\\r\\n\""
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "line.findFirst('\\n') == nullptr",
            "\"HTTP header contained newline; blocking to prevent injection.\""
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.findFirst",
          "args": [
            "'\\n'"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }"
  },
  {
    "function_name": "makeHeaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1578-1603",
    "snippet": "kj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String acceptLanguages;",
      "kj::String rootPath;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "catHeaderLines",
          "args": [
            "lines"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "catHeaderLines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1605-1612",
          "snippet": "static kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "addCommonHeaders",
          "args": [
            "lines",
            "context"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "addCommonHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1614-1738",
          "snippet": "void addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "class WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;",
            "kj::String sessionId;",
            "kj::String tabId;",
            "kj::String userDisplayName;",
            "kj::String userHandle;",
            "kj::String userPicture;",
            "Profile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;",
            "kj::Maybe<kj::String> userId;",
            "kj::String permissions;",
            "kj::String basePath;",
            "kj::String userAgent;",
            "kj::Maybe<kj::String> remoteAddress;",
            "kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nclass WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;\nkj::String sessionId;\nkj::String tabId;\nkj::String userDisplayName;\nkj::String userHandle;\nkj::String userPicture;\nProfile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;\nkj::Maybe<kj::String> userId;\nkj::String permissions;\nkj::String basePath;\nkj::String userAgent;\nkj::Maybe<kj::String> remoteAddress;\nkj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;\n\nvoid addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Accept-Language: \", acceptLanguages)"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Accept-Language: \"",
            "acceptLanguages"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptLanguages.size",
          "args": [],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::mv(extraHeader3)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "extraHeader3"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::mv(extraHeader2)"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "extraHeader2"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::mv(extraHeader1)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "extraHeader1"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Connection: close\")"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Connection: close\""
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(method, \" \", rootPath, path, \" HTTP/1.1\")"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "method",
            "\" \"",
            "rootPath",
            "path",
            "\" HTTP/1.1\""
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String acceptLanguages;\nkj::String rootPath;\n\nkj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }"
  },
  {
    "function_name": "save",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1542-1555",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "BridgeContext& bridgeContext;",
      "kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"can't save() non-powerbox BridgeHttpSession\""
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setLabel",
          "args": [
            "meta.getDisplayInfo().getTitle()"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta.getDisplayInfo",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta.getDisplayInfo",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->getName",
          "args": [],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta.getName",
          "args": [],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeContext.getPowerboxApis",
          "args": [],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "getPowerboxApis",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1078-1080",
          "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n      return config.getPowerboxApis();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "results.initObjectId",
          "args": [
            "*info"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initObjectId",
          "args": [],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;\n\nWebSessionImpl {\n  kj::Promise<void> save(SaveContext context) override {\n      KJ_IF_MAYBE(info, apiInfo) {\n        auto results = context.getResults();\n        results.initObjectId().setHttpApi(*info);\n        for (auto meta: bridgeContext.getPowerboxApis()) {\n          if (meta.getName() == info->getName()) {\n            results.setLabel(meta.getDisplayInfo().getTitle());\n            break;\n          }\n        }\n        return kj::READY_NOW;\n      } else {\n        KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n      }\n}"
  },
  {
    "function_name": "openWebSocket",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1489-1540",
    "snippet": "kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String rootPath;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [
            "[this, KJ_MVCAP(httpRequest),KJ_MVCAP(clientStream)",
            "responseStream",
            "context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable{\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    }"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "[KJ_MVCAP(stream)",
            "KJ_MVCAP(clientStream)",
            "responseStream",
            "context]\n                () mutable{\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          }"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "[results, KJ_MVCAP(stream),KJ_MVCAP(clientStream)",
            "KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable{\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            }"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setServerStream",
          "args": [
            "kj::mv(pump)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pump"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pump->pump",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "WebSocketPump",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "848-860",
          "snippet": "void pump() {\n    // Repeatedly read from serverStream and write to clientStream.\n    tasks.add(serverStream->tryRead(buffer, 1, sizeof(buffer))\n        .then([this](size_t amount) {\n      if (amount > 0) {\n        sendData(kj::arrayPtr(buffer, amount));\n        pump();\n      } else {\n        // EOF.\n        clientStream = nullptr;\n      }\n    }));\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void pump() {\n      // Repeatedly read from serverStream and write to clientStream.\n      tasks.add(serverStream->tryRead(buffer, 1, sizeof(buffer))\n          .then([this](size_t amount) {\n        if (amount > 0) {\n          sendData(kj::arrayPtr(buffer, amount));\n          pump();\n        } else {\n          // EOF.\n          clientStream = nullptr;\n        }\n      }));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pump->sendData",
          "args": [
            "remainder"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "sendData",
          "container": "WebSocketPump",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "862-868",
          "snippet": "void sendData(kj::ArrayPtr<byte> data) {\n    // Write the given bytes to clientStream.\n    auto request = clientStream.sendBytesRequest(\n        capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n    request.setMessage(data);\n    tasks.add(request.send().ignoreResult());\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void sendData(kj::ArrayPtr<byte> data) {\n      // Write the given bytes to clientStream.\n      auto request = clientStream.sendBytesRequest(\n          capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n      request.setMessage(data);\n      tasks.add(request.send().ignoreResult());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "remainder.size",
          "args": [],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->buildForWebSocket",
          "args": [
            "results"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSocketPump>",
          "args": [
            "kj::mv(stream)",
            "kj::mv(clientStream)"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "clientStream"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "]",
          "args": [
            "kj::ArrayPtr<byte> remainder"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "parser"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "clientStream"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "*stream"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<HttpParser>",
          "args": [
            "responseStream"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "clientStream"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "kj::mv(httpRequest)"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamRef.write",
          "args": [
            "httpRequestRef.begin()",
            "httpRequestRef.size()"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpRequestRef.begin",
          "args": [],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context",
          "args": [
            "kj::Own<kj::AsyncIoStream>&& stream"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "clientStream"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverAddr.connect",
          "args": [],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getClientStream",
          "args": [],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "catHeaderLines(lines)"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "catHeaderLines",
          "args": [
            "lines"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "catHeaderLines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1605-1612",
          "snippet": "static kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic kj::String catHeaderLines(kj::Vector<kj::String>& lines) {\n    for (auto& line: lines) {\n      KJ_ASSERT(line.findFirst('\\n') == nullptr,\n                \"HTTP header contained newline; blocking to prevent injection.\");\n    }\n\n    return kj::strArray(lines, \"\\r\\n\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "addCommonHeaders",
          "args": [
            "lines",
            "params.getContext()"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "addCommonHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1614-1738",
          "snippet": "void addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "class WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;",
            "kj::String sessionId;",
            "kj::String tabId;",
            "kj::String userDisplayName;",
            "kj::String userHandle;",
            "kj::String userPicture;",
            "Profile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;",
            "kj::Maybe<kj::String> userId;",
            "kj::String permissions;",
            "kj::String basePath;",
            "kj::String userAgent;",
            "kj::Maybe<kj::String> remoteAddress;",
            "kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nclass WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;\nkj::String sessionId;\nkj::String tabId;\nkj::String userDisplayName;\nkj::String userHandle;\nkj::String userPicture;\nProfile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;\nkj::Maybe<kj::String> userId;\nkj::String permissions;\nkj::String basePath;\nkj::String userAgent;\nkj::Maybe<kj::String> remoteAddress;\nkj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;\n\nvoid addCommonHeaders(kj::Vector<kj::String>& lines, WebSession::Context::Reader context) {\n    if (userAgent.size() > 0) {\n      lines.add(kj::str(\"User-Agent: \", userAgent));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Tab-Id: \", tabId));\n    lines.add(kj::str(\"X-Sandstorm-Username: \", userDisplayName));\n    KJ_IF_MAYBE(u, userId) {\n      lines.add(kj::str(\"X-Sandstorm-User-Id: \", *u));\n\n      // Since the user is logged in, also include their other info.\n      if (userHandle.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-Preferred-Handle: \", userHandle));\n      }\n      if (userPicture.size() > 0) {\n        lines.add(kj::str(\"X-Sandstorm-User-Picture: \", userPicture));\n      }\n      capnp::EnumSchema schema = capnp::Schema::from<Profile::Pronouns>();\n      uint pronounValue = static_cast<uint>(userPronouns);\n      auto enumerants = schema.getEnumerants();\n      if (pronounValue > 0 && pronounValue < enumerants.size()) {\n        lines.add(kj::str(\"X-Sandstorm-User-Pronouns: \",\n            enumerants[pronounValue].getProto().getName()));\n      }\n    }\n    lines.add(kj::str(\"X-Sandstorm-Permissions: \", permissions));\n    if (basePath.size() > 0) {\n      lines.add(kj::str(\"X-Sandstorm-Base-Path: \", basePath));\n      lines.add(kj::str(\"Host: \", extractHostFromUrl(basePath)));\n      lines.add(kj::str(\"X-Forwarded-Proto: \", extractProtocolFromUrl(basePath)));\n    } else {\n      // Dummy value. Some API servers (e.g. git-http-backend) fail if Host is not present.\n      lines.add(kj::str(\"Host: sandbox\"));\n    }\n    lines.add(kj::str(\"X-Sandstorm-Session-Id: \", sessionId));\n    KJ_IF_MAYBE(addr, remoteAddress) {\n      lines.add(kj::str(\"X-Real-IP: \", *addr));\n    }\n    KJ_IF_MAYBE(i, apiInfo) {\n      lines.add(kj::str(\"X-Sandstorm-Api: \", i->getName()));\n    }\n\n    auto cookies = context.getCookies();\n    if (cookies.size() > 0) {\n      lines.add(kj::str(\"Cookie: \", kj::strArray(\n            KJ_MAP(c, cookies) {\n              return kj::str(c.getKey(), \"=\", c.getValue());\n            }, \"; \")));\n    }\n    auto acceptList = context.getAccept();\n    if (acceptList.size() > 0) {\n      lines.add(kj::str(\"Accept: \", kj::strArray(\n            KJ_MAP(c, acceptList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getMimeType());\n              } else {\n                return kj::str(c.getMimeType(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    } else {\n      lines.add(kj::str(\"Accept: */*\"));\n    }\n    auto acceptEncodingList = context.getAcceptEncoding();\n    if (acceptEncodingList.size() > 0) {\n      lines.add(kj::str(\"Accept-Encoding: \", kj::strArray(\n            KJ_MAP(c, acceptEncodingList) {\n              if (c.getQValue() == 1.0) {\n                return kj::str(c.getContentCoding());\n              } else {\n                return kj::str(c.getContentCoding(), \"; q=\", c.getQValue());\n              }\n            }, \", \")));\n    }\n    auto additionalHeaderList = context.getAdditionalHeaders();\n    if (additionalHeaderList.size() > 0) {\n\n      for (auto header: additionalHeaderList) {\n        auto headerName = header.getName();\n        auto headerValue = header.getValue();\n\n        // Don't allow the header unless it is present in the whitelist. Note that Sandstorm never\n        // sends non-whitelisted headers, but it's possible that another app had directly obtained\n        // a WebSession capability to us, and that app could send whatever it wants, so we need\n        // to check.\n        if (REQUEST_HEADER_WHITELIST.matches(headerName)) {\n          // Note that we check elsewhere that each line contains no newlines, to prevent\n          // injections.\n          lines.add(kj::str(headerName, \": \", headerValue));\n        }\n      }\n    }\n    auto eTagPrecondition = context.getETagPrecondition();\n    switch (eTagPrecondition.which()) {\n      case WebSession::Context::ETagPrecondition::NONE:\n        break;\n      case WebSession::Context::ETagPrecondition::EXISTS:\n        lines.add(kj::str(\"If-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::DOESNT_EXIST:\n        lines.add(kj::str(\"If-None-Match: *\"));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_ONE_OF:\n        lines.add(kj::str(\"If-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesOneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n      case WebSession::Context::ETagPrecondition::MATCHES_NONE_OF:\n        lines.add(kj::str(\"If-None-Match: \", kj::strArray(\n              KJ_MAP(e, eTagPrecondition.getMatchesNoneOf()) {\n                if (e.getWeak()) {\n                  return kj::str(\"W/\\\"\", e.getValue(), '\"');\n                } else {\n                  return kj::str('\"', e.getValue(), '\"');\n                }\n              }, \", \")));\n        break;\n    }\n\n    lines.add(kj::str(\"\"));\n    lines.add(kj::str(\"\"));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Sec-WebSocket-Version: 13\")"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Sec-WebSocket-Version: 13\""
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \"))"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Sec-WebSocket-Protocol: \"",
            "kj::strArray(params.getProtocol(), \", \")"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "params.getProtocol()",
            "\", \""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getProtocol",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getProtocol",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\")"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\""
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Connection: Upgrade\")"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Connection: Upgrade\""
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"Upgrade: websocket\")"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Upgrade: websocket\""
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.add",
          "args": [
            "kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\")"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"GET \"",
            "rootPath",
            "params.getPath()",
            "\" HTTP/1.1\""
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String rootPath;\n\nWebSessionImpl {\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n      // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n      //   not trying to work around broken proxies.\n  \n      auto params = context.getParams();\n  \n      kj::Vector<kj::String> lines(16);\n  \n      lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n      lines.add(kj::str(\"Upgrade: websocket\"));\n      lines.add(kj::str(\"Connection: Upgrade\"));\n      lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n      auto protocols = params.getProtocol();\n      if (protocols.size() > 0) {\n        lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n      }\n      lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n  \n      addCommonHeaders(lines, params.getContext());\n  \n      auto httpRequest = toBytes(catHeaderLines(lines));\n      WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n      sandstorm::ByteStream::Client responseStream =\n          context.getParams().getContext().getResponseStream();\n      context.releaseParams();\n  \n      return serverAddr.connect().then(\n          [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n          (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n        kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n        auto& streamRef = *stream;\n        return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n            .attach(kj::mv(httpRequest))\n            .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                  () mutable {\n              auto parser = kj::heap<HttpParser>(responseStream);\n              auto results = context.getResults();\n  \n              return parser->readResponse(*stream).then(\n                  [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                  (kj::ArrayPtr<byte> remainder) mutable {\n                auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n                parser->buildForWebSocket(results);\n                if (remainder.size() > 0) {\n                  pump->sendData(remainder);\n                }\n                pump->pump();\n                results.setServerStream(kj::mv(pump));\n              });\n            });\n      });\n    }\n}"
  },
  {
    "function_name": "putStreaming",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1481-1487",
    "snippet": "kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequestStreaming",
          "args": [
            "kj::mv(httpRequest)",
            "context"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"PUT\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", params.getMimeType())",
            "params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "params.getEncoding()"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getEncoding",
          "args": [],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.hasEncoding",
          "args": [],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "params.getMimeType()"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getMimeType",
          "args": [],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n      PutStreamingParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: \", params.getMimeType()),\n          params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n      return sendRequestStreaming(kj::mv(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "postStreaming",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1473-1479",
    "snippet": "kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequestStreaming",
          "args": [
            "kj::mv(httpRequest)",
            "context"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"POST\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", params.getMimeType())",
            "params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "params.getEncoding()"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getEncoding",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.hasEncoding",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "params.getMimeType()"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getMimeType",
          "args": [],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n      PostStreamingParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: \", params.getMimeType()),\n          params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n      return sendRequestStreaming(kj::mv(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "options",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1467-1471",
    "snippet": "kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendOptionsRequest",
          "args": [
            "kj::mv(httpRequest)",
            "context"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "sendOptionsRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1786-1810",
          "snippet": "kj::Promise<void> sendOptionsRequest(kj::String httpRequest, OptionsContext& context) {\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::StringPtr httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(kj::heap<IgnoreStream>());\n\n        return parser->readResponse(*stream).then(\n            [context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        });\n      });\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendOptionsRequest(kj::String httpRequest, OptionsContext& context) {\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::StringPtr httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), context]() mutable {\n        // Note:  Do not do stream->shutdownWrite() as some HTTP servers will decide to close the\n        // socket immediately on EOF, even if they have not actually responded to previous requests\n        // yet.\n        auto parser = kj::heap<HttpParser>(kj::heap<IgnoreStream>());\n\n        return parser->readResponse(*stream).then(\n            [context, KJ_MVCAP(stream), KJ_MVCAP(parser)]\n            (kj::ArrayPtr<byte> remainder) mutable {\n          KJ_ASSERT(remainder.size() == 0);\n          parser->pumpStream(kj::mv(stream));\n          auto &parserRef = *parser;\n          parserRef.buildOptions(context.getResults());\n        });\n      });\n    }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"OPTIONS\"",
            "params.getPath()",
            "params.getContext()"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "makeHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1578-1603",
          "snippet": "kj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String acceptLanguages;",
            "kj::String rootPath;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String acceptLanguages;\nkj::String rootPath;\n\nkj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> options(OptionsContext context) override {\n      OptionsParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n      return sendOptionsRequest(kj::mv(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "report",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1456-1465",
    "snippet": "kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, content.getContent())",
            "context"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "content.getContent()"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"REPORT\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", content.getMimeType())",
            "kj::str(\"Content-Length: \", content.getContent().size())",
            "content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "content.getEncoding()"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "content.getContent().size()"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "content.getMimeType()"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> report(ReportContext context) override {\n      ReportParams::Reader params = context.getParams();\n      auto content = params.getContent();\n      kj::String httpRequest = makeHeaders(\n          \"REPORT\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: \", content.getMimeType()),\n          kj::str(\"Content-Length: \", content.getContent().size()),\n          content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n      return sendRequest(toBytes(httpRequest, content.getContent()), context);\n    }\n}"
  },
  {
    "function_name": "acl",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1446-1454",
    "snippet": "kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, xml.asBytes())",
            "context"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "xml.asBytes()"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.asBytes",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"ACL\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: application/xml;charset=utf-8\")",
            "kj::str(\"Content-Length: \", xml.size())"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "xml.size()"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.size",
          "args": [],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: application/xml;charset=utf-8\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getXmlContent",
          "args": [],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> acl(AclContext context) override {\n      AclParams::Reader params = context.getParams();\n      auto xml = params.getXmlContent();\n      kj::String httpRequest = makeHeaders(\n          \"ACL\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n          kj::str(\"Content-Length: \", xml.size()));\n      return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n    }\n}"
  },
  {
    "function_name": "unlock",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1438-1444",
    "snippet": "kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, nullptr)",
            "context"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "nullptr"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"UNLOCK\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Lock-Token: \", params.getLockToken())"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Lock-Token: \"",
            "params.getLockToken()"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getLockToken",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> unlock(UnlockContext context) override {\n      UnlockParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\n          \"UNLOCK\", params.getPath(), params.getContext(),\n          kj::str(\"Lock-Token: \", params.getLockToken()));\n      return sendRequest(toBytes(httpRequest, nullptr), context);\n    }\n}"
  },
  {
    "function_name": "lock",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1427-1436",
    "snippet": "kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, xml.asBytes())",
            "context"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "xml.asBytes()"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.asBytes",
          "args": [],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"LOCK\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: application/xml;charset=utf-8\")",
            "kj::str(\"Content-Length: \", xml.size())",
            "makeDepthHeader(params.getShallow())"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepthHeader",
          "args": [
            "params.getShallow()"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepthHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1832-1835",
          "snippet": "kj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getShallow",
          "args": [],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "xml.size()"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.size",
          "args": [],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: application/xml;charset=utf-8\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getXmlContent",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> lock(LockContext context) override {\n      LockParams::Reader params = context.getParams();\n      auto xml = params.getXmlContent();\n      kj::String httpRequest = makeHeaders(\n          \"LOCK\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n          kj::str(\"Content-Length: \", xml.size()),\n          makeDepthHeader(params.getShallow()));\n      return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n    }\n}"
  },
  {
    "function_name": "move",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1418-1425",
    "snippet": "kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest)",
            "context"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"MOVE\"",
            "params.getPath()",
            "params.getContext()",
            "makeDestinationHeader(params.getDestination())",
            "makeOverwriteHeader(params.getNoOverwrite())"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeOverwriteHeader",
          "args": [
            "params.getNoOverwrite()"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "makeOverwriteHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1827-1830",
          "snippet": "kj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getNoOverwrite",
          "args": [],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDestinationHeader",
          "args": [
            "params.getDestination()"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "makeDestinationHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1820-1825",
          "snippet": "kj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String basePath;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String basePath;\n\nkj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getDestination",
          "args": [],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> move(MoveContext context) override {\n      MoveParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\n          \"MOVE\", params.getPath(), params.getContext(),\n          makeDestinationHeader(params.getDestination()),\n          makeOverwriteHeader(params.getNoOverwrite()));\n      return sendRequest(toBytes(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "copy",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1408-1416",
    "snippet": "kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest)",
            "context"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"COPY\"",
            "params.getPath()",
            "params.getContext()",
            "makeDestinationHeader(params.getDestination())",
            "makeOverwriteHeader(params.getNoOverwrite())",
            "makeDepthHeader(params.getShallow())"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepthHeader",
          "args": [
            "params.getShallow()"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepthHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1832-1835",
          "snippet": "kj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeDepthHeader(bool shallow) {\n    return shallow ? kj::heapString(\"Depth: 0\")\n                   : kj::heapString(\"Depth: infinity\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getShallow",
          "args": [],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeOverwriteHeader",
          "args": [
            "params.getNoOverwrite()"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "makeOverwriteHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1827-1830",
          "snippet": "kj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String makeOverwriteHeader(bool noOverwrite) {\n    return noOverwrite ? kj::heapString(\"Overwrite: F\")\n                       : kj::heapString(\"Overwrite: T\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getNoOverwrite",
          "args": [],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDestinationHeader",
          "args": [
            "params.getDestination()"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "makeDestinationHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1820-1825",
          "snippet": "kj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String basePath;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String basePath;\n\nkj::String makeDestinationHeader(kj::StringPtr destination) {\n    for (char c: destination) {\n      KJ_ASSERT(c > ' ' && c != ',', \"invalid destination\", destination);\n    }\n    return kj::str(\"Destination: \", basePath, destination);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getDestination",
          "args": [],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> copy(CopyContext context) override {\n      CopyParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\n          \"COPY\", params.getPath(), params.getContext(),\n          makeDestinationHeader(params.getDestination()),\n          makeOverwriteHeader(params.getNoOverwrite()),\n          makeDepthHeader(params.getShallow()));\n      return sendRequest(toBytes(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "mkcol",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1397-1406",
    "snippet": "kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, content.getContent())",
            "context"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "content.getContent()"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"MKCOL\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", content.getMimeType())",
            "kj::str(\"Content-Length: \", content.getContent().size())",
            "content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "content.getEncoding()"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "content.getContent().size()"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "content.getMimeType()"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> mkcol(MkcolContext context) override {\n      MkcolParams::Reader params = context.getParams();\n      auto content = params.getContent();\n      kj::String httpRequest = makeHeaders(\n          \"MKCOL\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: \", content.getMimeType()),\n          kj::str(\"Content-Length: \", content.getContent().size()),\n          content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n      return sendRequest(toBytes(httpRequest, content.getContent()), context);\n    }\n}"
  },
  {
    "function_name": "proppatch",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1387-1395",
    "snippet": "kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, xml.asBytes())",
            "context"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "xml.asBytes()"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.asBytes",
          "args": [],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"PROPPATCH\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: application/xml;charset=utf-8\")",
            "kj::str(\"Content-Length: \", xml.size())"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "xml.size()"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.size",
          "args": [],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: application/xml;charset=utf-8\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getXmlContent",
          "args": [],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n      ProppatchParams::Reader params = context.getParams();\n      auto xml = params.getXmlContent();\n      kj::String httpRequest = makeHeaders(\n          \"PROPPATCH\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n          kj::str(\"Content-Length: \", xml.size()));\n      return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n    }\n}"
  },
  {
    "function_name": "propfind",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1368-1385",
    "snippet": "kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, xml.asBytes())",
            "context"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "xml.asBytes()"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.asBytes",
          "args": [],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"PROPFIND\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: application/xml;charset=utf-8\")",
            "kj::str(\"Content-Length: \", xml.size())",
            "kj::str(\"Depth: \", depth)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Depth: \"",
            "depth"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "xml.size()"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.size",
          "args": [],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: application/xml;charset=utf-8\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getXmlContent",
          "args": [],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getDepth",
          "args": [],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> propfind(PropfindContext context) override {\n      PropfindParams::Reader params = context.getParams();\n  \n      const char* depth = \"infinity\";\n      switch (params.getDepth()) {\n        case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n        case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n        case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n      }\n  \n      auto xml = params.getXmlContent();\n      kj::String httpRequest = makeHeaders(\n          \"PROPFIND\", params.getPath(), params.getContext(),\n          kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n          kj::str(\"Content-Length: \", xml.size()),\n          kj::str(\"Depth: \", depth));\n      return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n    }\n}"
  },
  {
    "function_name": "delete_",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1362-1366",
    "snippet": "kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest)",
            "context"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"DELETE\"",
            "params.getPath()",
            "params.getContext()"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "makeHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1578-1603",
          "snippet": "kj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String acceptLanguages;",
            "kj::String rootPath;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String acceptLanguages;\nkj::String rootPath;\n\nkj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> delete_(DeleteContext context) override {\n      DeleteParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n      return sendRequest(toBytes(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "patch",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1352-1360",
    "snippet": "kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, content.getContent())",
            "context"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "content.getContent()"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"PATCH\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", content.getMimeType())",
            "kj::str(\"Content-Length: \", content.getContent().size())",
            "content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "content.getEncoding()"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "content.getContent().size()"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "content.getMimeType()"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> patch(PatchContext context) override {\n      PatchParams::Reader params = context.getParams();\n      auto content = params.getContent();\n      kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n      return sendRequest(toBytes(httpRequest, content.getContent()), context);\n    }\n}"
  },
  {
    "function_name": "put",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1342-1350",
    "snippet": "kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, content.getContent())",
            "context"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "content.getContent()"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"PUT\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", content.getMimeType())",
            "kj::str(\"Content-Length: \", content.getContent().size())",
            "content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "content.getEncoding()"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "content.getContent().size()"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "content.getMimeType()"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> put(PutContext context) override {\n      PutParams::Reader params = context.getParams();\n      auto content = params.getContent();\n      kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n      return sendRequest(toBytes(httpRequest, content.getContent()), context);\n    }\n}"
  },
  {
    "function_name": "post",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1332-1340",
    "snippet": "kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest, content.getContent())",
            "context"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest",
            "content.getContent()"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "\"POST\"",
            "params.getPath()",
            "params.getContext()",
            "kj::str(\"Content-Type: \", content.getMimeType())",
            "kj::str(\"Content-Length: \", content.getContent().size())",
            "content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Encoding: \"",
            "content.getEncoding()"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Length: \"",
            "content.getContent().size()"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getContent",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Content-Type: \"",
            "content.getMimeType()"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContent",
          "args": [],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> post(PostContext context) override {\n      PostParams::Reader params = context.getParams();\n      auto content = params.getContent();\n      kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n      return sendRequest(toBytes(httpRequest, content.getContent()), context);\n    }\n}"
  },
  {
    "function_name": "get",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1325-1330",
    "snippet": "kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendRequest",
          "args": [
            "toBytes(httpRequest)",
            "context"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "sendRequestStreaming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1773-1784",
          "snippet": "kj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Promise<void> sendRequestStreaming(kj::String httpRequest, Context& context) {\n    sandstorm::ByteStream::Client responseStream =\n      context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n    return serverAddr.connect().then(\n        [KJ_MVCAP(httpRequest), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      auto requestStream = kj::heap<RequestStreamImpl>(\n          kj::mv(httpRequest), kj::mv(stream), responseStream);\n      context.getResults().setStream(kj::mv(requestStream));\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "httpRequest"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeHeaders",
          "args": [
            "params.getIgnoreBody() ? \"HEAD\" : \"GET\"",
            "params.getPath()",
            "params.getContext()"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "makeHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1578-1603",
          "snippet": "kj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String acceptLanguages;",
            "kj::String rootPath;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String acceptLanguages;\nkj::String rootPath;\n\nkj::String makeHeaders(kj::StringPtr method, kj::StringPtr path,\n                         WebSession::Context::Reader context,\n                         kj::String extraHeader1 = nullptr,\n                         kj::String extraHeader2 = nullptr,\n                         kj::String extraHeader3 = nullptr) {\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(method, \" \", rootPath, path, \" HTTP/1.1\"));\n    lines.add(kj::str(\"Connection: close\"));\n    if (extraHeader1 != nullptr) {\n      lines.add(kj::mv(extraHeader1));\n    }\n    if (extraHeader2 != nullptr) {\n      lines.add(kj::mv(extraHeader2));\n    }\n    if (extraHeader3 != nullptr) {\n      lines.add(kj::mv(extraHeader3));\n    }\n    if (acceptLanguages.size() > 0) {\n      lines.add(kj::str(\"Accept-Language: \", acceptLanguages));\n    }\n\n    addCommonHeaders(lines, context);\n\n    return catHeaderLines(lines);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getIgnoreBody",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      GetParams::Reader params = context.getParams();\n      kj::String httpRequest = makeHeaders(\n          params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n      return sendRequest(toBytes(httpRequest), context);\n    }\n}"
  },
  {
    "function_name": "WebSessionImpl",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1288-1317",
    "snippet": "WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "class WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;",
      "SessionContext::Client sessionContext;",
      "BridgeContext& bridgeContext;",
      "kj::String sessionId;",
      "kj::String tabId;",
      "kj::String userDisplayName;",
      "kj::String userHandle;",
      "kj::String userPicture;",
      "Profile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;",
      "kj::Maybe<kj::String> userId;",
      "kj::String permissions;",
      "kj::String basePath;",
      "kj::String userAgent;",
      "kj::String acceptLanguages;",
      "kj::String rootPath;",
      "kj::Maybe<kj::String> remoteAddress;",
      "kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bridgeContext.sessions.insert",
          "args": [
            "{kj::StringPtr(this->sessionId), this->sessionContext}"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "this->sessionId"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textIdentityId",
          "args": [
            "userInfo.getIdentityId()"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "textIdentityId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "70-74",
          "snippet": "kj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "userInfo.getIdentityId",
          "args": [],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.hasIdentityId",
          "args": [],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "apiInfo"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "remoteAddress"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "rootPath"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "acceptLanguages"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "userAgent"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "basePath"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "permissions"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPronouns",
          "args": [],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "userInfo.getPictureUrl()"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPictureUrl",
          "args": [],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "userInfo.getPreferredHandle()"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getPreferredHandle",
          "args": [],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percentEncode",
          "args": [
            "userInfo.getDisplayName().getDefaultText()"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "percentEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "818-820",
          "snippet": "kj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}"
        }
      },
      {
        "call_info": {
          "callee": "userInfo.getDisplayName",
          "args": [],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userInfo.getDisplayName",
          "args": [],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tabId"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sessionId"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sessionContext"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nclass WebSessionImpl final: public BridgeHttpSession::Server {\npublic:\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                 UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                 BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                 kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                 kj::String&& rootPath, kj::String&& permissions,\n                 kj::Maybe<kj::String> remoteAddress,\n                 kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n      : serverAddr(serverAddr),\n        sessionContext(kj::mv(sessionContext)),\n        bridgeContext(bridgeContext),\n        sessionId(kj::mv(sessionId)),\n        tabId(kj::mv(tabId)),\n        userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n        userHandle(kj::heapString(userInfo.getPreferredHandle())),\n        userPicture(kj::heapString(userInfo.getPictureUrl())),\n        userPronouns(userInfo.getPronouns()),\n        permissions(kj::mv(permissions)),\n        basePath(kj::mv(basePath)),\n        userAgent(kj::mv(userAgent)),\n        acceptLanguages(kj::mv(acceptLanguages)),\n        rootPath(kj::mv(rootPath)),\n        remoteAddress(kj::mv(remoteAddress)),\n        apiInfo(kj::mv(apiInfo)) {\n    if (userInfo.hasIdentityId()) {\n      userId = textIdentityId(userInfo.getIdentityId());\n    }\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n    }\n  }\n\n  ~WebSessionImpl() noexcept(false) {\n    if (this->sessionId != nullptr) {\n      bridgeContext.sessions.erase(kj::StringPtr(sessionId));\n    }\n  }\n\n  kj::Promise<void> get(GetContext context) override {\n    GetParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        params.getIgnoreBody() ? \"HEAD\" : \"GET\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> post(PostContext context) override {\n    PostParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> put(PutContext context) override {\n    PutParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> patch(PatchContext context) override {\n    PatchParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\"PATCH\", params.getPath(), params.getContext(),\n      kj::str(\"Content-Type: \", content.getMimeType()),\n      kj::str(\"Content-Length: \", content.getContent().size()),\n      content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> delete_(DeleteContext context) override {\n    DeleteParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"DELETE\", params.getPath(), params.getContext());\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> propfind(PropfindContext context) override {\n    PropfindParams::Reader params = context.getParams();\n\n    const char* depth = \"infinity\";\n    switch (params.getDepth()) {\n      case WebSession::PropfindDepth::INFINITY_: depth = \"infinity\"; break;\n      case WebSession::PropfindDepth::ZERO:      depth = \"0\"; break;\n      case WebSession::PropfindDepth::ONE:       depth = \"1\"; break;\n    }\n\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPFIND\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        kj::str(\"Depth: \", depth));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> proppatch(ProppatchContext context) override {\n    ProppatchParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"PROPPATCH\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> mkcol(MkcolContext context) override {\n    MkcolParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"MKCOL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> copy(CopyContext context) override {\n    CopyParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"COPY\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> move(MoveContext context) override {\n    MoveParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"MOVE\", params.getPath(), params.getContext(),\n        makeDestinationHeader(params.getDestination()),\n        makeOverwriteHeader(params.getNoOverwrite()));\n    return sendRequest(toBytes(httpRequest), context);\n  }\n\n  kj::Promise<void> lock(LockContext context) override {\n    LockParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"LOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()),\n        makeDepthHeader(params.getShallow()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> unlock(UnlockContext context) override {\n    UnlockParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\n        \"UNLOCK\", params.getPath(), params.getContext(),\n        kj::str(\"Lock-Token: \", params.getLockToken()));\n    return sendRequest(toBytes(httpRequest, nullptr), context);\n  }\n\n  kj::Promise<void> acl(AclContext context) override {\n    AclParams::Reader params = context.getParams();\n    auto xml = params.getXmlContent();\n    kj::String httpRequest = makeHeaders(\n        \"ACL\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: application/xml;charset=utf-8\"),\n        kj::str(\"Content-Length: \", xml.size()));\n    return sendRequest(toBytes(httpRequest, xml.asBytes()), context);\n  }\n\n  kj::Promise<void> report(ReportContext context) override {\n    ReportParams::Reader params = context.getParams();\n    auto content = params.getContent();\n    kj::String httpRequest = makeHeaders(\n        \"REPORT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", content.getMimeType()),\n        kj::str(\"Content-Length: \", content.getContent().size()),\n        content.hasEncoding() ? kj::str(\"Content-Encoding: \", content.getEncoding()) : nullptr);\n    return sendRequest(toBytes(httpRequest, content.getContent()), context);\n  }\n\n  kj::Promise<void> options(OptionsContext context) override {\n    OptionsParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"OPTIONS\", params.getPath(), params.getContext());\n    return sendOptionsRequest(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> postStreaming(PostStreamingContext context) override {\n    PostStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"POST\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> putStreaming(PutStreamingContext context) override {\n    PutStreamingParams::Reader params = context.getParams();\n    kj::String httpRequest = makeHeaders(\"PUT\", params.getPath(), params.getContext(),\n        kj::str(\"Content-Type: \", params.getMimeType()),\n        params.hasEncoding() ? kj::str(\"Content-Encoding: \", params.getEncoding()) : nullptr);\n    return sendRequestStreaming(kj::mv(httpRequest), context);\n  }\n\n  kj::Promise<void> openWebSocket(OpenWebSocketContext context) override {\n    // TODO(soon):  Use actual random Sec-WebSocket-Key?  Unclear if this has any importance when\n    //   not trying to work around broken proxies.\n\n    auto params = context.getParams();\n\n    kj::Vector<kj::String> lines(16);\n\n    lines.add(kj::str(\"GET \", rootPath, params.getPath(), \" HTTP/1.1\"));\n    lines.add(kj::str(\"Upgrade: websocket\"));\n    lines.add(kj::str(\"Connection: Upgrade\"));\n    lines.add(kj::str(\"Sec-WebSocket-Key: mj9i153gxeYNlGDoKdoXOQ==\"));\n    auto protocols = params.getProtocol();\n    if (protocols.size() > 0) {\n      lines.add(kj::str(\"Sec-WebSocket-Protocol: \", kj::strArray(params.getProtocol(), \", \")));\n    }\n    lines.add(kj::str(\"Sec-WebSocket-Version: 13\"));\n\n    addCommonHeaders(lines, params.getContext());\n\n    auto httpRequest = toBytes(catHeaderLines(lines));\n    WebSession::WebSocketStream::Client clientStream = params.getClientStream();\n    sandstorm::ByteStream::Client responseStream =\n        context.getParams().getContext().getResponseStream();\n    context.releaseParams();\n\n    return serverAddr.connect().then(\n        [this, KJ_MVCAP(httpRequest), KJ_MVCAP(clientStream), responseStream, context]\n        (kj::Own<kj::AsyncIoStream>&& stream) mutable {\n      kj::ArrayPtr<const byte> httpRequestRef = httpRequest;\n      auto& streamRef = *stream;\n      return streamRef.write(httpRequestRef.begin(), httpRequestRef.size())\n          .attach(kj::mv(httpRequest))\n          .then([KJ_MVCAP(stream), KJ_MVCAP(clientStream), responseStream, context]\n                () mutable {\n            auto parser = kj::heap<HttpParser>(responseStream);\n            auto results = context.getResults();\n\n            return parser->readResponse(*stream).then(\n                [results, KJ_MVCAP(stream), KJ_MVCAP(clientStream), KJ_MVCAP(parser)]\n                (kj::ArrayPtr<byte> remainder) mutable {\n              auto pump = kj::heap<WebSocketPump>(kj::mv(stream), kj::mv(clientStream));\n              parser->buildForWebSocket(results);\n              if (remainder.size() > 0) {\n                pump->sendData(remainder);\n              }\n              pump->pump();\n              results.setServerStream(kj::mv(pump));\n            });\n          });\n    });\n  }\n\n  kj::Promise<void> save(SaveContext context) override {\n    KJ_IF_MAYBE(info, apiInfo) {\n      auto results = context.getResults();\n      results.initObjectId().setHttpApi(*info);\n      for (auto meta: bridgeContext.getPowerboxApis()) {\n        if (meta.getName() == info->getName()) {\n          results.setLabel(meta.getDisplayInfo().getTitle());\n          break;\n        }\n      }\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"can't save() non-powerbox BridgeHttpSession\");\n    }\n  }\n\nprivate:\n  kj::NetworkAddress& serverAddr;\nSessionContext::Client sessionContext;\nBridgeContext& bridgeContext;\nkj::String sessionId;\nkj::String tabId;\nkj::String userDisplayName;\nkj::String userHandle;\nkj::String userPicture;\nProfile::Pronouns userPronouns = Profile::Pronouns::NEUTRAL;\nkj::Maybe<kj::String> userId;\nkj::String permissions;\nkj::String basePath;\nkj::String userAgent;\nkj::String acceptLanguages;\nkj::String rootPath;\nkj::Maybe<kj::String> remoteAddress;\nkj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>> apiInfo;\n\nWebSessionImpl {\n  WebSessionImpl(kj::NetworkAddress& serverAddr,\n                   UserInfo::Reader userInfo, SessionContext::Client sessionContext,\n                   BridgeContext& bridgeContext, kj::String&& sessionId, kj::String&& tabId,\n                   kj::String&& basePath, kj::String&& userAgent, kj::String&& acceptLanguages,\n                   kj::String&& rootPath, kj::String&& permissions,\n                   kj::Maybe<kj::String> remoteAddress,\n                   kj::Maybe<OwnCapnp<BridgeObjectId::HttpApi>>&& apiInfo)\n        : serverAddr(serverAddr),\n          sessionContext(kj::mv(sessionContext)),\n          bridgeContext(bridgeContext),\n          sessionId(kj::mv(sessionId)),\n          tabId(kj::mv(tabId)),\n          userDisplayName(percentEncode(userInfo.getDisplayName().getDefaultText())),\n          userHandle(kj::heapString(userInfo.getPreferredHandle())),\n          userPicture(kj::heapString(userInfo.getPictureUrl())),\n          userPronouns(userInfo.getPronouns()),\n          permissions(kj::mv(permissions)),\n          basePath(kj::mv(basePath)),\n          userAgent(kj::mv(userAgent)),\n          acceptLanguages(kj::mv(acceptLanguages)),\n          rootPath(kj::mv(rootPath)),\n          remoteAddress(kj::mv(remoteAddress)),\n          apiInfo(kj::mv(apiInfo)) {\n      if (userInfo.hasIdentityId()) {\n        userId = textIdentityId(userInfo.getIdentityId());\n      }\n      if (this->sessionId != nullptr) {\n        bridgeContext.sessions.insert({kj::StringPtr(this->sessionId), this->sessionContext});\n      }\n    }\n}"
  },
  {
    "function_name": "dropIdentity",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1258-1283",
    "snippet": "void dropIdentity(kj::StringPtr textId) {\n    auto symlink = kj::heapString(textId);\n\n    if (faccessat(identitiesDir, symlink.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n      char buf[512];\n      ssize_t n;\n      KJ_SYSCALL(n = readlinkat(identitiesDir, symlink.cStr(), buf, sizeof(buf)));\n      KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n      buf[n] = '\\0';\n\n      // We name the trash file after the token, not the identity ID. This way, it's okay\n      // if we overwrite an existing entry of the trash directory.\n      auto trashSymlink = kj::heapString(buf);\n      KJ_SYSCALL(renameat(identitiesDir, symlink.cStr(), trashDir, trashSymlink.cStr()));\n\n      auto req = apiCap.dropRequest();\n      req.setToken(percentDecode(buf));\n      tasks.add(req.send().then([KJ_MVCAP(trashSymlink), this](auto response) -> void {\n        KJ_SYSCALL(unlinkat(trashDir, trashSymlink.cStr(), 0));\n      }));\n\n      // TODO(someday): Implement some kind of garbage collection that clears out the trash\n      // directory periodically, to handle the rare case when the above drop() task fails to\n      // run to completion.\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "req.send().then([KJ_MVCAP(trashSymlink), this](auto response) -> void{\n        KJ_SYSCALL(unlinkat(trashDir, trashSymlink.cStr(), 0));\n      }"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unlinkat(trashDir, trashSymlink.cStr(), 0)"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlinkat",
          "args": [
            "trashDir",
            "trashSymlink.cStr()",
            "0"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trashSymlink.cStr",
          "args": [],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[KJ_MVCAP(trashSymlink)",
            "this](autoresponse"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "percentDecode(buf)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percentDecode",
          "args": [
            "buf"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "percentDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "822-840",
          "snippet": "kj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apiCap.dropRequest",
          "args": [],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "renameat(identitiesDir, symlink.cStr(), trashDir, trashSymlink.cStr())"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "renameat",
          "args": [
            "identitiesDir",
            "symlink.cStr()",
            "trashDir",
            "trashSymlink.cStr()"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trashSymlink.cStr",
          "args": [],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink.cStr",
          "args": [],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "buf"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n < sizeof(buf)",
            "\"token too long?\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = readlinkat(identitiesDir, symlink.cStr(), buf, sizeof(buf))"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlinkat",
          "args": [
            "identitiesDir",
            "symlink.cStr()",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink.cStr",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "faccessat",
          "args": [
            "identitiesDir",
            "symlink.cStr()",
            "F_OK",
            "AT_SYMLINK_NOFOLLOW"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink.cStr",
          "args": [],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "textId"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  void dropIdentity(kj::StringPtr textId) {\n      auto symlink = kj::heapString(textId);\n  \n      if (faccessat(identitiesDir, symlink.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        char buf[512];\n        ssize_t n;\n        KJ_SYSCALL(n = readlinkat(identitiesDir, symlink.cStr(), buf, sizeof(buf)));\n        KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n        buf[n] = '\\0';\n  \n        // We name the trash file after the token, not the identity ID. This way, it's okay\n        // if we overwrite an existing entry of the trash directory.\n        auto trashSymlink = kj::heapString(buf);\n        KJ_SYSCALL(renameat(identitiesDir, symlink.cStr(), trashDir, trashSymlink.cStr()));\n  \n        auto req = apiCap.dropRequest();\n        req.setToken(percentDecode(buf));\n        tasks.add(req.send().then([KJ_MVCAP(trashSymlink), this](auto response) -> void {\n          KJ_SYSCALL(unlinkat(trashDir, trashSymlink.cStr(), 0));\n        }));\n  \n        // TODO(someday): Implement some kind of garbage collection that clears out the trash\n        // directory periodically, to handle the rare case when the above drop() task fails to\n        // run to completion.\n      }\n    }\n}"
  },
  {
    "function_name": "saveIdentityInternal",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1235-1256",
    "snippet": "void saveIdentityInternal(kj::StringPtr textId, Identity::Client identity) {\n    // Writes the identity to disk, assuming that either we have not saved this identity yet\n    // or we have recently observed our existing save to be broken.\n\n    auto req = apiCap.saveRequest();\n    req.setCap(identity);\n    req.initLabel().setDefaultText(\"user identity\");\n    tasks.add(req.send().then([this,textId](auto result) -> void {\n      // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n      auto tokenText = percentEncode(result.getToken());\n\n      // Clean up any existing symlink.\n      dropIdentity(textId);\n\n      // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n      // allocating a block.\n      KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n\n      // Make sure it's really saved.\n      KJ_SYSCALL(fsync(identitiesDir));\n    }));\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "req.send().then([this,textId](auto result) -> void {\n      // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n      auto tokenText = percentEncode(result.getToken());\n\n      // Clean up any existing symlink.\n      dropIdentity(textId);\n\n      // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n      // allocating a block.\n      KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n\n      // Make sure it's really saved.\n      KJ_SYSCALL(fsync(identitiesDir));\n    })"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[this,textId](auto result) -> void {\n      // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n      auto tokenText = percentEncode(result.getToken());\n\n      // Clean up any existing symlink.\n      dropIdentity(textId);\n\n      // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n      // allocating a block.\n      KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n\n      // Make sure it's really saved.\n      KJ_SYSCALL(fsync(identitiesDir));\n    }"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fsync(identitiesDir)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "identitiesDir"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "symlinkat(tokenText.cStr(), identitiesDir, textId.cStr())"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlinkat",
          "args": [
            "tokenText.cStr()",
            "identitiesDir",
            "textId.cStr()"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textId.cStr",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokenText.cStr",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dropIdentity",
          "args": [
            "textId"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "dropIdentity",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1258-1283",
          "snippet": "void dropIdentity(kj::StringPtr textId) {\n    auto symlink = kj::heapString(textId);\n\n    if (faccessat(identitiesDir, symlink.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n      char buf[512];\n      ssize_t n;\n      KJ_SYSCALL(n = readlinkat(identitiesDir, symlink.cStr(), buf, sizeof(buf)));\n      KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n      buf[n] = '\\0';\n\n      // We name the trash file after the token, not the identity ID. This way, it's okay\n      // if we overwrite an existing entry of the trash directory.\n      auto trashSymlink = kj::heapString(buf);\n      KJ_SYSCALL(renameat(identitiesDir, symlink.cStr(), trashDir, trashSymlink.cStr()));\n\n      auto req = apiCap.dropRequest();\n      req.setToken(percentDecode(buf));\n      tasks.add(req.send().then([KJ_MVCAP(trashSymlink), this](auto response) -> void {\n        KJ_SYSCALL(unlinkat(trashDir, trashSymlink.cStr(), 0));\n      }));\n\n      // TODO(someday): Implement some kind of garbage collection that clears out the trash\n      // directory periodically, to handle the rare case when the above drop() task fails to\n      // run to completion.\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  void dropIdentity(kj::StringPtr textId) {\n      auto symlink = kj::heapString(textId);\n  \n      if (faccessat(identitiesDir, symlink.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        char buf[512];\n        ssize_t n;\n        KJ_SYSCALL(n = readlinkat(identitiesDir, symlink.cStr(), buf, sizeof(buf)));\n        KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n        buf[n] = '\\0';\n  \n        // We name the trash file after the token, not the identity ID. This way, it's okay\n        // if we overwrite an existing entry of the trash directory.\n        auto trashSymlink = kj::heapString(buf);\n        KJ_SYSCALL(renameat(identitiesDir, symlink.cStr(), trashDir, trashSymlink.cStr()));\n  \n        auto req = apiCap.dropRequest();\n        req.setToken(percentDecode(buf));\n        tasks.add(req.send().then([KJ_MVCAP(trashSymlink), this](auto response) -> void {\n          KJ_SYSCALL(unlinkat(trashDir, trashSymlink.cStr(), 0));\n        }));\n  \n        // TODO(someday): Implement some kind of garbage collection that clears out the trash\n        // directory periodically, to handle the rare case when the above drop() task fails to\n        // run to completion.\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "percentEncode",
          "args": [
            "result.getToken()"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "percentEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "818-820",
          "snippet": "kj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.getToken",
          "args": [],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initLabel",
          "args": [
            "\"user identity\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initLabel",
          "args": [],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setCap",
          "args": [
            "identity"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apiCap.saveRequest",
          "args": [],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  void saveIdentityInternal(kj::StringPtr textId, Identity::Client identity) {\n      // Writes the identity to disk, assuming that either we have not saved this identity yet\n      // or we have recently observed our existing save to be broken.\n  \n      auto req = apiCap.saveRequest();\n      req.setCap(identity);\n      req.initLabel().setDefaultText(\"user identity\");\n      tasks.add(req.send().then([this,textId](auto result) -> void {\n        // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n        auto tokenText = percentEncode(result.getToken());\n  \n        // Clean up any existing symlink.\n        dropIdentity(textId);\n  \n        // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n        // allocating a block.\n        KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n  \n        // Make sure it's really saved.\n        KJ_SYSCALL(fsync(identitiesDir));\n      }));\n    }\n}"
  },
  {
    "function_name": "loadIdentityFromDisk",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1215-1233",
    "snippet": "Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n    KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n    for (char c: textId) {\n      if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n        KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n      }\n    }\n\n    char buf[512];\n    ssize_t n;\n    KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n    KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n    buf[n] = '\\0';\n\n    auto req = apiCap.restoreRequest();\n    req.setToken(percentDecode(buf));\n\n    return req.send().getCap().castAs<Identity>();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "percentDecode(buf)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percentDecode",
          "args": [
            "buf"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "percentDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "822-840",
          "snippet": "kj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apiCap.restoreRequest",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n < sizeof(buf)",
            "\"token too long?\""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf))"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlinkat",
          "args": [
            "identitiesDir",
            "textId.cStr()",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textId.cStr",
          "args": [],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"invalid identity ID\"",
            "textId"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "textId.size() == 32",
            "\"invalid identity ID\"",
            "textId"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textId.size",
          "args": [],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n      KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n      for (char c: textId) {\n        if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n          KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n        }\n      }\n  \n      char buf[512];\n      ssize_t n;\n      KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n      KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n      buf[n] = '\\0';\n  \n      auto req = apiCap.restoreRequest();\n      req.setToken(percentDecode(buf));\n  \n      return req.send().getCap().castAs<Identity>();\n    }\n}"
  },
  {
    "function_name": "openTrashDir",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1205-1213",
    "snippet": "static kj::AutoCloseFd openTrashDir(spk::BridgeConfig::Reader config) {\n    if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n\n    recursivelyCreateParent(\"/var/.sandstorm-http-bridge/trash/foo\");\n\n    // Note: Using O_PATH here would prevent fsync().\n    return raiiOpen(\"/var/.sandstorm-http-bridge/trash\",\n                    O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/var/.sandstorm-http-bridge/trash\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyCreateParent",
          "args": [
            "\"/var/.sandstorm-http-bridge/trash/foo\""
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCreateParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "331-350",
          "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  static kj::AutoCloseFd openTrashDir(spk::BridgeConfig::Reader config) {\n      if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n  \n      recursivelyCreateParent(\"/var/.sandstorm-http-bridge/trash/foo\");\n  \n      // Note: Using O_PATH here would prevent fsync().\n      return raiiOpen(\"/var/.sandstorm-http-bridge/trash\",\n                      O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    }\n}"
  },
  {
    "function_name": "openIdentitiesDir",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1195-1203",
    "snippet": "static kj::AutoCloseFd openIdentitiesDir(spk::BridgeConfig::Reader config) {\n    if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n\n    recursivelyCreateParent(\"/var/.sandstorm-http-bridge/identities/foo\");\n\n    // Note: Using O_PATH here would prevent fsync().\n    return raiiOpen(\"/var/.sandstorm-http-bridge/identities\",\n                    O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/var/.sandstorm-http-bridge/identities\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyCreateParent",
          "args": [
            "\"/var/.sandstorm-http-bridge/identities/foo\""
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCreateParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "331-350",
          "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  static kj::AutoCloseFd openIdentitiesDir(spk::BridgeConfig::Reader config) {\n      if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n  \n      recursivelyCreateParent(\"/var/.sandstorm-http-bridge/identities/foo\");\n  \n      // Note: Using O_PATH here would prevent fsync().\n      return raiiOpen(\"/var/.sandstorm-http-bridge/identities\",\n                      O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1191-1193",
    "snippet": "virtual void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  virtual void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, exception);\n    }\n}"
  },
  {
    "function_name": "loadIdentity",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1109-1169",
    "snippet": "Identity::Client loadIdentity(kj::StringPtr origId) {\n    // Obtain the identity capability for the given identity ID.\n\n    KJ_REQUIRE(config.getSaveIdentityCaps(),\n        \"sandstorm-http-bridge is not configured to save identity capabilities\",\n        \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n\n    // Copy string to use as map key.\n    auto textId = kj::heapString(origId);\n\n    auto iter = liveIdentities.find(textId);\n    if (iter == liveIdentities.end()) {\n      // Not in the map. Load from disk.\n      Identity::Client identity = loadIdentityFromDisk(textId);\n\n      tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n        // Successfully resolved. Add to map.\n        kj::StringPtr textIdRef = textId;\n        KJ_ASSERT(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n      }, [] (auto e) {\n        // Ignore the error here because the returned capability will report it upon use.\n      }));\n\n      return kj::mv(identity);\n    } else {\n      // Identity is in the map.\n      Identity::Client identity = iter->second.identity;\n\n      // We need to verify the capability is still connected. Send a dummy call to check. We'll\n      // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n      auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n      ping.initAsAnyStruct(0, 0);\n      return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n        // Weird, we shouldn't get here.\n        KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n\n        // But clearly we are still connected, so continue.\n        return kj::mv(identity);\n      }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                      -> kj::Promise<Identity::Client> {\n        if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Disconnected. We'll need to reload from disk.\n          Identity::Client newIdentity = loadIdentityFromDisk(textId);\n          tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n            // Save the new identity to the map so that we don't have to reload it again.\n            auto iter = liveIdentities.find(textId);\n            KJ_ASSERT(iter != liveIdentities.end());\n            iter->second.identity = kj::mv(newIdentity);\n          }, [] (auto e) {\n            // Ignore the error here because the returned capability will report it upon use.\n          }));\n\n          return kj::mv(newIdentity);\n        } else {\n          // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n          return kj::mv(identity);\n        }\n      });\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newIdentity"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n            // Save the new identity to the map so that we don't have to reload it again.\n            auto iter = liveIdentities.find(textId);\n            KJ_ASSERT(iter != liveIdentities.end());\n            iter->second.identity = kj::mv(newIdentity);\n          }, [] (auto e) {\n            // Ignore the error here because the returned capability will report it upon use.\n          })"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newIdentity.whenResolved",
          "args": [
            "[this, KJ_MVCAP(textId), newIdentity]() mutable {\n            // Save the new identity to the map so that we don't have to reload it again.\n            auto iter = liveIdentities.find(textId);\n            KJ_ASSERT(iter != liveIdentities.end());\n            iter->second.identity = kj::mv(newIdentity);\n          }",
            "[] (auto e) {\n            // Ignore the error here because the returned capability will report it upon use.\n          }"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newIdentity"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != liveIdentities.end()"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.end",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.find",
          "args": [
            "textId"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newIdentity.whenResolved",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadIdentityFromDisk",
          "args": [
            "textId"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "loadIdentityFromDisk",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1215-1233",
          "snippet": "Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n    KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n    for (char c: textId) {\n      if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n        KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n      }\n    }\n\n    char buf[512];\n    ssize_t n;\n    KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n    KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n    buf[n] = '\\0';\n\n    auto req = apiCap.restoreRequest();\n    req.setToken(percentDecode(buf));\n\n    return req.send().getCap().castAs<Identity>();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n      KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n      for (char c: textId) {\n        if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n          KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n        }\n      }\n  \n      char buf[512];\n      ssize_t n;\n      KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n      KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n      buf[n] = '\\0';\n  \n      auto req = apiCap.restoreRequest();\n      req.setToken(percentDecode(buf));\n  \n      return req.send().getCap().castAs<Identity>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e2.getType",
          "args": [],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.send",
          "args": [
            "[identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n        // Weird, we shouldn't get here.\n        KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n\n        // But clearly we are still connected, so continue.\n        return kj::mv(identity);\n      }",
            "[this,KJ_MVCAP(textId),identity](kj::Exception&& e2"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"dummy ping request should have failed with UNIMPLEMENTED\""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.send",
          "args": [],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.initAsAnyStruct",
          "args": [
            "0",
            "0"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identity.typelessRequest",
          "args": [
            "0",
            "65535",
            "capnp::MessageSize { 4, 0 }"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n        // Successfully resolved. Add to map.\n        kj::StringPtr textIdRef = textId;\n        KJ_ASSERT(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n      }, [] (auto e) {\n        // Ignore the error here because the returned capability will report it upon use.\n      })"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identity.whenResolved",
          "args": [
            "[this, KJ_MVCAP(textId), identity]() mutable {\n        // Successfully resolved. Add to map.\n        kj::StringPtr textIdRef = textId;\n        KJ_ASSERT(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n      }",
            "[] (auto e) {\n        // Ignore the error here because the returned capability will report it upon use.\n      }"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.insert",
          "args": [
            "std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "textIdRef",
            "IdentityRecord { kj::mv(textId), kj::mv(identity) }"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "textId"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identity.whenResolved",
          "args": [],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.end",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.find",
          "args": [
            "textId"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "origId"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "config.getSaveIdentityCaps()",
            "\"sandstorm-http-bridge is not configured to save identity capabilities\"",
            "\"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  Identity::Client loadIdentity(kj::StringPtr origId) {\n      // Obtain the identity capability for the given identity ID.\n  \n      KJ_REQUIRE(config.getSaveIdentityCaps(),\n          \"sandstorm-http-bridge is not configured to save identity capabilities\",\n          \"please add `saveIdentityCaps = true` to your bridgeConfig in sandstorm-pkgdef.capnp\");\n  \n      // Copy string to use as map key.\n      auto textId = kj::heapString(origId);\n  \n      auto iter = liveIdentities.find(textId);\n      if (iter == liveIdentities.end()) {\n        // Not in the map. Load from disk.\n        Identity::Client identity = loadIdentityFromDisk(textId);\n  \n        tasks.add(identity.whenResolved().then([this, KJ_MVCAP(textId), identity]() mutable {\n          // Successfully resolved. Add to map.\n          kj::StringPtr textIdRef = textId;\n          KJ_ASSERT(liveIdentities.insert(std::make_pair(\n            textIdRef, IdentityRecord { kj::mv(textId), kj::mv(identity) })).second);\n        }, [] (auto e) {\n          // Ignore the error here because the returned capability will report it upon use.\n        }));\n  \n        return kj::mv(identity);\n      } else {\n        // Identity is in the map.\n        Identity::Client identity = iter->second.identity;\n  \n        // We need to verify the capability is still connected. Send a dummy call to check. We'll\n        // use a known-invalid type ID / method number and expect to get an UNIMPLEMENTED error.\n        auto ping = identity.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n        ping.initAsAnyStruct(0, 0);\n        return ping.send().then([identity](auto&&) mutable -> kj::Promise<Identity::Client> {\n          // Weird, we shouldn't get here.\n          KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n  \n          // But clearly we are still connected, so continue.\n          return kj::mv(identity);\n        }, [this,KJ_MVCAP(textId),identity](kj::Exception&& e2) mutable\n                                        -> kj::Promise<Identity::Client> {\n          if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n            // Disconnected. We'll need to reload from disk.\n            Identity::Client newIdentity = loadIdentityFromDisk(textId);\n            tasks.add(newIdentity.whenResolved().then([this, KJ_MVCAP(textId), newIdentity]() mutable {\n              // Save the new identity to the map so that we don't have to reload it again.\n              auto iter = liveIdentities.find(textId);\n              KJ_ASSERT(iter != liveIdentities.end());\n              iter->second.identity = kj::mv(newIdentity);\n            }, [] (auto e) {\n              // Ignore the error here because the returned capability will report it upon use.\n            }));\n  \n            return kj::mv(newIdentity);\n          } else {\n            // Some other error -- meaning we're NOT disconnected, so go ahead and use the cap.\n            return kj::mv(identity);\n          }\n        });\n      }\n    }\n}"
  },
  {
    "function_name": "saveIdentity",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1082-1107",
    "snippet": "void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n    if (!config.getSaveIdentityCaps()) return;\n\n    auto textId = textIdentityId(identityId);\n\n    kj::StringPtr textIdRef = textId;\n    if(liveIdentities.insert(std::make_pair(\n        textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n      // Newly-added to the map. Check if it's on disk.\n\n      // Note that we know now that textIdRef will live forever, since it's in the map.\n\n      if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n        // Not yet recorded to disk. Need to save a SturdyRef.\n        saveIdentityInternal(textIdRef, kj::mv(identity));\n      } else {\n        // Try restoring the existing SturdyRef and re-save on failure.\n        tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n            [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        }));\n      }\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n            [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        })"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadIdentityFromDisk",
          "args": [
            "[this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n          if (error.getType() == kj::Exception::Type::FAILED) {\n            saveIdentityInternal(textIdRef, kj::mv(identity));\n          }\n        }"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "loadIdentityFromDisk",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1215-1233",
          "snippet": "Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n    KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n    for (char c: textId) {\n      if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n        KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n      }\n    }\n\n    char buf[512];\n    ssize_t n;\n    KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n    KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n    buf[n] = '\\0';\n\n    auto req = apiCap.restoreRequest();\n    req.setToken(percentDecode(buf));\n\n    return req.send().getCap().castAs<Identity>();\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  Identity::Client loadIdentityFromDisk(kj::StringPtr textId) {\n      KJ_ASSERT(textId.size() == 32, \"invalid identity ID\", textId);\n      for (char c: textId) {\n        if ((c < '0' || '9' < c) && (c < 'a' && 'f' < c)) {\n          KJ_FAIL_ASSERT(\"invalid identity ID\", textId);\n        }\n      }\n  \n      char buf[512];\n      ssize_t n;\n      KJ_SYSCALL(n = readlinkat(identitiesDir, textId.cStr(), buf, sizeof(buf)));\n      KJ_ASSERT(n < sizeof(buf), \"token too long?\");\n      buf[n] = '\\0';\n  \n      auto req = apiCap.restoreRequest();\n      req.setToken(percentDecode(buf));\n  \n      return req.send().getCap().castAs<Identity>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saveIdentityInternal",
          "args": [
            "textIdRef",
            "kj::mv(identity)"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "saveIdentityInternal",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1235-1256",
          "snippet": "void saveIdentityInternal(kj::StringPtr textId, Identity::Client identity) {\n    // Writes the identity to disk, assuming that either we have not saved this identity yet\n    // or we have recently observed our existing save to be broken.\n\n    auto req = apiCap.saveRequest();\n    req.setCap(identity);\n    req.initLabel().setDefaultText(\"user identity\");\n    tasks.add(req.send().then([this,textId](auto result) -> void {\n      // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n      auto tokenText = percentEncode(result.getToken());\n\n      // Clean up any existing symlink.\n      dropIdentity(textId);\n\n      // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n      // allocating a block.\n      KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n\n      // Make sure it's really saved.\n      KJ_SYSCALL(fsync(identitiesDir));\n    }));\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext {\n  void saveIdentityInternal(kj::StringPtr textId, Identity::Client identity) {\n      // Writes the identity to disk, assuming that either we have not saved this identity yet\n      // or we have recently observed our existing save to be broken.\n  \n      auto req = apiCap.saveRequest();\n      req.setCap(identity);\n      req.initLabel().setDefaultText(\"user identity\");\n      tasks.add(req.send().then([this,textId](auto result) -> void {\n        // Sandstorm tokens are primarily text but use percent-encoding to be safe.\n        auto tokenText = percentEncode(result.getToken());\n  \n        // Clean up any existing symlink.\n        dropIdentity(textId);\n  \n        // Store as a symlink. ext4 can store up to 60 bytes directly in the inode, avoiding\n        // allocating a block.\n        KJ_SYSCALL(symlinkat(tokenText.cStr(), identitiesDir, textId.cStr()));\n  \n        // Make sure it's really saved.\n        KJ_SYSCALL(fsync(identitiesDir));\n      }));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.getType",
          "args": [],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadIdentityFromDisk",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "identity"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "faccessat",
          "args": [
            "identitiesDir",
            "textIdRef.cStr()",
            "F_OK",
            "AT_SYMLINK_NOFOLLOW"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textIdRef.cStr",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liveIdentities.insert",
          "args": [
            "std::make_pair(\n        textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "textIdRef",
            "IdentityRecord { kj::mv(textId), kj::cp(identity) }"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "identity"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "textId"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textIdentityId",
          "args": [
            "identityId"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "textIdentityId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "70-74",
          "snippet": "kj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "config.getSaveIdentityCaps",
          "args": [],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  void saveIdentity(capnp::Data::Reader identityId, Identity::Client identity) {\n      if (!config.getSaveIdentityCaps()) return;\n  \n      auto textId = textIdentityId(identityId);\n  \n      kj::StringPtr textIdRef = textId;\n      if(liveIdentities.insert(std::make_pair(\n          textIdRef, IdentityRecord { kj::mv(textId), kj::cp(identity) })).second) {\n        // Newly-added to the map. Check if it's on disk.\n  \n        // Note that we know now that textIdRef will live forever, since it's in the map.\n  \n        if (faccessat(identitiesDir, textIdRef.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) != 0) {\n          // Not yet recorded to disk. Need to save a SturdyRef.\n          saveIdentityInternal(textIdRef, kj::mv(identity));\n        } else {\n          // Try restoring the existing SturdyRef and re-save on failure.\n          tasks.add(loadIdentityFromDisk(textIdRef).whenResolved().catch_(\n              [this, textIdRef, KJ_MVCAP(identity)](auto error) mutable {\n            if (error.getType() == kj::Exception::Type::FAILED) {\n              saveIdentityInternal(textIdRef, kj::mv(identity));\n            }\n          }));\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "getPowerboxApis",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1078-1080",
    "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config.getPowerboxApis",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "getPowerboxApis",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1078-1080",
          "snippet": "capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n    return config.getPowerboxApis();\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  capnp::List<spk::BridgeConfig::PowerboxApi>::Reader getPowerboxApis() {\n      return config.getPowerboxApis();\n    }\n}"
  },
  {
    "function_name": "formatPermissions",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1066-1076",
    "snippet": "kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n    auto configPermissions = config.getViewInfo().getPermissions();\n    kj::Vector<kj::String> permissionVec(configPermissions.size());\n\n    for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n      if (userPermissions[i]) {\n        permissionVec.add(kj::str(configPermissions[i].getName()));\n      }\n    }\n    return kj::strArray(permissionVec, \",\");\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "permissionVec",
            "\",\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permissionVec.add",
          "args": [
            "kj::str(configPermissions[i].getName())"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "configPermissions[i].getName()"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configPermissions[i].getName",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userPermissions.size",
          "args": [],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "config.getViewInfo",
          "args": [],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getViewInfo",
          "args": [],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  kj::String formatPermissions(capnp::List<bool>::Reader userPermissions) {\n      auto configPermissions = config.getViewInfo().getPermissions();\n      kj::Vector<kj::String> permissionVec(configPermissions.size());\n  \n      for (uint i = 0; i < configPermissions.size() && i < userPermissions.size(); ++i) {\n        if (userPermissions[i]) {\n          permissionVec.add(kj::str(configPermissions[i].getName()));\n        }\n      }\n      return kj::strArray(permissionVec, \",\");\n    }\n}"
  },
  {
    "function_name": "BridgeContext",
    "container": "BridgeContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1061-1064",
    "snippet": "BridgeContext(SandstormApi<BridgeObjectId>::Client apiCap, spk::BridgeConfig::Reader config)\n      : apiCap(kj::mv(apiCap)), config(config),\n        identitiesDir(openIdentitiesDir(config)),\n        trashDir(openTrashDir(config)), tasks(*this) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "spk::BridgeConfig::Reader config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "openTrashDir",
          "args": [
            "config"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "openTrashDir",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1205-1213",
          "snippet": "static kj::AutoCloseFd openTrashDir(spk::BridgeConfig::Reader config) {\n    if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n\n    recursivelyCreateParent(\"/var/.sandstorm-http-bridge/trash/foo\");\n\n    // Note: Using O_PATH here would prevent fsync().\n    return raiiOpen(\"/var/.sandstorm-http-bridge/trash\",\n                    O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  static kj::AutoCloseFd openTrashDir(spk::BridgeConfig::Reader config) {\n      if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n  \n      recursivelyCreateParent(\"/var/.sandstorm-http-bridge/trash/foo\");\n  \n      // Note: Using O_PATH here would prevent fsync().\n      return raiiOpen(\"/var/.sandstorm-http-bridge/trash\",\n                      O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openIdentitiesDir",
          "args": [
            "config"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "openIdentitiesDir",
          "container": "BridgeContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1195-1203",
          "snippet": "static kj::AutoCloseFd openIdentitiesDir(spk::BridgeConfig::Reader config) {\n    if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n\n    recursivelyCreateParent(\"/var/.sandstorm-http-bridge/identities/foo\");\n\n    // Note: Using O_PATH here would prevent fsync().\n    return raiiOpen(\"/var/.sandstorm-http-bridge/identities\",\n                    O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  static kj::AutoCloseFd openIdentitiesDir(spk::BridgeConfig::Reader config) {\n      if (!config.getSaveIdentityCaps()) return kj::AutoCloseFd();\n  \n      recursivelyCreateParent(\"/var/.sandstorm-http-bridge/identities/foo\");\n  \n      // Note: Using O_PATH here would prevent fsync().\n      return raiiOpen(\"/var/.sandstorm-http-bridge/identities\",\n                      O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "apiCap"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nspk::BridgeConfig::Reader config;\n\nBridgeContext {\n  BridgeContext(SandstormApi<BridgeObjectId>::Client apiCap, spk::BridgeConfig::Reader config)\n        : apiCap(kj::mv(apiCap)), config(config),\n          identitiesDir(openIdentitiesDir(config)),\n          trashDir(openTrashDir(config)), tasks(*this) {}\n}"
  },
  {
    "function_name": "writeHeadersOnce",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1031-1055",
    "snippet": "void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n    KJ_IF_MAYBE(r, httpRequest) {\n      // We haven't sent the request yet.\n      kj::String reqString = kj::mv(*r);\n      httpRequest = nullptr;\n\n      // Hackily splice in content-length or transfer-encoding header.\n      KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n      KJ_IF_MAYBE(l, contentLength) {\n        isChunked = false;\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Content-Length: \", *l, \"\\r\\n\"\n            \"\\r\\n\");\n      } else {\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Transfer-Encoding: chunked\\r\\n\"\n            \"\\r\\n\");\n      }\n\n      auto bytes = toBytes(reqString);\n      kj::ArrayPtr<const byte> bytesRef = bytes;\n      previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n    }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "kj::mv(bytes)"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bytes"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "bytesRef.begin()",
            "bytesRef.size()"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bytesRef.size",
          "args": [],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bytesRef.begin",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toBytes",
          "args": [
            "reqString"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "toBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "63-68",
          "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "reqString.slice(0, reqString.size() - 2)",
            "\"Transfer-Encoding: chunked\\r\\n\"\n            \"\\r\\n\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqString.slice",
          "args": [
            "0",
            "reqString.size() - 2"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "reqString.slice(0, reqString.size() - 2)",
            "\"Content-Length: \"",
            "*l",
            "\"\\r\\n\"\n            \"\\r\\n\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqString.slice",
          "args": [
            "0",
            "reqString.size() - 2"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "reqString.endsWith(\"\\r\\n\\r\\n\")"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqString.endsWith",
          "args": [
            "\"\\r\\n\\r\\n\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*r"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n      KJ_IF_MAYBE(r, httpRequest) {\n        // We haven't sent the request yet.\n        kj::String reqString = kj::mv(*r);\n        httpRequest = nullptr;\n  \n        // Hackily splice in content-length or transfer-encoding header.\n        KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n        KJ_IF_MAYBE(l, contentLength) {\n          isChunked = false;\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Content-Length: \", *l, \"\\r\\n\"\n              \"\\r\\n\");\n        } else {\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Transfer-Encoding: chunked\\r\\n\"\n              \"\\r\\n\");\n        }\n  \n        auto bytes = toBytes(reqString);\n        kj::ArrayPtr<const byte> bytesRef = bytes;\n        previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n      }\n}"
  },
  {
    "function_name": "expectSize",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "1013-1018",
    "snippet": "kj::Promise<void> expectSize(ExpectSizeContext context) override {\n    uint64_t size = context.getParams().getSize();\n    expectedSize = bytesReceived + size;\n    writeHeadersOnce(size);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeHeadersOnce",
          "args": [
            "size"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "writeHeadersOnce",
          "container": "RequestStreamImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1031-1055",
          "snippet": "void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n    KJ_IF_MAYBE(r, httpRequest) {\n      // We haven't sent the request yet.\n      kj::String reqString = kj::mv(*r);\n      httpRequest = nullptr;\n\n      // Hackily splice in content-length or transfer-encoding header.\n      KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n      KJ_IF_MAYBE(l, contentLength) {\n        isChunked = false;\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Content-Length: \", *l, \"\\r\\n\"\n            \"\\r\\n\");\n      } else {\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Transfer-Encoding: chunked\\r\\n\"\n            \"\\r\\n\");\n      }\n\n      auto bytes = toBytes(reqString);\n      kj::ArrayPtr<const byte> bytesRef = bytes;\n      previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n      KJ_IF_MAYBE(r, httpRequest) {\n        // We haven't sent the request yet.\n        kj::String reqString = kj::mv(*r);\n        httpRequest = nullptr;\n  \n        // Hackily splice in content-length or transfer-encoding header.\n        KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n        KJ_IF_MAYBE(l, contentLength) {\n          isChunked = false;\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Content-Length: \", *l, \"\\r\\n\"\n              \"\\r\\n\");\n        } else {\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Transfer-Encoding: chunked\\r\\n\"\n              \"\\r\\n\");\n        }\n  \n        auto bytes = toBytes(reqString);\n        kj::ArrayPtr<const byte> bytesRef = bytes;\n        previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  kj::Promise<void> expectSize(ExpectSizeContext context) override {\n      uint64_t size = context.getParams().getSize();\n      expectedSize = bytesReceived + size;\n      writeHeadersOnce(size);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "done",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "990-1011",
    "snippet": "kj::Promise<void> done(DoneContext context) override {\n    KJ_IF_MAYBE(s, expectedSize) {\n      KJ_REQUIRE(bytesReceived == *s,\n          \"done() called before all bytes expected via expectedSize() were written\");\n    }\n    KJ_REQUIRE(!doneCalled, \"done() called twice\");\n    doneCalled = true;\n\n    // If we haven't written headers yet, then the content is empty, so we can pass zero for the\n    // expected size. (If we have written headers then the size we pass will be ignored.)\n    writeHeadersOnce(kj::implicitCast<uint64_t>(0));\n\n    if (isChunked) {\n      previousWrite = previousWrite.then([this]() {\n        return stream->write(\"0\\r\\n\\r\\n\", 5);\n      });\n    }\n\n    auto fork = previousWrite.fork();\n    previousWrite = fork.addBranch();\n    return fork.addBranch();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "previousWrite.fork",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "previousWrite.then",
          "args": [
            "[this]() {\n        return stream->write(\"0\\r\\n\\r\\n\", 5);\n      }"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "\"0\\r\\n\\r\\n\"",
            "5"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeHeadersOnce",
          "args": [
            "kj::implicitCast<uint64_t>(0)"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "writeHeadersOnce",
          "container": "RequestStreamImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1031-1055",
          "snippet": "void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n    KJ_IF_MAYBE(r, httpRequest) {\n      // We haven't sent the request yet.\n      kj::String reqString = kj::mv(*r);\n      httpRequest = nullptr;\n\n      // Hackily splice in content-length or transfer-encoding header.\n      KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n      KJ_IF_MAYBE(l, contentLength) {\n        isChunked = false;\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Content-Length: \", *l, \"\\r\\n\"\n            \"\\r\\n\");\n      } else {\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Transfer-Encoding: chunked\\r\\n\"\n            \"\\r\\n\");\n      }\n\n      auto bytes = toBytes(reqString);\n      kj::ArrayPtr<const byte> bytesRef = bytes;\n      previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n      KJ_IF_MAYBE(r, httpRequest) {\n        // We haven't sent the request yet.\n        kj::String reqString = kj::mv(*r);\n        httpRequest = nullptr;\n  \n        // Hackily splice in content-length or transfer-encoding header.\n        KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n        KJ_IF_MAYBE(l, contentLength) {\n          isChunked = false;\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Content-Length: \", *l, \"\\r\\n\"\n              \"\\r\\n\");\n        } else {\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Transfer-Encoding: chunked\\r\\n\"\n              \"\\r\\n\");\n        }\n  \n        auto bytes = toBytes(reqString);\n        kj::ArrayPtr<const byte> bytesRef = bytes;\n        previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<uint64_t>",
          "args": [
            "0"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!doneCalled",
            "\"done() called twice\""
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "bytesReceived == *s",
            "\"done() called before all bytes expected via expectedSize() were written\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  kj::Promise<void> done(DoneContext context) override {\n      KJ_IF_MAYBE(s, expectedSize) {\n        KJ_REQUIRE(bytesReceived == *s,\n            \"done() called before all bytes expected via expectedSize() were written\");\n      }\n      KJ_REQUIRE(!doneCalled, \"done() called twice\");\n      doneCalled = true;\n  \n      // If we haven't written headers yet, then the content is empty, so we can pass zero for the\n      // expected size. (If we have written headers then the size we pass will be ignored.)\n      writeHeadersOnce(kj::implicitCast<uint64_t>(0));\n  \n      if (isChunked) {\n        previousWrite = previousWrite.then([this]() {\n          return stream->write(\"0\\r\\n\\r\\n\", 5);\n        });\n      }\n  \n      auto fork = previousWrite.fork();\n      previousWrite = fork.addBranch();\n      return fork.addBranch();\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "959-988",
    "snippet": "kj::Promise<void> write(WriteContext context) override {\n    KJ_REQUIRE(!doneCalled, \"write() called after done()\");\n    writeHeadersOnce(nullptr);\n\n    auto data = context.getParams().getData();\n    bytesReceived += data.size();\n    KJ_IF_MAYBE(s, expectedSize) {\n      KJ_REQUIRE(bytesReceived <= *s, \"received more bytes than expected\");\n    }\n\n    // Forward the data.\n    auto promise = previousWrite.then([this, data]() {\n      if (isChunked) {\n        kj::String chunkSize = kj::str(kj::hex(data.size()), \"\\r\\n\");\n        kj::ArrayPtr<char> buffer = chunkSize.asArray();\n        return stream->write(buffer.begin(), buffer.size())\n            .attach(kj::mv(chunkSize))\n            .then([this, data] () {\n          return stream->write(data.begin(), data.size()).then([this] () {\n            return stream->write(\"\\r\\n\", 2);\n          });\n        });\n      } else {\n        return stream->write(data.begin(), data.size());\n      }\n    });\n    auto fork = promise.fork();\n    previousWrite = fork.addBranch();\n    return fork.addBranch();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.fork",
          "args": [],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "previousWrite.then",
          "args": [
            "[this, data]() {\n      if (isChunked) {\n        kj::String chunkSize = kj::str(kj::hex(data.size()), \"\\r\\n\");\n        kj::ArrayPtr<char> buffer = chunkSize.asArray();\n        return stream->write(buffer.begin(), buffer.size())\n            .attach(kj::mv(chunkSize))\n            .then([this, data] () {\n          return stream->write(data.begin(), data.size()).then([this] () {\n            return stream->write(\"\\r\\n\", 2);\n          });\n        });\n      } else {\n        return stream->write(data.begin(), data.size());\n      }\n    }"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "data.begin()",
            "data.size()"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "[this, data] () {\n          return stream->write(data.begin(), data.size()).then([this] () {\n            return stream->write(\"\\r\\n\", 2);\n          });\n        }"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "chunkSize"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunkSize.asArray",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "kj::hex(data.size())",
            "\"\\r\\n\""
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "data.size()"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "bytesReceived <= *s",
            "\"received more bytes than expected\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeHeadersOnce",
          "args": [
            "nullptr"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "writeHeadersOnce",
          "container": "RequestStreamImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1031-1055",
          "snippet": "void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n    KJ_IF_MAYBE(r, httpRequest) {\n      // We haven't sent the request yet.\n      kj::String reqString = kj::mv(*r);\n      httpRequest = nullptr;\n\n      // Hackily splice in content-length or transfer-encoding header.\n      KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n      KJ_IF_MAYBE(l, contentLength) {\n        isChunked = false;\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Content-Length: \", *l, \"\\r\\n\"\n            \"\\r\\n\");\n      } else {\n        reqString = kj::str(\n            reqString.slice(0, reqString.size() - 2),\n            \"Transfer-Encoding: chunked\\r\\n\"\n            \"\\r\\n\");\n      }\n\n      auto bytes = toBytes(reqString);\n      kj::ArrayPtr<const byte> bytesRef = bytes;\n      previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n    }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  void writeHeadersOnce(kj::Maybe<uint64_t> contentLength) {\n      KJ_IF_MAYBE(r, httpRequest) {\n        // We haven't sent the request yet.\n        kj::String reqString = kj::mv(*r);\n        httpRequest = nullptr;\n  \n        // Hackily splice in content-length or transfer-encoding header.\n        KJ_ASSERT(reqString.endsWith(\"\\r\\n\\r\\n\"));\n        KJ_IF_MAYBE(l, contentLength) {\n          isChunked = false;\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Content-Length: \", *l, \"\\r\\n\"\n              \"\\r\\n\");\n        } else {\n          reqString = kj::str(\n              reqString.slice(0, reqString.size() - 2),\n              \"Transfer-Encoding: chunked\\r\\n\"\n              \"\\r\\n\");\n        }\n  \n        auto bytes = toBytes(reqString);\n        kj::ArrayPtr<const byte> bytesRef = bytes;\n        previousWrite = stream->write(bytesRef.begin(), bytesRef.size()).attach(kj::mv(bytes));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!doneCalled",
            "\"write() called after done()\""
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  kj::Promise<void> write(WriteContext context) override {\n      KJ_REQUIRE(!doneCalled, \"write() called after done()\");\n      writeHeadersOnce(nullptr);\n  \n      auto data = context.getParams().getData();\n      bytesReceived += data.size();\n      KJ_IF_MAYBE(s, expectedSize) {\n        KJ_REQUIRE(bytesReceived <= *s, \"received more bytes than expected\");\n      }\n  \n      // Forward the data.\n      auto promise = previousWrite.then([this, data]() {\n        if (isChunked) {\n          kj::String chunkSize = kj::str(kj::hex(data.size()), \"\\r\\n\");\n          kj::ArrayPtr<char> buffer = chunkSize.asArray();\n          return stream->write(buffer.begin(), buffer.size())\n              .attach(kj::mv(chunkSize))\n              .then([this, data] () {\n            return stream->write(data.begin(), data.size()).then([this] () {\n              return stream->write(\"\\r\\n\", 2);\n            });\n          });\n        } else {\n          return stream->write(data.begin(), data.size());\n        }\n      });\n      auto fork = promise.fork();\n      previousWrite = fork.addBranch();\n      return fork.addBranch();\n    }\n}"
  },
  {
    "function_name": "getResponse",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "937-957",
    "snippet": "kj::Promise<void> getResponse(GetResponseContext context) override {\n    KJ_REQUIRE(!getResponseCalled, \"getResponse() called more than once\");\n    getResponseCalled = true;\n\n    // Remember that this is expected to be called *before* done() is called, so that the\n    // application can start sending back data before it has received the entire request if it so\n    // desires.\n\n    auto parser = kj::heap<HttpParser>(responseStream);\n    auto results = context.getResults();\n\n    return parser->readResponse(*stream).then(\n        [this, results, KJ_MVCAP(parser)]\n        (kj::ArrayPtr<byte> remainder) mutable {\n      KJ_ASSERT(remainder.size() == 0);\n      parser->pumpStream(kj::addRef(*stream));\n      auto &parserRef = *parser;\n      sandstorm::Handle::Client handle = kj::mv(parser);\n      parserRef.build(results, handle);\n    });\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "[this, results, KJ_MVCAP(parser)]\n        (kj::ArrayPtr<byte> remainder) mutable {\n      KJ_ASSERT(remainder.size() == 0);\n      parser->pumpStream(kj::addRef(*stream));\n      auto &parserRef = *parser;\n      sandstorm::Handle::Client handle = kj::mv(parser);\n      parserRef.build(results, handle);\n    }"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parserRef.build",
          "args": [
            "results",
            "handle"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "parser"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->pumpStream",
          "args": [
            "kj::addRef(*stream)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*stream"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "remainder.size() == 0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remainder.size",
          "args": [],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->readResponse",
          "args": [
            "*stream"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<HttpParser>",
          "args": [
            "responseStream"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!getResponseCalled",
            "\"getResponse() called more than once\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  kj::Promise<void> getResponse(GetResponseContext context) override {\n      KJ_REQUIRE(!getResponseCalled, \"getResponse() called more than once\");\n      getResponseCalled = true;\n  \n      // Remember that this is expected to be called *before* done() is called, so that the\n      // application can start sending back data before it has received the entire request if it so\n      // desires.\n  \n      auto parser = kj::heap<HttpParser>(responseStream);\n      auto results = context.getResults();\n  \n      return parser->readResponse(*stream).then(\n          [this, results, KJ_MVCAP(parser)]\n          (kj::ArrayPtr<byte> remainder) mutable {\n        KJ_ASSERT(remainder.size() == 0);\n        parser->pumpStream(kj::addRef(*stream));\n        auto &parserRef = *parser;\n        sandstorm::Handle::Client handle = kj::mv(parser);\n        parserRef.build(results, handle);\n      });\n    }\n}"
  },
  {
    "function_name": "RequestStreamImpl",
    "container": "RequestStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "930-935",
    "snippet": "RequestStreamImpl(kj::String httpRequest,\n                    kj::Own<kj::AsyncIoStream> stream,\n                    sandstorm::ByteStream::Client responseStream)\n      : stream(kj::refcounted<RefcountedAsyncIoStream>(kj::mv(stream))),\n        responseStream(responseStream),\n        httpRequest(kj::mv(httpRequest)) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "httpRequest"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<RefcountedAsyncIoStream>",
          "args": [
            "kj::mv(stream)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRequestStreamImpl {\n  RequestStreamImpl(kj::String httpRequest,\n                      kj::Own<kj::AsyncIoStream> stream,\n                      sandstorm::ByteStream::Client responseStream)\n        : stream(kj::refcounted<RefcountedAsyncIoStream>(kj::mv(stream))),\n          responseStream(responseStream),\n          httpRequest(kj::mv(httpRequest)) {}\n}"
  },
  {
    "function_name": "shutdownWrite",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "920-922",
    "snippet": "void shutdownWrite() override {\n    return stream->shutdownWrite();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->shutdownWrite",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "shutdownWrite",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "920-922",
          "snippet": "void shutdownWrite() override {\n    return stream->shutdownWrite();\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  void shutdownWrite() override {\n      return stream->shutdownWrite();\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "917-919",
    "snippet": "kj::Promise<void> write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n    return stream->write(pieces);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "pieces"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "IgnoreStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1815-1815",
          "snippet": "kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nIgnoreStream {\n  kj::Promise<void> write(WriteContext context) override { return kj::READY_NOW; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n      return stream->write(pieces);\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "914-916",
    "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "buffer",
            "size"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
  },
  {
    "function_name": "tryRead",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "911-913",
    "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->tryRead",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
  },
  {
    "function_name": "read",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "908-910",
    "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream->read",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
  },
  {
    "function_name": "RefcountedAsyncIoStream",
    "container": "RefcountedAsyncIoStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "905-906",
    "snippet": "RefcountedAsyncIoStream(kj::Own<kj::AsyncIoStream>&& stream)\n      : stream(kj::mv(stream)) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  RefcountedAsyncIoStream(kj::Own<kj::AsyncIoStream>&& stream)\n        : stream(kj::mv(stream)) {}\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "WebSocketPump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "894-900",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    // TODO(soon):  What do we do when a server -> client send throws?  Probably just ignore it;\n    //   WebSocket datagrams are intended to be one-way and thus the application protocol on top of\n    //   them needs to implement acks at a higher level.  If the client has disconnected, we expect\n    //   the whole pump will be destroyed shortly anyway.\n    KJ_LOG(ERROR, exception);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void taskFailed(kj::Exception&& exception) override {\n      // TODO(soon):  What do we do when a server -> client send throws?  Probably just ignore it;\n      //   WebSocket datagrams are intended to be one-way and thus the application protocol on top of\n      //   them needs to implement acks at a higher level.  If the client has disconnected, we expect\n      //   the whole pump will be destroyed shortly anyway.\n      KJ_LOG(ERROR, exception);\n    }\n}"
  },
  {
    "function_name": "sendBytes",
    "container": "WebSocketPump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "871-879",
    "snippet": "kj::Promise<void> sendBytes(SendBytesContext context) override {\n    // Received bytes from the client.  Write them to serverStream.\n    auto forked = upstreamOp.then([context,this]() mutable {\n      auto message = context.getParams().getMessage();\n      return serverStream->write(message.begin(), message.size());\n    }).fork();\n    upstreamOp = forked.addBranch();\n    return forked.addBranch();\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upstreamOp.then",
          "args": [],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upstreamOp.then",
          "args": [
            "[context,this]() mutable {\n      auto message = context.getParams().getMessage();\n      return serverStream->write(message.begin(), message.size());\n    }"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverStream->write",
          "args": [
            "message.begin()",
            "message.size()"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.size",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.begin",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  kj::Promise<void> sendBytes(SendBytesContext context) override {\n      // Received bytes from the client.  Write them to serverStream.\n      auto forked = upstreamOp.then([context,this]() mutable {\n        auto message = context.getParams().getMessage();\n        return serverStream->write(message.begin(), message.size());\n      }).fork();\n      upstreamOp = forked.addBranch();\n      return forked.addBranch();\n    }\n}"
  },
  {
    "function_name": "sendData",
    "container": "WebSocketPump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "862-868",
    "snippet": "void sendData(kj::ArrayPtr<byte> data) {\n    // Write the given bytes to clientStream.\n    auto request = clientStream.sendBytesRequest(\n        capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n    request.setMessage(data);\n    tasks.add(request.send().ignoreResult());\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "request.send().ignoreResult()"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setMessage",
          "args": [
            "data"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientStream.sendBytesRequest",
          "args": [
            "capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 }"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void sendData(kj::ArrayPtr<byte> data) {\n      // Write the given bytes to clientStream.\n      auto request = clientStream.sendBytesRequest(\n          capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n      request.setMessage(data);\n      tasks.add(request.send().ignoreResult());\n    }\n}"
  },
  {
    "function_name": "pump",
    "container": "WebSocketPump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "848-860",
    "snippet": "void pump() {\n    // Repeatedly read from serverStream and write to clientStream.\n    tasks.add(serverStream->tryRead(buffer, 1, sizeof(buffer))\n        .then([this](size_t amount) {\n      if (amount > 0) {\n        sendData(kj::arrayPtr(buffer, amount));\n        pump();\n      } else {\n        // EOF.\n        clientStream = nullptr;\n      }\n    }));\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "serverStream->tryRead(buffer, 1, sizeof(buffer))\n        .then([this](size_t amount) {\n      if (amount > 0) {\n        sendData(kj::arrayPtr(buffer, amount));\n        pump();\n      } else {\n        // EOF.\n        clientStream = nullptr;\n      }\n    })"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverStream->tryRead",
          "args": [
            "[this](size_t amount) {\n      if (amount > 0) {\n        sendData(kj::arrayPtr(buffer, amount));\n        pump();\n      } else {\n        // EOF.\n        clientStream = nullptr;\n      }\n    }"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "WebSocketPump",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "848-860",
          "snippet": "void pump() {\n    // Repeatedly read from serverStream and write to clientStream.\n    tasks.add(serverStream->tryRead(buffer, 1, sizeof(buffer))\n        .then([this](size_t amount) {\n      if (amount > 0) {\n        sendData(kj::arrayPtr(buffer, amount));\n        pump();\n      } else {\n        // EOF.\n        clientStream = nullptr;\n      }\n    }));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sendData",
          "args": [
            "kj::arrayPtr(buffer, amount)"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "sendData",
          "container": "WebSocketPump",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "862-868",
          "snippet": "void sendData(kj::ArrayPtr<byte> data) {\n    // Write the given bytes to clientStream.\n    auto request = clientStream.sendBytesRequest(\n        capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n    request.setMessage(data);\n    tasks.add(request.send().ignoreResult());\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void sendData(kj::ArrayPtr<byte> data) {\n      // Write the given bytes to clientStream.\n      auto request = clientStream.sendBytesRequest(\n          capnp::MessageSize { data.size() / sizeof(capnp::word) + 8, 0 });\n      request.setMessage(data);\n      tasks.add(request.send().ignoreResult());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "amount"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverStream->tryRead",
          "args": [
            "buffer",
            "1",
            "sizeof(buffer)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  void pump() {\n      // Repeatedly read from serverStream and write to clientStream.\n      tasks.add(serverStream->tryRead(buffer, 1, sizeof(buffer))\n          .then([this](size_t amount) {\n        if (amount > 0) {\n          sendData(kj::arrayPtr(buffer, amount));\n          pump();\n        } else {\n          // EOF.\n          clientStream = nullptr;\n        }\n      }));\n    }\n}"
  },
  {
    "function_name": "WebSocketPump",
    "container": "WebSocketPump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "841-846",
    "snippet": "WebSocketPump(kj::Own<kj::AsyncIoStream> serverStream,\n                WebSession::WebSocketStream::Client clientStream)\n      : serverStream(kj::mv(serverStream)),\n        clientStream(kj::mv(clientStream)),\n        upstreamOp(kj::READY_NOW),\n        tasks(*this) {}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "clientStream"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "serverStream"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSocketPump {\n  WebSocketPump(kj::Own<kj::AsyncIoStream> serverStream,\n                  WebSession::WebSocketStream::Client clientStream)\n        : serverStream(kj::mv(serverStream)),\n          clientStream(kj::mv(clientStream)),\n          upstreamOp(kj::READY_NOW),\n          tasks(*this) {}\n}"
  },
  {
    "function_name": "parseETag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "802-835",
    "snippet": "static void parseETag(kj::StringPtr input, WebSession::ETag::Builder builder) {\n    auto trimmed = trim(input);\n    input = trimmed;\n    if (input.startsWith(\"W/\")) {\n      input = input.slice(2);\n      builder.setWeak(true);\n    }\n\n    // Apps sometimes send invalid ETag data. Rather than crash, we log a warning, due to #2295.\n    if (! (input.endsWith(\"\\\"\") && input.size() > 1)) {\n      maybePrintInvalidEtagWarning(input);\n      return;\n    }\n\n    bool escaped = false;\n    kj::Vector<char> result(input.size() - 2);\n    for (char c: input.slice(1, input.size() - 1)) {\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (c == '\"') {\n          maybePrintInvalidEtagWarning(input);\n          return;\n        }\n        if (c == '\\\\') {\n          escaped = true;\n          continue;\n        }\n      }\n      result.add(c);\n    }\n\n    memcpy(builder.initValue(result.size()).begin(), result.begin(), result.size());\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "builder.initValue(result.size()).begin()",
            "result.begin()",
            "result.size()"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initValue",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initValue",
          "args": [
            "result.size()"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "c"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybePrintInvalidEtagWarning",
          "args": [
            "input"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "maybePrintInvalidEtagWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "790-800",
          "snippet": "static void maybePrintInvalidEtagWarning(kj::StringPtr input) {\n    static bool alreadyLoggedMessage = false;\n    if (alreadyLoggedMessage) {\n      // We already logged the message once this session, which is plenty for now.\n    } else {\n      KJ_LOG(ERROR, \"HTTP protocol error, dropping ETag: app returned invalid ETag data\", input);\n      KJ_LOG(ERROR, \"See Sandstorm documentation: \"\n             \"https://docs.sandstorm.io/en/latest/search.html?q=invalid+etag+data\");\n      alreadyLoggedMessage = true;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic void maybePrintInvalidEtagWarning(kj::StringPtr input) {\n    static bool alreadyLoggedMessage = false;\n    if (alreadyLoggedMessage) {\n      // We already logged the message once this session, which is plenty for now.\n    } else {\n      KJ_LOG(ERROR, \"HTTP protocol error, dropping ETag: app returned invalid ETag data\", input);\n      KJ_LOG(ERROR, \"See Sandstorm documentation: \"\n             \"https://docs.sandstorm.io/en/latest/search.html?q=invalid+etag+data\");\n      alreadyLoggedMessage = true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "1",
            "input.size() - 1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.endsWith",
          "args": [
            "\"\\\"\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setWeak",
          "args": [
            "true"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "2"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.startsWith",
          "args": [
            "\"W/\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "input"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic void parseETag(kj::StringPtr input, WebSession::ETag::Builder builder) {\n    auto trimmed = trim(input);\n    input = trimmed;\n    if (input.startsWith(\"W/\")) {\n      input = input.slice(2);\n      builder.setWeak(true);\n    }\n\n    // Apps sometimes send invalid ETag data. Rather than crash, we log a warning, due to #2295.\n    if (! (input.endsWith(\"\\\"\") && input.size() > 1)) {\n      maybePrintInvalidEtagWarning(input);\n      return;\n    }\n\n    bool escaped = false;\n    kj::Vector<char> result(input.size() - 2);\n    for (char c: input.slice(1, input.size() - 1)) {\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (c == '\"') {\n          maybePrintInvalidEtagWarning(input);\n          return;\n        }\n        if (c == '\\\\') {\n          escaped = true;\n          continue;\n        }\n      }\n      result.add(c);\n    }\n\n    memcpy(builder.initValue(result.size()).begin(), result.begin(), result.size());\n  }"
  },
  {
    "function_name": "maybePrintInvalidEtagWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "790-800",
    "snippet": "static void maybePrintInvalidEtagWarning(kj::StringPtr input) {\n    static bool alreadyLoggedMessage = false;\n    if (alreadyLoggedMessage) {\n      // We already logged the message once this session, which is plenty for now.\n    } else {\n      KJ_LOG(ERROR, \"HTTP protocol error, dropping ETag: app returned invalid ETag data\", input);\n      KJ_LOG(ERROR, \"See Sandstorm documentation: \"\n             \"https://docs.sandstorm.io/en/latest/search.html?q=invalid+etag+data\");\n      alreadyLoggedMessage = true;\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"See Sandstorm documentation: \"\n             \"https://docs.sandstorm.io/en/latest/search.html?q=invalid+etag+data\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"HTTP protocol error, dropping ETag: app returned invalid ETag data\"",
            "input"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic void maybePrintInvalidEtagWarning(kj::StringPtr input) {\n    static bool alreadyLoggedMessage = false;\n    if (alreadyLoggedMessage) {\n      // We already logged the message once this session, which is plenty for now.\n    } else {\n      KJ_LOG(ERROR, \"HTTP protocol error, dropping ETag: app returned invalid ETag data\", input);\n      KJ_LOG(ERROR, \"See Sandstorm documentation: \"\n             \"https://docs.sandstorm.io/en/latest/search.html?q=invalid+etag+data\");\n      alreadyLoggedMessage = true;\n    }\n  }"
  },
  {
    "function_name": "onMessageComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "766-768",
    "snippet": "void onMessageComplete() {\n    messageComplete = true;\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nvoid onMessageComplete() {\n    messageComplete = true;\n  }"
  },
  {
    "function_name": "onHeadersComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "755-764",
    "snippet": "void onHeadersComplete() {\n    for (auto &rawHeader : rawHeaders) {\n      addHeader(rawHeader);\n    }\n\n    statusString = kj::heapString(rawStatusString);\n\n    headersComplete = true;\n    KJ_ASSERT(status_code >= 100, (int)status_code);\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "status_code >= 100",
            "(int)status_code"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "rawStatusString"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addHeader",
          "args": [
            "rawHeader"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nvoid onHeadersComplete() {\n    for (auto &rawHeader : rawHeaders) {\n      addHeader(rawHeader);\n    }\n\n    statusString = kj::heapString(rawStatusString);\n\n    headersComplete = true;\n    KJ_ASSERT(status_code >= 100, (int)status_code);\n  }"
  },
  {
    "function_name": "onBody",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "157-753",
    "snippet": "class HttpParser: public sandstorm::Handle::Server,\n                  private http_parser,\n                  private kj::TaskSet::ErrorHandler {\npublic:\n  HttpParser(sandstorm::ByteStream::Client responseStream)\n    : responseStream(responseStream),\n      taskSet(*this) {\n    memset(&settings, 0, sizeof(settings));\n    settings.on_status = &on_status;\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_body = &on_body;\n    settings.on_headers_complete = &on_headers_complete;\n    settings.on_message_complete = &on_message_complete;\n    http_parser_init(this, HTTP_RESPONSE);\n  }\n\n  kj::Promise<kj::ArrayPtr<byte>> readResponse(kj::AsyncIoStream& stream) {\n    // Read from the stream until we have enough data to forward the response. If the response\n    // is streaming or an upgrade, then just read the headers; otherwise read the entire stream.\n    // If the response is an upgrade, return any remainder bytes that should be forwarded to the\n    // new web socket; otherwise return an empty array.\n\n    return stream.tryRead(buffer, 1, sizeof(buffer)).then(\n        [this, &stream](size_t actual) mutable -> kj::Promise<kj::ArrayPtr<byte>> {\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual && !upgrade) {\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (upgrade) {\n        KJ_ASSERT(nread <= actual && nread >= 0);\n        return kj::arrayPtr(buffer + nread, actual - nread);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        KJ_ASSERT(headersComplete, \"HTTP response from sandboxed app had incomplete headers.\");\n        return kj::arrayPtr(buffer, 0);\n      } else if (headersComplete && status_code / 100 == 2) {\n        isStreaming = true;\n\n        KJ_IF_MAYBE(length, findHeader(\"content-length\")) {\n          auto req = responseStream.expectSizeRequest();\n          req.setSize(length->parseAs<uint64_t>());\n          taskSet.add(req.send().ignoreResult());\n        }\n\n        allocateNextWrite(body.asPtr().asBytes());\n        body = kj::Vector<char>();\n        taskSet.add(pumpWrites().catch_([this](kj::Exception&&) {\n          // Error while writing.\n\n          // Shut down input, so that the app knows it can stop generating it.\n          responseInput->abortRead();\n\n          // Drop the response stream, so that Sandstorm knows no more data is coming.\n          responseStream = nullptr;\n\n          // Mark aborted.\n          aborted = true;\n        }));\n        return kj::arrayPtr(buffer,0);\n      } else {\n        return readResponse(stream);\n      }\n    });\n  }\n\n  void pumpStream(kj::Own<kj::AsyncIoStream>&& stream) {\n    if (isStreaming) {\n      responseInput = kj::mv(stream);\n      startPumpStream();\n    }\n  }\n\n  void build(WebSession::Response::Builder builder, sandstorm::Handle::Client handle) {\n    KJ_ASSERT(!upgrade,\n        \"Sandboxed app attempted to upgrade protocol when client did not request this.\");\n\n    auto iter = HTTP_STATUS_CODES.find(status_code);\n    HttpStatusInfo statusInfo;\n    if (iter != HTTP_STATUS_CODES.end()) {\n      statusInfo = iter->second;\n    } else if (status_code / 100 == 4) {\n      statusInfo.type = WebSession::Response::CLIENT_ERROR;\n      statusInfo.clientErrorCode = WebSession::Response::ClientErrorCode::BAD_REQUEST;\n    } else if (status_code / 100 == 5) {\n      statusInfo.type = WebSession::Response::SERVER_ERROR;\n    } else {\n      KJ_FAIL_REQUIRE(\n          \"Application used unsupported HTTP status code.  Status codes must be whitelisted \"\n          \"because some have sandbox-breaking effects.\", (uint)status_code, statusString);\n    }\n\n    auto cookieList = builder.initSetCookies(cookies.size());\n    for (size_t i: kj::indices(cookies)) {\n      auto cookie = cookieList[i];\n      cookie.setName(cookies[i].name);\n      cookie.setValue(cookies[i].value);\n      if (cookies[i].path != nullptr) {\n        cookie.setPath(cookies[i].path);\n      }\n      switch (cookies[i].expirationType) {\n        case Cookie::ExpirationType::NONE:\n          cookie.getExpires().setNone();\n          break;\n        case Cookie::ExpirationType::ABSOLUTE:\n          cookie.getExpires().setAbsolute(cookies[i].expires);\n          break;\n        case Cookie::ExpirationType::RELATIVE:\n          cookie.getExpires().setRelative(cookies[i].expires);\n          break;\n      }\n      cookie.setHttpOnly(cookies[i].httpOnly);\n    }\n\n    // Add whitelisted headers to additionalHeaders. With respect to security,\n    // the consumers of  WebSession::Response are responsible for making sure\n    // these headers are actually whitelisted. Since this bridge is included in\n    // the app package and runs in the grain itself, we cannot trust that the\n    // whitelist is correctly implemented here. An alternate implementation may\n    // not respect the whitelist. However, for the sake of building a Response\n    // that contains only valid headers, only whitelisted headers are added\n    // here.\n\n    // Add whitelisted headers, and headers matching the app prefix, to a\n    // temporary vector of headers. It is possible for a header name to appear\n    // more than once.\n    kj::Vector<Header*> headersMatching;\n    for (auto& header: headers) {\n      if (RESPONSE_HEADER_WHITELIST.matches(header.first)) {\n        headersMatching.add(&header.second);\n      }\n    }\n    // Initialize additionalHeaders once we know how many headers to include.\n    auto headerList = builder.initAdditionalHeaders(headersMatching.size());\n    // Add the headers matching the whitelist\n    int i = 0;\n    for (auto header: headersMatching) {\n      auto respHeader = headerList[i];\n      respHeader.setName(header->name);\n      respHeader.setValue(header->value);\n      i++;\n    }\n\n    switch (statusInfo.type) {\n      case WebSession::Response::CONTENT: {\n        auto content = builder.initContent();\n        content.setStatusCode(statusInfo.successCode);\n\n        KJ_IF_MAYBE(encoding, findHeader(\"content-encoding\")) {\n          content.setEncoding(*encoding);\n        }\n        KJ_IF_MAYBE(language, findHeader(\"content-language\")) {\n          content.setLanguage(*language);\n        }\n        KJ_IF_MAYBE(mimeType, findHeader(\"content-type\")) {\n          content.setMimeType(*mimeType);\n        }\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, content.initETag());\n        }\n        KJ_IF_MAYBE(disposition, findHeader(\"content-disposition\")) {\n          // Parse `attachment; filename=\"foo\"`\n          // TODO(cleanup):  This is awful.  Use KJ parser library?\n          auto parts = split(*disposition, ';');\n          if (parts.size() > 1 && trim(parts[0]) == \"attachment\") {\n            // Starst with \"attachment;\".  Parse params.\n            for (auto& part: parts.asPtr().slice(1, parts.size())) {\n              // Parse a \"name=value\" parameter.\n              for (size_t i: kj::indices(part)) {\n                if (part[i] == '=') {\n                  // Found '='.  Split and interpret.\n                  if (trim(part.slice(0, i)) == \"filename\") {\n                    // It's \"filename=\", the one we're looking for!\n                    // We need to unquote/unescape the file name.\n                    auto filename = trimArray(part.slice(i + 1, part.size()));\n\n                    if (filename.size() >= 2 && filename[0] == '\\\"' &&\n                        filename[filename.size() - 1] == '\\\"') {\n                      // OK, it is in fact surrounded in quotes.  Unescape the contents.  The\n                      // escaping scheme defined in RFC 822 is very simple:  a backslash followed\n                      // by any character C is interpreted as simply C.\n                      filename = filename.slice(1, filename.size() - 1);\n\n                      kj::Vector<char> unescaped(filename.size() + 1);\n                      for (size_t j = 0; j < filename.size(); j++) {\n                        if (filename[j] == '\\\\') {\n                          if (++j >= filename.size()) {\n                            break;\n                          }\n                        }\n                        unescaped.add(filename[j]);\n                      }\n                      unescaped.add('\\0');\n\n                      content.getDisposition().setDownload(\n                          kj::StringPtr(unescaped.begin(), unescaped.size() - 1));\n                    } else {\n                      // Buggy app failed to quote filename, but we'll try to deal.\n                      content.getDisposition().setDownload(kj::str(filename));\n                    }\n                  }\n                  break;  // Only split at first '='.\n                }\n              }\n            }\n          }\n        }\n\n        if (isStreaming) {\n          KJ_ASSERT(body.size() == 0);\n          content.initBody().setStream(handle);\n        } else {\n          auto data = content.initBody().initBytes(body.size());\n          memcpy(data.begin(), body.begin(), body.size());\n        }\n        break;\n      }\n      case WebSession::Response::NO_CONTENT: {\n        auto noContent = builder.initNoContent();\n        noContent.setShouldResetForm(statusInfo.noContent.shouldResetForm);\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, noContent.initETag());\n        }\n        break;\n      }\n      case WebSession::Response::PRECONDITION_FAILED: {\n        auto preconditionFailed = builder.initPreconditionFailed();\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, preconditionFailed.initMatchingETag());\n        }\n        break;\n      }\n      case WebSession::Response::REDIRECT: {\n        auto redirect = builder.initRedirect();\n        redirect.setIsPermanent(statusInfo.redirect.isPermanent);\n        redirect.setSwitchToGet(statusInfo.redirect.switchToGet);\n        redirect.setLocation(KJ_ASSERT_NONNULL(findHeader(\"location\"),\n            \"Application returned redirect response missing Location header.\", (int)status_code));\n        break;\n      }\n      case WebSession::Response::CLIENT_ERROR: {\n        auto error = builder.initClientError();\n        error.setStatusCode(statusInfo.clientErrorCode);\n        auto text = error.initDescriptionHtml(body.size());\n        memcpy(text.begin(), body.begin(), body.size());\n        break;\n      }\n      case WebSession::Response::SERVER_ERROR: {\n        auto text = builder.initServerError().initDescriptionHtml(body.size());\n        memcpy(text.begin(), body.begin(), body.size());\n        break;\n      }\n    }\n  }\n\n  void buildForWebSocket(WebSession::OpenWebSocketResults::Builder builder) {\n    // TODO(soon):  If the app returned a normal response without upgrading, we should forward that\n    //   through, as it's perfectly valid HTTP.  The WebSession interface currently does not\n    //   support this.\n    KJ_ASSERT(status_code == 101, \"Sandboxed app does not support WebSocket.\",\n              (int)upgrade, (int)status_code, statusString);\n\n    KJ_IF_MAYBE(protocol, findHeader(\"sec-websocket-protocol\")) {\n      auto parts = split(*protocol, ',');\n      auto list = builder.initProtocol(parts.size());\n      for (auto i: kj::indices(parts)) {\n        auto trimmed = trim(parts[i]);\n        memcpy(list.init(i, trimmed.size()).begin(), trimmed.begin(), trimmed.size());\n      }\n    }\n\n    // TODO(soon):  Should we do more validation here, like checking the exact value of the Upgrade\n    //   header or Sec-WebSocket-Accept?\n  }\n\n  void buildOptions(WebSession::Options::Builder builder) {\n    KJ_ASSERT(!upgrade,\n        \"Sandboxed app attempted to upgrade protocol when client did not request this.\");\n\n    KJ_IF_MAYBE(dav, findHeader(\"dav\")) {\n      kj::Vector<kj::String> extensions;\n      for (auto level: split(*dav, ',')) {\n        auto trimmed = trim(level);\n        if (trimmed == \"1\") {\n          builder.setDavClass1(true);\n        } else if (trimmed == \"2\") {\n          builder.setDavClass2(true);\n        } else if (trimmed == \"3\") {\n          builder.setDavClass3(true);\n        } else {\n          extensions.add(kj::mv(trimmed));\n        }\n      }\n      if (extensions.size() > 0) {\n        auto list = builder.initDavExtensions(extensions.size());\n        for (auto i: kj::indices(extensions)) {\n          list.set(i, extensions[i]);\n        }\n      }\n    }\n  }\n\nprivate:\n  enum HeaderElementType { NONE, FIELD, VALUE };\n\n  struct RawHeader {\n    kj::Vector<char> name;\n    kj::Vector<char> value;\n  };\n\n  struct Header {\n    kj::String name;\n    kj::String value;\n  };\n\n  struct Cookie {\n    kj::String name;\n    kj::String value;\n    kj::String path;\n    int64_t expires;\n\n    enum ExpirationType {\n      NONE, RELATIVE, ABSOLUTE\n    };\n    ExpirationType expirationType = NONE;\n\n    bool httpOnly = false;\n  };\n\n  sandstorm::ByteStream::Client responseStream;\n  kj::TaskSet taskSet;\n  http_parser_settings settings;\n  kj::Vector<RawHeader> rawHeaders;\n  kj::Vector<char> rawStatusString;\n  HeaderElementType lastHeaderElement = NONE;\n  std::map<kj::StringPtr, Header> headers;\n  kj::Vector<char> body;\n  kj::Vector<Cookie> cookies;\n  kj::String statusString;\n  bool headersComplete = false;\n  bool messageComplete = false;\n  bool isStreaming = false;\n  bool streamDone = false;\n  bool readStalled = false;\n  bool aborted = false;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> writeReady;\n  capnp::Request<ByteStream::WriteParams, ByteStream::WriteResults> nextWrite = nullptr;\n  capnp::Orphan<capnp::Data> nextWriteData;\n  size_t nextWriteSize = 0;  // how many bytes are already in `nextWriteData`\n\n  kj::Own<kj::AsyncIoStream> responseInput;\n  byte buffer[8192];\n\n  kj::Promise<void> pumpWrites() {\n    if (nextWriteSize > 0) {\n      // Send the current write and allocate a new one.\n      nextWriteData.truncate(nextWriteSize);\n      nextWrite.adoptData(kj::mv(nextWriteData));\n\n      auto result = nextWrite.send().then([this](auto&&) {\n        return pumpWrites();\n      });\n\n      allocateNextWrite();\n\n      return result;\n    } else if (streamDone) {\n      // No more bytes coming.\n      nextWriteData = capnp::Orphan<capnp::Data>();\n      nextWrite = nullptr;\n      auto promise = responseStream.doneRequest().send().ignoreResult();\n      responseStream = nullptr;\n      return kj::mv(promise);\n    } else {\n      // No bytes received yet. Wait.\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      writeReady = kj::mv(paf.fulfiller);\n      return paf.promise.then([this]() { return pumpWrites(); });\n    }\n  }\n\n  void allocateNextWrite(kj::ArrayPtr<const byte> initData = nullptr) {\n    // For each write we start out allocating twice as much space as we actually managed to fill\n    // on the previous write, though we cap this at 128k.\n    size_t size = nextWriteSize * 2;\n    if (size < sizeof(buffer)) {\n      size = sizeof(buffer);\n    } else if (size > (128u << 10)) {\n      size = (128u << 10);\n    }\n\n    size = kj::max(size, initData.size());\n\n    nextWriteData = capnp::Orphan<capnp::Data>();\n    nextWrite = responseStream.writeRequest();\n    nextWriteData = capnp::Orphanage::getForMessageContaining(\n        ByteStream::WriteParams::Builder(nextWrite))\n        .newOrphan<capnp::Data>(size);\n\n    nextWriteSize = initData.size();\n    if (initData.size() > 0) {\n      memcpy(nextWriteData.get().begin(), initData.begin(), initData.size());\n    }\n\n    if (readStalled) {\n      // Start reading again.\n      readStalled = false;\n      startPumpStream();\n    }\n  }\n\n  void startPumpStream() {\n    taskSet.add(pumpStreamInternal().catch_([this](kj::Exception&& e) {\n      // Error while reading.\n\n      // Drop the response stream, so that Sandstorm knows no more data is coming.\n      responseStream = nullptr;\n    }));\n  }\n\n  kj::Promise<void> pumpStreamInternal() {\n    // Read HTTP response data coming out of the app.\n\n    if (aborted) {\n      // Output failed; give up.\n      return kj::READY_NOW;\n    }\n\n    // Make sure not to read more bytes than would fit in our output buffer.\n    size_t n = kj::min(sizeof(buffer), nextWriteData.getReader().size() - nextWriteSize);\n\n    if (n == 0) {\n      // We're out of space. Wait.\n      readStalled = true;\n      return kj::READY_NOW;\n    }\n\n    return responseInput->tryRead(buffer, 1, n)\n        .then([this](size_t actual) -> kj::Promise<void> {\n      if (aborted) {\n        // Output failed; give up.\n        return kj::READY_NOW;\n      }\n\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual) {\n        // The parser failed.\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        streamDone = true;\n        KJ_IF_MAYBE(w, writeReady) {\n          w->get()->fulfill();\n          writeReady = nullptr;\n        }\n        return kj::READY_NOW;\n      } else {\n        return pumpStreamInternal();\n      }\n    });\n  }\n\n  void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }\n\n  kj::Maybe<kj::StringPtr> findHeader(kj::StringPtr name) {\n    auto iter = headers.find(name);\n    if (iter == headers.end()) {\n      return nullptr;\n    } else {\n      return kj::StringPtr(iter->second.value);\n    }\n  }\n\n  void onStatus(kj::ArrayPtr<const char> status) {\n    rawStatusString.addAll(status);\n  }\n\n  void onHeaderField(kj::ArrayPtr<const char> name) {\n    if (lastHeaderElement != FIELD) {\n      rawHeaders.resize(rawHeaders.size() + 1);\n    }\n    rawHeaders[rawHeaders.size() - 1].name.addAll(name);\n    lastHeaderElement = FIELD;\n  }\n\n  void onHeaderValue(kj::ArrayPtr<const char> value) {\n    rawHeaders[rawHeaders.size() - 1].value.addAll(value);\n    lastHeaderElement = VALUE;\n  }\n\n  void addHeader(RawHeader &rawHeader) {\n    auto name = kj::heapString(rawHeader.name);\n    toLower(name);\n    kj::ArrayPtr<const char> value = rawHeader.value.asPtr();\n\n    if (name == \"set-cookie\") {\n      // Really ugly cookie-parsing code.\n      // TODO(cleanup):  Clean up.\n      bool isFirst = true;\n      Cookie cookie;\n      for (auto part: split(value, ';')) {\n        if (isFirst) {\n          isFirst = false;\n          cookie.name = trim(KJ_ASSERT_NONNULL(splitFirst(part, '='),\n              \"Invalid cookie header from app.\", value));\n          cookie.value = trim(part);\n        } else KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n          auto prop = trim(*name);\n          toLower(prop);\n          if (prop == \"expires\") {\n            auto value = trim(part);\n            // Wed, 15 Nov 1995 06:25:24 GMT\n            struct tm t;\n            memset(&t, 0, sizeof(t));\n\n            // There are three allowed formats for HTTP dates.  Ugh.\n            char* end = strptime(value.cStr(), \"%a, %d %b %Y %T GMT\", &t);\n            if (end == nullptr) {\n              end = strptime(value.cStr(), \"%a, %d-%b-%y %T GMT\", &t);\n              if (end == nullptr) {\n                end = strptime(value.cStr(), \"%a %b %d %T %Y\", &t);\n                if (end == nullptr) {\n                  // Not valid per HTTP spec, but MediaWiki seems to return this format sometimes.\n                  end = strptime(value.cStr(), \"%a, %d-%b-%Y %T GMT\", &t);\n                  if (end == nullptr) {\n                    // Not valid per HTTP spec, but used by Rack.\n                    end = strptime(value.cStr(), \"%a, %d %b %Y %T -0000\", &t);\n                  }\n                }\n              }\n            }\n            KJ_ASSERT(end != nullptr && *end == '\\0', \"Invalid HTTP date from app.\", value);\n            cookie.expires = timegm(&t);\n            cookie.expirationType = Cookie::ExpirationType::ABSOLUTE;\n          } else if (prop == \"max-age\") {\n            auto value = trim(part);\n            char* end;\n            cookie.expires = strtoull(value.cStr(), &end, 10);\n            KJ_ASSERT(end > value.begin() && *end == '\\0', \"Invalid cookie max-age app.\", value);\n            cookie.expirationType = Cookie::ExpirationType::RELATIVE;\n          } else if (prop == \"path\") {\n            cookie.path = trim(part);\n          } else {\n            // Ignore other properties:\n            //   Path:  Not useful on the modern same-origin-policy web.\n            //   Domain:  We do not allow the app to publish cookies visible to other hosts in the\n            //     domain.\n          }\n        } else {\n          auto prop = trim(part);\n          toLower(prop);\n          if (prop == \"httponly\") {\n            cookie.httpOnly = true;\n          } else {\n            // Ignore other properties:\n            //   Secure:  We always set this, since we always require https.\n          }\n        }\n      }\n\n      cookies.add(kj::mv(cookie));\n\n    } else {\n      auto& slot = headers[name];\n      if (slot.name != nullptr) {\n        // Multiple instances of the same header are equivalent to comma-delimited.\n        slot.value = kj::str(kj::mv(slot.value), \", \", value);\n      } else {\n        slot = Header { kj::mv(name), kj::heapString(value) };\n      }\n    }\n  }\n\n\n  void onBody(kj::ArrayPtr<const char> data) {\n    if (isStreaming) {\n      // Copy into the buffer we're working on.\n      kj::ArrayPtr<byte> buffer = nextWriteData.get();\n      buffer = buffer.slice(nextWriteSize, buffer.size());\n      KJ_ASSERT(data.size() <= buffer.size(), data.size(), buffer.size(), nextWriteSize);\n      memcpy(buffer.begin(), data.begin(), data.size());\n      nextWriteSize += data.size();\n\n      // Indicate data is ready. (Most of these fulfill() calls will be no-ops if no one is\n      // waiting.)\n      KJ_IF_MAYBE(w, writeReady) {\n        w->get()->fulfill();\n        writeReady = nullptr;\n      }\n    } else {\n      body.addAll(data);\n    }\n  }",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.addAll",
          "args": [
            "data"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w->get",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w->get",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer.begin()",
            "data.begin()",
            "data.size()"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "data.size() <= buffer.size()",
            "data.size()",
            "buffer.size()",
            "nextWriteSize"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.slice",
          "args": [
            "nextWriteSize",
            "buffer.size()"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.get",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "value"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "name"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "kj::mv(slot.value)",
            "\", \"",
            "value"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "slot.value"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookies.add",
          "args": [
            "kj::mv(cookie)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cookie"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toLower",
          "args": [
            "prop"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "toLower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "206-212",
          "snippet": "void toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "part"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "end > value.begin() && *end == '\\0'",
            "\"Invalid cookie max-age app.\"",
            "value"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.begin",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value.cStr()",
            "&end",
            "10"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timegm",
          "args": [
            "&t"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "end != nullptr && *end == '\\0'",
            "\"Invalid HTTP date from app.\"",
            "value"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strptime",
          "args": [
            "value.cStr()",
            "\"%a, %d %b %Y %T -0000\"",
            "&t"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strptime",
          "args": [
            "value.cStr()",
            "\"%a, %d-%b-%Y %T GMT\"",
            "&t"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strptime",
          "args": [
            "value.cStr()",
            "\"%a %b %d %T %Y\"",
            "&t"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strptime",
          "args": [
            "value.cStr()",
            "\"%a, %d-%b-%y %T GMT\"",
            "&t"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strptime",
          "args": [
            "value.cStr()",
            "\"%a, %d %b %Y %T GMT\"",
            "&t"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&t",
            "0",
            "sizeof(t)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "name",
            "splitFirst(part, '=')"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "splitFirst",
          "args": [
            "part",
            "'='"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "splitFirst(part, '=')",
            "\"Invalid cookie header from app.\"",
            "value"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawHeader.value.asPtr",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "rawHeader.name"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawHeaders[rawHeaders.size",
          "args": [
            "value"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawHeaders[rawHeaders.size",
          "args": [
            "name"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawHeaders.resize",
          "args": [
            "rawHeaders.size() + 1"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawStatusString.addAll",
          "args": [
            "status"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "iter->second.value"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.end",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.find",
          "args": [
            "name"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseInput->tryRead",
          "args": [
            "[this](size_t actual) -> kj::Promise<void> {\n      if (aborted) {\n        // Output failed; give up.\n        return kj::READY_NOW;\n      }\n\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual) {\n        // The parser failed.\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        streamDone = true;\n        KJ_IF_MAYBE(w, writeReady) {\n          w->get()->fulfill();\n          writeReady = nullptr;\n        }\n        return kj::READY_NOW;\n      } else {\n        return pumpStreamInternal();\n      }\n    }"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpStreamInternal",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w->get",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w->get",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Failed to parse HTTP response from sandboxed app.\"",
            "error"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_errno_description",
          "args": [
            "HTTP_PARSER_ERRNO(this)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HTTP_PARSER_ERRNO",
          "args": [
            "this"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_parser_execute",
          "args": [
            "this",
            "&settings",
            "reinterpret_cast<char*>(buffer)",
            "actual"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "http_parser_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/joyent-http/http_parser.c++",
          "lines": "573-1897",
          "snippet": "size_t http_parser_execute (http_parser *parser,\n                            const http_parser_settings *settings,\n                            const char *data,\n                            size_t len)\n{\n  char c, ch;\n  int8_t unhex_val;\n  const char *p = data;\n  const char *header_field_mark = 0;\n  const char *header_value_mark = 0;\n  const char *url_mark = 0;\n  const char *body_mark = 0;\n  const char *status_mark = 0;\n\n  /* We're in an error state. Don't bother doing anything. */\n  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n    return 0;\n  }\n\n  if (len == 0) {\n    switch (parser->state) {\n      case s_body_identity_eof:\n        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if\n         * we got paused.\n         */\n        CALLBACK_NOTIFY_NOADVANCE(message_complete);\n        return 0;\n\n      case s_dead:\n      case s_start_req_or_res:\n      case s_start_res:\n      case s_start_req:\n        return 0;\n\n      default:\n        SET_ERRNO(HPE_INVALID_EOF_STATE);\n        return 1;\n    }\n  }\n\n\n  if (parser->state == s_header_field)\n    header_field_mark = data;\n  if (parser->state == s_header_value)\n    header_value_mark = data;\n  switch (parser->state) {\n  case s_req_path:\n  case s_req_schema:\n  case s_req_schema_slash:\n  case s_req_schema_slash_slash:\n  case s_req_server_start:\n  case s_req_server:\n  case s_req_server_with_at:\n  case s_req_query_string_start:\n  case s_req_query_string:\n  case s_req_fragment_start:\n  case s_req_fragment:\n    url_mark = data;\n    break;\n  case s_res_status:\n    status_mark = data;\n    break;\n  }\n\n  for (p=data; p != data + len; p++) {\n    ch = *p;\n\n    if (PARSING_HEADER(parser->state)) {\n      ++parser->nread;\n      /* Don't allow the total size of the HTTP headers (including the status\n       * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect\n       * embedders against denial-of-service attacks where the attacker feeds\n       * us a never-ending header that the embedder keeps buffering.\n       *\n       * This check is arguably the responsibility of embedders but we're doing\n       * it on the embedder's behalf because most won't bother and this way we\n       * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger\n       * than any reasonable request or response so this should never affect\n       * day-to-day operation.\n       */\n      if (parser->nread > HTTP_MAX_HEADER_SIZE) {\n        SET_ERRNO(HPE_HEADER_OVERFLOW);\n        goto error;\n      }\n    }\n\n    reexecute_byte:\n    switch (parser->state) {\n\n      case s_dead:\n        /* this state is used after a 'Connection: close' message\n         * the parser will error out if it reads another message\n         */\n        if (ch == CR || ch == LF)\n          break;\n\n        SET_ERRNO(HPE_CLOSED_CONNECTION);\n        goto error;\n\n      case s_start_req_or_res:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (ch == 'H') {\n          parser->state = s_res_or_resp_H;\n\n          CALLBACK_NOTIFY(message_begin);\n        } else {\n          parser->type = HTTP_REQUEST;\n          parser->state = s_start_req;\n          goto reexecute_byte;\n        }\n\n        break;\n      }\n\n      case s_res_or_resp_H:\n        if (ch == 'T') {\n          parser->type = HTTP_RESPONSE;\n          parser->state = s_res_HT;\n        } else {\n          if (ch != 'E') {\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n          }\n\n          parser->type = HTTP_REQUEST;\n          parser->method = HTTP_HEAD;\n          parser->index = 2;\n          parser->state = s_req_method;\n        }\n        break;\n\n      case s_start_res:\n      {\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        switch (ch) {\n          case 'H':\n            parser->state = s_res_H;\n            break;\n\n          case CR:\n          case LF:\n            break;\n\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n\n        CALLBACK_NOTIFY(message_begin);\n        break;\n      }\n\n      case s_res_H:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_res_HT;\n        break;\n\n      case s_res_HT:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_res_HTT;\n        break;\n\n      case s_res_HTT:\n        STRICT_CHECK(ch != 'P');\n        parser->state = s_res_HTTP;\n        break;\n\n      case s_res_HTTP:\n        STRICT_CHECK(ch != '/');\n        parser->state = s_res_first_http_major;\n        break;\n\n      case s_res_first_http_major:\n        if (ch < '0' || ch > '9') {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        parser->state = s_res_http_major;\n        break;\n\n      /* major HTTP version or dot */\n      case s_res_http_major:\n      {\n        if (ch == '.') {\n          parser->state = s_res_first_http_minor;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (parser->http_major > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_res_first_http_minor:\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        parser->state = s_res_http_minor;\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_res_http_minor:\n      {\n        if (ch == ' ') {\n          parser->state = s_res_first_status_code;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (parser->http_minor > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_first_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          if (ch == ' ') {\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n        parser->status_code = ch - '0';\n        parser->state = s_res_status_code;\n        break;\n      }\n\n      case s_res_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          switch (ch) {\n            case ' ':\n              parser->state = s_res_status_start;\n              break;\n            case CR:\n              parser->state = s_res_line_almost_done;\n              break;\n            case LF:\n              parser->state = s_header_field_start;\n              break;\n            default:\n              SET_ERRNO(HPE_INVALID_STATUS);\n              goto error;\n          }\n          break;\n        }\n\n        parser->status_code *= 10;\n        parser->status_code += ch - '0';\n\n        if (parser->status_code > 999) {\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_status_start:\n      {\n        if (ch == CR) {\n          parser->state = s_res_line_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          break;\n        }\n\n        MARK(status);\n        parser->state = s_res_status;\n        parser->index = 0;\n        break;\n      }\n\n      case s_res_status:\n        if (ch == CR) {\n          parser->state = s_res_line_almost_done;\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        break;\n\n      case s_res_line_almost_done:\n        STRICT_CHECK(ch != LF);\n        parser->state = s_header_field_start;\n        break;\n\n      case s_start_req:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (!IS_ALPHA(ch)) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        parser->method = (enum http_method) 0;\n        parser->index = 1;\n        switch (ch) {\n          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;\n          case 'D': parser->method = HTTP_DELETE; break;\n          case 'G': parser->method = HTTP_GET; break;\n          case 'H': parser->method = HTTP_HEAD; break;\n          case 'L': parser->method = HTTP_LOCK; break;\n          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH */ break;\n          case 'N': parser->method = HTTP_NOTIFY; break;\n          case 'O': parser->method = HTTP_OPTIONS; break;\n          case 'P': parser->method = HTTP_POST;\n            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */\n            break;\n          case 'R': parser->method = HTTP_REPORT; break;\n          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;\n          case 'T': parser->method = HTTP_TRACE; break;\n          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE */ break;\n          default:\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n        }\n        parser->state = s_req_method;\n\n        CALLBACK_NOTIFY(message_begin);\n\n        break;\n      }\n\n      case s_req_method:\n      {\n        const char *matcher;\n        if (ch == '\\0') {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        matcher = method_strings[parser->method];\n        if (ch == ' ' && matcher[parser->index] == '\\0') {\n          parser->state = s_req_spaces_before_url;\n        } else if (ch == matcher[parser->index]) {\n          ; /* nada */\n        } else if (parser->method == HTTP_CONNECT) {\n          if (parser->index == 1 && ch == 'H') {\n            parser->method = HTTP_CHECKOUT;\n          } else if (parser->index == 2  && ch == 'P') {\n            parser->method = HTTP_COPY;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->method == HTTP_MKCOL) {\n          if (parser->index == 1 && ch == 'O') {\n            parser->method = HTTP_MOVE;\n          } else if (parser->index == 1 && ch == 'E') {\n            parser->method = HTTP_MERGE;\n          } else if (parser->index == 1 && ch == '-') {\n            parser->method = HTTP_MSEARCH;\n          } else if (parser->index == 2 && ch == 'A') {\n            parser->method = HTTP_MKACTIVITY;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->method == HTTP_SUBSCRIBE) {\n          if (parser->index == 1 && ch == 'E') {\n            parser->method = HTTP_SEARCH;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 1 && parser->method == HTTP_POST) {\n          if (ch == 'R') {\n            parser->method = HTTP_PROPFIND; /* or HTTP_PROPPATCH */\n          } else if (ch == 'U') {\n            parser->method = HTTP_PUT; /* or HTTP_PURGE */\n          } else if (ch == 'A') {\n            parser->method = HTTP_PATCH;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 2) {\n          if (parser->method == HTTP_PUT) {\n            if (ch == 'R') {\n              parser->method = HTTP_PURGE;\n            } else {\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n            }\n          } else if (parser->method == HTTP_UNLOCK) {\n            if (ch == 'S') {\n              parser->method = HTTP_UNSUBSCRIBE;\n            } else {\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n            }\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 4 && parser->method == HTTP_PROPFIND && ch == 'P') {\n          parser->method = HTTP_PROPPATCH;\n        } else {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        ++parser->index;\n        break;\n      }\n\n      case s_req_spaces_before_url:\n      {\n        if (ch == ' ') break;\n\n        MARK(url);\n        if (parser->method == HTTP_CONNECT) {\n          parser->state = s_req_server_start;\n        }\n\n        parser->state = parse_url_char((enum state)parser->state, ch);\n        if (parser->state == s_dead) {\n          SET_ERRNO(HPE_INVALID_URL);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_req_schema:\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      {\n        switch (ch) {\n          /* No whitespace allowed here */\n          case ' ':\n          case CR:\n          case LF:\n            SET_ERRNO(HPE_INVALID_URL);\n            goto error;\n          default:\n            parser->state = parse_url_char((enum state)parser->state, ch);\n            if (parser->state == s_dead) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n\n        break;\n      }\n\n      case s_req_server:\n      case s_req_server_with_at:\n      case s_req_path:\n      case s_req_query_string_start:\n      case s_req_query_string:\n      case s_req_fragment_start:\n      case s_req_fragment:\n      {\n        switch (ch) {\n          case ' ':\n            parser->state = s_req_http_start;\n            CALLBACK_DATA(url);\n            break;\n          case CR:\n          case LF:\n            parser->http_major = 0;\n            parser->http_minor = 9;\n            parser->state = (ch == CR) ?\n              s_req_line_almost_done :\n              s_header_field_start;\n            CALLBACK_DATA(url);\n            break;\n          default:\n            parser->state = parse_url_char((enum state)parser->state, ch);\n            if (parser->state == s_dead) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n        break;\n      }\n\n      case s_req_http_start:\n        switch (ch) {\n          case 'H':\n            parser->state = s_req_http_H;\n            break;\n          case ' ':\n            break;\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n        break;\n\n      case s_req_http_H:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_req_http_HT;\n        break;\n\n      case s_req_http_HT:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_req_http_HTT;\n        break;\n\n      case s_req_http_HTT:\n        STRICT_CHECK(ch != 'P');\n        parser->state = s_req_http_HTTP;\n        break;\n\n      case s_req_http_HTTP:\n        STRICT_CHECK(ch != '/');\n        parser->state = s_req_first_http_major;\n        break;\n\n      /* first digit of major HTTP version */\n      case s_req_first_http_major:\n        if (ch < '1' || ch > '9') {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        parser->state = s_req_http_major;\n        break;\n\n      /* major HTTP version or dot */\n      case s_req_http_major:\n      {\n        if (ch == '.') {\n          parser->state = s_req_first_http_minor;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (parser->http_major > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_req_first_http_minor:\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        parser->state = s_req_http_minor;\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_req_http_minor:\n      {\n        if (ch == CR) {\n          parser->state = s_req_line_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          break;\n        }\n\n        /* XXX allow spaces after digit? */\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (parser->http_minor > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* end of request line */\n      case s_req_line_almost_done:\n      {\n        if (ch != LF) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        parser->state = s_header_field_start;\n        break;\n      }\n\n      case s_header_field_start:\n      {\n        if (ch == CR) {\n          parser->state = s_headers_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          /* they might be just sending \\n instead of \\r\\n so this would be\n           * the second \\n to denote the end of headers*/\n          parser->state = s_headers_almost_done;\n          goto reexecute_byte;\n        }\n\n        c = TOKEN(ch);\n\n        if (!c) {\n          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n          goto error;\n        }\n\n        MARK(header_field);\n\n        parser->index = 0;\n        parser->state = s_header_field;\n\n        switch (c) {\n          case 'c':\n            parser->header_state = h_C;\n            break;\n\n          case 'p':\n            parser->header_state = h_matching_proxy_connection;\n            break;\n\n          case 't':\n            parser->header_state = h_matching_transfer_encoding;\n            break;\n\n          case 'u':\n            parser->header_state = h_matching_upgrade;\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_field:\n      {\n        c = TOKEN(ch);\n\n        if (c) {\n          switch (parser->header_state) {\n            case h_general:\n              break;\n\n            case h_C:\n              parser->index++;\n              parser->header_state = (c == 'o' ? h_CO : h_general);\n              break;\n\n            case h_CO:\n              parser->index++;\n              parser->header_state = (c == 'n' ? h_CON : h_general);\n              break;\n\n            case h_CON:\n              parser->index++;\n              switch (c) {\n                case 'n':\n                  parser->header_state = h_matching_connection;\n                  break;\n                case 't':\n                  parser->header_state = h_matching_content_length;\n                  break;\n                default:\n                  parser->header_state = h_general;\n                  break;\n              }\n              break;\n\n            /* connection */\n\n            case h_matching_connection:\n              parser->index++;\n              if (parser->index > sizeof(CONNECTION)-1\n                  || c != CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* proxy-connection */\n\n            case h_matching_proxy_connection:\n              parser->index++;\n              if (parser->index > sizeof(PROXY_CONNECTION)-1\n                  || c != PROXY_CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* content-length */\n\n            case h_matching_content_length:\n              parser->index++;\n              if (parser->index > sizeof(CONTENT_LENGTH)-1\n                  || c != CONTENT_LENGTH[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {\n                parser->header_state = h_content_length;\n              }\n              break;\n\n            /* transfer-encoding */\n\n            case h_matching_transfer_encoding:\n              parser->index++;\n              if (parser->index > sizeof(TRANSFER_ENCODING)-1\n                  || c != TRANSFER_ENCODING[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {\n                parser->header_state = h_transfer_encoding;\n              }\n              break;\n\n            /* upgrade */\n\n            case h_matching_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE)-1\n                  || c != UPGRADE[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                parser->header_state = h_upgrade;\n              }\n              break;\n\n            case h_connection:\n            case h_content_length:\n            case h_transfer_encoding:\n            case h_upgrade:\n              if (ch != ' ') parser->header_state = h_general;\n              break;\n\n            default:\n              assert(0 && \"Unknown header_state\");\n              break;\n          }\n          break;\n        }\n\n        if (ch == ':') {\n          parser->state = s_header_value_start;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        if (ch == CR) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n        goto error;\n      }\n\n      case s_header_value_start:\n      {\n        if (ch == ' ' || ch == '\\t') break;\n\n        MARK(header_value);\n\n        parser->state = s_header_value;\n        parser->index = 0;\n\n        if (ch == CR) {\n          parser->header_state = h_general;\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_upgrade:\n            parser->flags |= F_UPGRADE;\n            parser->header_state = h_general;\n            break;\n\n          case h_transfer_encoding:\n            /* looking for 'Transfer-Encoding: chunked' */\n            if ('c' == c) {\n              parser->header_state = h_matching_transfer_encoding_chunked;\n            } else {\n              parser->header_state = h_general;\n            }\n            break;\n\n          case h_content_length:\n            if (!IS_NUM(ch)) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->content_length = ch - '0';\n            break;\n\n          case h_connection:\n            /* looking for 'Connection: keep-alive' */\n            if (c == 'k') {\n              parser->header_state = h_matching_connection_keep_alive;\n            /* looking for 'Connection: close' */\n            } else if (c == 'c') {\n              parser->header_state = h_matching_connection_close;\n            } else {\n              parser->header_state = h_general;\n            }\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_value:\n      {\n\n        if (ch == CR) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA_NOADVANCE(header_value);\n          goto reexecute_byte;\n        }\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_general:\n            break;\n\n          case h_connection:\n          case h_transfer_encoding:\n            assert(0 && \"Shouldn't get here.\");\n            break;\n\n          case h_content_length:\n          {\n            uint64_t t;\n\n            if (ch == ' ') break;\n\n            if (!IS_NUM(ch)) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            t = parser->content_length;\n            t *= 10;\n            t += ch - '0';\n\n            /* Overflow? Test against a conservative limit for simplicity. */\n            if ((ULLONG_MAX - 10) / 10 < parser->content_length) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->content_length = t;\n            break;\n          }\n\n          /* Transfer-Encoding: chunked */\n          case h_matching_transfer_encoding_chunked:\n            parser->index++;\n            if (parser->index > sizeof(CHUNKED)-1\n                || c != CHUNKED[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(CHUNKED)-2) {\n              parser->header_state = h_transfer_encoding_chunked;\n            }\n            break;\n\n          /* looking for 'Connection: keep-alive' */\n          case h_matching_connection_keep_alive:\n            parser->index++;\n            if (parser->index > sizeof(KEEP_ALIVE)-1\n                || c != KEEP_ALIVE[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(KEEP_ALIVE)-2) {\n              parser->header_state = h_connection_keep_alive;\n            }\n            break;\n\n          /* looking for 'Connection: close' */\n          case h_matching_connection_close:\n            parser->index++;\n            if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(CLOSE)-2) {\n              parser->header_state = h_connection_close;\n            }\n            break;\n\n          case h_transfer_encoding_chunked:\n          case h_connection_keep_alive:\n          case h_connection_close:\n            if (ch != ' ') parser->header_state = h_general;\n            break;\n\n          default:\n            parser->state = s_header_value;\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        parser->state = s_header_value_lws;\n\n        switch (parser->header_state) {\n          case h_connection_keep_alive:\n            parser->flags |= F_CONNECTION_KEEP_ALIVE;\n            break;\n          case h_connection_close:\n            parser->flags |= F_CONNECTION_CLOSE;\n            break;\n          case h_transfer_encoding_chunked:\n            parser->flags |= F_CHUNKED;\n            break;\n          default:\n            break;\n        }\n\n        break;\n      }\n\n      case s_header_value_lws:\n      {\n        if (ch == ' ' || ch == '\\t')\n          parser->state = s_header_value_start;\n        else\n        {\n          parser->state = s_header_field_start;\n          goto reexecute_byte;\n        }\n        break;\n      }\n\n      case s_headers_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        if (parser->flags & F_TRAILING) {\n          /* End of a chunked request */\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n          break;\n        }\n\n        parser->state = s_headers_done;\n\n        /* Set this here so that on_headers_complete() callbacks can see it */\n        parser->upgrade =\n          (parser->flags & F_UPGRADE || parser->method == HTTP_CONNECT);\n\n        /* Here we call the headers_complete callback. This is somewhat\n         * different than other callbacks because if the user returns 1, we\n         * will interpret that as saying that this message has no body. This\n         * is needed for the annoying case of recieving a response to a HEAD\n         * request.\n         *\n         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so\n         * we have to simulate it by handling a change in errno below.\n         */\n        if (settings->on_headers_complete) {\n          switch (settings->on_headers_complete(parser)) {\n            case 0:\n              break;\n\n            case 1:\n              parser->flags |= F_SKIPBODY;\n              break;\n\n            default:\n              SET_ERRNO(HPE_CB_headers_complete);\n              return p - data; /* Error */\n          }\n        }\n\n        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n          return p - data;\n        }\n\n        goto reexecute_byte;\n      }\n\n      case s_headers_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        /* Exit, the rest of the connect is in a different protocol. */\n        if (parser->upgrade) {\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n          return (p - data) + 1;\n        }\n\n        if (parser->flags & F_SKIPBODY) {\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n        } else if (parser->flags & F_CHUNKED) {\n          /* chunked encoding - ignore Content-Length header */\n          parser->state = s_chunk_size_start;\n        } else {\n          if (parser->content_length == 0) {\n            /* Content-Length header given but zero: Content-Length: 0\\r\\n */\n            parser->state = NEW_MESSAGE();\n            CALLBACK_NOTIFY(message_complete);\n          } else if (parser->content_length != ULLONG_MAX) {\n            /* Content-Length header given and non-zero */\n            parser->state = s_body_identity;\n          } else {\n            if (parser->type == HTTP_REQUEST ||\n                !http_message_needs_eof(parser)) {\n              /* Assume content-length 0 - read the next */\n              parser->state = NEW_MESSAGE();\n              CALLBACK_NOTIFY(message_complete);\n            } else {\n              /* Read body until EOF */\n              parser->state = s_body_identity_eof;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case s_body_identity:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* The difference between advancing content_length and p is because\n         * the latter will automaticaly advance on the next loop iteration.\n         * Further, if content_length ends up at 0, we want to see the last\n         * byte again for our message complete callback.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          parser->state = s_message_done;\n\n          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.\n           *\n           * The alternative to doing this is to wait for the next byte to\n           * trigger the data callback, just as in every other case. The\n           * problem with this is that this makes it difficult for the test\n           * harness to distinguish between complete-on-EOF and\n           * complete-on-length. It's not clear that this distinction is\n           * important for applications, but let's keep it for now.\n           */\n          CALLBACK_DATA_(body, p - body_mark + 1, p - data);\n          goto reexecute_byte;\n        }\n\n        break;\n      }\n\n      /* read until EOF */\n      case s_body_identity_eof:\n        MARK(body);\n        p = data + len - 1;\n\n        break;\n\n      case s_message_done:\n        parser->state = NEW_MESSAGE();\n        CALLBACK_NOTIFY(message_complete);\n        break;\n\n      case s_chunk_size_start:\n      {\n        assert(parser->nread == 1);\n        assert(parser->flags & F_CHUNKED);\n\n        unhex_val = unhex[(unsigned char)ch];\n        if (unhex_val == -1) {\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        parser->content_length = unhex_val;\n        parser->state = s_chunk_size;\n        break;\n      }\n\n      case s_chunk_size:\n      {\n        uint64_t t;\n\n        assert(parser->flags & F_CHUNKED);\n\n        if (ch == CR) {\n          parser->state = s_chunk_size_almost_done;\n          break;\n        }\n\n        unhex_val = unhex[(unsigned char)ch];\n\n        if (unhex_val == -1) {\n          if (ch == ';' || ch == ' ') {\n            parser->state = s_chunk_parameters;\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        t = parser->content_length;\n        t *= 16;\n        t += unhex_val;\n\n        /* Overflow? Test against a conservative limit for simplicity. */\n        if ((ULLONG_MAX - 16) / 16 < parser->content_length) {\n          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n          goto error;\n        }\n\n        parser->content_length = t;\n        break;\n      }\n\n      case s_chunk_parameters:\n      {\n        assert(parser->flags & F_CHUNKED);\n        /* just ignore this shit. TODO check for overflow */\n        if (ch == CR) {\n          parser->state = s_chunk_size_almost_done;\n          break;\n        }\n        break;\n      }\n\n      case s_chunk_size_almost_done:\n      {\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        if (parser->content_length == 0) {\n          parser->flags |= F_TRAILING;\n          parser->state = s_header_field_start;\n        } else {\n          parser->state = s_chunk_data;\n        }\n        break;\n      }\n\n      case s_chunk_data:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* See the explanation in s_body_identity for why the content\n         * length and data pointers are managed this way.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          parser->state = s_chunk_data_almost_done;\n        }\n\n        break;\n      }\n\n      case s_chunk_data_almost_done:\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length == 0);\n        STRICT_CHECK(ch != CR);\n        parser->state = s_chunk_data_done;\n        CALLBACK_DATA(body);\n        break;\n\n      case s_chunk_data_done:\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n        parser->nread = 0;\n        parser->state = s_chunk_size_start;\n        break;\n\n      default:\n        assert(0 && \"unhandled state\");\n        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);\n        goto error;\n    }\n  }\n\n  /* Run callbacks for any marks that we have leftover after we ran our of\n   * bytes. There should be at most one of these set, so it's OK to invoke\n   * them in series (unset marks will not result in callbacks).\n   *\n   * We use the NOADVANCE() variety of callbacks here because 'p' has already\n   * overflowed 'data' and this allows us to correct for the off-by-one that\n   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'\n   * value that's in-bounds).\n   */\n\n  assert(((header_field_mark ? 1 : 0) +\n          (header_value_mark ? 1 : 0) +\n          (url_mark ? 1 : 0)  +\n          (body_mark ? 1 : 0) +\n          (status_mark ? 1 : 0)) <= 1);\n\n  CALLBACK_DATA_NOADVANCE(header_field);\n  CALLBACK_DATA_NOADVANCE(header_value);\n  CALLBACK_DATA_NOADVANCE(url);\n  CALLBACK_DATA_NOADVANCE(body);\n  CALLBACK_DATA_NOADVANCE(status);\n\n  return len;\n\nerror:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  return (p - data);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <stddef.h>",
            "#include <assert.h>",
            "#include \"http_parser.h\""
          ],
          "macros_used": [
            "#define LF                  '\\n'",
            "#define CR                  '\\r'",
            "#define CLOSE \"close\"",
            "#define KEEP_ALIVE \"keep-alive\"",
            "#define CHUNKED \"chunked\"",
            "#define UPGRADE \"upgrade\"",
            "#define TRANSFER_ENCODING \"transfer-encoding\"",
            "#define CONTENT_LENGTH \"content-length\"",
            "#define CONNECTION \"connection\"",
            "#define PROXY_CONNECTION \"proxy-connection\""
          ],
          "globals_used": [
            "static const char *method_strings[] =\n  {\n#define XX(num, name, string) #string,\n  HTTP_METHOD_MAP(XX)\n#undef XX\n  };",
            "static const int8_t unhex[256] =\n  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  };",
            "int http_message_needs_eof(const http_parser *parser);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stddef.h>\n#include <assert.h>\n#include \"http_parser.h\"\n\n#define LF                  '\\n'\n#define CR                  '\\r'\n#define CLOSE \"close\"\n#define KEEP_ALIVE \"keep-alive\"\n#define CHUNKED \"chunked\"\n#define UPGRADE \"upgrade\"\n#define TRANSFER_ENCODING \"transfer-encoding\"\n#define CONTENT_LENGTH \"content-length\"\n#define CONNECTION \"connection\"\n#define PROXY_CONNECTION \"proxy-connection\"\n\nstatic const char *method_strings[] =\n  {\n#define XX(num, name, string) #string,\n  HTTP_METHOD_MAP(XX)\n#undef XX\n  };\nstatic const int8_t unhex[256] =\n  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  };\nint http_message_needs_eof(const http_parser *parser);\n\nsize_t http_parser_execute (http_parser *parser,\n                            const http_parser_settings *settings,\n                            const char *data,\n                            size_t len)\n{\n  char c, ch;\n  int8_t unhex_val;\n  const char *p = data;\n  const char *header_field_mark = 0;\n  const char *header_value_mark = 0;\n  const char *url_mark = 0;\n  const char *body_mark = 0;\n  const char *status_mark = 0;\n\n  /* We're in an error state. Don't bother doing anything. */\n  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n    return 0;\n  }\n\n  if (len == 0) {\n    switch (parser->state) {\n      case s_body_identity_eof:\n        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if\n         * we got paused.\n         */\n        CALLBACK_NOTIFY_NOADVANCE(message_complete);\n        return 0;\n\n      case s_dead:\n      case s_start_req_or_res:\n      case s_start_res:\n      case s_start_req:\n        return 0;\n\n      default:\n        SET_ERRNO(HPE_INVALID_EOF_STATE);\n        return 1;\n    }\n  }\n\n\n  if (parser->state == s_header_field)\n    header_field_mark = data;\n  if (parser->state == s_header_value)\n    header_value_mark = data;\n  switch (parser->state) {\n  case s_req_path:\n  case s_req_schema:\n  case s_req_schema_slash:\n  case s_req_schema_slash_slash:\n  case s_req_server_start:\n  case s_req_server:\n  case s_req_server_with_at:\n  case s_req_query_string_start:\n  case s_req_query_string:\n  case s_req_fragment_start:\n  case s_req_fragment:\n    url_mark = data;\n    break;\n  case s_res_status:\n    status_mark = data;\n    break;\n  }\n\n  for (p=data; p != data + len; p++) {\n    ch = *p;\n\n    if (PARSING_HEADER(parser->state)) {\n      ++parser->nread;\n      /* Don't allow the total size of the HTTP headers (including the status\n       * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect\n       * embedders against denial-of-service attacks where the attacker feeds\n       * us a never-ending header that the embedder keeps buffering.\n       *\n       * This check is arguably the responsibility of embedders but we're doing\n       * it on the embedder's behalf because most won't bother and this way we\n       * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger\n       * than any reasonable request or response so this should never affect\n       * day-to-day operation.\n       */\n      if (parser->nread > HTTP_MAX_HEADER_SIZE) {\n        SET_ERRNO(HPE_HEADER_OVERFLOW);\n        goto error;\n      }\n    }\n\n    reexecute_byte:\n    switch (parser->state) {\n\n      case s_dead:\n        /* this state is used after a 'Connection: close' message\n         * the parser will error out if it reads another message\n         */\n        if (ch == CR || ch == LF)\n          break;\n\n        SET_ERRNO(HPE_CLOSED_CONNECTION);\n        goto error;\n\n      case s_start_req_or_res:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (ch == 'H') {\n          parser->state = s_res_or_resp_H;\n\n          CALLBACK_NOTIFY(message_begin);\n        } else {\n          parser->type = HTTP_REQUEST;\n          parser->state = s_start_req;\n          goto reexecute_byte;\n        }\n\n        break;\n      }\n\n      case s_res_or_resp_H:\n        if (ch == 'T') {\n          parser->type = HTTP_RESPONSE;\n          parser->state = s_res_HT;\n        } else {\n          if (ch != 'E') {\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n          }\n\n          parser->type = HTTP_REQUEST;\n          parser->method = HTTP_HEAD;\n          parser->index = 2;\n          parser->state = s_req_method;\n        }\n        break;\n\n      case s_start_res:\n      {\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        switch (ch) {\n          case 'H':\n            parser->state = s_res_H;\n            break;\n\n          case CR:\n          case LF:\n            break;\n\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n\n        CALLBACK_NOTIFY(message_begin);\n        break;\n      }\n\n      case s_res_H:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_res_HT;\n        break;\n\n      case s_res_HT:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_res_HTT;\n        break;\n\n      case s_res_HTT:\n        STRICT_CHECK(ch != 'P');\n        parser->state = s_res_HTTP;\n        break;\n\n      case s_res_HTTP:\n        STRICT_CHECK(ch != '/');\n        parser->state = s_res_first_http_major;\n        break;\n\n      case s_res_first_http_major:\n        if (ch < '0' || ch > '9') {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        parser->state = s_res_http_major;\n        break;\n\n      /* major HTTP version or dot */\n      case s_res_http_major:\n      {\n        if (ch == '.') {\n          parser->state = s_res_first_http_minor;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (parser->http_major > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_res_first_http_minor:\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        parser->state = s_res_http_minor;\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_res_http_minor:\n      {\n        if (ch == ' ') {\n          parser->state = s_res_first_status_code;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (parser->http_minor > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_first_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          if (ch == ' ') {\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n        parser->status_code = ch - '0';\n        parser->state = s_res_status_code;\n        break;\n      }\n\n      case s_res_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          switch (ch) {\n            case ' ':\n              parser->state = s_res_status_start;\n              break;\n            case CR:\n              parser->state = s_res_line_almost_done;\n              break;\n            case LF:\n              parser->state = s_header_field_start;\n              break;\n            default:\n              SET_ERRNO(HPE_INVALID_STATUS);\n              goto error;\n          }\n          break;\n        }\n\n        parser->status_code *= 10;\n        parser->status_code += ch - '0';\n\n        if (parser->status_code > 999) {\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_status_start:\n      {\n        if (ch == CR) {\n          parser->state = s_res_line_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          break;\n        }\n\n        MARK(status);\n        parser->state = s_res_status;\n        parser->index = 0;\n        break;\n      }\n\n      case s_res_status:\n        if (ch == CR) {\n          parser->state = s_res_line_almost_done;\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        break;\n\n      case s_res_line_almost_done:\n        STRICT_CHECK(ch != LF);\n        parser->state = s_header_field_start;\n        break;\n\n      case s_start_req:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (!IS_ALPHA(ch)) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        parser->method = (enum http_method) 0;\n        parser->index = 1;\n        switch (ch) {\n          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;\n          case 'D': parser->method = HTTP_DELETE; break;\n          case 'G': parser->method = HTTP_GET; break;\n          case 'H': parser->method = HTTP_HEAD; break;\n          case 'L': parser->method = HTTP_LOCK; break;\n          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH */ break;\n          case 'N': parser->method = HTTP_NOTIFY; break;\n          case 'O': parser->method = HTTP_OPTIONS; break;\n          case 'P': parser->method = HTTP_POST;\n            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */\n            break;\n          case 'R': parser->method = HTTP_REPORT; break;\n          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;\n          case 'T': parser->method = HTTP_TRACE; break;\n          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE */ break;\n          default:\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n        }\n        parser->state = s_req_method;\n\n        CALLBACK_NOTIFY(message_begin);\n\n        break;\n      }\n\n      case s_req_method:\n      {\n        const char *matcher;\n        if (ch == '\\0') {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        matcher = method_strings[parser->method];\n        if (ch == ' ' && matcher[parser->index] == '\\0') {\n          parser->state = s_req_spaces_before_url;\n        } else if (ch == matcher[parser->index]) {\n          ; /* nada */\n        } else if (parser->method == HTTP_CONNECT) {\n          if (parser->index == 1 && ch == 'H') {\n            parser->method = HTTP_CHECKOUT;\n          } else if (parser->index == 2  && ch == 'P') {\n            parser->method = HTTP_COPY;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->method == HTTP_MKCOL) {\n          if (parser->index == 1 && ch == 'O') {\n            parser->method = HTTP_MOVE;\n          } else if (parser->index == 1 && ch == 'E') {\n            parser->method = HTTP_MERGE;\n          } else if (parser->index == 1 && ch == '-') {\n            parser->method = HTTP_MSEARCH;\n          } else if (parser->index == 2 && ch == 'A') {\n            parser->method = HTTP_MKACTIVITY;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->method == HTTP_SUBSCRIBE) {\n          if (parser->index == 1 && ch == 'E') {\n            parser->method = HTTP_SEARCH;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 1 && parser->method == HTTP_POST) {\n          if (ch == 'R') {\n            parser->method = HTTP_PROPFIND; /* or HTTP_PROPPATCH */\n          } else if (ch == 'U') {\n            parser->method = HTTP_PUT; /* or HTTP_PURGE */\n          } else if (ch == 'A') {\n            parser->method = HTTP_PATCH;\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 2) {\n          if (parser->method == HTTP_PUT) {\n            if (ch == 'R') {\n              parser->method = HTTP_PURGE;\n            } else {\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n            }\n          } else if (parser->method == HTTP_UNLOCK) {\n            if (ch == 'S') {\n              parser->method = HTTP_UNSUBSCRIBE;\n            } else {\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n            }\n          } else {\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n          }\n        } else if (parser->index == 4 && parser->method == HTTP_PROPFIND && ch == 'P') {\n          parser->method = HTTP_PROPPATCH;\n        } else {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        ++parser->index;\n        break;\n      }\n\n      case s_req_spaces_before_url:\n      {\n        if (ch == ' ') break;\n\n        MARK(url);\n        if (parser->method == HTTP_CONNECT) {\n          parser->state = s_req_server_start;\n        }\n\n        parser->state = parse_url_char((enum state)parser->state, ch);\n        if (parser->state == s_dead) {\n          SET_ERRNO(HPE_INVALID_URL);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_req_schema:\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      {\n        switch (ch) {\n          /* No whitespace allowed here */\n          case ' ':\n          case CR:\n          case LF:\n            SET_ERRNO(HPE_INVALID_URL);\n            goto error;\n          default:\n            parser->state = parse_url_char((enum state)parser->state, ch);\n            if (parser->state == s_dead) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n\n        break;\n      }\n\n      case s_req_server:\n      case s_req_server_with_at:\n      case s_req_path:\n      case s_req_query_string_start:\n      case s_req_query_string:\n      case s_req_fragment_start:\n      case s_req_fragment:\n      {\n        switch (ch) {\n          case ' ':\n            parser->state = s_req_http_start;\n            CALLBACK_DATA(url);\n            break;\n          case CR:\n          case LF:\n            parser->http_major = 0;\n            parser->http_minor = 9;\n            parser->state = (ch == CR) ?\n              s_req_line_almost_done :\n              s_header_field_start;\n            CALLBACK_DATA(url);\n            break;\n          default:\n            parser->state = parse_url_char((enum state)parser->state, ch);\n            if (parser->state == s_dead) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n        break;\n      }\n\n      case s_req_http_start:\n        switch (ch) {\n          case 'H':\n            parser->state = s_req_http_H;\n            break;\n          case ' ':\n            break;\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n        break;\n\n      case s_req_http_H:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_req_http_HT;\n        break;\n\n      case s_req_http_HT:\n        STRICT_CHECK(ch != 'T');\n        parser->state = s_req_http_HTT;\n        break;\n\n      case s_req_http_HTT:\n        STRICT_CHECK(ch != 'P');\n        parser->state = s_req_http_HTTP;\n        break;\n\n      case s_req_http_HTTP:\n        STRICT_CHECK(ch != '/');\n        parser->state = s_req_first_http_major;\n        break;\n\n      /* first digit of major HTTP version */\n      case s_req_first_http_major:\n        if (ch < '1' || ch > '9') {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        parser->state = s_req_http_major;\n        break;\n\n      /* major HTTP version or dot */\n      case s_req_http_major:\n      {\n        if (ch == '.') {\n          parser->state = s_req_first_http_minor;\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (parser->http_major > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_req_first_http_minor:\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        parser->state = s_req_http_minor;\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_req_http_minor:\n      {\n        if (ch == CR) {\n          parser->state = s_req_line_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          break;\n        }\n\n        /* XXX allow spaces after digit? */\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (parser->http_minor > 999) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* end of request line */\n      case s_req_line_almost_done:\n      {\n        if (ch != LF) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        parser->state = s_header_field_start;\n        break;\n      }\n\n      case s_header_field_start:\n      {\n        if (ch == CR) {\n          parser->state = s_headers_almost_done;\n          break;\n        }\n\n        if (ch == LF) {\n          /* they might be just sending \\n instead of \\r\\n so this would be\n           * the second \\n to denote the end of headers*/\n          parser->state = s_headers_almost_done;\n          goto reexecute_byte;\n        }\n\n        c = TOKEN(ch);\n\n        if (!c) {\n          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n          goto error;\n        }\n\n        MARK(header_field);\n\n        parser->index = 0;\n        parser->state = s_header_field;\n\n        switch (c) {\n          case 'c':\n            parser->header_state = h_C;\n            break;\n\n          case 'p':\n            parser->header_state = h_matching_proxy_connection;\n            break;\n\n          case 't':\n            parser->header_state = h_matching_transfer_encoding;\n            break;\n\n          case 'u':\n            parser->header_state = h_matching_upgrade;\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_field:\n      {\n        c = TOKEN(ch);\n\n        if (c) {\n          switch (parser->header_state) {\n            case h_general:\n              break;\n\n            case h_C:\n              parser->index++;\n              parser->header_state = (c == 'o' ? h_CO : h_general);\n              break;\n\n            case h_CO:\n              parser->index++;\n              parser->header_state = (c == 'n' ? h_CON : h_general);\n              break;\n\n            case h_CON:\n              parser->index++;\n              switch (c) {\n                case 'n':\n                  parser->header_state = h_matching_connection;\n                  break;\n                case 't':\n                  parser->header_state = h_matching_content_length;\n                  break;\n                default:\n                  parser->header_state = h_general;\n                  break;\n              }\n              break;\n\n            /* connection */\n\n            case h_matching_connection:\n              parser->index++;\n              if (parser->index > sizeof(CONNECTION)-1\n                  || c != CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* proxy-connection */\n\n            case h_matching_proxy_connection:\n              parser->index++;\n              if (parser->index > sizeof(PROXY_CONNECTION)-1\n                  || c != PROXY_CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* content-length */\n\n            case h_matching_content_length:\n              parser->index++;\n              if (parser->index > sizeof(CONTENT_LENGTH)-1\n                  || c != CONTENT_LENGTH[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {\n                parser->header_state = h_content_length;\n              }\n              break;\n\n            /* transfer-encoding */\n\n            case h_matching_transfer_encoding:\n              parser->index++;\n              if (parser->index > sizeof(TRANSFER_ENCODING)-1\n                  || c != TRANSFER_ENCODING[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {\n                parser->header_state = h_transfer_encoding;\n              }\n              break;\n\n            /* upgrade */\n\n            case h_matching_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE)-1\n                  || c != UPGRADE[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                parser->header_state = h_upgrade;\n              }\n              break;\n\n            case h_connection:\n            case h_content_length:\n            case h_transfer_encoding:\n            case h_upgrade:\n              if (ch != ' ') parser->header_state = h_general;\n              break;\n\n            default:\n              assert(0 && \"Unknown header_state\");\n              break;\n          }\n          break;\n        }\n\n        if (ch == ':') {\n          parser->state = s_header_value_start;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        if (ch == CR) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n        goto error;\n      }\n\n      case s_header_value_start:\n      {\n        if (ch == ' ' || ch == '\\t') break;\n\n        MARK(header_value);\n\n        parser->state = s_header_value;\n        parser->index = 0;\n\n        if (ch == CR) {\n          parser->header_state = h_general;\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_field_start;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_upgrade:\n            parser->flags |= F_UPGRADE;\n            parser->header_state = h_general;\n            break;\n\n          case h_transfer_encoding:\n            /* looking for 'Transfer-Encoding: chunked' */\n            if ('c' == c) {\n              parser->header_state = h_matching_transfer_encoding_chunked;\n            } else {\n              parser->header_state = h_general;\n            }\n            break;\n\n          case h_content_length:\n            if (!IS_NUM(ch)) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->content_length = ch - '0';\n            break;\n\n          case h_connection:\n            /* looking for 'Connection: keep-alive' */\n            if (c == 'k') {\n              parser->header_state = h_matching_connection_keep_alive;\n            /* looking for 'Connection: close' */\n            } else if (c == 'c') {\n              parser->header_state = h_matching_connection_close;\n            } else {\n              parser->header_state = h_general;\n            }\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_value:\n      {\n\n        if (ch == CR) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA(header_value);\n          break;\n        }\n\n        if (ch == LF) {\n          parser->state = s_header_almost_done;\n          CALLBACK_DATA_NOADVANCE(header_value);\n          goto reexecute_byte;\n        }\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_general:\n            break;\n\n          case h_connection:\n          case h_transfer_encoding:\n            assert(0 && \"Shouldn't get here.\");\n            break;\n\n          case h_content_length:\n          {\n            uint64_t t;\n\n            if (ch == ' ') break;\n\n            if (!IS_NUM(ch)) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            t = parser->content_length;\n            t *= 10;\n            t += ch - '0';\n\n            /* Overflow? Test against a conservative limit for simplicity. */\n            if ((ULLONG_MAX - 10) / 10 < parser->content_length) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->content_length = t;\n            break;\n          }\n\n          /* Transfer-Encoding: chunked */\n          case h_matching_transfer_encoding_chunked:\n            parser->index++;\n            if (parser->index > sizeof(CHUNKED)-1\n                || c != CHUNKED[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(CHUNKED)-2) {\n              parser->header_state = h_transfer_encoding_chunked;\n            }\n            break;\n\n          /* looking for 'Connection: keep-alive' */\n          case h_matching_connection_keep_alive:\n            parser->index++;\n            if (parser->index > sizeof(KEEP_ALIVE)-1\n                || c != KEEP_ALIVE[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(KEEP_ALIVE)-2) {\n              parser->header_state = h_connection_keep_alive;\n            }\n            break;\n\n          /* looking for 'Connection: close' */\n          case h_matching_connection_close:\n            parser->index++;\n            if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {\n              parser->header_state = h_general;\n            } else if (parser->index == sizeof(CLOSE)-2) {\n              parser->header_state = h_connection_close;\n            }\n            break;\n\n          case h_transfer_encoding_chunked:\n          case h_connection_keep_alive:\n          case h_connection_close:\n            if (ch != ' ') parser->header_state = h_general;\n            break;\n\n          default:\n            parser->state = s_header_value;\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        parser->state = s_header_value_lws;\n\n        switch (parser->header_state) {\n          case h_connection_keep_alive:\n            parser->flags |= F_CONNECTION_KEEP_ALIVE;\n            break;\n          case h_connection_close:\n            parser->flags |= F_CONNECTION_CLOSE;\n            break;\n          case h_transfer_encoding_chunked:\n            parser->flags |= F_CHUNKED;\n            break;\n          default:\n            break;\n        }\n\n        break;\n      }\n\n      case s_header_value_lws:\n      {\n        if (ch == ' ' || ch == '\\t')\n          parser->state = s_header_value_start;\n        else\n        {\n          parser->state = s_header_field_start;\n          goto reexecute_byte;\n        }\n        break;\n      }\n\n      case s_headers_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        if (parser->flags & F_TRAILING) {\n          /* End of a chunked request */\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n          break;\n        }\n\n        parser->state = s_headers_done;\n\n        /* Set this here so that on_headers_complete() callbacks can see it */\n        parser->upgrade =\n          (parser->flags & F_UPGRADE || parser->method == HTTP_CONNECT);\n\n        /* Here we call the headers_complete callback. This is somewhat\n         * different than other callbacks because if the user returns 1, we\n         * will interpret that as saying that this message has no body. This\n         * is needed for the annoying case of recieving a response to a HEAD\n         * request.\n         *\n         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so\n         * we have to simulate it by handling a change in errno below.\n         */\n        if (settings->on_headers_complete) {\n          switch (settings->on_headers_complete(parser)) {\n            case 0:\n              break;\n\n            case 1:\n              parser->flags |= F_SKIPBODY;\n              break;\n\n            default:\n              SET_ERRNO(HPE_CB_headers_complete);\n              return p - data; /* Error */\n          }\n        }\n\n        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n          return p - data;\n        }\n\n        goto reexecute_byte;\n      }\n\n      case s_headers_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        /* Exit, the rest of the connect is in a different protocol. */\n        if (parser->upgrade) {\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n          return (p - data) + 1;\n        }\n\n        if (parser->flags & F_SKIPBODY) {\n          parser->state = NEW_MESSAGE();\n          CALLBACK_NOTIFY(message_complete);\n        } else if (parser->flags & F_CHUNKED) {\n          /* chunked encoding - ignore Content-Length header */\n          parser->state = s_chunk_size_start;\n        } else {\n          if (parser->content_length == 0) {\n            /* Content-Length header given but zero: Content-Length: 0\\r\\n */\n            parser->state = NEW_MESSAGE();\n            CALLBACK_NOTIFY(message_complete);\n          } else if (parser->content_length != ULLONG_MAX) {\n            /* Content-Length header given and non-zero */\n            parser->state = s_body_identity;\n          } else {\n            if (parser->type == HTTP_REQUEST ||\n                !http_message_needs_eof(parser)) {\n              /* Assume content-length 0 - read the next */\n              parser->state = NEW_MESSAGE();\n              CALLBACK_NOTIFY(message_complete);\n            } else {\n              /* Read body until EOF */\n              parser->state = s_body_identity_eof;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case s_body_identity:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* The difference between advancing content_length and p is because\n         * the latter will automaticaly advance on the next loop iteration.\n         * Further, if content_length ends up at 0, we want to see the last\n         * byte again for our message complete callback.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          parser->state = s_message_done;\n\n          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.\n           *\n           * The alternative to doing this is to wait for the next byte to\n           * trigger the data callback, just as in every other case. The\n           * problem with this is that this makes it difficult for the test\n           * harness to distinguish between complete-on-EOF and\n           * complete-on-length. It's not clear that this distinction is\n           * important for applications, but let's keep it for now.\n           */\n          CALLBACK_DATA_(body, p - body_mark + 1, p - data);\n          goto reexecute_byte;\n        }\n\n        break;\n      }\n\n      /* read until EOF */\n      case s_body_identity_eof:\n        MARK(body);\n        p = data + len - 1;\n\n        break;\n\n      case s_message_done:\n        parser->state = NEW_MESSAGE();\n        CALLBACK_NOTIFY(message_complete);\n        break;\n\n      case s_chunk_size_start:\n      {\n        assert(parser->nread == 1);\n        assert(parser->flags & F_CHUNKED);\n\n        unhex_val = unhex[(unsigned char)ch];\n        if (unhex_val == -1) {\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        parser->content_length = unhex_val;\n        parser->state = s_chunk_size;\n        break;\n      }\n\n      case s_chunk_size:\n      {\n        uint64_t t;\n\n        assert(parser->flags & F_CHUNKED);\n\n        if (ch == CR) {\n          parser->state = s_chunk_size_almost_done;\n          break;\n        }\n\n        unhex_val = unhex[(unsigned char)ch];\n\n        if (unhex_val == -1) {\n          if (ch == ';' || ch == ' ') {\n            parser->state = s_chunk_parameters;\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        t = parser->content_length;\n        t *= 16;\n        t += unhex_val;\n\n        /* Overflow? Test against a conservative limit for simplicity. */\n        if ((ULLONG_MAX - 16) / 16 < parser->content_length) {\n          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n          goto error;\n        }\n\n        parser->content_length = t;\n        break;\n      }\n\n      case s_chunk_parameters:\n      {\n        assert(parser->flags & F_CHUNKED);\n        /* just ignore this shit. TODO check for overflow */\n        if (ch == CR) {\n          parser->state = s_chunk_size_almost_done;\n          break;\n        }\n        break;\n      }\n\n      case s_chunk_size_almost_done:\n      {\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        if (parser->content_length == 0) {\n          parser->flags |= F_TRAILING;\n          parser->state = s_header_field_start;\n        } else {\n          parser->state = s_chunk_data;\n        }\n        break;\n      }\n\n      case s_chunk_data:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* See the explanation in s_body_identity for why the content\n         * length and data pointers are managed this way.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          parser->state = s_chunk_data_almost_done;\n        }\n\n        break;\n      }\n\n      case s_chunk_data_almost_done:\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length == 0);\n        STRICT_CHECK(ch != CR);\n        parser->state = s_chunk_data_done;\n        CALLBACK_DATA(body);\n        break;\n\n      case s_chunk_data_done:\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n        parser->nread = 0;\n        parser->state = s_chunk_size_start;\n        break;\n\n      default:\n        assert(0 && \"unhandled state\");\n        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);\n        goto error;\n    }\n  }\n\n  /* Run callbacks for any marks that we have leftover after we ran our of\n   * bytes. There should be at most one of these set, so it's OK to invoke\n   * them in series (unset marks will not result in callbacks).\n   *\n   * We use the NOADVANCE() variety of callbacks here because 'p' has already\n   * overflowed 'data' and this allows us to correct for the off-by-one that\n   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'\n   * value that's in-bounds).\n   */\n\n  assert(((header_field_mark ? 1 : 0) +\n          (header_value_mark ? 1 : 0) +\n          (url_mark ? 1 : 0)  +\n          (body_mark ? 1 : 0) +\n          (status_mark ? 1 : 0)) <= 1);\n\n  CALLBACK_DATA_NOADVANCE(header_field);\n  CALLBACK_DATA_NOADVANCE(header_value);\n  CALLBACK_DATA_NOADVANCE(url);\n  CALLBACK_DATA_NOADVANCE(body);\n  CALLBACK_DATA_NOADVANCE(status);\n\n  return len;\n\nerror:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  return (p - data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "buffer"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseInput->tryRead",
          "args": [
            "buffer",
            "1",
            "n"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "sizeof(buffer)",
            "nextWriteData.getReader().size() - nextWriteSize"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.getReader",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.getReader",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.add",
          "args": [
            "pumpStreamInternal().catch_([this](kj::Exception&& e) {\n      // Error while reading.\n\n      // Drop the response stream, so that Sandstorm knows no more data is coming.\n      responseStream = nullptr;\n    })"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpStreamInternal",
          "args": [
            "[this](kj::Exception&& e) {\n      // Error while reading.\n\n      // Drop the response stream, so that Sandstorm knows no more data is coming.\n      responseStream = nullptr;\n    }"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpStreamInternal",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startPumpStream",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nextWriteData.get().begin()",
            "initData.begin()",
            "initData.size()"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initData.begin",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.get",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.get",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "size"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "ByteStream::WriteParams::Builder(nextWrite)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteStream::WriteParams::Builder",
          "args": [
            "nextWrite"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseStream.writeRequest",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphan<capnp::Data>",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "size",
            "initData.size()"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[this]() { return pumpWrites(); }"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpWrites",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseStream.doneRequest",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseStream.doneRequest",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseStream.doneRequest",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphan<capnp::Data>",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateNextWrite",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWrite.send",
          "args": [
            "[this](auto&&) {\n        return pumpWrites();\n      }"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pumpWrites",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWrite.send",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWrite.adoptData",
          "args": [
            "kj::mv(nextWriteData)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "nextWriteData"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextWriteData.truncate",
          "args": [
            "nextWriteSize"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.set",
          "args": [
            "i",
            "extensions[i]"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "extensions"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initDavExtensions",
          "args": [
            "extensions.size()"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extensions.add",
          "args": [
            "kj::mv(trimmed)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "trimmed"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setDavClass3",
          "args": [
            "true"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setDavClass2",
          "args": [
            "true"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setDavClass1",
          "args": [
            "true"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"dav\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "!upgrade",
            "\"Sandboxed app attempted to upgrade protocol when client did not request this.\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list.init(i, trimmed.size()).begin()",
            "trimmed.begin()",
            "trimmed.size()"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trimmed.begin",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.init",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "98-118",
          "snippet": "kj::Promise<void> init() {\n    // Start watching the current directory.\n\n    // Note: this function is also called to restart watching from scratch when the inotify event\n    //   queue overflows (hopefully rare).\n\n    int fd;\n    KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n    inotifyFd = kj::AutoCloseFd(fd);\n\n    // Note that because we create the FdObserver before creating any watches, we don't have\n    // to worry about the possibility that we missed an event between creation of the fd and\n    // creation of the FdObserver.\n    observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n        kj::UnixEventPort::FdObserver::OBSERVE_READ);\n\n    totalSize = 0;\n    watchMap.clear();\n    pendingWatches.add(nullptr);  // root directory\n    return readLoop();\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> init() {\n      // Start watching the current directory.\n  \n      // Note: this function is also called to restart watching from scratch when the inotify event\n      //   queue overflows (hopefully rare).\n  \n      int fd;\n      KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      inotifyFd = kj::AutoCloseFd(fd);\n  \n      // Note that because we create the FdObserver before creating any watches, we don't have\n      // to worry about the possibility that we missed an event between creation of the fd and\n      // creation of the FdObserver.\n      observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n          kj::UnixEventPort::FdObserver::OBSERVE_READ);\n  \n      totalSize = 0;\n      watchMap.clear();\n      pendingWatches.add(nullptr);  // root directory\n      return readLoop();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list.init",
          "args": [
            "i",
            "trimmed.size()"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "parts"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initProtocol",
          "args": [
            "parts.size()"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"sec-websocket-protocol\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "status_code == 101",
            "\"Sandboxed app does not support WebSocket.\"",
            "(int)upgrade",
            "(int)status_code",
            "statusString"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "text.begin()",
            "body.begin()",
            "body.size()"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initServerError",
          "args": [
            "body.size()"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initServerError",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "text.begin()",
            "body.begin()",
            "body.size()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.initDescriptionHtml",
          "args": [
            "body.size()"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.setStatusCode",
          "args": [
            "statusInfo.clientErrorCode"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initClientError",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.setLocation",
          "args": [
            "KJ_ASSERT_NONNULL(findHeader(\"location\"),\n            \"Application returned redirect response missing Location header.\", (int)status_code)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "findHeader(\"location\")",
            "\"Application returned redirect response missing Location header.\"",
            "(int)status_code"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"location\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.setSwitchToGet",
          "args": [
            "statusInfo.redirect.switchToGet"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.setIsPermanent",
          "args": [
            "statusInfo.redirect.isPermanent"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRedirect",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseETag",
          "args": [
            "*etag",
            "preconditionFailed.initMatchingETag()"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "parseETag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "802-835",
          "snippet": "static void parseETag(kj::StringPtr input, WebSession::ETag::Builder builder) {\n    auto trimmed = trim(input);\n    input = trimmed;\n    if (input.startsWith(\"W/\")) {\n      input = input.slice(2);\n      builder.setWeak(true);\n    }\n\n    // Apps sometimes send invalid ETag data. Rather than crash, we log a warning, due to #2295.\n    if (! (input.endsWith(\"\\\"\") && input.size() > 1)) {\n      maybePrintInvalidEtagWarning(input);\n      return;\n    }\n\n    bool escaped = false;\n    kj::Vector<char> result(input.size() - 2);\n    for (char c: input.slice(1, input.size() - 1)) {\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (c == '\"') {\n          maybePrintInvalidEtagWarning(input);\n          return;\n        }\n        if (c == '\\\\') {\n          escaped = true;\n          continue;\n        }\n      }\n      result.add(c);\n    }\n\n    memcpy(builder.initValue(result.size()).begin(), result.begin(), result.size());\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic void parseETag(kj::StringPtr input, WebSession::ETag::Builder builder) {\n    auto trimmed = trim(input);\n    input = trimmed;\n    if (input.startsWith(\"W/\")) {\n      input = input.slice(2);\n      builder.setWeak(true);\n    }\n\n    // Apps sometimes send invalid ETag data. Rather than crash, we log a warning, due to #2295.\n    if (! (input.endsWith(\"\\\"\") && input.size() > 1)) {\n      maybePrintInvalidEtagWarning(input);\n      return;\n    }\n\n    bool escaped = false;\n    kj::Vector<char> result(input.size() - 2);\n    for (char c: input.slice(1, input.size() - 1)) {\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (c == '\"') {\n          maybePrintInvalidEtagWarning(input);\n          return;\n        }\n        if (c == '\\\\') {\n          escaped = true;\n          continue;\n        }\n      }\n      result.add(c);\n    }\n\n    memcpy(builder.initValue(result.size()).begin(), result.begin(), result.size());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "preconditionFailed.initMatchingETag",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"etag\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initPreconditionFailed",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noContent.initETag",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"etag\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noContent.setShouldResetForm",
          "args": [
            "statusInfo.noContent.shouldResetForm"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initNoContent",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data.begin()",
            "body.begin()",
            "body.size()"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [
            "body.size()"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [
            "handle"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initBody",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "body.size() == 0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getDisposition",
          "args": [
            "kj::str(filename)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "filename"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getDisposition",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getDisposition",
          "args": [
            "kj::StringPtr(unescaped.begin(), unescaped.size() - 1)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "unescaped.begin()",
            "unescaped.size() - 1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unescaped.begin",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getDisposition",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unescaped.add",
          "args": [
            "'\\0'"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unescaped.add",
          "args": [
            "filename[j]"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.slice",
          "args": [
            "1",
            "filename.size() - 1"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trimArray",
          "args": [
            "part.slice(i + 1, part.size())"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "trimArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "191-200",
          "snippet": "kj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}"
        }
      },
      {
        "call_info": {
          "callee": "part.slice",
          "args": [
            "i + 1",
            "part.size()"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part.slice",
          "args": [
            "0",
            "i"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "part"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [
            "1",
            "parts.size()"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"content-disposition\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.initETag",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"etag\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.setMimeType",
          "args": [
            "*mimeType"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"content-type\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.setLanguage",
          "args": [
            "*language"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"content-language\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.setEncoding",
          "args": [
            "*encoding"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"content-encoding\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.setStatusCode",
          "args": [
            "statusInfo.successCode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initContent",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "respHeader.setValue",
          "args": [
            "header->value"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "respHeader.setName",
          "args": [
            "header->name"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initAdditionalHeaders",
          "args": [
            "headersMatching.size()"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headersMatching.add",
          "args": [
            "&header.second"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RESPONSE_HEADER_WHITELIST.matches",
          "args": [
            "header.first"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "matches",
          "container": "HeaderWhitelist",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "842-869",
          "snippet": "bool HeaderWhitelist::matches(kj::StringPtr header) const {\n  // Convert to lower-case on stack.\n  KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n  memcpy(buffer.begin(), header.begin(), buffer.size());\n  toLower(buffer);\n  header = kj::StringPtr(buffer.begin(), header.size());\n\n  auto iter = patterns.lower_bound(header);\n  if (iter != patterns.end() && *iter == header) {\n    return true;\n  }\n\n  if (iter == patterns.begin()) return false;\n\n  // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n  // because the character '*' sorts before all characters that are valid inside headers.\n  --iter;\n  if (iter->endsWith(\"*\")) {\n    // Check if prefix matches.\n    auto prefix = iter->slice(0, iter->size() - 1);\n    if (header.size() >= prefix.size() &&\n        memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nHeaderWhitelist {\n  bool HeaderWhitelist::matches(kj::StringPtr header) const {\n    // Convert to lower-case on stack.\n    KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n    memcpy(buffer.begin(), header.begin(), buffer.size());\n    toLower(buffer);\n    header = kj::StringPtr(buffer.begin(), header.size());\n  \n    auto iter = patterns.lower_bound(header);\n    if (iter != patterns.end() && *iter == header) {\n      return true;\n    }\n  \n    if (iter == patterns.begin()) return false;\n  \n    // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n    // because the character '*' sorts before all characters that are valid inside headers.\n    --iter;\n    if (iter->endsWith(\"*\")) {\n      // Check if prefix matches.\n      auto prefix = iter->slice(0, iter->size() - 1);\n      if (header.size() >= prefix.size() &&\n          memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cookie.setHttpOnly",
          "args": [
            "cookies[i].httpOnly"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [
            "cookies[i].expires"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [
            "cookies[i].expires"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.getExpires",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.setPath",
          "args": [
            "cookies[i].path"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.setValue",
          "args": [
            "cookies[i].value"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie.setName",
          "args": [
            "cookies[i].name"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "cookies"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initSetCookies",
          "args": [
            "cookies.size()"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Application used unsupported HTTP status code.  Status codes must be whitelisted \"\n          \"because some have sandbox-breaking effects.\"",
            "(uint)status_code",
            "statusString"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HTTP_STATUS_CODES.end",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HTTP_STATUS_CODES.find",
          "args": [
            "status_code"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "!upgrade",
            "\"Sandboxed app attempted to upgrade protocol when client did not request this.\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startPumpStream",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.tryRead",
          "args": [
            "[this, &stream](size_t actual) mutable -> kj::Promise<kj::ArrayPtr<byte>> {\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual && !upgrade) {\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (upgrade) {\n        KJ_ASSERT(nread <= actual && nread >= 0);\n        return kj::arrayPtr(buffer + nread, actual - nread);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        KJ_ASSERT(headersComplete, \"HTTP response from sandboxed app had incomplete headers.\");\n        return kj::arrayPtr(buffer, 0);\n      } else if (headersComplete && status_code / 100 == 2) {\n        isStreaming = true;\n\n        KJ_IF_MAYBE(length, findHeader(\"content-length\")) {\n          auto req = responseStream.expectSizeRequest();\n          req.setSize(length->parseAs<uint64_t>());\n          taskSet.add(req.send().ignoreResult());\n        }\n\n        allocateNextWrite(body.asPtr().asBytes());\n        body = kj::Vector<char>();\n        taskSet.add(pumpWrites().catch_([this](kj::Exception&&) {\n          // Error while writing.\n\n          // Shut down input, so that the app knows it can stop generating it.\n          responseInput->abortRead();\n\n          // Drop the response stream, so that Sandstorm knows no more data is coming.\n          responseStream = nullptr;\n\n          // Mark aborted.\n          aborted = true;\n        }));\n        return kj::arrayPtr(buffer,0);\n      } else {\n        return readResponse(stream);\n      }\n    }"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readResponse",
          "args": [
            "stream"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.add",
          "args": [
            "pumpWrites().catch_([this](kj::Exception&&) {\n          // Error while writing.\n\n          // Shut down input, so that the app knows it can stop generating it.\n          responseInput->abortRead();\n\n          // Drop the response stream, so that Sandstorm knows no more data is coming.\n          responseStream = nullptr;\n\n          // Mark aborted.\n          aborted = true;\n        })"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpWrites",
          "args": [
            "[this](kj::Exception&&) {\n          // Error while writing.\n\n          // Shut down input, so that the app knows it can stop generating it.\n          responseInput->abortRead();\n\n          // Drop the response stream, so that Sandstorm knows no more data is coming.\n          responseStream = nullptr;\n\n          // Mark aborted.\n          aborted = true;\n        }"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseInput->abortRead",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pumpWrites",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Vector<char>",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateNextWrite",
          "args": [
            "body.asPtr().asBytes()"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.asPtr",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.asPtr",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.add",
          "args": [
            "req.send().ignoreResult()"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setSize",
          "args": [
            "length->parseAs<uint64_t>()"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "length->parseAs<uint64_t>",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseStream.expectSizeRequest",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findHeader",
          "args": [
            "\"content-length\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "0"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "headersComplete",
            "\"HTTP response from sandboxed app had incomplete headers.\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer + nread",
            "actual - nread"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "nread <= actual && nread >= 0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Failed to parse HTTP response from sandboxed app.\"",
            "error"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_errno_description",
          "args": [
            "HTTP_PARSER_ERRNO(this)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HTTP_PARSER_ERRNO",
          "args": [
            "this"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "buffer"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_parser_init",
          "args": [
            "this",
            "HTTP_RESPONSE"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "http_parser_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/joyent-http/http_parser.c++",
          "lines": "1950-1959",
          "snippet": "void\nhttp_parser_init (http_parser *parser, enum http_parser_type t)\n{\n  void *data = parser->data; /* preserve application data */\n  memset(parser, 0, sizeof(*parser));\n  parser->data = data;\n  parser->type = t;\n  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));\n  parser->http_errno = HPE_OK;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <stddef.h>",
            "#include <assert.h>",
            "#include \"http_parser.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int http_message_needs_eof(const http_parser *parser);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stddef.h>\n#include <assert.h>\n#include \"http_parser.h\"\n\nint http_message_needs_eof(const http_parser *parser);\n\nvoid\nhttp_parser_init (http_parser *parser, enum http_parser_type t)\n{\n  void *data = parser->data; /* preserve application data */\n  memset(parser, 0, sizeof(*parser));\n  parser->data = data;\n  parser->type = t;\n  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));\n  parser->http_errno = HPE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&settings",
            "0",
            "sizeof(settings)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nclass HttpParser: public sandstorm::Handle::Server,\n                  private http_parser,\n                  private kj::TaskSet::ErrorHandler {\npublic:\n  HttpParser(sandstorm::ByteStream::Client responseStream)\n    : responseStream(responseStream),\n      taskSet(*this) {\n    memset(&settings, 0, sizeof(settings));\n    settings.on_status = &on_status;\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_body = &on_body;\n    settings.on_headers_complete = &on_headers_complete;\n    settings.on_message_complete = &on_message_complete;\n    http_parser_init(this, HTTP_RESPONSE);\n  }\n\n  kj::Promise<kj::ArrayPtr<byte>> readResponse(kj::AsyncIoStream& stream) {\n    // Read from the stream until we have enough data to forward the response. If the response\n    // is streaming or an upgrade, then just read the headers; otherwise read the entire stream.\n    // If the response is an upgrade, return any remainder bytes that should be forwarded to the\n    // new web socket; otherwise return an empty array.\n\n    return stream.tryRead(buffer, 1, sizeof(buffer)).then(\n        [this, &stream](size_t actual) mutable -> kj::Promise<kj::ArrayPtr<byte>> {\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual && !upgrade) {\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (upgrade) {\n        KJ_ASSERT(nread <= actual && nread >= 0);\n        return kj::arrayPtr(buffer + nread, actual - nread);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        KJ_ASSERT(headersComplete, \"HTTP response from sandboxed app had incomplete headers.\");\n        return kj::arrayPtr(buffer, 0);\n      } else if (headersComplete && status_code / 100 == 2) {\n        isStreaming = true;\n\n        KJ_IF_MAYBE(length, findHeader(\"content-length\")) {\n          auto req = responseStream.expectSizeRequest();\n          req.setSize(length->parseAs<uint64_t>());\n          taskSet.add(req.send().ignoreResult());\n        }\n\n        allocateNextWrite(body.asPtr().asBytes());\n        body = kj::Vector<char>();\n        taskSet.add(pumpWrites().catch_([this](kj::Exception&&) {\n          // Error while writing.\n\n          // Shut down input, so that the app knows it can stop generating it.\n          responseInput->abortRead();\n\n          // Drop the response stream, so that Sandstorm knows no more data is coming.\n          responseStream = nullptr;\n\n          // Mark aborted.\n          aborted = true;\n        }));\n        return kj::arrayPtr(buffer,0);\n      } else {\n        return readResponse(stream);\n      }\n    });\n  }\n\n  void pumpStream(kj::Own<kj::AsyncIoStream>&& stream) {\n    if (isStreaming) {\n      responseInput = kj::mv(stream);\n      startPumpStream();\n    }\n  }\n\n  void build(WebSession::Response::Builder builder, sandstorm::Handle::Client handle) {\n    KJ_ASSERT(!upgrade,\n        \"Sandboxed app attempted to upgrade protocol when client did not request this.\");\n\n    auto iter = HTTP_STATUS_CODES.find(status_code);\n    HttpStatusInfo statusInfo;\n    if (iter != HTTP_STATUS_CODES.end()) {\n      statusInfo = iter->second;\n    } else if (status_code / 100 == 4) {\n      statusInfo.type = WebSession::Response::CLIENT_ERROR;\n      statusInfo.clientErrorCode = WebSession::Response::ClientErrorCode::BAD_REQUEST;\n    } else if (status_code / 100 == 5) {\n      statusInfo.type = WebSession::Response::SERVER_ERROR;\n    } else {\n      KJ_FAIL_REQUIRE(\n          \"Application used unsupported HTTP status code.  Status codes must be whitelisted \"\n          \"because some have sandbox-breaking effects.\", (uint)status_code, statusString);\n    }\n\n    auto cookieList = builder.initSetCookies(cookies.size());\n    for (size_t i: kj::indices(cookies)) {\n      auto cookie = cookieList[i];\n      cookie.setName(cookies[i].name);\n      cookie.setValue(cookies[i].value);\n      if (cookies[i].path != nullptr) {\n        cookie.setPath(cookies[i].path);\n      }\n      switch (cookies[i].expirationType) {\n        case Cookie::ExpirationType::NONE:\n          cookie.getExpires().setNone();\n          break;\n        case Cookie::ExpirationType::ABSOLUTE:\n          cookie.getExpires().setAbsolute(cookies[i].expires);\n          break;\n        case Cookie::ExpirationType::RELATIVE:\n          cookie.getExpires().setRelative(cookies[i].expires);\n          break;\n      }\n      cookie.setHttpOnly(cookies[i].httpOnly);\n    }\n\n    // Add whitelisted headers to additionalHeaders. With respect to security,\n    // the consumers of  WebSession::Response are responsible for making sure\n    // these headers are actually whitelisted. Since this bridge is included in\n    // the app package and runs in the grain itself, we cannot trust that the\n    // whitelist is correctly implemented here. An alternate implementation may\n    // not respect the whitelist. However, for the sake of building a Response\n    // that contains only valid headers, only whitelisted headers are added\n    // here.\n\n    // Add whitelisted headers, and headers matching the app prefix, to a\n    // temporary vector of headers. It is possible for a header name to appear\n    // more than once.\n    kj::Vector<Header*> headersMatching;\n    for (auto& header: headers) {\n      if (RESPONSE_HEADER_WHITELIST.matches(header.first)) {\n        headersMatching.add(&header.second);\n      }\n    }\n    // Initialize additionalHeaders once we know how many headers to include.\n    auto headerList = builder.initAdditionalHeaders(headersMatching.size());\n    // Add the headers matching the whitelist\n    int i = 0;\n    for (auto header: headersMatching) {\n      auto respHeader = headerList[i];\n      respHeader.setName(header->name);\n      respHeader.setValue(header->value);\n      i++;\n    }\n\n    switch (statusInfo.type) {\n      case WebSession::Response::CONTENT: {\n        auto content = builder.initContent();\n        content.setStatusCode(statusInfo.successCode);\n\n        KJ_IF_MAYBE(encoding, findHeader(\"content-encoding\")) {\n          content.setEncoding(*encoding);\n        }\n        KJ_IF_MAYBE(language, findHeader(\"content-language\")) {\n          content.setLanguage(*language);\n        }\n        KJ_IF_MAYBE(mimeType, findHeader(\"content-type\")) {\n          content.setMimeType(*mimeType);\n        }\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, content.initETag());\n        }\n        KJ_IF_MAYBE(disposition, findHeader(\"content-disposition\")) {\n          // Parse `attachment; filename=\"foo\"`\n          // TODO(cleanup):  This is awful.  Use KJ parser library?\n          auto parts = split(*disposition, ';');\n          if (parts.size() > 1 && trim(parts[0]) == \"attachment\") {\n            // Starst with \"attachment;\".  Parse params.\n            for (auto& part: parts.asPtr().slice(1, parts.size())) {\n              // Parse a \"name=value\" parameter.\n              for (size_t i: kj::indices(part)) {\n                if (part[i] == '=') {\n                  // Found '='.  Split and interpret.\n                  if (trim(part.slice(0, i)) == \"filename\") {\n                    // It's \"filename=\", the one we're looking for!\n                    // We need to unquote/unescape the file name.\n                    auto filename = trimArray(part.slice(i + 1, part.size()));\n\n                    if (filename.size() >= 2 && filename[0] == '\\\"' &&\n                        filename[filename.size() - 1] == '\\\"') {\n                      // OK, it is in fact surrounded in quotes.  Unescape the contents.  The\n                      // escaping scheme defined in RFC 822 is very simple:  a backslash followed\n                      // by any character C is interpreted as simply C.\n                      filename = filename.slice(1, filename.size() - 1);\n\n                      kj::Vector<char> unescaped(filename.size() + 1);\n                      for (size_t j = 0; j < filename.size(); j++) {\n                        if (filename[j] == '\\\\') {\n                          if (++j >= filename.size()) {\n                            break;\n                          }\n                        }\n                        unescaped.add(filename[j]);\n                      }\n                      unescaped.add('\\0');\n\n                      content.getDisposition().setDownload(\n                          kj::StringPtr(unescaped.begin(), unescaped.size() - 1));\n                    } else {\n                      // Buggy app failed to quote filename, but we'll try to deal.\n                      content.getDisposition().setDownload(kj::str(filename));\n                    }\n                  }\n                  break;  // Only split at first '='.\n                }\n              }\n            }\n          }\n        }\n\n        if (isStreaming) {\n          KJ_ASSERT(body.size() == 0);\n          content.initBody().setStream(handle);\n        } else {\n          auto data = content.initBody().initBytes(body.size());\n          memcpy(data.begin(), body.begin(), body.size());\n        }\n        break;\n      }\n      case WebSession::Response::NO_CONTENT: {\n        auto noContent = builder.initNoContent();\n        noContent.setShouldResetForm(statusInfo.noContent.shouldResetForm);\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, noContent.initETag());\n        }\n        break;\n      }\n      case WebSession::Response::PRECONDITION_FAILED: {\n        auto preconditionFailed = builder.initPreconditionFailed();\n        KJ_IF_MAYBE(etag, findHeader(\"etag\")) {\n          parseETag(*etag, preconditionFailed.initMatchingETag());\n        }\n        break;\n      }\n      case WebSession::Response::REDIRECT: {\n        auto redirect = builder.initRedirect();\n        redirect.setIsPermanent(statusInfo.redirect.isPermanent);\n        redirect.setSwitchToGet(statusInfo.redirect.switchToGet);\n        redirect.setLocation(KJ_ASSERT_NONNULL(findHeader(\"location\"),\n            \"Application returned redirect response missing Location header.\", (int)status_code));\n        break;\n      }\n      case WebSession::Response::CLIENT_ERROR: {\n        auto error = builder.initClientError();\n        error.setStatusCode(statusInfo.clientErrorCode);\n        auto text = error.initDescriptionHtml(body.size());\n        memcpy(text.begin(), body.begin(), body.size());\n        break;\n      }\n      case WebSession::Response::SERVER_ERROR: {\n        auto text = builder.initServerError().initDescriptionHtml(body.size());\n        memcpy(text.begin(), body.begin(), body.size());\n        break;\n      }\n    }\n  }\n\n  void buildForWebSocket(WebSession::OpenWebSocketResults::Builder builder) {\n    // TODO(soon):  If the app returned a normal response without upgrading, we should forward that\n    //   through, as it's perfectly valid HTTP.  The WebSession interface currently does not\n    //   support this.\n    KJ_ASSERT(status_code == 101, \"Sandboxed app does not support WebSocket.\",\n              (int)upgrade, (int)status_code, statusString);\n\n    KJ_IF_MAYBE(protocol, findHeader(\"sec-websocket-protocol\")) {\n      auto parts = split(*protocol, ',');\n      auto list = builder.initProtocol(parts.size());\n      for (auto i: kj::indices(parts)) {\n        auto trimmed = trim(parts[i]);\n        memcpy(list.init(i, trimmed.size()).begin(), trimmed.begin(), trimmed.size());\n      }\n    }\n\n    // TODO(soon):  Should we do more validation here, like checking the exact value of the Upgrade\n    //   header or Sec-WebSocket-Accept?\n  }\n\n  void buildOptions(WebSession::Options::Builder builder) {\n    KJ_ASSERT(!upgrade,\n        \"Sandboxed app attempted to upgrade protocol when client did not request this.\");\n\n    KJ_IF_MAYBE(dav, findHeader(\"dav\")) {\n      kj::Vector<kj::String> extensions;\n      for (auto level: split(*dav, ',')) {\n        auto trimmed = trim(level);\n        if (trimmed == \"1\") {\n          builder.setDavClass1(true);\n        } else if (trimmed == \"2\") {\n          builder.setDavClass2(true);\n        } else if (trimmed == \"3\") {\n          builder.setDavClass3(true);\n        } else {\n          extensions.add(kj::mv(trimmed));\n        }\n      }\n      if (extensions.size() > 0) {\n        auto list = builder.initDavExtensions(extensions.size());\n        for (auto i: kj::indices(extensions)) {\n          list.set(i, extensions[i]);\n        }\n      }\n    }\n  }\n\nprivate:\n  enum HeaderElementType { NONE, FIELD, VALUE };\n\n  struct RawHeader {\n    kj::Vector<char> name;\n    kj::Vector<char> value;\n  };\n\n  struct Header {\n    kj::String name;\n    kj::String value;\n  };\n\n  struct Cookie {\n    kj::String name;\n    kj::String value;\n    kj::String path;\n    int64_t expires;\n\n    enum ExpirationType {\n      NONE, RELATIVE, ABSOLUTE\n    };\n    ExpirationType expirationType = NONE;\n\n    bool httpOnly = false;\n  };\n\n  sandstorm::ByteStream::Client responseStream;\n  kj::TaskSet taskSet;\n  http_parser_settings settings;\n  kj::Vector<RawHeader> rawHeaders;\n  kj::Vector<char> rawStatusString;\n  HeaderElementType lastHeaderElement = NONE;\n  std::map<kj::StringPtr, Header> headers;\n  kj::Vector<char> body;\n  kj::Vector<Cookie> cookies;\n  kj::String statusString;\n  bool headersComplete = false;\n  bool messageComplete = false;\n  bool isStreaming = false;\n  bool streamDone = false;\n  bool readStalled = false;\n  bool aborted = false;\n\n  kj::Maybe<kj::Own<kj::PromiseFulfiller<void>>> writeReady;\n  capnp::Request<ByteStream::WriteParams, ByteStream::WriteResults> nextWrite = nullptr;\n  capnp::Orphan<capnp::Data> nextWriteData;\n  size_t nextWriteSize = 0;  // how many bytes are already in `nextWriteData`\n\n  kj::Own<kj::AsyncIoStream> responseInput;\n  byte buffer[8192];\n\n  kj::Promise<void> pumpWrites() {\n    if (nextWriteSize > 0) {\n      // Send the current write and allocate a new one.\n      nextWriteData.truncate(nextWriteSize);\n      nextWrite.adoptData(kj::mv(nextWriteData));\n\n      auto result = nextWrite.send().then([this](auto&&) {\n        return pumpWrites();\n      });\n\n      allocateNextWrite();\n\n      return result;\n    } else if (streamDone) {\n      // No more bytes coming.\n      nextWriteData = capnp::Orphan<capnp::Data>();\n      nextWrite = nullptr;\n      auto promise = responseStream.doneRequest().send().ignoreResult();\n      responseStream = nullptr;\n      return kj::mv(promise);\n    } else {\n      // No bytes received yet. Wait.\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      writeReady = kj::mv(paf.fulfiller);\n      return paf.promise.then([this]() { return pumpWrites(); });\n    }\n  }\n\n  void allocateNextWrite(kj::ArrayPtr<const byte> initData = nullptr) {\n    // For each write we start out allocating twice as much space as we actually managed to fill\n    // on the previous write, though we cap this at 128k.\n    size_t size = nextWriteSize * 2;\n    if (size < sizeof(buffer)) {\n      size = sizeof(buffer);\n    } else if (size > (128u << 10)) {\n      size = (128u << 10);\n    }\n\n    size = kj::max(size, initData.size());\n\n    nextWriteData = capnp::Orphan<capnp::Data>();\n    nextWrite = responseStream.writeRequest();\n    nextWriteData = capnp::Orphanage::getForMessageContaining(\n        ByteStream::WriteParams::Builder(nextWrite))\n        .newOrphan<capnp::Data>(size);\n\n    nextWriteSize = initData.size();\n    if (initData.size() > 0) {\n      memcpy(nextWriteData.get().begin(), initData.begin(), initData.size());\n    }\n\n    if (readStalled) {\n      // Start reading again.\n      readStalled = false;\n      startPumpStream();\n    }\n  }\n\n  void startPumpStream() {\n    taskSet.add(pumpStreamInternal().catch_([this](kj::Exception&& e) {\n      // Error while reading.\n\n      // Drop the response stream, so that Sandstorm knows no more data is coming.\n      responseStream = nullptr;\n    }));\n  }\n\n  kj::Promise<void> pumpStreamInternal() {\n    // Read HTTP response data coming out of the app.\n\n    if (aborted) {\n      // Output failed; give up.\n      return kj::READY_NOW;\n    }\n\n    // Make sure not to read more bytes than would fit in our output buffer.\n    size_t n = kj::min(sizeof(buffer), nextWriteData.getReader().size() - nextWriteSize);\n\n    if (n == 0) {\n      // We're out of space. Wait.\n      readStalled = true;\n      return kj::READY_NOW;\n    }\n\n    return responseInput->tryRead(buffer, 1, n)\n        .then([this](size_t actual) -> kj::Promise<void> {\n      if (aborted) {\n        // Output failed; give up.\n        return kj::READY_NOW;\n      }\n\n      size_t nread = http_parser_execute(this, &settings, reinterpret_cast<char*>(buffer), actual);\n      if (nread != actual) {\n        // The parser failed.\n        const char* error = http_errno_description(HTTP_PARSER_ERRNO(this));\n        KJ_FAIL_ASSERT(\"Failed to parse HTTP response from sandboxed app.\", error);\n      } else if (messageComplete || actual == 0) {\n        // The parser is done or the stream has closed.\n        streamDone = true;\n        KJ_IF_MAYBE(w, writeReady) {\n          w->get()->fulfill();\n          writeReady = nullptr;\n        }\n        return kj::READY_NOW;\n      } else {\n        return pumpStreamInternal();\n      }\n    });\n  }\n\n  void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }\n\n  kj::Maybe<kj::StringPtr> findHeader(kj::StringPtr name) {\n    auto iter = headers.find(name);\n    if (iter == headers.end()) {\n      return nullptr;\n    } else {\n      return kj::StringPtr(iter->second.value);\n    }\n  }\n\n  void onStatus(kj::ArrayPtr<const char> status) {\n    rawStatusString.addAll(status);\n  }\n\n  void onHeaderField(kj::ArrayPtr<const char> name) {\n    if (lastHeaderElement != FIELD) {\n      rawHeaders.resize(rawHeaders.size() + 1);\n    }\n    rawHeaders[rawHeaders.size() - 1].name.addAll(name);\n    lastHeaderElement = FIELD;\n  }\n\n  void onHeaderValue(kj::ArrayPtr<const char> value) {\n    rawHeaders[rawHeaders.size() - 1].value.addAll(value);\n    lastHeaderElement = VALUE;\n  }\n\n  void addHeader(RawHeader &rawHeader) {\n    auto name = kj::heapString(rawHeader.name);\n    toLower(name);\n    kj::ArrayPtr<const char> value = rawHeader.value.asPtr();\n\n    if (name == \"set-cookie\") {\n      // Really ugly cookie-parsing code.\n      // TODO(cleanup):  Clean up.\n      bool isFirst = true;\n      Cookie cookie;\n      for (auto part: split(value, ';')) {\n        if (isFirst) {\n          isFirst = false;\n          cookie.name = trim(KJ_ASSERT_NONNULL(splitFirst(part, '='),\n              \"Invalid cookie header from app.\", value));\n          cookie.value = trim(part);\n        } else KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n          auto prop = trim(*name);\n          toLower(prop);\n          if (prop == \"expires\") {\n            auto value = trim(part);\n            // Wed, 15 Nov 1995 06:25:24 GMT\n            struct tm t;\n            memset(&t, 0, sizeof(t));\n\n            // There are three allowed formats for HTTP dates.  Ugh.\n            char* end = strptime(value.cStr(), \"%a, %d %b %Y %T GMT\", &t);\n            if (end == nullptr) {\n              end = strptime(value.cStr(), \"%a, %d-%b-%y %T GMT\", &t);\n              if (end == nullptr) {\n                end = strptime(value.cStr(), \"%a %b %d %T %Y\", &t);\n                if (end == nullptr) {\n                  // Not valid per HTTP spec, but MediaWiki seems to return this format sometimes.\n                  end = strptime(value.cStr(), \"%a, %d-%b-%Y %T GMT\", &t);\n                  if (end == nullptr) {\n                    // Not valid per HTTP spec, but used by Rack.\n                    end = strptime(value.cStr(), \"%a, %d %b %Y %T -0000\", &t);\n                  }\n                }\n              }\n            }\n            KJ_ASSERT(end != nullptr && *end == '\\0', \"Invalid HTTP date from app.\", value);\n            cookie.expires = timegm(&t);\n            cookie.expirationType = Cookie::ExpirationType::ABSOLUTE;\n          } else if (prop == \"max-age\") {\n            auto value = trim(part);\n            char* end;\n            cookie.expires = strtoull(value.cStr(), &end, 10);\n            KJ_ASSERT(end > value.begin() && *end == '\\0', \"Invalid cookie max-age app.\", value);\n            cookie.expirationType = Cookie::ExpirationType::RELATIVE;\n          } else if (prop == \"path\") {\n            cookie.path = trim(part);\n          } else {\n            // Ignore other properties:\n            //   Path:  Not useful on the modern same-origin-policy web.\n            //   Domain:  We do not allow the app to publish cookies visible to other hosts in the\n            //     domain.\n          }\n        } else {\n          auto prop = trim(part);\n          toLower(prop);\n          if (prop == \"httponly\") {\n            cookie.httpOnly = true;\n          } else {\n            // Ignore other properties:\n            //   Secure:  We always set this, since we always require https.\n          }\n        }\n      }\n\n      cookies.add(kj::mv(cookie));\n\n    } else {\n      auto& slot = headers[name];\n      if (slot.name != nullptr) {\n        // Multiple instances of the same header are equivalent to comma-delimited.\n        slot.value = kj::str(kj::mv(slot.value), \", \", value);\n      } else {\n        slot = Header { kj::mv(name), kj::heapString(value) };\n      }\n    }\n  }\n\n\n  void onBody(kj::ArrayPtr<const char> data) {\n    if (isStreaming) {\n      // Copy into the buffer we're working on.\n      kj::ArrayPtr<byte> buffer = nextWriteData.get();\n      buffer = buffer.slice(nextWriteSize, buffer.size());\n      KJ_ASSERT(data.size() <= buffer.size(), data.size(), buffer.size(), nextWriteSize);\n      memcpy(buffer.begin(), data.begin(), data.size());\n      nextWriteSize += data.size();\n\n      // Indicate data is ready. (Most of these fulfill() calls will be no-ops if no one is\n      // waiting.)\n      KJ_IF_MAYBE(w, writeReady) {\n        w->get()->fulfill();\n        writeReady = nullptr;\n      }\n    } else {\n      body.addAll(data);\n    }\n  }"
  },
  {
    "function_name": "makeStatusCodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "118-148",
    "snippet": "std::unordered_map<uint, HttpStatusInfo> makeStatusCodes() {\n  std::unordered_map<uint, HttpStatusInfo> result;\n  for (capnp::EnumSchema::Enumerant enumerant:\n       capnp::Schema::from<WebSession::Response::SuccessCode>().getEnumerants()) {\n    auto& info = result[getHttpStatusAnnotation(enumerant).getId()];\n    info.type = WebSession::Response::CONTENT;\n    info.successCode = static_cast<WebSession::Response::SuccessCode>(enumerant.getOrdinal());\n  }\n  for (capnp::EnumSchema::Enumerant enumerant:\n       capnp::Schema::from<WebSession::Response::ClientErrorCode>().getEnumerants()) {\n    auto& info = result[getHttpStatusAnnotation(enumerant).getId()];\n    info.type = WebSession::Response::CLIENT_ERROR;\n    info.clientErrorCode =\n        static_cast<WebSession::Response::ClientErrorCode>(enumerant.getOrdinal());\n  }\n\n  result[204] = noContentInfo(false);\n  result[205] = noContentInfo(true);\n\n  result[304] = preconditionFailedInfo();\n\n  result[301] = redirectInfo(true, true);\n  result[302] = redirectInfo(false, true);\n  result[303] = redirectInfo(false, true);\n  result[307] = redirectInfo(false, false);\n  result[308] = redirectInfo(true, false);\n\n  result[412] = preconditionFailedInfo();\n\n  return result;\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preconditionFailedInfo",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "preconditionFailedInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "102-106",
          "snippet": "HttpStatusInfo preconditionFailedInfo() {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::PRECONDITION_FAILED;\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo preconditionFailedInfo() {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::PRECONDITION_FAILED;\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirectInfo",
          "args": [
            "true",
            "false"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "redirectInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "94-100",
          "snippet": "HttpStatusInfo redirectInfo(bool isPermanent, bool switchToGet) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::REDIRECT;\n  result.redirect.isPermanent = isPermanent;\n  result.redirect.switchToGet = switchToGet;\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo redirectInfo(bool isPermanent, bool switchToGet) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::REDIRECT;\n  result.redirect.isPermanent = isPermanent;\n  result.redirect.switchToGet = switchToGet;\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "noContentInfo",
          "args": [
            "true"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "noContentInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "87-92",
          "snippet": "HttpStatusInfo noContentInfo(bool shouldResetForm) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::NO_CONTENT;\n  result.noContent.shouldResetForm = shouldResetForm;\n  return result;\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo noContentInfo(bool shouldResetForm) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::NO_CONTENT;\n  result.noContent.shouldResetForm = shouldResetForm;\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<WebSession::Response::ClientErrorCode>",
          "args": [
            "enumerant.getOrdinal()"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getOrdinal",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getHttpStatusAnnotation",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getHttpStatusAnnotation",
          "args": [
            "enumerant"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "getHttpStatusAnnotation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "108-116",
          "snippet": "HttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}"
        }
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::ClientErrorCode>",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::ClientErrorCode>",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<WebSession::Response::SuccessCode>",
          "args": [
            "enumerant.getOrdinal()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getOrdinal",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getHttpStatusAnnotation",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::SuccessCode>",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::SuccessCode>",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstd::unordered_map<uint, HttpStatusInfo> makeStatusCodes() {\n  std::unordered_map<uint, HttpStatusInfo> result;\n  for (capnp::EnumSchema::Enumerant enumerant:\n       capnp::Schema::from<WebSession::Response::SuccessCode>().getEnumerants()) {\n    auto& info = result[getHttpStatusAnnotation(enumerant).getId()];\n    info.type = WebSession::Response::CONTENT;\n    info.successCode = static_cast<WebSession::Response::SuccessCode>(enumerant.getOrdinal());\n  }\n  for (capnp::EnumSchema::Enumerant enumerant:\n       capnp::Schema::from<WebSession::Response::ClientErrorCode>().getEnumerants()) {\n    auto& info = result[getHttpStatusAnnotation(enumerant).getId()];\n    info.type = WebSession::Response::CLIENT_ERROR;\n    info.clientErrorCode =\n        static_cast<WebSession::Response::ClientErrorCode>(enumerant.getOrdinal());\n  }\n\n  result[204] = noContentInfo(false);\n  result[205] = noContentInfo(true);\n\n  result[304] = preconditionFailedInfo();\n\n  result[301] = redirectInfo(true, true);\n  result[302] = redirectInfo(false, true);\n  result[303] = redirectInfo(false, true);\n  result[307] = redirectInfo(false, false);\n  result[308] = redirectInfo(true, false);\n\n  result[412] = preconditionFailedInfo();\n\n  return result;\n}"
  },
  {
    "function_name": "getHttpStatusAnnotation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "108-116",
    "snippet": "HttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Missing httpStatus annotation on status code enumerant.\"",
            "enumerant.getProto().getName()"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getId",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}"
  },
  {
    "function_name": "preconditionFailedInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "102-106",
    "snippet": "HttpStatusInfo preconditionFailedInfo() {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::PRECONDITION_FAILED;\n  return result;\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo preconditionFailedInfo() {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::PRECONDITION_FAILED;\n  return result;\n}"
  },
  {
    "function_name": "redirectInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "94-100",
    "snippet": "HttpStatusInfo redirectInfo(bool isPermanent, bool switchToGet) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::REDIRECT;\n  result.redirect.isPermanent = isPermanent;\n  result.redirect.switchToGet = switchToGet;\n  return result;\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo redirectInfo(bool isPermanent, bool switchToGet) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::REDIRECT;\n  result.redirect.isPermanent = isPermanent;\n  result.redirect.switchToGet = switchToGet;\n  return result;\n}"
  },
  {
    "function_name": "noContentInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "87-92",
    "snippet": "HttpStatusInfo noContentInfo(bool shouldResetForm) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::NO_CONTENT;\n  result.noContent.shouldResetForm = shouldResetForm;\n  return result;\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nHttpStatusInfo noContentInfo(bool shouldResetForm) {\n  HttpStatusInfo result;\n  result.type = WebSession::Response::NO_CONTENT;\n  result.noContent.shouldResetForm = shouldResetForm;\n  return result;\n}"
  },
  {
    "function_name": "textIdentityId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "70-74",
    "snippet": "kj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hexEncode",
          "args": [
            "id.slice(0, kj::min(id.size(), 16))"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "hexEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "784-787",
          "snippet": "kj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "id.slice",
          "args": [
            "0",
            "kj::min(id.size(), 16)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "id.size()",
            "16"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id.size",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "id.size() == 32",
            "\"Identity ID not a SHA-256?\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::String textIdentityId(capnp::Data::Reader id) {\n  // We truncate to 128 bits to be a little more wieldy. Still 32 chars, though.\n  KJ_ASSERT(id.size() == 32, \"Identity ID not a SHA-256?\");\n  return hexEncode(id.slice(0, kj::min(id.size(), 16)));\n}"
  },
  {
    "function_name": "toBytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
    "lines": "63-68",
    "snippet": "kj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}",
    "includes": [
      "#include \"bridge-proxy.h\"",
      "#include \"util.h\"",
      "#include \"version.h\"",
      "#include <joyent-http/http_parser.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
      "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
      "#include <sandstorm/email.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <sandstorm/util.capnp.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/schema.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result.begin() + text.size()",
            "data.begin()",
            "data.size()"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result.begin()",
            "text.begin()",
            "text.size()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<byte>",
          "args": [
            "text.size() + data.size()"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nkj::Array<byte> toBytes(kj::StringPtr text, kj::ArrayPtr<const byte> data = nullptr) {\n  auto result = kj::heapArray<byte>(text.size() + data.size());\n  memcpy(result.begin(), text.begin(), text.size());\n  memcpy(result.begin() + text.size(), data.begin(), data.size());\n  return result;\n}"
  }
]