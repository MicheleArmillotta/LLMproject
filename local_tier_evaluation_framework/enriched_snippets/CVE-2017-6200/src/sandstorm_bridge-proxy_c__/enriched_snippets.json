[
  {
    "function_name": "newBridgeProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "763-769",
    "snippet": "kj::Own<kj::HttpService> newBridgeProxy(\n    SandstormApi<BridgeObjectId>::Client sandstormApi,\n    SandstormHttpBridge::Client bridge,\n    spk::BridgeConfig::Reader config,\n    kj::HttpHeaderTable::Builder& requestHeaders) {\n  return kj::heap<BridgeProxy>(kj::mv(sandstormApi), kj::mv(bridge), config, requestHeaders);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<BridgeProxy>",
          "args": [
            "kj::mv(sandstormApi)",
            "kj::mv(bridge)",
            "config",
            "requestHeaders"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bridge"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sandstormApi"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Own<kj::HttpService> newBridgeProxy(\n    SandstormApi<BridgeObjectId>::Client sandstormApi,\n    SandstormHttpBridge::Client bridge,\n    spk::BridgeConfig::Reader config,\n    kj::HttpHeaderTable::Builder& requestHeaders) {\n  return kj::heap<BridgeProxy>(kj::mv(sandstormApi), kj::mv(bridge), config, requestHeaders);\n}"
  },
  {
    "function_name": "expectSize",
    "container": "ByteStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "724-727",
    "snippet": "kj::Promise<void> expectSize(ExpectSizeContext context) override {\n      ensureStarted(context.getParams().getSize());\n      return kj::READY_NOW;\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ensureStarted",
          "args": [
            "context.getParams().getSize()"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> expectSize(ExpectSizeContext context) override {\n        ensureStarted(context.getParams().getSize());\n        return kj::READY_NOW;\n      }\n}"
  },
  {
    "function_name": "done",
    "container": "ByteStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "718-722",
    "snippet": "kj::Promise<void> done(DoneContext context) override {\n      state.init<Done>();\n      doneFulfiller->fulfill();\n      return kj::READY_NOW;\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "doneFulfiller->fulfill",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.init<Done>",
          "args": [],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "98-118",
          "snippet": "kj::Promise<void> init() {\n    // Start watching the current directory.\n\n    // Note: this function is also called to restart watching from scratch when the inotify event\n    //   queue overflows (hopefully rare).\n\n    int fd;\n    KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n    inotifyFd = kj::AutoCloseFd(fd);\n\n    // Note that because we create the FdObserver before creating any watches, we don't have\n    // to worry about the possibility that we missed an event between creation of the fd and\n    // creation of the FdObserver.\n    observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n        kj::UnixEventPort::FdObserver::OBSERVE_READ);\n\n    totalSize = 0;\n    watchMap.clear();\n    pendingWatches.add(nullptr);  // root directory\n    return readLoop();\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> init() {\n      // Start watching the current directory.\n  \n      // Note: this function is also called to restart watching from scratch when the inotify event\n      //   queue overflows (hopefully rare).\n  \n      int fd;\n      KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      inotifyFd = kj::AutoCloseFd(fd);\n  \n      // Note that because we create the FdObserver before creating any watches, we don't have\n      // to worry about the possibility that we missed an event between creation of the fd and\n      // creation of the FdObserver.\n      observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n          kj::UnixEventPort::FdObserver::OBSERVE_READ);\n  \n      totalSize = 0;\n      watchMap.clear();\n      pendingWatches.add(nullptr);  // root directory\n      return readLoop();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> done(DoneContext context) override {\n        state.init<Done>();\n        doneFulfiller->fulfill();\n        return kj::READY_NOW;\n      }\n}"
  },
  {
    "function_name": "write",
    "container": "ByteStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "712-716",
    "snippet": "kj::Promise<void> write(WriteContext context) override {\n      auto& stream = ensureStarted(nullptr);\n      auto data = context.getParams().getData();\n      return stream.write(data.begin(), data.size());\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stream.write",
          "args": [
            "data.begin()",
            "data.size()"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureStarted",
          "args": [
            "nullptr"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> write(WriteContext context) override {\n        auto& stream = ensureStarted(nullptr);\n        auto data = context.getParams().getData();\n        return stream.write(data.begin(), data.size());\n      }\n}"
  },
  {
    "function_name": "whenDone",
    "container": "ByteStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "706-710",
    "snippet": "kj::Promise<void> whenDone() {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      doneFulfiller = kj::mv(paf.fulfiller);\n      return kj::mv(paf.promise);\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> whenDone() {\n        auto paf = kj::newPromiseAndFulfiller<void>();\n        doneFulfiller = kj::mv(paf.fulfiller);\n        return kj::mv(paf.promise);\n      }\n}"
  },
  {
    "function_name": "ByteStreamImpl",
    "container": "ByteStreamImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "699-704",
    "snippet": "ByteStreamImpl(HttpStatusDescriptor::Reader status,\n                   kj::HttpHeaders&& headers,\n                   capnp::Response<WebSession::Response>&& inResponse,\n                   kj::HttpService::Response& response) {\n      state.init<NotStarted>(NotStarted { status, kj::mv(headers), kj::mv(inResponse), response });\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.init<NotStarted>",
          "args": [
            "NotStarted { status, kj::mv(headers), kj::mv(inResponse), response }"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inResponse"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "headers"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  ByteStreamImpl(HttpStatusDescriptor::Reader status,\n                     kj::HttpHeaders&& headers,\n                     capnp::Response<WebSession::Response>&& inResponse,\n                     kj::HttpService::Response& response) {\n        state.init<NotStarted>(NotStarted { status, kj::mv(headers), kj::mv(inResponse), response });\n      }\n}"
  },
  {
    "function_name": "escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "679-695",
    "snippet": "kj::String escape(kj::StringPtr value) {\n    kj::Vector<char> chars(value.size());\n\n    for (char c: value) {\n      switch (c) {\n        case '\\\\':\n        case '\\\"':\n          chars.add('\\\\');\n          break;\n        default:\n          break;\n      }\n      chars.add(c);\n    }\n\n    return kj::String(chars.releaseAsArray());\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "chars.releaseAsArray()"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.releaseAsArray",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "c"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "'\\\\'"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::String escape(kj::StringPtr value) {\n    kj::Vector<char> chars(value.size());\n\n    for (char c: value) {\n      switch (c) {\n        case '\\\\':\n        case '\\\"':\n          chars.add('\\\\');\n          break;\n        default:\n          break;\n      }\n      chars.add(c);\n    }\n\n    return kj::String(chars.releaseAsArray());\n  }"
  },
  {
    "function_name": "setETag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "671-677",
    "snippet": "void setETag(kj::HttpHeaders& headers, WebSession::ETag::Reader etag) {\n    if (etag.getWeak()) {\n      headers.set(hETag, kj::str(\"W/\\\"\", etag.getValue(), \"\\\"\"));\n    } else {\n      headers.set(hETag, kj::str(\"\\\"\", etag.getValue(), \"\\\"\"));\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hETag",
            "kj::str(\"\\\"\", etag.getValue(), \"\\\"\")"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\\\"\"",
            "etag.getValue()",
            "\"\\\"\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etag.getValue",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hETag",
            "kj::str(\"W/\\\"\", etag.getValue(), \"\\\"\")"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"W/\\\"\"",
            "etag.getValue()",
            "\"\\\"\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etag.getValue",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etag.getWeak",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nvoid setETag(kj::HttpHeaders& headers, WebSession::ETag::Reader etag) {\n    if (etag.getWeak()) {\n      headers.set(hETag, kj::str(\"W/\\\"\", etag.getValue(), \"\\\"\"));\n    } else {\n      headers.set(hETag, kj::str(\"\\\"\", etag.getValue(), \"\\\"\"));\n    }\n  }"
  },
  {
    "function_name": "handleResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "518-669",
    "snippet": "kj::Promise<void> handleResponse(kj::Promise<capnp::Response<WebSession::Response>>&& promise,\n                                   kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n                                   kj::HttpService::Response& out) {\n    return promise.then([this,KJ_MVCAP(streamer),&out](\n        capnp::Response<WebSession::Response>&& in) mutable -> kj::Promise<void> {\n      // TODO(someday): cachePolicy (not supported in Sandstorm proper as of this writing)\n\n      kj::HttpHeaders headers(headerTable);\n\n      for (auto addlHeader: in.getAdditionalHeaders()) {\n        auto name = addlHeader.getName();\n        if (responseHeaderWhitelist.matches(name)) {\n          headers.add(name, addlHeader.getValue());\n        }\n      }\n\n      switch (in.which()) {\n        case WebSession::Response::CONTENT: {\n          auto content = in.getContent();\n\n          auto status = lookupStatus(successCodeTable, content.getStatusCode());\n\n          if (content.hasEncoding()) {\n            headers.set(hContentEncoding, content.getEncoding());\n          }\n          if (content.hasLanguage()) {\n            headers.set(hContentLanguage, content.getLanguage());\n          }\n          if (content.hasMimeType()) {\n            headers.set(hContentType, content.getMimeType());\n          }\n\n          if (content.hasETag()) {\n            setETag(headers, content.getETag());\n          }\n\n          auto disposition = content.getDisposition();\n          switch (disposition.which()) {\n            case WebSession::Response::Content::Disposition::NORMAL:\n              break;\n            case WebSession::Response::Content::Disposition::DOWNLOAD: {\n              headers.set(hContentDisposition,\n                  kj::str(\"attachment; filename=\\\"\", escape(disposition.getDownload()), \"\\\"\"));\n              break;\n            }\n          }\n\n          auto body = content.getBody();\n\n          switch (body.which()) {\n            case WebSession::Response::Content::Body::BYTES: {\n              auto data = body.getBytes();\n              auto stream = out.send(status.getId(), status.getTitle(), headers, data.size());\n              auto promise = stream->write(data.begin(), data.size());\n              return promise.attach(kj::mv(stream), kj::mv(in));\n            }\n            case WebSession::Response::Content::Body::STREAM: {\n              auto handle = body.getStream();\n              auto outStream = kj::heap<ByteStreamImpl>(\n                  status, kj::mv(headers), kj::mv(in), out);\n              auto promise = outStream->whenDone();\n              streamer->fulfill(kj::mv(outStream));\n              return promise.attach(kj::mv(handle));\n            }\n          }\n\n          KJ_UNREACHABLE;\n        }\n\n        case WebSession::Response::NO_CONTENT: {\n          auto noContent = in.getNoContent();\n\n          if (noContent.hasETag()) {\n            setETag(headers, noContent.getETag());\n          }\n\n          if (noContent.getShouldResetForm()) {\n            out.send(205, \"Reset Content\", headers);\n          } else {\n            out.send(204, \"No Content\", headers);\n          }\n          return kj::READY_NOW;\n        }\n\n        case WebSession::Response::PRECONDITION_FAILED: {\n          auto failed = in.getPreconditionFailed();\n\n          if (failed.hasMatchingETag()) {\n            setETag(headers, failed.getMatchingETag());\n          }\n\n          return sendError(out, 412, \"Precondition Failed\", headers);\n        }\n\n        case WebSession::Response::REDIRECT: {\n          auto redirect = in.getRedirect();\n\n          uint code;\n          kj::StringPtr name;\n          if (redirect.getSwitchToGet()) {\n            if (redirect.getIsPermanent()) {\n              code = 301; name = \"Moved Permanently\";\n            } else {\n              code = 303; name = \"See Other\";\n            }\n          } else {\n            if (redirect.getIsPermanent()) {\n              code = 308; name = \"Permanent Redirect\";\n            } else {\n              code = 307; name = \"Temporary Redirect\";\n            }\n          }\n\n          auto location = redirect.getLocation();\n          headers.set(kj::HttpHeaderId::LOCATION, location);\n\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n          auto body = kj::str(name, \": \", location);\n\n          auto stream = out.send(code, name, headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(body));\n        }\n\n        case WebSession::Response::CLIENT_ERROR: {\n          auto error = in.getClientError();\n\n          auto status = lookupStatus(errorCodeTable, error.getStatusCode());\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(status.getId(), status.getTitle(), headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n\n        case WebSession::Response::SERVER_ERROR: {\n          auto error = in.getServerError();\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(500, \"Internal Server Error\", headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)",
            "kj::mv(in)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "in"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "body.begin()",
            "body.size()"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "body.size",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "500",
            "\"Internal Server Error\"",
            "headers",
            "body.size()"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "kj::HttpHeaderId::CONTENT_TYPE",
            "\"text/html; charset=UTF-8\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.getDescriptionHtml",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getServerError",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)",
            "kj::mv(in)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "in"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "status.getId()",
            "status.getTitle()",
            "headers",
            "body.size()"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.getTitle",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.getId",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "kj::HttpHeaderId::CONTENT_TYPE",
            "\"text/html; charset=UTF-8\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error.getDescriptionHtml",
          "args": [],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookupStatus",
          "args": [
            "errorCodeTable",
            "error.getStatusCode()"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "lookupStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "190-199",
          "snippet": "inline HttpStatusDescriptor::Reader lookupStatus(\n      kj::ArrayPtr<HttpStatusDescriptor::Reader> table,\n      T codeEnum) {\n    if (static_cast<uint>(codeEnum) < table.size()) {\n      return table[static_cast<uint>(codeEnum)];\n    } else {\n      // The first item in each table happens to be a reasonable generic code for that table.\n      return table.front();\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\ninline HttpStatusDescriptor::Reader lookupStatus(\n      kj::ArrayPtr<HttpStatusDescriptor::Reader> table,\n      T codeEnum) {\n    if (static_cast<uint>(codeEnum) < table.size()) {\n      return table[static_cast<uint>(codeEnum)];\n    } else {\n      // The first item in each table happens to be a reasonable generic code for that table.\n      return table.front();\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "error.getStatusCode",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getClientError",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)",
            "kj::mv(body)"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "body"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.begin",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "code",
            "name",
            "headers",
            "body.size()"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name",
            "\": \"",
            "location"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "kj::HttpHeaderId::CONTENT_TYPE",
            "\"text/plain; charset=UTF-8\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "kj::HttpHeaderId::LOCATION",
            "location"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.getLocation",
          "args": [],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.getIsPermanent",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.getIsPermanent",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect.getSwitchToGet",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getRedirect",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendError",
          "args": [
            "out",
            "412",
            "\"Precondition Failed\"",
            "headers"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "sendError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "207-213",
          "snippet": "kj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText,\n                              kj::HttpHeaders& headers) {\n    auto stream = response.send(statusCode, statusText, headers, statusText.size());\n    auto promise = stream->write(statusText.begin(), statusText.size());\n    return promise.attach(kj::mv(stream));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText,\n                              kj::HttpHeaders& headers) {\n    auto stream = response.send(statusCode, statusText, headers, statusText.size());\n    auto promise = stream->write(statusText.begin(), statusText.size());\n    return promise.attach(kj::mv(stream));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "setETag",
          "args": [
            "headers",
            "failed.getMatchingETag()"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "setETag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "671-677",
          "snippet": "void setETag(kj::HttpHeaders& headers, WebSession::ETag::Reader etag) {\n    if (etag.getWeak()) {\n      headers.set(hETag, kj::str(\"W/\\\"\", etag.getValue(), \"\\\"\"));\n    } else {\n      headers.set(hETag, kj::str(\"\\\"\", etag.getValue(), \"\\\"\"));\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nvoid setETag(kj::HttpHeaders& headers, WebSession::ETag::Reader etag) {\n    if (etag.getWeak()) {\n      headers.set(hETag, kj::str(\"W/\\\"\", etag.getValue(), \"\\\"\"));\n    } else {\n      headers.set(hETag, kj::str(\"\\\"\", etag.getValue(), \"\\\"\"));\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "failed.getMatchingETag",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed.hasMatchingETag",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getPreconditionFailed",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "204",
            "\"No Content\"",
            "headers"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "205",
            "\"Reset Content\"",
            "headers"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noContent.getShouldResetForm",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noContent.getETag",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noContent.hasETag",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getNoContent",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(handle)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "handle"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "streamer->fulfill",
          "args": [
            "kj::mv(outStream)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "outStream"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outStream->whenDone",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "whenDone",
          "container": "ByteStreamImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "706-710",
          "snippet": "kj::Promise<void> whenDone() {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      doneFulfiller = kj::mv(paf.fulfiller);\n      return kj::mv(paf.promise);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> whenDone() {\n        auto paf = kj::newPromiseAndFulfiller<void>();\n        doneFulfiller = kj::mv(paf.fulfiller);\n        return kj::mv(paf.promise);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<ByteStreamImpl>",
          "args": [
            "status",
            "kj::mv(headers)",
            "kj::mv(in)",
            "out"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "in"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "headers"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.getStream",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)",
            "kj::mv(in)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "in"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.send",
          "args": [
            "status.getId()",
            "status.getTitle()",
            "headers",
            "data.size()"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.getTitle",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.getId",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.getBytes",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.which",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getBody",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hContentDisposition",
            "kj::str(\"attachment; filename=\\\"\", escape(disposition.getDownload()), \"\\\"\")"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"attachment; filename=\\\"\"",
            "escape(disposition.getDownload())",
            "\"\\\"\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape",
          "args": [
            "disposition.getDownload()"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "679-695",
          "snippet": "kj::String escape(kj::StringPtr value) {\n    kj::Vector<char> chars(value.size());\n\n    for (char c: value) {\n      switch (c) {\n        case '\\\\':\n        case '\\\"':\n          chars.add('\\\\');\n          break;\n        default:\n          break;\n      }\n      chars.add(c);\n    }\n\n    return kj::String(chars.releaseAsArray());\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::String escape(kj::StringPtr value) {\n    kj::Vector<char> chars(value.size());\n\n    for (char c: value) {\n      switch (c) {\n        case '\\\\':\n        case '\\\"':\n          chars.add('\\\\');\n          break;\n        default:\n          break;\n      }\n      chars.add(c);\n    }\n\n    return kj::String(chars.releaseAsArray());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "disposition.getDownload",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disposition.which",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getDisposition",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getETag",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasETag",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hContentType",
            "content.getMimeType()"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getMimeType",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasMimeType",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hContentLanguage",
            "content.getLanguage()"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getLanguage",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasLanguage",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hContentEncoding",
            "content.getEncoding()"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getEncoding",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.hasEncoding",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.getStatusCode",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getContent",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.which",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.add",
          "args": [
            "name",
            "addlHeader.getValue()"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addlHeader.getValue",
          "args": [],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseHeaderWhitelist.matches",
          "args": [
            "name"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "matches",
          "container": "HeaderWhitelist",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "842-869",
          "snippet": "bool HeaderWhitelist::matches(kj::StringPtr header) const {\n  // Convert to lower-case on stack.\n  KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n  memcpy(buffer.begin(), header.begin(), buffer.size());\n  toLower(buffer);\n  header = kj::StringPtr(buffer.begin(), header.size());\n\n  auto iter = patterns.lower_bound(header);\n  if (iter != patterns.end() && *iter == header) {\n    return true;\n  }\n\n  if (iter == patterns.begin()) return false;\n\n  // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n  // because the character '*' sorts before all characters that are valid inside headers.\n  --iter;\n  if (iter->endsWith(\"*\")) {\n    // Check if prefix matches.\n    auto prefix = iter->slice(0, iter->size() - 1);\n    if (header.size() >= prefix.size() &&\n        memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nHeaderWhitelist {\n  bool HeaderWhitelist::matches(kj::StringPtr header) const {\n    // Convert to lower-case on stack.\n    KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n    memcpy(buffer.begin(), header.begin(), buffer.size());\n    toLower(buffer);\n    header = kj::StringPtr(buffer.begin(), header.size());\n  \n    auto iter = patterns.lower_bound(header);\n    if (iter != patterns.end() && *iter == header) {\n      return true;\n    }\n  \n    if (iter == patterns.begin()) return false;\n  \n    // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n    // because the character '*' sorts before all characters that are valid inside headers.\n    --iter;\n    if (iter->endsWith(\"*\")) {\n      // Check if prefix matches.\n      auto prefix = iter->slice(0, iter->size() - 1);\n      if (header.size() >= prefix.size() &&\n          memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addlHeader.getName",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.getAdditionalHeaders",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[this,KJ_MVCAP(streamer),&out](capnp::Response<WebSession::Response>&& in"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> handleResponse(kj::Promise<capnp::Response<WebSession::Response>>&& promise,\n                                   kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n                                   kj::HttpService::Response& out) {\n    return promise.then([this,KJ_MVCAP(streamer),&out](\n        capnp::Response<WebSession::Response>&& in) mutable -> kj::Promise<void> {\n      // TODO(someday): cachePolicy (not supported in Sandstorm proper as of this writing)\n\n      kj::HttpHeaders headers(headerTable);\n\n      for (auto addlHeader: in.getAdditionalHeaders()) {\n        auto name = addlHeader.getName();\n        if (responseHeaderWhitelist.matches(name)) {\n          headers.add(name, addlHeader.getValue());\n        }\n      }\n\n      switch (in.which()) {\n        case WebSession::Response::CONTENT: {\n          auto content = in.getContent();\n\n          auto status = lookupStatus(successCodeTable, content.getStatusCode());\n\n          if (content.hasEncoding()) {\n            headers.set(hContentEncoding, content.getEncoding());\n          }\n          if (content.hasLanguage()) {\n            headers.set(hContentLanguage, content.getLanguage());\n          }\n          if (content.hasMimeType()) {\n            headers.set(hContentType, content.getMimeType());\n          }\n\n          if (content.hasETag()) {\n            setETag(headers, content.getETag());\n          }\n\n          auto disposition = content.getDisposition();\n          switch (disposition.which()) {\n            case WebSession::Response::Content::Disposition::NORMAL:\n              break;\n            case WebSession::Response::Content::Disposition::DOWNLOAD: {\n              headers.set(hContentDisposition,\n                  kj::str(\"attachment; filename=\\\"\", escape(disposition.getDownload()), \"\\\"\"));\n              break;\n            }\n          }\n\n          auto body = content.getBody();\n\n          switch (body.which()) {\n            case WebSession::Response::Content::Body::BYTES: {\n              auto data = body.getBytes();\n              auto stream = out.send(status.getId(), status.getTitle(), headers, data.size());\n              auto promise = stream->write(data.begin(), data.size());\n              return promise.attach(kj::mv(stream), kj::mv(in));\n            }\n            case WebSession::Response::Content::Body::STREAM: {\n              auto handle = body.getStream();\n              auto outStream = kj::heap<ByteStreamImpl>(\n                  status, kj::mv(headers), kj::mv(in), out);\n              auto promise = outStream->whenDone();\n              streamer->fulfill(kj::mv(outStream));\n              return promise.attach(kj::mv(handle));\n            }\n          }\n\n          KJ_UNREACHABLE;\n        }\n\n        case WebSession::Response::NO_CONTENT: {\n          auto noContent = in.getNoContent();\n\n          if (noContent.hasETag()) {\n            setETag(headers, noContent.getETag());\n          }\n\n          if (noContent.getShouldResetForm()) {\n            out.send(205, \"Reset Content\", headers);\n          } else {\n            out.send(204, \"No Content\", headers);\n          }\n          return kj::READY_NOW;\n        }\n\n        case WebSession::Response::PRECONDITION_FAILED: {\n          auto failed = in.getPreconditionFailed();\n\n          if (failed.hasMatchingETag()) {\n            setETag(headers, failed.getMatchingETag());\n          }\n\n          return sendError(out, 412, \"Precondition Failed\", headers);\n        }\n\n        case WebSession::Response::REDIRECT: {\n          auto redirect = in.getRedirect();\n\n          uint code;\n          kj::StringPtr name;\n          if (redirect.getSwitchToGet()) {\n            if (redirect.getIsPermanent()) {\n              code = 301; name = \"Moved Permanently\";\n            } else {\n              code = 303; name = \"See Other\";\n            }\n          } else {\n            if (redirect.getIsPermanent()) {\n              code = 308; name = \"Permanent Redirect\";\n            } else {\n              code = 307; name = \"Temporary Redirect\";\n            }\n          }\n\n          auto location = redirect.getLocation();\n          headers.set(kj::HttpHeaderId::LOCATION, location);\n\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n          auto body = kj::str(name, \": \", location);\n\n          auto stream = out.send(code, name, headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(body));\n        }\n\n        case WebSession::Response::CLIENT_ERROR: {\n          auto error = in.getClientError();\n\n          auto status = lookupStatus(errorCodeTable, error.getStatusCode());\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(status.getId(), status.getTitle(), headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n\n        case WebSession::Response::SERVER_ERROR: {\n          auto error = in.getServerError();\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(500, \"Internal Server Error\", headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }"
  },
  {
    "function_name": "handleStreamingRequestResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "506-516",
    "snippet": "kj::Promise<void> handleStreamingRequestResponse(\n      WebSession::RequestStream::Client reqStream,\n      kj::AsyncInputStream& requestBody,\n      kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n      kj::HttpService::Response& out) {\n    auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n    promises.add(pump(requestBody, reqStream));\n    promises.add(handleResponse(reqStream.getResponseRequest().send(),\n                                kj::mv(streamer), out));\n    return kj::joinPromises(promises.finish());\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::joinPromises",
          "args": [
            "promises.finish()"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promises.finish",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promises.add",
          "args": [
            "handleResponse(reqStream.getResponseRequest().send(),\n                                kj::mv(streamer), out)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleResponse",
          "args": [
            "reqStream.getResponseRequest().send()",
            "kj::mv(streamer)",
            "out"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "handleResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "518-669",
          "snippet": "kj::Promise<void> handleResponse(kj::Promise<capnp::Response<WebSession::Response>>&& promise,\n                                   kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n                                   kj::HttpService::Response& out) {\n    return promise.then([this,KJ_MVCAP(streamer),&out](\n        capnp::Response<WebSession::Response>&& in) mutable -> kj::Promise<void> {\n      // TODO(someday): cachePolicy (not supported in Sandstorm proper as of this writing)\n\n      kj::HttpHeaders headers(headerTable);\n\n      for (auto addlHeader: in.getAdditionalHeaders()) {\n        auto name = addlHeader.getName();\n        if (responseHeaderWhitelist.matches(name)) {\n          headers.add(name, addlHeader.getValue());\n        }\n      }\n\n      switch (in.which()) {\n        case WebSession::Response::CONTENT: {\n          auto content = in.getContent();\n\n          auto status = lookupStatus(successCodeTable, content.getStatusCode());\n\n          if (content.hasEncoding()) {\n            headers.set(hContentEncoding, content.getEncoding());\n          }\n          if (content.hasLanguage()) {\n            headers.set(hContentLanguage, content.getLanguage());\n          }\n          if (content.hasMimeType()) {\n            headers.set(hContentType, content.getMimeType());\n          }\n\n          if (content.hasETag()) {\n            setETag(headers, content.getETag());\n          }\n\n          auto disposition = content.getDisposition();\n          switch (disposition.which()) {\n            case WebSession::Response::Content::Disposition::NORMAL:\n              break;\n            case WebSession::Response::Content::Disposition::DOWNLOAD: {\n              headers.set(hContentDisposition,\n                  kj::str(\"attachment; filename=\\\"\", escape(disposition.getDownload()), \"\\\"\"));\n              break;\n            }\n          }\n\n          auto body = content.getBody();\n\n          switch (body.which()) {\n            case WebSession::Response::Content::Body::BYTES: {\n              auto data = body.getBytes();\n              auto stream = out.send(status.getId(), status.getTitle(), headers, data.size());\n              auto promise = stream->write(data.begin(), data.size());\n              return promise.attach(kj::mv(stream), kj::mv(in));\n            }\n            case WebSession::Response::Content::Body::STREAM: {\n              auto handle = body.getStream();\n              auto outStream = kj::heap<ByteStreamImpl>(\n                  status, kj::mv(headers), kj::mv(in), out);\n              auto promise = outStream->whenDone();\n              streamer->fulfill(kj::mv(outStream));\n              return promise.attach(kj::mv(handle));\n            }\n          }\n\n          KJ_UNREACHABLE;\n        }\n\n        case WebSession::Response::NO_CONTENT: {\n          auto noContent = in.getNoContent();\n\n          if (noContent.hasETag()) {\n            setETag(headers, noContent.getETag());\n          }\n\n          if (noContent.getShouldResetForm()) {\n            out.send(205, \"Reset Content\", headers);\n          } else {\n            out.send(204, \"No Content\", headers);\n          }\n          return kj::READY_NOW;\n        }\n\n        case WebSession::Response::PRECONDITION_FAILED: {\n          auto failed = in.getPreconditionFailed();\n\n          if (failed.hasMatchingETag()) {\n            setETag(headers, failed.getMatchingETag());\n          }\n\n          return sendError(out, 412, \"Precondition Failed\", headers);\n        }\n\n        case WebSession::Response::REDIRECT: {\n          auto redirect = in.getRedirect();\n\n          uint code;\n          kj::StringPtr name;\n          if (redirect.getSwitchToGet()) {\n            if (redirect.getIsPermanent()) {\n              code = 301; name = \"Moved Permanently\";\n            } else {\n              code = 303; name = \"See Other\";\n            }\n          } else {\n            if (redirect.getIsPermanent()) {\n              code = 308; name = \"Permanent Redirect\";\n            } else {\n              code = 307; name = \"Temporary Redirect\";\n            }\n          }\n\n          auto location = redirect.getLocation();\n          headers.set(kj::HttpHeaderId::LOCATION, location);\n\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n          auto body = kj::str(name, \": \", location);\n\n          auto stream = out.send(code, name, headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(body));\n        }\n\n        case WebSession::Response::CLIENT_ERROR: {\n          auto error = in.getClientError();\n\n          auto status = lookupStatus(errorCodeTable, error.getStatusCode());\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(status.getId(), status.getTitle(), headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n\n        case WebSession::Response::SERVER_ERROR: {\n          auto error = in.getServerError();\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(500, \"Internal Server Error\", headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> handleResponse(kj::Promise<capnp::Response<WebSession::Response>>&& promise,\n                                   kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n                                   kj::HttpService::Response& out) {\n    return promise.then([this,KJ_MVCAP(streamer),&out](\n        capnp::Response<WebSession::Response>&& in) mutable -> kj::Promise<void> {\n      // TODO(someday): cachePolicy (not supported in Sandstorm proper as of this writing)\n\n      kj::HttpHeaders headers(headerTable);\n\n      for (auto addlHeader: in.getAdditionalHeaders()) {\n        auto name = addlHeader.getName();\n        if (responseHeaderWhitelist.matches(name)) {\n          headers.add(name, addlHeader.getValue());\n        }\n      }\n\n      switch (in.which()) {\n        case WebSession::Response::CONTENT: {\n          auto content = in.getContent();\n\n          auto status = lookupStatus(successCodeTable, content.getStatusCode());\n\n          if (content.hasEncoding()) {\n            headers.set(hContentEncoding, content.getEncoding());\n          }\n          if (content.hasLanguage()) {\n            headers.set(hContentLanguage, content.getLanguage());\n          }\n          if (content.hasMimeType()) {\n            headers.set(hContentType, content.getMimeType());\n          }\n\n          if (content.hasETag()) {\n            setETag(headers, content.getETag());\n          }\n\n          auto disposition = content.getDisposition();\n          switch (disposition.which()) {\n            case WebSession::Response::Content::Disposition::NORMAL:\n              break;\n            case WebSession::Response::Content::Disposition::DOWNLOAD: {\n              headers.set(hContentDisposition,\n                  kj::str(\"attachment; filename=\\\"\", escape(disposition.getDownload()), \"\\\"\"));\n              break;\n            }\n          }\n\n          auto body = content.getBody();\n\n          switch (body.which()) {\n            case WebSession::Response::Content::Body::BYTES: {\n              auto data = body.getBytes();\n              auto stream = out.send(status.getId(), status.getTitle(), headers, data.size());\n              auto promise = stream->write(data.begin(), data.size());\n              return promise.attach(kj::mv(stream), kj::mv(in));\n            }\n            case WebSession::Response::Content::Body::STREAM: {\n              auto handle = body.getStream();\n              auto outStream = kj::heap<ByteStreamImpl>(\n                  status, kj::mv(headers), kj::mv(in), out);\n              auto promise = outStream->whenDone();\n              streamer->fulfill(kj::mv(outStream));\n              return promise.attach(kj::mv(handle));\n            }\n          }\n\n          KJ_UNREACHABLE;\n        }\n\n        case WebSession::Response::NO_CONTENT: {\n          auto noContent = in.getNoContent();\n\n          if (noContent.hasETag()) {\n            setETag(headers, noContent.getETag());\n          }\n\n          if (noContent.getShouldResetForm()) {\n            out.send(205, \"Reset Content\", headers);\n          } else {\n            out.send(204, \"No Content\", headers);\n          }\n          return kj::READY_NOW;\n        }\n\n        case WebSession::Response::PRECONDITION_FAILED: {\n          auto failed = in.getPreconditionFailed();\n\n          if (failed.hasMatchingETag()) {\n            setETag(headers, failed.getMatchingETag());\n          }\n\n          return sendError(out, 412, \"Precondition Failed\", headers);\n        }\n\n        case WebSession::Response::REDIRECT: {\n          auto redirect = in.getRedirect();\n\n          uint code;\n          kj::StringPtr name;\n          if (redirect.getSwitchToGet()) {\n            if (redirect.getIsPermanent()) {\n              code = 301; name = \"Moved Permanently\";\n            } else {\n              code = 303; name = \"See Other\";\n            }\n          } else {\n            if (redirect.getIsPermanent()) {\n              code = 308; name = \"Permanent Redirect\";\n            } else {\n              code = 307; name = \"Temporary Redirect\";\n            }\n          }\n\n          auto location = redirect.getLocation();\n          headers.set(kj::HttpHeaderId::LOCATION, location);\n\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n          auto body = kj::str(name, \": \", location);\n\n          auto stream = out.send(code, name, headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(body));\n        }\n\n        case WebSession::Response::CLIENT_ERROR: {\n          auto error = in.getClientError();\n\n          auto status = lookupStatus(errorCodeTable, error.getStatusCode());\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(status.getId(), status.getTitle(), headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n\n        case WebSession::Response::SERVER_ERROR: {\n          auto error = in.getServerError();\n\n          auto body = error.getDescriptionHtml();\n          headers.set(kj::HttpHeaderId::CONTENT_TYPE, \"text/html; charset=UTF-8\");\n\n          auto stream = out.send(500, \"Internal Server Error\", headers, body.size());\n          auto promise = stream->write(body.begin(), body.size());\n          return promise.attach(kj::mv(stream), kj::mv(in));\n        }\n      }\n\n      KJ_UNREACHABLE;\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "streamer"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqStream.getResponseRequest",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reqStream.getResponseRequest",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promises.add",
          "args": [
            "pump(requestBody, reqStream)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "requestBody",
            "reqStream"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "246-251",
          "snippet": "void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n    byte buffer[4096];\n    while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n      out.write(buffer, n);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<kj::Promise<void>>",
          "args": [
            "2"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> handleStreamingRequestResponse(\n      WebSession::RequestStream::Client reqStream,\n      kj::AsyncInputStream& requestBody,\n      kj::Own<kj::PromiseFulfiller<ByteStream::Client>>&& streamer,\n      kj::HttpService::Response& out) {\n    auto promises = kj::heapArrayBuilder<kj::Promise<void>>(2);\n    promises.add(pump(requestBody, reqStream));\n    promises.add(handleResponse(reqStream.getResponseRequest().send(),\n                                kj::mv(streamer), out));\n    return kj::joinPromises(promises.finish());\n  }"
  },
  {
    "function_name": "parseETagInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "466-504",
    "snippet": "kj::Tuple<kj::String, bool> parseETagInternal(kj::StringPtr& text) {\n    const char* p = text.begin();\n\n    while (*p == ' ') ++p;\n\n    bool weak = false;\n    if (p[0] == 'W' && p[1] == '/') {\n      weak = true;\n      p += 2;\n    }\n\n    while (*p == ' ') ++p;\n\n    KJ_REQUIRE(*p == '\\\"', \"invalid ETag; must be quoted\", text);\n\n    ++p;\n    kj::Vector<char> chars;\n\n    for (;;) {\n      switch (*p) {\n        case '\\\"':\n          // done\n          while (p[0] == ' ') ++p;\n          text = text.slice(p - text.begin());\n          return kj::tuple(kj::String(chars.releaseAsArray()), weak);\n        case '\\\\':\n          ++p;\n          KJ_REQUIRE(*p != '\\0', \"invalid ETag escape sequence\", text);\n          chars.add(*p);\n          break;\n        case '\\0':\n          KJ_FAIL_ASSERT(\"invalid ETag missing end quote\",text);\n        default:\n          chars.add(*p);\n          break;\n      }\n      ++p;\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "*p"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"invalid ETag missing end quote\"",
            "text"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.add",
          "args": [
            "*p"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "*p != '\\0'",
            "\"invalid ETag escape sequence\"",
            "text"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::tuple",
          "args": [
            "kj::String(chars.releaseAsArray())",
            "weak"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "chars.releaseAsArray()"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chars.releaseAsArray",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.slice",
          "args": [
            "p - text.begin()"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "*p == '\\\"'",
            "\"invalid ETag; must be quoted\"",
            "text"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Tuple<kj::String, bool> parseETagInternal(kj::StringPtr& text) {\n    const char* p = text.begin();\n\n    while (*p == ' ') ++p;\n\n    bool weak = false;\n    if (p[0] == 'W' && p[1] == '/') {\n      weak = true;\n      p += 2;\n    }\n\n    while (*p == ' ') ++p;\n\n    KJ_REQUIRE(*p == '\\\"', \"invalid ETag; must be quoted\", text);\n\n    ++p;\n    kj::Vector<char> chars;\n\n    for (;;) {\n      switch (*p) {\n        case '\\\"':\n          // done\n          while (p[0] == ' ') ++p;\n          text = text.slice(p - text.begin());\n          return kj::tuple(kj::String(chars.releaseAsArray()), weak);\n        case '\\\\':\n          ++p;\n          KJ_REQUIRE(*p != '\\0', \"invalid ETag escape sequence\", text);\n          chars.add(*p);\n          break;\n        case '\\0':\n          KJ_FAIL_ASSERT(\"invalid ETag missing end quote\",text);\n        default:\n          chars.add(*p);\n          break;\n      }\n      ++p;\n    }\n  }"
  },
  {
    "function_name": "parseETagList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "447-464",
    "snippet": "capnp::Orphan<capnp::List<WebSession::ETag>> parseETagList(\n      capnp::Orphanage orphanage, kj::StringPtr text,\n      kj::Vector<kj::Tuple<kj::String, bool>> parsed = kj::Vector<kj::Tuple<kj::String, bool>>()) {\n    parsed.add(parseETagInternal(text));\n    if (text.size() > 0) {\n      KJ_REQUIRE(text[0] == ',', \"etag must be followed by comma\", text);\n      return parseETagList(orphanage, text, kj::mv(parsed));\n    } else {\n      auto result = orphanage.newOrphan<capnp::List<WebSession::ETag>>(parsed.size());\n      auto list = result.get();\n      for (size_t i: kj::indices(parsed)) {\n        auto etag = list[i];\n        etag.setValue(kj::get<0>(parsed[i]));\n        etag.setWeak(kj::get<1>(parsed[i]));\n      }\n      return result;\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etag.setWeak",
          "args": [
            "kj::get<1>(parsed[i])"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::get<1>",
          "args": [
            "parsed[i]"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "RequestSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2053-2107",
          "snippet": "kj::Promise<void> get(GetContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      // Determine the subset of PowerboxApis which the user has permission to choose.\n      //\n      // TODO(soon): Also match against descriptors.\n      kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        bool requirementsMet = true;\n\n        if (api.hasPermissions()) {\n          auto requiredPermissions = api.getPermissions();\n          for (size_t i: kj::indices(requiredPermissions)) {\n            if (requiredPermissions[i]) {\n              if (permissions.size() <= i || !permissions[i]) {\n                requirementsMet = false;\n                break;\n              }\n            }\n          }\n        }\n\n        if (requirementsMet) {\n          apis.add(api);\n        }\n      }\n\n      // JSON-ify that list as the config blob.\n      capnp::MallocMessageBuilder filteredConfig;\n      auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        list.setWithCaveats(i, apis[i]);\n      }\n\n      capnp::JsonCodec codec;\n      auto config = codec.encode(list);\n\n      // Send back our static HTML with the config blob injected into it.\n      auto content = results.initContent();\n      content.setMimeType(\"text/html; charset=UTF-8\");\n      auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n      memcpy(body.begin(), prefix.begin(), prefix.size());\n      memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n      memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n      return kj::READY_NOW;\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;",
            "kj::String permissions;",
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        // Determine the subset of PowerboxApis which the user has permission to choose.\n        //\n        // TODO(soon): Also match against descriptors.\n        kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n        for (auto api: bridgeContext.getPowerboxApis()) {\n          bool requirementsMet = true;\n  \n          if (api.hasPermissions()) {\n            auto requiredPermissions = api.getPermissions();\n            for (size_t i: kj::indices(requiredPermissions)) {\n              if (requiredPermissions[i]) {\n                if (permissions.size() <= i || !permissions[i]) {\n                  requirementsMet = false;\n                  break;\n                }\n              }\n            }\n          }\n  \n          if (requirementsMet) {\n            apis.add(api);\n          }\n        }\n  \n        // JSON-ify that list as the config blob.\n        capnp::MallocMessageBuilder filteredConfig;\n        auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          list.setWithCaveats(i, apis[i]);\n        }\n  \n        capnp::JsonCodec codec;\n        auto config = codec.encode(list);\n  \n        // Send back our static HTML with the config blob injected into it.\n        auto content = results.initContent();\n        content.setMimeType(\"text/html; charset=UTF-8\");\n        auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n        memcpy(body.begin(), prefix.begin(), prefix.size());\n        memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n        memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n        return kj::READY_NOW;\n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etag.setValue",
          "args": [
            "kj::get<0>(parsed[i])"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "parsed"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<capnp::List<WebSession::ETag>>",
          "args": [
            "parsed.size()"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsed.size",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseETagList",
          "args": [
            "orphanage",
            "text",
            "kj::mv(parsed)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "parsed"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "text[0] == ','",
            "\"etag must be followed by comma\"",
            "text"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsed.add",
          "args": [
            "parseETagInternal(text)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseETagInternal",
          "args": [
            "text"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "parseETagInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "466-504",
          "snippet": "kj::Tuple<kj::String, bool> parseETagInternal(kj::StringPtr& text) {\n    const char* p = text.begin();\n\n    while (*p == ' ') ++p;\n\n    bool weak = false;\n    if (p[0] == 'W' && p[1] == '/') {\n      weak = true;\n      p += 2;\n    }\n\n    while (*p == ' ') ++p;\n\n    KJ_REQUIRE(*p == '\\\"', \"invalid ETag; must be quoted\", text);\n\n    ++p;\n    kj::Vector<char> chars;\n\n    for (;;) {\n      switch (*p) {\n        case '\\\"':\n          // done\n          while (p[0] == ' ') ++p;\n          text = text.slice(p - text.begin());\n          return kj::tuple(kj::String(chars.releaseAsArray()), weak);\n        case '\\\\':\n          ++p;\n          KJ_REQUIRE(*p != '\\0', \"invalid ETag escape sequence\", text);\n          chars.add(*p);\n          break;\n        case '\\0':\n          KJ_FAIL_ASSERT(\"invalid ETag missing end quote\",text);\n        default:\n          chars.add(*p);\n          break;\n      }\n      ++p;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Tuple<kj::String, bool> parseETagInternal(kj::StringPtr& text) {\n    const char* p = text.begin();\n\n    while (*p == ' ') ++p;\n\n    bool weak = false;\n    if (p[0] == 'W' && p[1] == '/') {\n      weak = true;\n      p += 2;\n    }\n\n    while (*p == ' ') ++p;\n\n    KJ_REQUIRE(*p == '\\\"', \"invalid ETag; must be quoted\", text);\n\n    ++p;\n    kj::Vector<char> chars;\n\n    for (;;) {\n      switch (*p) {\n        case '\\\"':\n          // done\n          while (p[0] == ' ') ++p;\n          text = text.slice(p - text.begin());\n          return kj::tuple(kj::String(chars.releaseAsArray()), weak);\n        case '\\\\':\n          ++p;\n          KJ_REQUIRE(*p != '\\0', \"invalid ETag escape sequence\", text);\n          chars.add(*p);\n          break;\n        case '\\0':\n          KJ_FAIL_ASSERT(\"invalid ETag missing end quote\",text);\n        default:\n          chars.add(*p);\n          break;\n      }\n      ++p;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::Vector<kj::Tuple<kj::String, bool>>",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\ncapnp::Orphan<capnp::List<WebSession::ETag>> parseETagList(\n      capnp::Orphanage orphanage, kj::StringPtr text,\n      kj::Vector<kj::Tuple<kj::String, bool>> parsed = kj::Vector<kj::Tuple<kj::String, bool>>()) {\n    parsed.add(parseETagInternal(text));\n    if (text.size() > 0) {\n      KJ_REQUIRE(text[0] == ',', \"etag must be followed by comma\", text);\n      return parseETagList(orphanage, text, kj::mv(parsed));\n    } else {\n      auto result = orphanage.newOrphan<capnp::List<WebSession::ETag>>(parsed.size());\n      auto list = result.get();\n      for (size_t i: kj::indices(parsed)) {\n        auto etag = list[i];\n        etag.setValue(kj::get<0>(parsed[i]));\n        etag.setWeak(kj::get<1>(parsed[i]));\n      }\n      return result;\n    }\n  }"
  },
  {
    "function_name": "initContent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "438-445",
    "snippet": "void initContent(Builder&& builder, const kj::HttpHeaders& headers) {\n    KJ_IF_MAYBE(value, headers.get(hContentEncoding)) {\n      builder.setEncoding(*value);\n    }\n    KJ_IF_MAYBE(value, headers.get(hContentType)) {\n      builder.setMimeType(*value);\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.setMimeType",
          "args": [
            "*value"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "value",
            "headers.get(hContentType)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "headers.get",
          "args": [
            "hContentType"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "RequestSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2053-2107",
          "snippet": "kj::Promise<void> get(GetContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      // Determine the subset of PowerboxApis which the user has permission to choose.\n      //\n      // TODO(soon): Also match against descriptors.\n      kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        bool requirementsMet = true;\n\n        if (api.hasPermissions()) {\n          auto requiredPermissions = api.getPermissions();\n          for (size_t i: kj::indices(requiredPermissions)) {\n            if (requiredPermissions[i]) {\n              if (permissions.size() <= i || !permissions[i]) {\n                requirementsMet = false;\n                break;\n              }\n            }\n          }\n        }\n\n        if (requirementsMet) {\n          apis.add(api);\n        }\n      }\n\n      // JSON-ify that list as the config blob.\n      capnp::MallocMessageBuilder filteredConfig;\n      auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        list.setWithCaveats(i, apis[i]);\n      }\n\n      capnp::JsonCodec codec;\n      auto config = codec.encode(list);\n\n      // Send back our static HTML with the config blob injected into it.\n      auto content = results.initContent();\n      content.setMimeType(\"text/html; charset=UTF-8\");\n      auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n      memcpy(body.begin(), prefix.begin(), prefix.size());\n      memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n      memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n      return kj::READY_NOW;\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;",
            "kj::String permissions;",
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        // Determine the subset of PowerboxApis which the user has permission to choose.\n        //\n        // TODO(soon): Also match against descriptors.\n        kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n        for (auto api: bridgeContext.getPowerboxApis()) {\n          bool requirementsMet = true;\n  \n          if (api.hasPermissions()) {\n            auto requiredPermissions = api.getPermissions();\n            for (size_t i: kj::indices(requiredPermissions)) {\n              if (requiredPermissions[i]) {\n                if (permissions.size() <= i || !permissions[i]) {\n                  requirementsMet = false;\n                  break;\n                }\n              }\n            }\n          }\n  \n          if (requirementsMet) {\n            apis.add(api);\n          }\n        }\n  \n        // JSON-ify that list as the config blob.\n        capnp::MallocMessageBuilder filteredConfig;\n        auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          list.setWithCaveats(i, apis[i]);\n        }\n  \n        capnp::JsonCodec codec;\n        auto config = codec.encode(list);\n  \n        // Send back our static HTML with the config blob injected into it.\n        auto content = results.initContent();\n        content.setMimeType(\"text/html; charset=UTF-8\");\n        auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n        memcpy(body.begin(), prefix.begin(), prefix.size());\n        memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n        memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n        return kj::READY_NOW;\n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setEncoding",
          "args": [
            "*value"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nvoid initContent(Builder&& builder, const kj::HttpHeaders& headers) {\n    KJ_IF_MAYBE(value, headers.get(hContentEncoding)) {\n      builder.setEncoding(*value);\n    }\n    KJ_IF_MAYBE(value, headers.get(hContentType)) {\n      builder.setMimeType(*value);\n    }\n  }"
  },
  {
    "function_name": "initContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "356-435",
    "snippet": "kj::Own<kj::PromiseFulfiller<ByteStream::Client>> initContext(\n      WebSession::Context::Builder context, const kj::HttpHeaders& headers) {\n    // We intentionally ignore cookies.\n\n    auto paf = kj::newPromiseAndFulfiller<ByteStream::Client>();\n    context.setResponseStream(kj::mv(paf.promise));\n\n    KJ_IF_MAYBE(accept, headers.get(hAccept)) {\n      auto items = split(*accept, ',');\n      auto list = context.initAccept(items.size());\n      for (size_t i: kj::indices(items)) {\n        auto item = items[i];\n        auto builder = list[i];\n\n        auto parts = split(item, ';');\n        builder.setMimeType(trim(parts[0]));\n\n        for (auto part: parts.asPtr().slice(1, parts.size())) {\n          KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n            if (trim(*name) == \"q\") {\n              builder.setQValue(trim(part).parseAs<float>());\n            }\n          }\n        }\n      }\n    }\n\n    KJ_IF_MAYBE(accept, headers.get(hAcceptEncoding)) {\n      auto items = split(*accept, ',');\n      auto list = context.initAcceptEncoding(items.size());\n      for (size_t i: kj::indices(items)) {\n        auto item = items[i];\n        auto builder = list[i];\n\n        auto parts = split(item, ';');\n        builder.setContentCoding(trim(parts[0]));\n\n        for (auto part: parts.asPtr().slice(1, parts.size())) {\n          KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n            if (trim(*name) == \"q\") {\n              builder.setQValue(trim(part).parseAs<float>());\n            }\n          }\n        }\n      }\n    }\n\n    KJ_IF_MAYBE(match, headers.get(hIfMatch)) {\n      if (*match == \"*\") {\n        context.getETagPrecondition().setExists();\n      } else {\n        context.getETagPrecondition().adoptMatchesOneOf(\n            parseETagList(capnp::Orphanage::getForMessageContaining(context), *match));\n      }\n    } else KJ_IF_MAYBE(match, headers.get(hIfNoneMatch)) {\n      if (*match == \"*\") {\n        context.getETagPrecondition().setDoesntExist();\n      } else {\n        context.getETagPrecondition().adoptMatchesNoneOf(\n            parseETagList(capnp::Orphanage::getForMessageContaining(context), *match));\n      }\n    }\n\n    kj::Vector<kj::Tuple<kj::StringPtr, kj::StringPtr>> whitelisted;\n    headers.forEach([&](kj::StringPtr name, kj::StringPtr value) {\n      if (requestHeaderWhitelist.matches(name)) {\n        whitelisted.add(kj::tuple(name, value));\n      }\n    });\n    if (whitelisted.size() > 0) {\n      auto list = context.initAdditionalHeaders(whitelisted.size());\n      for (size_t i: kj::indices(whitelisted)) {\n        auto out = list[i];\n        out.setName(kj::get<0>(whitelisted[i]));\n        out.setValue(kj::get<1>(whitelisted[i]));\n      }\n    }\n\n    return kj::mv(paf.fulfiller);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.setValue",
          "args": [
            "kj::get<1>(whitelisted[i])"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::get<1>",
          "args": [
            "whitelisted[i]"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "RequestSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2053-2107",
          "snippet": "kj::Promise<void> get(GetContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      // Determine the subset of PowerboxApis which the user has permission to choose.\n      //\n      // TODO(soon): Also match against descriptors.\n      kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        bool requirementsMet = true;\n\n        if (api.hasPermissions()) {\n          auto requiredPermissions = api.getPermissions();\n          for (size_t i: kj::indices(requiredPermissions)) {\n            if (requiredPermissions[i]) {\n              if (permissions.size() <= i || !permissions[i]) {\n                requirementsMet = false;\n                break;\n              }\n            }\n          }\n        }\n\n        if (requirementsMet) {\n          apis.add(api);\n        }\n      }\n\n      // JSON-ify that list as the config blob.\n      capnp::MallocMessageBuilder filteredConfig;\n      auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        list.setWithCaveats(i, apis[i]);\n      }\n\n      capnp::JsonCodec codec;\n      auto config = codec.encode(list);\n\n      // Send back our static HTML with the config blob injected into it.\n      auto content = results.initContent();\n      content.setMimeType(\"text/html; charset=UTF-8\");\n      auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n      memcpy(body.begin(), prefix.begin(), prefix.size());\n      memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n      memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n      return kj::READY_NOW;\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;",
            "kj::String permissions;",
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        // Determine the subset of PowerboxApis which the user has permission to choose.\n        //\n        // TODO(soon): Also match against descriptors.\n        kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n        for (auto api: bridgeContext.getPowerboxApis()) {\n          bool requirementsMet = true;\n  \n          if (api.hasPermissions()) {\n            auto requiredPermissions = api.getPermissions();\n            for (size_t i: kj::indices(requiredPermissions)) {\n              if (requiredPermissions[i]) {\n                if (permissions.size() <= i || !permissions[i]) {\n                  requirementsMet = false;\n                  break;\n                }\n              }\n            }\n          }\n  \n          if (requirementsMet) {\n            apis.add(api);\n          }\n        }\n  \n        // JSON-ify that list as the config blob.\n        capnp::MallocMessageBuilder filteredConfig;\n        auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          list.setWithCaveats(i, apis[i]);\n        }\n  \n        capnp::JsonCodec codec;\n        auto config = codec.encode(list);\n  \n        // Send back our static HTML with the config blob injected into it.\n        auto content = results.initContent();\n        content.setMimeType(\"text/html; charset=UTF-8\");\n        auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n        memcpy(body.begin(), prefix.begin(), prefix.size());\n        memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n        memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n        return kj::READY_NOW;\n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.setName",
          "args": [
            "kj::get<0>(whitelisted[i])"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "whitelisted"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initAdditionalHeaders",
          "args": [
            "whitelisted.size()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "whitelisted.size",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "headers.forEach",
          "args": [
            "[&](kj::StringPtr name, kj::StringPtr value) {\n      if (requestHeaderWhitelist.matches(name)) {\n        whitelisted.add(kj::tuple(name, value));\n      }\n    }"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "whitelisted.add",
          "args": [
            "kj::tuple(name, value)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::tuple",
          "args": [
            "name",
            "value"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaderWhitelist.matches",
          "args": [
            "name"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "matches",
          "container": "HeaderWhitelist",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "842-869",
          "snippet": "bool HeaderWhitelist::matches(kj::StringPtr header) const {\n  // Convert to lower-case on stack.\n  KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n  memcpy(buffer.begin(), header.begin(), buffer.size());\n  toLower(buffer);\n  header = kj::StringPtr(buffer.begin(), header.size());\n\n  auto iter = patterns.lower_bound(header);\n  if (iter != patterns.end() && *iter == header) {\n    return true;\n  }\n\n  if (iter == patterns.begin()) return false;\n\n  // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n  // because the character '*' sorts before all characters that are valid inside headers.\n  --iter;\n  if (iter->endsWith(\"*\")) {\n    // Check if prefix matches.\n    auto prefix = iter->slice(0, iter->size() - 1);\n    if (header.size() >= prefix.size() &&\n        memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nHeaderWhitelist {\n  bool HeaderWhitelist::matches(kj::StringPtr header) const {\n    // Convert to lower-case on stack.\n    KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n    memcpy(buffer.begin(), header.begin(), buffer.size());\n    toLower(buffer);\n    header = kj::StringPtr(buffer.begin(), header.size());\n  \n    auto iter = patterns.lower_bound(header);\n    if (iter != patterns.end() && *iter == header) {\n      return true;\n    }\n  \n    if (iter == patterns.begin()) return false;\n  \n    // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n    // because the character '*' sorts before all characters that are valid inside headers.\n    --iter;\n    if (iter->endsWith(\"*\")) {\n      // Check if prefix matches.\n      auto prefix = iter->slice(0, iter->size() - 1);\n      if (header.size() >= prefix.size() &&\n          memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [
            "parseETagList(capnp::Orphanage::getForMessageContaining(context), *match)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseETagList",
          "args": [
            "capnp::Orphanage::getForMessageContaining(context)",
            "*match"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "parseETagList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "447-464",
          "snippet": "capnp::Orphan<capnp::List<WebSession::ETag>> parseETagList(\n      capnp::Orphanage orphanage, kj::StringPtr text,\n      kj::Vector<kj::Tuple<kj::String, bool>> parsed = kj::Vector<kj::Tuple<kj::String, bool>>()) {\n    parsed.add(parseETagInternal(text));\n    if (text.size() > 0) {\n      KJ_REQUIRE(text[0] == ',', \"etag must be followed by comma\", text);\n      return parseETagList(orphanage, text, kj::mv(parsed));\n    } else {\n      auto result = orphanage.newOrphan<capnp::List<WebSession::ETag>>(parsed.size());\n      auto list = result.get();\n      for (size_t i: kj::indices(parsed)) {\n        auto etag = list[i];\n        etag.setValue(kj::get<0>(parsed[i]));\n        etag.setWeak(kj::get<1>(parsed[i]));\n      }\n      return result;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\ncapnp::Orphan<capnp::List<WebSession::ETag>> parseETagList(\n      capnp::Orphanage orphanage, kj::StringPtr text,\n      kj::Vector<kj::Tuple<kj::String, bool>> parsed = kj::Vector<kj::Tuple<kj::String, bool>>()) {\n    parsed.add(parseETagInternal(text));\n    if (text.size() > 0) {\n      KJ_REQUIRE(text[0] == ',', \"etag must be followed by comma\", text);\n      return parseETagList(orphanage, text, kj::mv(parsed));\n    } else {\n      auto result = orphanage.newOrphan<capnp::List<WebSession::ETag>>(parsed.size());\n      auto list = result.get();\n      for (size_t i: kj::indices(parsed)) {\n        auto etag = list[i];\n        etag.setValue(kj::get<0>(parsed[i]));\n        etag.setWeak(kj::get<1>(parsed[i]));\n      }\n      return result;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "context"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [
            "parseETagList(capnp::Orphanage::getForMessageContaining(context), *match)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "context"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getETagPrecondition",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "match",
            "headers.get(hIfMatch)"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setQValue",
          "args": [
            "trim(part).parseAs<float>()"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "part"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splitFirst",
          "args": [
            "part",
            "'='"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [
            "1",
            "parts.size()"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setContentCoding",
          "args": [
            "trim(parts[0])"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "items"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initAcceptEncoding",
          "args": [
            "items.size()"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setQValue",
          "args": [
            "trim(part).parseAs<float>()"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [
            "1",
            "parts.size()"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.asPtr",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setMimeType",
          "args": [
            "trim(parts[0])"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "items"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initAccept",
          "args": [
            "items.size()"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.setResponseStream",
          "args": [
            "kj::mv(paf.promise)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<ByteStream::Client>",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Own<kj::PromiseFulfiller<ByteStream::Client>> initContext(\n      WebSession::Context::Builder context, const kj::HttpHeaders& headers) {\n    // We intentionally ignore cookies.\n\n    auto paf = kj::newPromiseAndFulfiller<ByteStream::Client>();\n    context.setResponseStream(kj::mv(paf.promise));\n\n    KJ_IF_MAYBE(accept, headers.get(hAccept)) {\n      auto items = split(*accept, ',');\n      auto list = context.initAccept(items.size());\n      for (size_t i: kj::indices(items)) {\n        auto item = items[i];\n        auto builder = list[i];\n\n        auto parts = split(item, ';');\n        builder.setMimeType(trim(parts[0]));\n\n        for (auto part: parts.asPtr().slice(1, parts.size())) {\n          KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n            if (trim(*name) == \"q\") {\n              builder.setQValue(trim(part).parseAs<float>());\n            }\n          }\n        }\n      }\n    }\n\n    KJ_IF_MAYBE(accept, headers.get(hAcceptEncoding)) {\n      auto items = split(*accept, ',');\n      auto list = context.initAcceptEncoding(items.size());\n      for (size_t i: kj::indices(items)) {\n        auto item = items[i];\n        auto builder = list[i];\n\n        auto parts = split(item, ';');\n        builder.setContentCoding(trim(parts[0]));\n\n        for (auto part: parts.asPtr().slice(1, parts.size())) {\n          KJ_IF_MAYBE(name, splitFirst(part, '=')) {\n            if (trim(*name) == \"q\") {\n              builder.setQValue(trim(part).parseAs<float>());\n            }\n          }\n        }\n      }\n    }\n\n    KJ_IF_MAYBE(match, headers.get(hIfMatch)) {\n      if (*match == \"*\") {\n        context.getETagPrecondition().setExists();\n      } else {\n        context.getETagPrecondition().adoptMatchesOneOf(\n            parseETagList(capnp::Orphanage::getForMessageContaining(context), *match));\n      }\n    } else KJ_IF_MAYBE(match, headers.get(hIfNoneMatch)) {\n      if (*match == \"*\") {\n        context.getETagPrecondition().setDoesntExist();\n      } else {\n        context.getETagPrecondition().adoptMatchesNoneOf(\n            parseETagList(capnp::Orphanage::getForMessageContaining(context), *match));\n      }\n    }\n\n    kj::Vector<kj::Tuple<kj::StringPtr, kj::StringPtr>> whitelisted;\n    headers.forEach([&](kj::StringPtr name, kj::StringPtr value) {\n      if (requestHeaderWhitelist.matches(name)) {\n        whitelisted.add(kj::tuple(name, value));\n      }\n    });\n    if (whitelisted.size() > 0) {\n      auto list = context.initAdditionalHeaders(whitelisted.size());\n      for (size_t i: kj::indices(whitelisted)) {\n        auto out = list[i];\n        out.setName(kj::get<0>(whitelisted[i]));\n        out.setValue(kj::get<1>(whitelisted[i]));\n      }\n    }\n\n    return kj::mv(paf.fulfiller);\n  }"
  },
  {
    "function_name": "dispatchToSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "237-252",
    "snippet": "kj::Promise<void> dispatchToSession(ApiSession::Client session,\n      kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) {\n    // TODO(cleanup): Factor this out into a reusable component that adapts\n    //   HttpService -> WebSession. We could then consider moving the HTTP proxy code out of the\n    //   Sandstorm shell, replacing it with this! Which would be amazing!\n\n    kj::StringPtr path;\n\n    KJ_IF_MAYBE(p, removePrefix(\"http://\", url)) {\n      path = *p;\n    } else KJ_IF_MAYBE(p, removePrefix(\"https://\", url)) {\n      path = *p;\n    } else {\n      KJ_FAIL_REQUIRE(\"unknown protocol\", url);\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"unknown protocol\"",
            "url"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "removePrefix",
          "args": [
            "\"https://\"",
            "url"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "removePrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "28-34",
          "snippet": "kj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "removePrefix(\"http://\", url)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> dispatchToSession(ApiSession::Client session,\n      kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) {\n    // TODO(cleanup): Factor this out into a reusable component that adapts\n    //   HttpService -> WebSession. We could then consider moving the HTTP proxy code out of the\n    //   Sandstorm shell, replacing it with this! Which would be amazing!\n\n    kj::StringPtr path;\n\n    KJ_IF_MAYBE(p, removePrefix(\"http://\", url)) {\n      path = *p;\n    } else KJ_IF_MAYBE(p, removePrefix(\"https://\", url)) {\n      path = *p;\n    } else {\n      KJ_FAIL_REQUIRE(\"unknown protocol\", url);\n    }"
  },
  {
    "function_name": "getHttpSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "215-235",
    "snippet": "ApiSession::Client getHttpSession(kj::StringPtr token) {\n    auto iter = tokenMap.find(token);\n    if (iter == tokenMap.end()) {\n      // Use a CapRedirector to automatically reconnect after disconnects. Keep in mind that due\n      // to refcounting, the CapRedirector could outlive the BridgeProxy. Luckily it doesn't need\n      // to capture \"this\".\n      auto cap = capnp::Capability::Client(\n          kj::heap<CapRedirector>([sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      })).castAs<ApiSession>();\n\n      TokenInfo info { kj::heapString(token), cap };\n      kj::StringPtr key = info.key;\n      tokenMap.insert(std::make_pair(key, kj::mv(info)));\n      return kj::mv(cap);\n    } else {\n      return iter->second.cap;\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokenMap.insert",
          "args": [
            "std::make_pair(key, kj::mv(info))"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "key",
            "kj::mv(info)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "info"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "token"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Capability::Client",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Capability::Client",
          "args": [
            "kj::heap<CapRedirector>([sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      })"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<CapRedirector>",
          "args": [
            "[sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      }"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "base64Decode(token)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64Decode",
          "args": [
            "token"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "base64Decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "764-780",
          "snippet": "kj::Array<byte> base64Decode(kj::StringPtr input) {\n  base64_decodestate state;\n  base64_init_decodestate(&state);\n\n  auto output = kj::heapArray<byte>((input.size() * 6 + 7) / 8);\n\n  size_t n = base64_decode_block(input.begin(), input.size(),\n      reinterpret_cast<char*>(output.begin()), &state);\n\n  if (n < output.size()) {\n    auto copy = kj::heapArray<byte>(n);\n    memcpy(copy.begin(), output.begin(), n);\n    output = kj::mv(copy);\n  }\n\n  return output;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> base64Decode(kj::StringPtr input) {\n  base64_decodestate state;\n  base64_init_decodestate(&state);\n\n  auto output = kj::heapArray<byte>((input.size() * 6 + 7) / 8);\n\n  size_t n = base64_decode_block(input.begin(), input.size(),\n      reinterpret_cast<char*>(output.begin()), &state);\n\n  if (n < output.size()) {\n    auto copy = kj::heapArray<byte>(n);\n    memcpy(copy.begin(), output.begin(), n);\n    output = kj::mv(copy);\n  }\n\n  return output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sandstormApi.restoreRequest",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "token"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokenMap.end",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokenMap.find",
          "args": [
            "token"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nApiSession::Client getHttpSession(kj::StringPtr token) {\n    auto iter = tokenMap.find(token);\n    if (iter == tokenMap.end()) {\n      // Use a CapRedirector to automatically reconnect after disconnects. Keep in mind that due\n      // to refcounting, the CapRedirector could outlive the BridgeProxy. Luckily it doesn't need\n      // to capture \"this\".\n      auto cap = capnp::Capability::Client(\n          kj::heap<CapRedirector>([sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      })).castAs<ApiSession>();\n\n      TokenInfo info { kj::heapString(token), cap };\n      kj::StringPtr key = info.key;\n      tokenMap.insert(std::make_pair(key, kj::mv(info)));\n      return kj::mv(cap);\n    } else {\n      return iter->second.cap;\n    }\n  }"
  },
  {
    "function_name": "sendError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "207-213",
    "snippet": "kj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText,\n                              kj::HttpHeaders& headers) {\n    auto stream = response.send(statusCode, statusText, headers, statusText.size());\n    auto promise = stream->write(statusText.begin(), statusText.size());\n    return promise.attach(kj::mv(stream));\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "statusText.begin()",
            "statusText.size()"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statusText.size",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statusText.begin",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.send",
          "args": [
            "statusCode",
            "statusText",
            "headers",
            "statusText.size()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText,\n                              kj::HttpHeaders& headers) {\n    auto stream = response.send(statusCode, statusText, headers, statusText.size());\n    auto promise = stream->write(statusText.begin(), statusText.size());\n    return promise.attach(kj::mv(stream));\n  }"
  },
  {
    "function_name": "sendError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "201-205",
    "snippet": "kj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText) {\n    kj::HttpHeaders headers(headerTable);\n    return sendError(response, statusCode, statusText, headers);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendError",
          "args": [
            "response",
            "statusCode",
            "statusText",
            "headers"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "sendError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "207-213",
          "snippet": "kj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText,\n                              kj::HttpHeaders& headers) {\n    auto stream = response.send(statusCode, statusText, headers, statusText.size());\n    auto promise = stream->write(statusText.begin(), statusText.size());\n    return promise.attach(kj::mv(stream));\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> sendError(kj::HttpService::Response& response,\n                              uint statusCode, kj::StringPtr statusText) {\n    kj::HttpHeaders headers(headerTable);\n    return sendError(response, statusCode, statusText, headers);\n  }"
  },
  {
    "function_name": "lookupStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "190-199",
    "snippet": "inline HttpStatusDescriptor::Reader lookupStatus(\n      kj::ArrayPtr<HttpStatusDescriptor::Reader> table,\n      T codeEnum) {\n    if (static_cast<uint>(codeEnum) < table.size()) {\n      return table[static_cast<uint>(codeEnum)];\n    } else {\n      // The first item in each table happens to be a reasonable generic code for that table.\n      return table.front();\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table.front",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "codeEnum"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table.size",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "codeEnum"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\ninline HttpStatusDescriptor::Reader lookupStatus(\n      kj::ArrayPtr<HttpStatusDescriptor::Reader> table,\n      T codeEnum) {\n    if (static_cast<uint>(codeEnum) < table.size()) {\n      return table[static_cast<uint>(codeEnum)];\n    } else {\n      // The first item in each table happens to be a reasonable generic code for that table.\n      return table.front();\n    }\n  }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": "BridgeProxy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "144-150",
    "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatchToSession",
          "args": [
            "kj::mv(session)",
            "method",
            "url",
            "headers",
            "requestBody",
            "response"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "dispatchToSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "237-252",
          "snippet": "kj::Promise<void> dispatchToSession(ApiSession::Client session,\n      kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) {\n    // TODO(cleanup): Factor this out into a reusable component that adapts\n    //   HttpService -> WebSession. We could then consider moving the HTTP proxy code out of the\n    //   Sandstorm shell, replacing it with this! Which would be amazing!\n\n    kj::StringPtr path;\n\n    KJ_IF_MAYBE(p, removePrefix(\"http://\", url)) {\n      path = *p;\n    } else KJ_IF_MAYBE(p, removePrefix(\"https://\", url)) {\n      path = *p;\n    } else {\n      KJ_FAIL_REQUIRE(\"unknown protocol\", url);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Promise<void> dispatchToSession(ApiSession::Client session,\n      kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) {\n    // TODO(cleanup): Factor this out into a reusable component that adapts\n    //   HttpService -> WebSession. We could then consider moving the HTTP proxy code out of the\n    //   Sandstorm shell, replacing it with this! Which would be amazing!\n\n    kj::StringPtr path;\n\n    KJ_IF_MAYBE(p, removePrefix(\"http://\", url)) {\n      path = *p;\n    } else KJ_IF_MAYBE(p, removePrefix(\"https://\", url)) {\n      path = *p;\n    } else {\n      KJ_FAIL_REQUIRE(\"unknown protocol\", url);\n    }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "session"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getHttpSession",
          "args": [
            "token"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "getHttpSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "215-235",
          "snippet": "ApiSession::Client getHttpSession(kj::StringPtr token) {\n    auto iter = tokenMap.find(token);\n    if (iter == tokenMap.end()) {\n      // Use a CapRedirector to automatically reconnect after disconnects. Keep in mind that due\n      // to refcounting, the CapRedirector could outlive the BridgeProxy. Luckily it doesn't need\n      // to capture \"this\".\n      auto cap = capnp::Capability::Client(\n          kj::heap<CapRedirector>([sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      })).castAs<ApiSession>();\n\n      TokenInfo info { kj::heapString(token), cap };\n      kj::StringPtr key = info.key;\n      tokenMap.insert(std::make_pair(key, kj::mv(info)));\n      return kj::mv(cap);\n    } else {\n      return iter->second.cap;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nApiSession::Client getHttpSession(kj::StringPtr token) {\n    auto iter = tokenMap.find(token);\n    if (iter == tokenMap.end()) {\n      // Use a CapRedirector to automatically reconnect after disconnects. Keep in mind that due\n      // to refcounting, the CapRedirector could outlive the BridgeProxy. Luckily it doesn't need\n      // to capture \"this\".\n      auto cap = capnp::Capability::Client(\n          kj::heap<CapRedirector>([sandstormApi=sandstormApi,token=kj::str(token)]() mutable {\n        auto req = sandstormApi.restoreRequest();\n        req.setToken(base64Decode(token));\n        return req.send().getCap();\n      })).castAs<ApiSession>();\n\n      TokenInfo info { kj::heapString(token), cap };\n      kj::StringPtr key = info.key;\n      tokenMap.insert(std::make_pair(key, kj::mv(info)));\n      return kj::mv(cap);\n    } else {\n      return iter->second.cap;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "auth->slice",
          "args": [
            "strlen(\"bearer \")"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"bearer \""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth->startsWith",
          "args": [
            "\"Bearer \""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth->startsWith",
          "args": [
            "\"bearer \""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
  },
  {
    "function_name": "request",
    "container": "BridgeProxy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "78-142",
    "snippet": "kj::Promise<void> request(\n      kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n      kj::AsyncInputStream& requestBody, Response& response) override {\n    KJ_IF_MAYBE(pathStr, removePrefix(\"http://http-bridge/\", url)) {\n      KJ_REQUIRE(pathStr->findFirst('?') == nullptr, \"unrecognized query string\", url);\n      auto path = KJ_MAP(part, split(*pathStr, '/')) { return kj::heapString(part); };\n\n      if (path.size() > 2 && path[0] == \"session\" && path[2] == \"claim\" &&\n          method == kj::HttpMethod::POST) {\n        // POST /session/<id>/claim -- do a claimRequest().\n\n        auto context = ({\n          auto req = bridge.getSessionContextRequest();\n          req.setId(path[1]);\n          req.send().getContext();\n        });\n\n        return requestBody.readAllText()\n            .then([this,KJ_MVCAP(context)](kj::String body) mutable\n                -> kj::Promise<capnp::Response<SandstormApi<BridgeObjectId>::SaveResults>> {\n          capnp::MallocMessageBuilder builder(128);\n          auto parsedRequest = builder.initRoot<ProxyClaimRequestRequest>();\n          capnp::JsonCodec json;\n          json.decode(body, parsedRequest);\n\n          auto req = context.claimRequestRequest();\n          req.setRequestToken(parsedRequest.getRequestToken());\n\n          auto permissionDefs = config.getViewInfo().getPermissions();\n          auto requiredPerms = KJ_MAP(name, parsedRequest.getRequiredPermissions())\n                                       -> kj::StringPtr { return name; };\n\n          auto permArray = req.initRequiredPermissions(permissionDefs.size());\n\n          for (size_t i: kj::indices(permissionDefs)) {\n            auto defName = permissionDefs[i].getName();\n\n            for (auto& reqName: requiredPerms) {\n              if (reqName == defName) {\n                permArray.set(i, true);\n              }\n            }\n          }\n\n          auto req2 = sandstormApi.saveRequest();\n          req2.setCap(req.send().getCap());\n          req2.setLabel(parsedRequest.getLabel());\n          return req2.send();\n        }).then([this,&response]\n            (capnp::Response<SandstormApi<BridgeObjectId>::SaveResults>&& claim) {\n          capnp::MallocMessageBuilder builder(64);\n          auto root = builder.initRoot<ProxyClaimRequestResponse>();\n          root.setCap(base64Encode(claim.getToken(), false));\n\n          capnp::JsonCodec json;\n          kj::String text = json.encode(root);\n\n          kj::HttpHeaders headers(headerTable);\n          headers.set(hContentType, \"application/json; charset=UTF-8\");\n          auto stream = response.send(200, \"OK\", headers, text.size());\n          auto promise = stream->write(text.begin(), text.size());\n          return promise.attach(kj::mv(stream), kj::mv(text));\n        });\n      }\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "then",
          "args": [
            "[this,&response]\n            (capnp::Response<SandstormApi<BridgeObjectId>::SaveResults>&& claim) {\n          capnp::MallocMessageBuilder builder(64);\n          auto root = builder.initRoot<ProxyClaimRequestResponse>();\n          root.setCap(base64Encode(claim.getToken(), false));\n\n          capnp::JsonCodec json;\n          kj::String text = json.encode(root);\n\n          kj::HttpHeaders headers(headerTable);\n          headers.set(hContentType, \"application/json; charset=UTF-8\");\n          auto stream = response.send(200, \"OK\", headers, text.size());\n          auto promise = stream->write(text.begin(), text.size());\n          return promise.attach(kj::mv(stream), kj::mv(text));\n        }"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(stream)",
            "kj::mv(text)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "text"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream->write",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.send",
          "args": [
            "200",
            "\"OK\"",
            "headers",
            "text.size()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "headers.set",
          "args": [
            "hContentType",
            "\"application/json; charset=UTF-8\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.encode",
          "args": [
            "root"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.setCap",
          "args": [
            "base64Encode(claim.getToken(), false)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64Encode",
          "args": [
            "claim.getToken()",
            "false"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "base64Encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "630-670",
          "snippet": "kj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "claim.getToken",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRoot<ProxyClaimRequestResponse>",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req2.send",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req2.setLabel",
          "args": [
            "parsedRequest.getLabel()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsedRequest.getLabel",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req2.setCap",
          "args": [
            "req.send().getCap()"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormApi.saveRequest",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permArray.set",
          "args": [
            "i",
            "true"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permissionDefs[i].getName",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "permissionDefs"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initRequiredPermissions",
          "args": [
            "permissionDefs.size()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "name",
            "parsedRequest.getRequiredPermissions()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsedRequest.getRequiredPermissions",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getViewInfo",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config.getViewInfo",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setRequestToken",
          "args": [
            "parsedRequest.getRequestToken()"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsedRequest.getRequestToken",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.claimRequestRequest",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.decode",
          "args": [
            "body",
            "parsedRequest"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRoot<ProxyClaimRequestRequest>",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder",
          "args": [
            "128"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestBody.readAllText",
          "args": [
            "[this,KJ_MVCAP(context)](kj::Stringbody"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestBody.readAllText",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setId",
          "args": [
            "path[1]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridge.getSessionContextRequest",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "part"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "part",
            "split(*pathStr, '/')"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "*pathStr",
            "'/'"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "pathStr->findFirst('?') == nullptr",
            "\"unrecognized query string\"",
            "url"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathStr->findFirst",
          "args": [
            "'?'"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "pathStr",
            "removePrefix(\"http://http-bridge/\", url)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "removePrefix",
          "args": [
            "\"http://http-bridge/\"",
            "url"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "removePrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "28-34",
          "snippet": "kj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  kj::Promise<void> request(\n        kj::HttpMethod method, kj::StringPtr url, const kj::HttpHeaders& headers,\n        kj::AsyncInputStream& requestBody, Response& response) override {\n      KJ_IF_MAYBE(pathStr, removePrefix(\"http://http-bridge/\", url)) {\n        KJ_REQUIRE(pathStr->findFirst('?') == nullptr, \"unrecognized query string\", url);\n        auto path = KJ_MAP(part, split(*pathStr, '/')) { return kj::heapString(part); };\n  \n        if (path.size() > 2 && path[0] == \"session\" && path[2] == \"claim\" &&\n            method == kj::HttpMethod::POST) {\n          // POST /session/<id>/claim -- do a claimRequest().\n  \n          auto context = ({\n            auto req = bridge.getSessionContextRequest();\n            req.setId(path[1]);\n            req.send().getContext();\n          });\n  \n          return requestBody.readAllText()\n              .then([this,KJ_MVCAP(context)](kj::String body) mutable\n                  -> kj::Promise<capnp::Response<SandstormApi<BridgeObjectId>::SaveResults>> {\n            capnp::MallocMessageBuilder builder(128);\n            auto parsedRequest = builder.initRoot<ProxyClaimRequestRequest>();\n            capnp::JsonCodec json;\n            json.decode(body, parsedRequest);\n  \n            auto req = context.claimRequestRequest();\n            req.setRequestToken(parsedRequest.getRequestToken());\n  \n            auto permissionDefs = config.getViewInfo().getPermissions();\n            auto requiredPerms = KJ_MAP(name, parsedRequest.getRequiredPermissions())\n                                         -> kj::StringPtr { return name; };\n  \n            auto permArray = req.initRequiredPermissions(permissionDefs.size());\n  \n            for (size_t i: kj::indices(permissionDefs)) {\n              auto defName = permissionDefs[i].getName();\n  \n              for (auto& reqName: requiredPerms) {\n                if (reqName == defName) {\n                  permArray.set(i, true);\n                }\n              }\n            }\n  \n            auto req2 = sandstormApi.saveRequest();\n            req2.setCap(req.send().getCap());\n            req2.setLabel(parsedRequest.getLabel());\n            return req2.send();\n          }).then([this,&response]\n              (capnp::Response<SandstormApi<BridgeObjectId>::SaveResults>&& claim) {\n            capnp::MallocMessageBuilder builder(64);\n            auto root = builder.initRoot<ProxyClaimRequestResponse>();\n            root.setCap(base64Encode(claim.getToken(), false));\n  \n            capnp::JsonCodec json;\n            kj::String text = json.encode(root);\n  \n            kj::HttpHeaders headers(headerTable);\n            headers.set(hContentType, \"application/json; charset=UTF-8\");\n            auto stream = response.send(200, \"OK\", headers, text.size());\n            auto promise = stream->write(text.begin(), text.size());\n            return promise.attach(kj::mv(stream), kj::mv(text));\n          });\n        }\n      }\n}"
  },
  {
    "function_name": "responseHeaderWhitelist",
    "container": "BridgeProxy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "74-76",
    "snippet": "::Context::HEADER_WHITELIST),\n        responseHeaderWhitelist(*WebSession::Response::HEADER_WHITELIST) {\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  ::Context::HEADER_WHITELIST),\n          responseHeaderWhitelist(*WebSession::Response::HEADER_WHITELIST) {\n    }\n}"
  },
  {
    "function_name": "BridgeProxy",
    "container": "BridgeProxy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "48-69",
    "snippet": "BridgeProxy(SandstormApi<BridgeObjectId>::Client sandstormApi,\n              SandstormHttpBridge::Client bridge,\n              spk::BridgeConfig::Reader config,\n              kj::HttpHeaderTable::Builder& requestHeaders)\n      : sandstormApi(kj::mv(sandstormApi)),\n        bridge(kj::mv(bridge)),\n        config(config),\n        hAccept(requestHeaders.add(\"Accept\")),\n        hAcceptEncoding(requestHeaders.add(\"Accept-Encoding\")),\n        hAuthorization(requestHeaders.add(\"Authorization\")),\n        hContentDisposition(requestHeaders.add(\"Content-Disposition\")),\n        hContentEncoding(requestHeaders.add(\"Content-Encoding\")),\n        hContentLanguage(requestHeaders.add(\"Content-Language\")),\n        hContentType(requestHeaders.add(\"Content-Type\")),\n        hETag(requestHeaders.add(\"ETag\")),\n        hIfMatch(requestHeaders.add(\"If-Match\")),\n        hIfNoneMatch(requestHeaders.add(\"If-None-Match\")),\n        headerTable(requestHeaders.getFutureTable()),\n        successCodeTable(KJ_MAP(enumerant,\n              capnp::Schema::from<WebSession::Response::SuccessCode>().getEnumerants()) {\n          return getHttpStatusAnnotation(enumerant);\n        }",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getHttpStatusAnnotation",
          "args": [
            "enumerant"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "getHttpStatusAnnotation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "36-44",
          "snippet": "HttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nHttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "enumerant",
            "capnp::Schema::from<WebSession::Response::SuccessCode>().getEnumerants()"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::SuccessCode>",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Schema::from<WebSession::Response::SuccessCode>",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.getFutureTable",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"If-None-Match\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"If-Match\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"ETag\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Content-Type\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Content-Language\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Content-Encoding\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Content-Disposition\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Authorization\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Accept-Encoding\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestHeaders.add",
          "args": [
            "\"Accept\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bridge"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sandstormApi"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  BridgeProxy(SandstormApi<BridgeObjectId>::Client sandstormApi,\n                SandstormHttpBridge::Client bridge,\n                spk::BridgeConfig::Reader config,\n                kj::HttpHeaderTable::Builder& requestHeaders)\n        : sandstormApi(kj::mv(sandstormApi)),\n          bridge(kj::mv(bridge)),\n          config(config),\n          hAccept(requestHeaders.add(\"Accept\")),\n          hAcceptEncoding(requestHeaders.add(\"Accept-Encoding\")),\n          hAuthorization(requestHeaders.add(\"Authorization\")),\n          hContentDisposition(requestHeaders.add(\"Content-Disposition\")),\n          hContentEncoding(requestHeaders.add(\"Content-Encoding\")),\n          hContentLanguage(requestHeaders.add(\"Content-Language\")),\n          hContentType(requestHeaders.add(\"Content-Type\")),\n          hETag(requestHeaders.add(\"ETag\")),\n          hIfMatch(requestHeaders.add(\"If-Match\")),\n          hIfNoneMatch(requestHeaders.add(\"If-None-Match\")),\n          headerTable(requestHeaders.getFutureTable()),\n          successCodeTable(KJ_MAP(enumerant,\n                capnp::Schema::from<WebSession::Response::SuccessCode>().getEnumerants()) {\n            return getHttpStatusAnnotation(enumerant);\n          }\n}"
  },
  {
    "function_name": "getHttpStatusAnnotation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "36-44",
    "snippet": "HttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Missing httpStatus annotation on status code enumerant.\"",
            "enumerant.getProto().getName()"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getId",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getProto",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nHttpStatusDescriptor::Reader getHttpStatusAnnotation(capnp::EnumSchema::Enumerant enumerant) {\n  for (auto annotation: enumerant.getProto().getAnnotations()) {\n    if (annotation.getId() == HTTP_STATUS_ANNOTATION_ID) {\n      return annotation.getValue().getStruct().getAs<HttpStatusDescriptor>();\n    }\n  }\n  KJ_FAIL_ASSERT(\"Missing httpStatus annotation on status code enumerant.\",\n                 enumerant.getProto().getName());\n}"
  },
  {
    "function_name": "removePrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
    "lines": "28-34",
    "snippet": "kj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include <capnp/compat/json.h>",
      "#include <sandstorm/bridge-proxy.capnp.h>",
      "#include <sandstorm/api-session.capnp.h>",
      "#include <map>",
      "#include \"bridge-proxy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.slice",
          "args": [
            "prefix.size()"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.startsWith",
          "args": [
            "prefix"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nkj::Maybe<kj::StringPtr> removePrefix(kj::StringPtr prefix, kj::StringPtr str) {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.size());\n  } else {\n    return nullptr;\n  }\n}"
  }
]