[
  {
    "function_name": "doGetPublicKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
    "lines": "96-98",
    "snippet": "kj::String doGetPublicKey(kj::StringPtr appId) {\n  return appIdString(getPublicKeyForApp(appidBytes(appId), *TEST_APP_ID_REPLACEMENT_LIST));\n}",
    "includes": [
      "#include <set>",
      "#include <sandstorm/appid-replacements-test.capnp.h>",
      "#include <kj/test.h>",
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "getPublicKeyForApp(appidBytes(appId), *TEST_APP_ID_REPLACEMENT_LIST)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getPublicKeyForApp",
          "args": [
            "appidBytes(appId)",
            "*TEST_APP_ID_REPLACEMENT_LIST"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "getPublicKeyForApp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements.c++",
          "lines": "77-94",
          "snippet": "kj::Array<kj::byte> getPublicKeyForApp(kj::ArrayPtr<const kj::byte> appId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  auto appidOwnStr = appIdString(appId);\n  kj::StringPtr appidStr = appidOwnStr;\n  auto result = kj::heapArray(appId);\n\nretry:\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      appidStr = item.getReplacement();\n      KJ_ASSERT(tryParseAppId(appidStr, result));\n      goto retry;\n    }\n  }\n\n  return result;\n}",
          "includes": [
            "#include \"id-to-text.h\"",
            "#include \"appid-replacements.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> getPublicKeyForApp(kj::ArrayPtr<const kj::byte> appId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  auto appidOwnStr = appIdString(appId);\n  kj::StringPtr appidStr = appidOwnStr;\n  auto result = kj::heapArray(appId);\n\nretry:\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      appidStr = item.getReplacement();\n      KJ_ASSERT(tryParseAppId(appidStr, result));\n      goto retry;\n    }\n  }\n\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appidBytes",
          "args": [
            "appId"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "appidBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
          "lines": "26-30",
          "snippet": "kj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/appid-replacements-test.capnp.h>",
            "#include <kj/test.h>",
            "#include \"id-to-text.h\"",
            "#include \"appid-replacements.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::String doGetPublicKey(kj::StringPtr appId) {\n  return appIdString(getPublicKeyForApp(appidBytes(appId), *TEST_APP_ID_REPLACEMENT_LIST));\n}"
  },
  {
    "function_name": "doReplacement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
    "lines": "90-94",
    "snippet": "kj::String doReplacement(kj::StringPtr appId, kj::StringPtr packageId) {\n  auto bytes = appidBytes(appId);\n  applyAppidReplacements(bytes, pkgidBytes(packageId), *TEST_APP_ID_REPLACEMENT_LIST);\n  return appIdString(bytes);\n}",
    "includes": [
      "#include <set>",
      "#include <sandstorm/appid-replacements-test.capnp.h>",
      "#include <kj/test.h>",
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "bytes"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "applyAppidReplacements",
          "args": [
            "bytes",
            "pkgidBytes(packageId)",
            "*TEST_APP_ID_REPLACEMENT_LIST"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "applyAppidReplacements",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements.c++",
          "lines": "22-75",
          "snippet": "void applyAppidReplacements(\n    kj::ArrayPtr<kj::byte> appId, kj::ArrayPtr<const kj::byte> packageId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  // Given an input app ID that was just verified to have signed the given package ID,\n  // check appid-replacements.capnp to see if the app ID is revoked (throws exception) or the\n  // package should be treated as some other app (replaces appId).\n\n  // The logic here is slightly weird because the replacement list is organized into events --\n  // which makes it easier for people modifying it to understand what to do -- rather than into\n  // rules -- which could be more directly processed. Each event introduces one or two rules:\n  // a revocation of an original key (except for grandfathered whitelist) and a mapping of a\n  // replacement key to and original key.\n\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n\n  auto appidStr = appIdString(appId);\n  auto pkgidStr = packageIdString(packageId);\n\n  // First check if this app ID is revoked.\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      // The app ID matches the `original` of this entry. Check if it was revoked.\n      if (item.hasRevokeExceptPackageIds()) {\n        // This app ID is revoked, except for specific package IDs...\n        for (auto allowed: item.getRevokeExceptPackageIds()) {\n          if (pkgidStr == allowed) {\n            goto checkReplacements;  // Need to break outer loop...\n          }\n        }\n        KJ_FAIL_REQUIRE(\"package is signed with an app key that has been revoked\",\n                        appidStr, pkgidStr);\n      }\n    }\n  }\n\ncheckReplacements:\n  // Not revoked. Now check if it is a replacement.\n  for (auto item: replacements) {\n    if (item.getReplacement() == appidStr) {\n      // The app ID is a replacement. We want to make this package look like it uses the original\n      // ID, therefore we want to replace the replacement with the original.\n      KJ_ASSERT(tryParseAppId(item.getOriginal(), appId));\n\n      // We may have mapped the replacement ID back to an ID which has itself been replaced.\n      // So, we need to apply the replacements step again. We could make the rule that a second\n      // replacement for the same app should list the app's original-original ID as `original`, but\n      // this would mean that if the first replacement key needs to be revoked then two entries\n      // would need to be made, which is not intuitive.\n      appidStr = appIdString(appId);\n      goto checkReplacements;\n    }\n  }\n}",
          "includes": [
            "#include \"id-to-text.h\"",
            "#include \"appid-replacements.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nvoid applyAppidReplacements(\n    kj::ArrayPtr<kj::byte> appId, kj::ArrayPtr<const kj::byte> packageId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  // Given an input app ID that was just verified to have signed the given package ID,\n  // check appid-replacements.capnp to see if the app ID is revoked (throws exception) or the\n  // package should be treated as some other app (replaces appId).\n\n  // The logic here is slightly weird because the replacement list is organized into events --\n  // which makes it easier for people modifying it to understand what to do -- rather than into\n  // rules -- which could be more directly processed. Each event introduces one or two rules:\n  // a revocation of an original key (except for grandfathered whitelist) and a mapping of a\n  // replacement key to and original key.\n\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n\n  auto appidStr = appIdString(appId);\n  auto pkgidStr = packageIdString(packageId);\n\n  // First check if this app ID is revoked.\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      // The app ID matches the `original` of this entry. Check if it was revoked.\n      if (item.hasRevokeExceptPackageIds()) {\n        // This app ID is revoked, except for specific package IDs...\n        for (auto allowed: item.getRevokeExceptPackageIds()) {\n          if (pkgidStr == allowed) {\n            goto checkReplacements;  // Need to break outer loop...\n          }\n        }\n        KJ_FAIL_REQUIRE(\"package is signed with an app key that has been revoked\",\n                        appidStr, pkgidStr);\n      }\n    }\n  }\n\ncheckReplacements:\n  // Not revoked. Now check if it is a replacement.\n  for (auto item: replacements) {\n    if (item.getReplacement() == appidStr) {\n      // The app ID is a replacement. We want to make this package look like it uses the original\n      // ID, therefore we want to replace the replacement with the original.\n      KJ_ASSERT(tryParseAppId(item.getOriginal(), appId));\n\n      // We may have mapped the replacement ID back to an ID which has itself been replaced.\n      // So, we need to apply the replacements step again. We could make the rule that a second\n      // replacement for the same app should list the app's original-original ID as `original`, but\n      // this would mean that if the first replacement key needs to be revoked then two entries\n      // would need to be made, which is not intuitive.\n      appidStr = appIdString(appId);\n      goto checkReplacements;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkgidBytes",
          "args": [
            "packageId"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "pkgidBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
          "lines": "32-36",
          "snippet": "kj::Array<kj::byte> pkgidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(PACKAGE_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParsePackageId(id, result), \"invalid package ID\", id);\n  return result;\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/appid-replacements-test.capnp.h>",
            "#include <kj/test.h>",
            "#include \"id-to-text.h\"",
            "#include \"appid-replacements.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> pkgidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(PACKAGE_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParsePackageId(id, result), \"invalid package ID\", id);\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appidBytes",
          "args": [
            "appId"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "appidBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
          "lines": "26-30",
          "snippet": "kj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/appid-replacements-test.capnp.h>",
            "#include <kj/test.h>",
            "#include \"id-to-text.h\"",
            "#include \"appid-replacements.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::String doReplacement(kj::StringPtr appId, kj::StringPtr packageId) {\n  auto bytes = appidBytes(appId);\n  applyAppidReplacements(bytes, pkgidBytes(packageId), *TEST_APP_ID_REPLACEMENT_LIST);\n  return appIdString(bytes);\n}"
  },
  {
    "function_name": "pkgidBytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
    "lines": "32-36",
    "snippet": "kj::Array<kj::byte> pkgidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(PACKAGE_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParsePackageId(id, result), \"invalid package ID\", id);\n  return result;\n}",
    "includes": [
      "#include <set>",
      "#include <sandstorm/appid-replacements-test.capnp.h>",
      "#include <kj/test.h>",
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tryParsePackageId(id, result)",
            "\"invalid package ID\"",
            "id"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParsePackageId",
          "args": [
            "id",
            "result"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "tryParsePackageId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "198-219",
          "snippet": "bool tryParsePackageId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  if (in.size() != PACKAGE_ID_TEXT_SIZE) return false;\n\n  KJ_ASSERT(out.size() == PACKAGE_ID_BYTE_SIZE);\n\n  for (auto i: kj::indices(out)) {\n    byte b = 0;\n    KJ_IF_MAYBE(d, parseHexDigit(in[i*2])) {\n      b = *d << 4;\n    } else {\n      return false;\n    }\n    KJ_IF_MAYBE(d, parseHexDigit(in[i*2+1])) {\n      b |= *d;\n    } else {\n      return false;\n    }\n    out[i] = b;\n  }\n\n  return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nbool tryParsePackageId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  if (in.size() != PACKAGE_ID_TEXT_SIZE) return false;\n\n  KJ_ASSERT(out.size() == PACKAGE_ID_BYTE_SIZE);\n\n  for (auto i: kj::indices(out)) {\n    byte b = 0;\n    KJ_IF_MAYBE(d, parseHexDigit(in[i*2])) {\n      b = *d << 4;\n    } else {\n      return false;\n    }\n    KJ_IF_MAYBE(d, parseHexDigit(in[i*2+1])) {\n      b |= *d;\n    } else {\n      return false;\n    }\n    out[i] = b;\n  }\n\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::byte>",
          "args": [
            "PACKAGE_ID_BYTE_SIZE"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> pkgidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(PACKAGE_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParsePackageId(id, result), \"invalid package ID\", id);\n  return result;\n}"
  },
  {
    "function_name": "appidBytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements-test.c++",
    "lines": "26-30",
    "snippet": "kj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}",
    "includes": [
      "#include <set>",
      "#include <sandstorm/appid-replacements-test.capnp.h>",
      "#include <kj/test.h>",
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tryParseAppId(id, result)",
            "\"invalid app ID\"",
            "id"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParseAppId",
          "args": [
            "id",
            "result"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "tryParseAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "180-183",
          "snippet": "bool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nbool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::byte>",
          "args": [
            "APP_ID_BYTE_SIZE"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <set>\n#include <sandstorm/appid-replacements-test.capnp.h>\n#include <kj/test.h>\n#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> appidBytes(kj::StringPtr id) {\n  auto result = kj::heapArray<kj::byte>(APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(tryParseAppId(id, result), \"invalid app ID\", id);\n  return result;\n}"
  }
]