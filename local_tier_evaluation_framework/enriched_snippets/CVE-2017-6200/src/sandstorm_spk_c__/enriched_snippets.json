[
  {
    "function_name": "checkPgpSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2449-2465",
    "snippet": "kj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpkTool::checkPgpSignature",
          "args": [
            "appIdString",
            "author.getPgpSignature()",
            "metadata.getPgpKeyring()",
            "error",
            "sandboxUid"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.getPgpKeyring",
          "args": [],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "author.getPgpSignature",
          "args": [],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"PGP signature verification problem\"",
            "problem"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "metadata.hasPgpKeyring()",
            "\"package metadata contains PGP signature but no keyring\""
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.hasPgpKeyring",
          "args": [],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "author.hasPgpSignature",
          "args": [],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.getAuthor",
          "args": [],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);\n\nkj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "verifySpk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2443-2447",
    "snippet": "void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output) {\n  SpkTool::verifyImpl(spkfd, tmpfile, output, [](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk verification failed\", problem);\n  });\n}",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpkTool::verifyImpl",
          "args": [
            "spkfd",
            "tmpfile",
            "output",
            "[](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk verification failed\", problem);\n  }"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "verifyImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1395-1586",
          "snippet": "static kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"spk verification failed\"",
            "problem"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nvoid verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output) {\n  SpkTool::verifyImpl(spkfd, tmpfile, output, [](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk verification failed\", problem);\n  });\n}"
  },
  {
    "function_name": "unpackSpk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2436-2441",
    "snippet": "kj::String unpackSpk(int spkfd, kj::StringPtr outdir, kj::StringPtr tmpdir) {\n  return SpkTool::unpackImpl(spkfd, outdir, kj::str(tmpdir, \"/spk-unpack-tmp\"),\n      [](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk unpack failed\", problem);\n  });\n}",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend kj::String unpackSpk(int spkfd, kj::StringPtr outdir, kj::StringPtr tmpdir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpkTool::unpackImpl",
          "args": [
            "spkfd",
            "outdir",
            "kj::str(tmpdir, \"/spk-unpack-tmp\")",
            "[](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk unpack failed\", problem);\n  }"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "unpackImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1716-1748",
          "snippet": "static kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;",
            "kj::String dirname;",
            "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\nkj::String dirname;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nstatic kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"spk unpack failed\"",
            "problem"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "tmpdir",
            "\"/spk-unpack-tmp\""
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend kj::String unpackSpk(int spkfd, kj::StringPtr outdir, kj::StringPtr tmpdir);\n\nkj::String unpackSpk(int spkfd, kj::StringPtr outdir, kj::StringPtr tmpdir) {\n  return SpkTool::unpackImpl(spkfd, outdir, kj::str(tmpdir, \"/spk-unpack-tmp\"),\n      [](kj::StringPtr problem) -> kj::String {\n    KJ_FAIL_ASSERT(\"spk unpack failed\", problem);\n  });\n}"
  },
  {
    "function_name": "getSpkMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2432-2434",
    "snippet": "kj::Own<AbstractMain> getSpkMain(kj::ProcessContext& context) {\n  return kj::heap<SpkTool>(context);\n}",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<SpkTool>",
          "args": [
            "context"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Own<AbstractMain> getSpkMain(kj::ProcessContext& context) {\n  return kj::heap<SpkTool>(context);\n}"
  },
  {
    "function_name": "doPublish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2251-2284",
    "snippet": "kj::MainBuilder::Validity doPublish(kj::StringPtr spkfile) {\n    if (appIndexEndpoint == nullptr) {\n      context.exitError(\n          \"Hello! The publishing tool isn't quite ready yet, but if you have an app \"\n          \"you'd like to publish please email kenton@sandstorm.io with a link to the spk!\");\n    }\n\n    if (access(spkfile.cStr(), F_OK) < 0) {\n      return \"no such file\";\n    }\n\n    capnp::MallocMessageBuilder scratch;\n    auto arena = scratch.getOrphanage();\n\n    auto infoOrphan = arena.newOrphan<spk::VerifiedInfo>();\n    auto info = infoOrphan.get();\n    auto spkfd = raiiOpen(spkfile, O_RDONLY);\n    verifyImpl(spkfd, openTemporary(\"/tmp/spk-verify\"), info,\n        [&](kj::StringPtr problem) -> kj::String {\n      validationError(spkfile, problem);\n    });\n\n    auto key = lookupKey(appIdString(info.getAppId()));\n\n    capnp::MallocMessageBuilder requestMessage;\n    auto request = requestMessage.getRoot<appindex::SubmissionRequest>();\n    request.setPackageId(info.getPackageId());\n    KJ_IF_MAYBE(s, publishState) {\n      auto mutation = request.initSetState();\n      mutation.setNewState(*s);\n      mutation.setSequenceNumber(time(nullptr));\n    } else {\n      request.setCheckStatus();\n    }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "kj::Maybe<appindex::SubmissionState> publishState = appindex::SubmissionState::PUBLISH;",
      "kj::String appIndexEndpoint = kj::heapString(\"https://alpha-api.sandstorm.io\");"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request.setCheckStatus",
          "args": [],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutation.setSequenceNumber",
          "args": [
            "time(nullptr)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "nullptr"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutation.setNewState",
          "args": [
            "*s"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.initSetState",
          "args": [],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setPackageId",
          "args": [
            "info.getPackageId()"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info.getPackageId",
          "args": [],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requestMessage.getRoot<appindex::SubmissionRequest>",
          "args": [],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookupKey",
          "args": [
            "appIdString(info.getAppId())"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "lookupKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "411-447",
          "snippet": "spk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nspk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "info.getAppId()"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "info.getAppId",
          "args": [],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifyImpl",
          "args": [
            "spkfd",
            "openTemporary(\"/tmp/spk-verify\")",
            "info",
            "[&](kj::StringPtr problem) -> kj::String {\n      validationError(spkfile, problem);\n    }"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "verifyImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1395-1586",
          "snippet": "static kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "spkfile",
            "problem"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "validationError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1355-1357",
          "snippet": "[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\n[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "openTemporary",
          "args": [
            "\"/tmp/spk-verify\""
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "openTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "232-241",
          "snippet": "kj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "spkfile",
            "O_RDONLY"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "infoOrphan.get",
          "args": [],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.newOrphan<spk::VerifiedInfo>",
          "args": [],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch.getOrphanage",
          "args": [],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "spkfile.cStr()",
            "F_OK"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spkfile.cStr",
          "args": [],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "\"Hello! The publishing tool isn't quite ready yet, but if you have an app \"\n          \"you'd like to publish please email kenton@sandstorm.io with a link to the spk!\""
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nkj::Maybe<appindex::SubmissionState> publishState = appindex::SubmissionState::PUBLISH;\nkj::String appIndexEndpoint = kj::heapString(\"https://alpha-api.sandstorm.io\");\n\nkj::MainBuilder::Validity doPublish(kj::StringPtr spkfile) {\n    if (appIndexEndpoint == nullptr) {\n      context.exitError(\n          \"Hello! The publishing tool isn't quite ready yet, but if you have an app \"\n          \"you'd like to publish please email kenton@sandstorm.io with a link to the spk!\");\n    }\n\n    if (access(spkfile.cStr(), F_OK) < 0) {\n      return \"no such file\";\n    }\n\n    capnp::MallocMessageBuilder scratch;\n    auto arena = scratch.getOrphanage();\n\n    auto infoOrphan = arena.newOrphan<spk::VerifiedInfo>();\n    auto info = infoOrphan.get();\n    auto spkfd = raiiOpen(spkfile, O_RDONLY);\n    verifyImpl(spkfd, openTemporary(\"/tmp/spk-verify\"), info,\n        [&](kj::StringPtr problem) -> kj::String {\n      validationError(spkfile, problem);\n    });\n\n    auto key = lookupKey(appIdString(info.getAppId()));\n\n    capnp::MallocMessageBuilder requestMessage;\n    auto request = requestMessage.getRoot<appindex::SubmissionRequest>();\n    request.setPackageId(info.getPackageId());\n    KJ_IF_MAYBE(s, publishState) {\n      auto mutation = request.initSetState();\n      mutation.setNewState(*s);\n      mutation.setSequenceNumber(time(nullptr));\n    } else {\n      request.setCheckStatus();\n    }"
  },
  {
    "function_name": "setPublishWebkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2232-2249",
    "snippet": "kj::MainBuilder::Validity setPublishWebkey(kj::StringPtr webkey) {\n    auto parts = split(webkey, '#');\n    if (parts.size() != 2) return \"invalid webkey format\";\n\n    // Strip trailing slashes from host.\n    while (parts[0].size() > 0 && parts[0][parts[0].size() - 1] == '/') {\n      parts[0] = parts[0].slice(0, parts[0].size() - 1);\n    }\n\n    appIndexEndpoint = kj::str(parts[0]);\n    appIndexToken = kj::str(parts[1]);\n\n    if (!appIndexEndpoint.startsWith(\"http://\") && !appIndexEndpoint.startsWith(\"https://\")) {\n      return \"invalid webkey format\";\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String appIndexEndpoint = kj::heapString(\"https://alpha-api.sandstorm.io\");",
      "kj::String appIndexToken = kj::heapString(\"Rs-0TT13YrNSbv7Fiz5K9bBkLaJn3E5TB0PU1GSn1HE\");",
      "auto webkey = kj::str(appIndexEndpoint, '#', appIndexToken);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appIndexEndpoint.startsWith",
          "args": [
            "\"https://\""
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appIndexEndpoint.startsWith",
          "args": [
            "\"http://\""
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "parts[1]"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "parts[0]"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts[0].slice",
          "args": [
            "0",
            "parts[0].size() - 1"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts[0].size",
          "args": [],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "webkey",
            "'#'"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String appIndexEndpoint = kj::heapString(\"https://alpha-api.sandstorm.io\");\nkj::String appIndexToken = kj::heapString(\"Rs-0TT13YrNSbv7Fiz5K9bBkLaJn3E5TB0PU1GSn1HE\");\nauto webkey = kj::str(appIndexEndpoint, '#', appIndexToken);\n\nkj::MainBuilder::Validity setPublishWebkey(kj::StringPtr webkey) {\n    auto parts = split(webkey, '#');\n    if (parts.size() != 2) return \"invalid webkey format\";\n\n    // Strip trailing slashes from host.\n    while (parts[0].size() > 0 && parts[0][parts[0].size() - 1] == '/') {\n      parts[0] = parts[0].slice(0, parts[0].size() - 1);\n    }\n\n    appIndexEndpoint = kj::str(parts[0]);\n    appIndexToken = kj::str(parts[1]);\n\n    if (!appIndexEndpoint.startsWith(\"http://\") && !appIndexEndpoint.startsWith(\"https://\")) {\n      return \"invalid webkey format\";\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "getPublishMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2208-2230",
    "snippet": "kj::MainFunc getPublishMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Publish an SPK to the Sandstorm app index, or check the status of a \"\n            \"previous submission.\")\n        .addOption({'s', \"status\"}, [this]() {publishState = nullptr; return true;},\n            \"Just check the review status of a previously-submitted SPK.\")\n        .addOption({'e', \"embargo\"},\n            [this]() {publishState = appindex::SubmissionState::REVIEW; return true;},\n            \"Embargoes the package, preventing it from being published publicly. However, \"\n            \"it will still be actively reviewed. You may run the command again later without \"\n            \"this flag to mark the app for publishing. This allows you to submit an app for \"\n            \"review in advance of a launch date but still control the exact time of launch.\")\n        .addOption({'r', \"remove\"},\n            [this]() {publishState = appindex::SubmissionState::IGNORE; return true;},\n            \"Removes a package listing. If the package was published, it is un-published. If the \"\n            \"package was still pending review, the review is canceled.\")\n        .addOptionWithArg({\"webkey\"}, KJ_BIND_METHOD(*this, setPublishWebkey), \"<webkey>\",\n            \"Submit to the index at the given webkey. If not specified, the main Sandstorm \"\n            \"app index is assumed.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, doPublish)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "kj::Maybe<appindex::SubmissionState> publishState = appindex::SubmissionState::PUBLISH;",
      "auto webkey = kj::str(appIndexEndpoint, '#', appIndexToken);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::KEYS_READONLY",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Publish an SPK to the Sandstorm app index, or check the status of a \"\n            \"previous submission.\")\n        .addOption({'s', \"status\"}, [this]() {publishState = nullptr; return true;},\n            \"Just check the review status of a previously-submitted SPK.\")\n        .addOption({'e', \"embargo\"},\n            [this]() {publishState = appindex::SubmissionState::REVIEW; return true;},\n            \"Embargoes the package, preventing it from being published publicly. However, \"\n            \"it will still be actively reviewed. You may run the command again later without \"\n            \"this flag to mark the app for publishing. This allows you to submit an app for \"\n            \"review in advance of a launch date but still control the exact time of launch.\")\n        .addOption({'r', \"remove\"},\n            [this]() {publishState = appindex::SubmissionState::IGNORE; return true;},\n            \"Removes a package listing. If the package was published, it is un-published. If the \"\n            \"package was still pending review, the review is canceled.\")\n        .addOptionWithArg({\"webkey\"}, KJ_BIND_METHOD(*this, setPublishWebkey), \"<webkey>\",\n            \"Submit to the index at the given webkey. If not specified, the main Sandstorm \"\n            \"app index is assumed.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, doPublish))"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<spkfile>\"",
            "KJ_BIND_METHOD(*this, doPublish)"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doPublish"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"webkey\"}",
            "KJ_BIND_METHOD(*this, setPublishWebkey)",
            "\"<webkey>\"",
            "\"Submit to the index at the given webkey. If not specified, the main Sandstorm \"\n            \"app index is assumed.\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setPublishWebkey"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'r', \"remove\"}",
            "[this]() {publishState = appindex::SubmissionState::IGNORE; return true;}",
            "\"Removes a package listing. If the package was published, it is un-published. If the \"\n            \"package was still pending review, the review is canceled.\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'e', \"embargo\"}",
            "[this]() {publishState = appindex::SubmissionState::REVIEW; return true;}",
            "\"Embargoes the package, preventing it from being published publicly. However, \"\n            \"it will still be actively reviewed. You may run the command again later without \"\n            \"this flag to mark the app for publishing. This allows you to submit an app for \"\n            \"review in advance of a launch date but still control the exact time of launch.\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'s', \"status\"}",
            "[this]() {publishState = nullptr; return true;}",
            "\"Just check the review status of a previously-submitted SPK.\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Publish an SPK to the Sandstorm app index, or check the status of a \"\n            \"previous submission.\""
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nkj::Maybe<appindex::SubmissionState> publishState = appindex::SubmissionState::PUBLISH;\nauto webkey = kj::str(appIndexEndpoint, '#', appIndexToken);\n\nkj::MainFunc getPublishMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Publish an SPK to the Sandstorm app index, or check the status of a \"\n            \"previous submission.\")\n        .addOption({'s', \"status\"}, [this]() {publishState = nullptr; return true;},\n            \"Just check the review status of a previously-submitted SPK.\")\n        .addOption({'e', \"embargo\"},\n            [this]() {publishState = appindex::SubmissionState::REVIEW; return true;},\n            \"Embargoes the package, preventing it from being published publicly. However, \"\n            \"it will still be actively reviewed. You may run the command again later without \"\n            \"this flag to mark the app for publishing. This allows you to submit an app for \"\n            \"review in advance of a launch date but still control the exact time of launch.\")\n        .addOption({'r', \"remove\"},\n            [this]() {publishState = appindex::SubmissionState::IGNORE; return true;},\n            \"Removes a package listing. If the package was published, it is un-published. If the \"\n            \"package was still pending review, the review is canceled.\")\n        .addOptionWithArg({\"webkey\"}, KJ_BIND_METHOD(*this, setPublishWebkey), \"<webkey>\",\n            \"Submit to the index at the given webkey. If not specified, the main Sandstorm \"\n            \"app index is assumed.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, doPublish)))\n        .build();\n  }"
  },
  {
    "function_name": "pipeToStdout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "2175-2196",
    "snippet": "static kj::Promise<void> pipeToStdout(kj::UnixEventPort::FdObserver& observer, int fd) {\n    // Asynchronously read all data from fd and write it to STDOUT.\n    // TODO(cleanup): Use KJ I/O facilities. Requires making it possible to construct\n    //   kj::LowLevelAsyncIoProvider directly from UnixEventPort.\n\n    for (;;) {\n      ssize_t n;\n      char buffer[1024];\n      KJ_NONBLOCKING_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n\n      if (n < 0) {\n        // Got EAGAIN.\n        return observer.whenBecomesReadable().then([&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        });\n      } else if (n == 0) {\n        return kj::READY_NOW;\n      }\n\n      kj::FdOutputStream(STDOUT_FILENO).write(buffer, n);\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Array<capnp::word>> data;",
      "byte buffer[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "buffer",
            "n"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        }"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeToStdout",
          "args": [
            "observer",
            "fd"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "pipeToStdout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "2175-2196",
          "snippet": "static kj::Promise<void> pipeToStdout(kj::UnixEventPort::FdObserver& observer, int fd) {\n    // Asynchronously read all data from fd and write it to STDOUT.\n    // TODO(cleanup): Use KJ I/O facilities. Requires making it possible to construct\n    //   kj::LowLevelAsyncIoProvider directly from UnixEventPort.\n\n    for (;;) {\n      ssize_t n;\n      char buffer[1024];\n      KJ_NONBLOCKING_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n\n      if (n < 0) {\n        // Got EAGAIN.\n        return observer.whenBecomesReadable().then([&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        });\n      } else if (n == 0) {\n        return kj::READY_NOW;\n      }\n\n      kj::FdOutputStream(STDOUT_FILENO).write(buffer, n);\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = read(fd, buffer, sizeof(buffer))"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::Promise<void> pipeToStdout(kj::UnixEventPort::FdObserver& observer, int fd) {\n    // Asynchronously read all data from fd and write it to STDOUT.\n    // TODO(cleanup): Use KJ I/O facilities. Requires making it possible to construct\n    //   kj::LowLevelAsyncIoProvider directly from UnixEventPort.\n\n    for (;;) {\n      ssize_t n;\n      char buffer[1024];\n      KJ_NONBLOCKING_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n\n      if (n < 0) {\n        // Got EAGAIN.\n        return observer.whenBecomesReadable().then([&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        });\n      } else if (n == 0) {\n        return kj::READY_NOW;\n      }\n\n      kj::FdOutputStream(STDOUT_FILENO).write(buffer, n);\n    }\n  }"
  },
  {
    "function_name": "doDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1947-2173",
    "snippet": "kj::MainBuilder::Validity doDev() {\n    ensurePackageDefParsed();\n\n    if (serverBinary == nullptr) {\n      // Try to find the server. First try looking where `spk` is installed.\n      KJ_IF_MAYBE(i, installHome) {\n        auto candidate = kj::str(*i, \"/sandstorm\");\n        if (access(candidate.cStr(), F_OK) == 0) {\n          struct stat stats;\n          KJ_SYSCALL(stat(candidate.cStr(), &stats));\n          if (S_ISREG(stats.st_mode) && stats.st_mode & S_IXUSR) {\n            // Indeed!\n            serverBinary = kj::mv(candidate);\n          }\n        }\n      }\n\n      if (serverBinary == nullptr) {\n        // Try checking for an init script.\n        kj::StringPtr candidate = \"/etc/init.d/sandstorm\";\n        if (access(candidate.cStr(), F_OK) == 0) {\n          serverBinary = kj::str(candidate);\n        }\n      }\n\n      if (serverBinary == nullptr) {\n        return \"Couldn't find Sandstorm server installation. Please use -s to specify it.\";\n      }\n    }\n\n    kj::AutoCloseFd fuseFd;\n    kj::Maybe<kj::AutoCloseFd> connection;\n    kj::Maybe<kj::Own<FuseMount>> fuseMount;\n\n    if (mountDir == nullptr) {\n      // call \"sandstorm dev\"\n\n      // Create a unix socket over which to receive the fuse FD.\n      int serverSocket[2];\n      KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, serverSocket));\n      kj::AutoCloseFd clientEnd(serverSocket[0]);\n      kj::AutoCloseFd serverEnd(serverSocket[1]);\n\n      // Run \"sandstorm dev\".\n      pid_t sandstormPid = fork();\n      if (sandstormPid == 0) {\n        dup2(serverEnd, STDIN_FILENO);\n        dup2(serverEnd, STDOUT_FILENO);\n\n        KJ_SYSCALL(execl(serverBinary.cStr(), serverBinary.cStr(), \"dev\", (char*)nullptr),\n                   serverBinary);\n        KJ_UNREACHABLE;\n      }\n\n      serverEnd = nullptr;\n\n      // Write the app ID to the socket.\n      {\n        auto msg = kj::str(packageDef.getId(), \"\\n\");\n        kj::FdOutputStream((int)clientEnd).write(msg.begin(), msg.size());\n      }\n\n      // Write the mountProc option to the socket.\n      {\n        auto msg = kj::str(mountProc ? \"1\" : \"0\", \"\\n\");\n        kj::FdOutputStream((int)clientEnd).write(msg.begin(), msg.size());\n      }\n\n      // The server connection starts by sending us the FUSE FD.\n      fuseFd = receiveFd(clientEnd, [](kj::ArrayPtr<const kj::byte> bytes) {\n        // Got some data. Pipe it to stdout.\n        kj::FdOutputStream(STDOUT_FILENO).write(bytes.begin(), bytes.size());\n      });\n\n      // Switch connection to async I/O.\n      {\n        int flags;\n        KJ_SYSCALL(flags = fcntl(clientEnd, F_GETFL));\n        if ((flags & O_NONBLOCK) == 0) {\n          KJ_SYSCALL(fcntl(clientEnd, F_SETFL, flags | O_NONBLOCK));\n        }\n      }\n\n      connection = kj::mv(clientEnd);\n    } else {\n      // Just mount directly.\n\n      auto mount = kj::heap<FuseMount>(mountDir, \"\");\n      fuseFd = mount->disownFd();\n      fuseMount = kj::mv(mount);\n    }\n\n    std::set<kj::String> usedFiles;\n\n    {\n      kj::UnixEventPort::captureSignal(SIGINT);\n      kj::UnixEventPort::captureSignal(SIGQUIT);\n      kj::UnixEventPort::captureSignal(SIGTERM);\n      kj::UnixEventPort::captureSignal(SIGHUP);\n\n      kj::UnixEventPort eventPort;\n      kj::EventLoop eventLoop(eventPort);\n      kj::WaitScope waitScope(eventLoop);\n\n      kj::Function<void(kj::StringPtr)> callback = [&](kj::StringPtr path) {\n        usedFiles.insert(kj::heapString(path));\n      };\n      auto rootNode = makeUnionFs(sourceDir, packageDef.getSourceMap(), packageDef.getManifest(),\n                                  packageDef.getBridgeConfig(), getHttpBridgeExe(), callback);\n\n      FuseOptions options;\n\n      // Caching improves performance significantly... but the ability to update code and see those\n      // updates live without restarting seems more important for this use case.\n      // TODO(perf): Implement active cache invalidation. FUSE has protocol support for it. Use\n      //   inotify at the other end to detect changes.\n      options.cacheForever = fuseCaching;\n\n      auto onSignal = eventPort.onSignal(SIGINT)\n          .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n          .exclusiveJoin(eventPort.onSignal(SIGTERM))\n          .exclusiveJoin(eventPort.onSignal(SIGHUP))\n          .then([&](siginfo_t&& sig) {\n        context.warning(kj::str(\"Requesting shutdown due to signal: \", strsignal(sig.si_signo)));\n\n        KJ_IF_MAYBE(c, connection) {\n          // Close pipe to request unmount.\n          KJ_SYSCALL(shutdown(*c, SHUT_WR));\n        }\n        fuseMount = nullptr;\n\n        return eventPort.onSignal(SIGINT)\n            .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n            .exclusiveJoin(eventPort.onSignal(SIGTERM))\n            .exclusiveJoin(eventPort.onSignal(SIGHUP))\n            .then([&](siginfo_t&& sig) {\n          context.exitError(\"Received second signal. Aborting. You may want to restart Sandstorm.\");\n        });\n      }).eagerlyEvaluate(nullptr);\n\n      kj::Maybe<kj::Promise<void>> logPipe;\n      KJ_IF_MAYBE(c, connection) {\n        kj::Own<kj::UnixEventPort::FdObserver> logObserver =\n            kj::heap<kj::UnixEventPort::FdObserver>(eventPort, *c,\n                kj::UnixEventPort::FdObserver::OBSERVE_READ);\n        auto promise = pipeToStdout(*logObserver, *c);\n        logPipe = promise.attach(kj::mv(logObserver)).eagerlyEvaluate(nullptr);\n      }\n\n      if (connection == nullptr) {\n        context.warning(\"App mounted. Ctrl+C to disconnect.\");\n      } else {\n        context.warning(\"App is now available from Sandstorm server. Ctrl+C to disconnect.\");\n      }\n\n      bindFuse(eventPort, fuseFd, kj::mv(rootNode), options)\n          .then([&]() {\n            context.warning(\"Unmounted cleanly.\");\n            KJ_IF_MAYBE(m, fuseMount) {\n              m->get()->dontUnmount();\n            }\n          })\n          .wait(waitScope);\n\n      KJ_IF_MAYBE(p, logPipe) {\n        p->wait(waitScope);\n      }\n    }\n\n    // OK, we're done running. Output the file list.\n    if (packageDef.hasFileList()) {\n      context.warning(\"Updating file list.\");\n\n      // Merge with the existing file list.\n      auto path = packageDef.getFileList();\n      if (access(path.cStr(), F_OK) == 0) {\n        auto fileList = raiiOpen(packageDef.getFileList(), O_RDONLY);\n        auto sourceMap = packageDef.getSourceMap();\n        for (auto& line: splitLines(readAll(fileList))) {\n          auto mapping = mapFile(sourceDir, sourceMap, line);\n          if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0 &&\n              line != \"sandstorm-manifest\" &&\n              line != \"sandstorm-http-bridge\" &&\n              line != \"sandstorm-http-bridge-config\" &&\n              line != \"proc/cpuinfo\") {\n            context.warning(kj::str(\"No file found to satisfy requirement: \", line,\n                                    \", removing from sandstorm-files.list\"));\n          } else {\n            usedFiles.insert(kj::mv(line));\n          }\n        }\n      }\n\n      // Now write back out.\n      ReplacementFile newFileList(path);\n      auto content = kj::str(\n          \"# *** WARNING: GENERATED FILE ***\\n\"\n          \"# This file is automatically updated and rewritten in sorted order every time\\n\"\n          \"# the app runs in dev mode. You may manually add or remove files, but don't\\n\"\n          \"# expect comments or ordering to be retained.\\n\",\n          kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\"),\n          \"\\n\");\n      kj::FdOutputStream(newFileList.getFd()).write(content.begin(), content.size());\n      newFileList.commit();\n    } else {\n      // If alwaysInclude contains \".\" then the user doesn't care about the used files list, so\n      // don't print in that case.\n      bool includeAll = false;\n      for (auto alwaysInclude: packageDef.getAlwaysInclude()) {\n        if (alwaysInclude == \".\") {\n          includeAll = true;\n          break;\n        }\n      }\n\n      if (!includeAll) {\n        context.warning(\n            \"Your program used the following files. (If you would specify `fileList` in\\n\"\n            \"the package definition, I could write the list there.)\\n\\n\");\n        auto msg = kj::str(\n            kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\"), \"\\n\");\n        kj::FdOutputStream(STDOUT_FILENO).write(msg.begin(), msg.size());\n      }\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;",
      "kj::Maybe<kj::Array<capnp::word>> data;",
      "kj::String serverBinary;",
      "kj::StringPtr mountDir;",
      "bool fuseCaching = false;",
      "bool mountProc = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "msg.begin()",
            "msg.size()"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.size",
          "args": [],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.begin",
          "args": [],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\")",
            "\"\\n\""
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(file, usedFiles){ return kj::strTree(file); }",
            "\"\\n\""
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "file"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "file",
            "usedFiles"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"Your program used the following files. (If you would specify `fileList` in\\n\"\n            \"the package definition, I could write the list there.)\\n\\n\""
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getAlwaysInclude",
          "args": [],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFileList.commit",
          "args": [],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "commit",
          "container": "ReplacementFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "145-149",
          "snippet": "void commit() {\n    fd = nullptr;\n    KJ_SYSCALL(rename(replacementName.cStr(), name.cStr()));\n    committed = true;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nReplacementFile {\n  void commit() {\n      fd = nullptr;\n      KJ_SYSCALL(rename(replacementName.cStr(), name.cStr()));\n      committed = true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "content.begin()",
            "content.size()"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "newFileList.getFd()"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFileList.getFd",
          "args": [],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "getFd",
          "container": "ReplacementFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "143-143",
          "snippet": "inline int getFd() { return fd; }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nReplacementFile {\n  inline int getFd() { return fd; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"# *** WARNING: GENERATED FILE ***\\n\"\n          \"# This file is automatically updated and rewritten in sorted order every time\\n\"\n          \"# the app runs in dev mode. You may manually add or remove files, but don't\\n\"\n          \"# expect comments or ordering to be retained.\\n\"",
            "kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\")",
            "\"\\n\""
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(file, usedFiles){ return kj::strTree(file); }",
            "\"\\n\""
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "file"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "file",
            "usedFiles"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usedFiles.insert",
          "args": [
            "kj::mv(line)"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "line"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\"No file found to satisfy requirement: \", line,\n                                    \", removing from sandstorm-files.list\")"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"No file found to satisfy requirement: \"",
            "line",
            "\", removing from sandstorm-files.list\""
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapFile",
          "args": [
            "sourceDir",
            "sourceMap",
            "line"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "mapFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "726-787",
          "snippet": "FileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nFileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}"
        }
      },
      {
        "call_info": {
          "callee": "splitLines",
          "args": [
            "readAll(fileList)"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "splitLines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "387-414",
          "snippet": "kj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "fileList"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "383-385",
          "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packageDef.getSourceMap",
          "args": [],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "packageDef.getFileList()",
            "O_RDONLY"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getFileList",
          "args": [],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path.cStr()",
            "F_OK"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getFileList",
          "args": [],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"Updating file list.\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.hasFileList",
          "args": [],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->wait",
          "args": [
            "waitScope"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "waitScope"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "[&]() {\n            context.warning(\"Unmounted cleanly.\");\n            KJ_IF_MAYBE(m, fuseMount) {\n              m->get()->dontUnmount();\n            }\n          }"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->get",
          "args": [],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->get",
          "args": [],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"Unmounted cleanly.\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bindFuse",
          "args": [
            "eventPort",
            "fuseFd",
            "kj::mv(rootNode)",
            "options"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "bindFuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "833-838",
          "snippet": "kj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nkj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "rootNode"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"App is now available from Sandstorm server. Ctrl+C to disconnect.\""
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"App mounted. Ctrl+C to disconnect.\""
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "nullptr"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(logObserver)"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "logObserver"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeToStdout",
          "args": [
            "*logObserver",
            "*c"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "pipeToStdout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "2175-2196",
          "snippet": "static kj::Promise<void> pipeToStdout(kj::UnixEventPort::FdObserver& observer, int fd) {\n    // Asynchronously read all data from fd and write it to STDOUT.\n    // TODO(cleanup): Use KJ I/O facilities. Requires making it possible to construct\n    //   kj::LowLevelAsyncIoProvider directly from UnixEventPort.\n\n    for (;;) {\n      ssize_t n;\n      char buffer[1024];\n      KJ_NONBLOCKING_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n\n      if (n < 0) {\n        // Got EAGAIN.\n        return observer.whenBecomesReadable().then([&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        });\n      } else if (n == 0) {\n        return kj::READY_NOW;\n      }\n\n      kj::FdOutputStream(STDOUT_FILENO).write(buffer, n);\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::Promise<void> pipeToStdout(kj::UnixEventPort::FdObserver& observer, int fd) {\n    // Asynchronously read all data from fd and write it to STDOUT.\n    // TODO(cleanup): Use KJ I/O facilities. Requires making it possible to construct\n    //   kj::LowLevelAsyncIoProvider directly from UnixEventPort.\n\n    for (;;) {\n      ssize_t n;\n      char buffer[1024];\n      KJ_NONBLOCKING_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n\n      if (n < 0) {\n        // Got EAGAIN.\n        return observer.whenBecomesReadable().then([&observer, fd]() {\n          return pipeToStdout(observer, fd);\n        });\n      } else if (n == 0) {\n        return kj::READY_NOW;\n      }\n\n      kj::FdOutputStream(STDOUT_FILENO).write(buffer, n);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<kj::UnixEventPort::FdObserver>",
          "args": [
            "eventPort",
            "*c",
            "kj::UnixEventPort::FdObserver::OBSERVE_READ"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "nullptr"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "[&](siginfo_t&& sig) {\n        context.warning(kj::str(\"Requesting shutdown due to signal: \", strsignal(sig.si_signo)));\n\n        KJ_IF_MAYBE(c, connection) {\n          // Close pipe to request unmount.\n          KJ_SYSCALL(shutdown(*c, SHUT_WR));\n        }\n        fuseMount = nullptr;\n\n        return eventPort.onSignal(SIGINT)\n            .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n            .exclusiveJoin(eventPort.onSignal(SIGTERM))\n            .exclusiveJoin(eventPort.onSignal(SIGHUP))\n            .then([&](siginfo_t&& sig) {\n          context.exitError(\"Received second signal. Aborting. You may want to restart Sandstorm.\");\n        });\n      }"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "[&](siginfo_t&& sig) {\n          context.exitError(\"Received second signal. Aborting. You may want to restart Sandstorm.\");\n        }"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "\"Received second signal. Aborting. You may want to restart Sandstorm.\""
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGHUP)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGHUP"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGTERM)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGTERM"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGQUIT)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGQUIT"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGINT"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "shutdown(*c, SHUT_WR)"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "*c",
            "SHUT_WR"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\"Requesting shutdown due to signal: \", strsignal(sig.si_signo))"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Requesting shutdown due to signal: \"",
            "strsignal(sig.si_signo)"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "sig.si_signo"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGHUP)"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGHUP"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGTERM)"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGTERM"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "eventPort.onSignal(SIGQUIT)"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGQUIT"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGINT"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeUnionFs",
          "args": [
            "sourceDir",
            "packageDef.getSourceMap()",
            "packageDef.getManifest()",
            "packageDef.getBridgeConfig()",
            "getHttpBridgeExe()",
            "callback"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "makeUnionFs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "586-668",
          "snippet": "kj::Own<fuse::Node> makeUnionFs(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap,\n                               spk::Manifest::Reader manifest,\n                               spk::BridgeConfig::Reader bridgeConfig, kj::StringPtr bridgePath,\n                               kj::Function<void(kj::StringPtr)>& callback) {\n  auto searchPath = sourceMap.getSearchPath();\n  auto layers = kj::Vector<kj::Own<fuse::Node>>(searchPath.size() + 10);\n\n  {\n    capnp::MallocMessageBuilder manifestCopy(manifest.totalSize().wordCount + 4);\n    manifestCopy.setRoot(manifest);\n    layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(\n        capnp::messageToFlatArray(manifestCopy)), \"sandstorm-manifest\"));\n  }\n\n  {\n    capnp::MallocMessageBuilder bridgeConfigCopy(bridgeConfig.totalSize().wordCount + 4);\n    bridgeConfigCopy.setRoot(bridgeConfig);\n    layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(\n        capnp::messageToFlatArray(bridgeConfigCopy)), \"sandstorm-http-bridge-config\"));\n  }\n\n  layers.add(kj::refcounted<SingletonNode>(\n      newLoopbackFuseNode(bridgePath, kj::maxValue), \"sandstorm-http-bridge\"));\n\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"dev\"));\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"tmp\"));\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"var\"));\n\n  // Empty /proc/cpuinfo will be overmounted by the supervisor.\n  layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(nullptr), \"proc/cpuinfo\"));\n\n  for (auto mapping: searchPath) {\n    kj::StringPtr sourcePath = mapping.getSourcePath();\n    kj::String ownSourcePath;\n    kj::StringPtr packagePath = mapping.getPackagePath();\n\n    // Interpret relative paths against the source dir (if it's not the current directory).\n    if (sourceDir.size() != 0 && !sourcePath.startsWith(\"/\")) {\n      ownSourcePath = kj::str(sourceDir, '/', sourcePath);\n      sourcePath = ownSourcePath;\n    }\n\n    // If this is a symlink mapped to virtual root, follow it, because it makes no sense for\n    // root to be a symlink.\n    if (packagePath.size() == 0) {\n      struct stat stats;\n      KJ_SYSCALL(lstat(sourcePath.cStr(), &stats), sourcePath);\n      if (S_ISLNK(stats.st_mode)) {\n        char* real;\n        KJ_SYSCALL(real = realpath(sourcePath.cStr(), NULL));\n        KJ_DEFER(free(real));\n        ownSourcePath = kj::str(real);\n        sourcePath = ownSourcePath;\n      }\n    }\n\n    // Create the filesystem node.\n    // We set a low TTL here, but note that the spk tool overrides it anyway.\n    kj::Own<fuse::Node> node = newLoopbackFuseNode(sourcePath, 1 * kj::SECONDS);\n\n    // If any contents are hidden, wrap in a hiding node.\n    auto hides = mapping.getHidePaths();\n    if (hides.size() > 0) {\n      std::set<kj::StringPtr> hideSet;\n      for (auto hide: hides) {\n        hideSet.insert(hide);\n      }\n      node = kj::refcounted<HidingNode>(kj::mv(node), kj::mv(hideSet));\n    }\n\n    // If the contents are mapped to a non-root location, wrap in a singleton node.\n    KJ_ASSERT(!packagePath.startsWith(\"/\"),\n              \"`packagePath` in source map should not start with '/'.\");\n    if (packagePath.size() > 0) {\n      node = kj::refcounted<SingletonNode>(kj::mv(node), packagePath);\n    }\n\n    layers.add(kj::mv(node));\n  }\n\n  auto merged = kj::refcounted<UnionNode>(layers.releaseAsArray());\n  return kj::refcounted<TrackingNode>(kj::mv(merged), nullptr, callback);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nkj::Own<fuse::Node> makeUnionFs(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap,\n                               spk::Manifest::Reader manifest,\n                               spk::BridgeConfig::Reader bridgeConfig, kj::StringPtr bridgePath,\n                               kj::Function<void(kj::StringPtr)>& callback) {\n  auto searchPath = sourceMap.getSearchPath();\n  auto layers = kj::Vector<kj::Own<fuse::Node>>(searchPath.size() + 10);\n\n  {\n    capnp::MallocMessageBuilder manifestCopy(manifest.totalSize().wordCount + 4);\n    manifestCopy.setRoot(manifest);\n    layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(\n        capnp::messageToFlatArray(manifestCopy)), \"sandstorm-manifest\"));\n  }\n\n  {\n    capnp::MallocMessageBuilder bridgeConfigCopy(bridgeConfig.totalSize().wordCount + 4);\n    bridgeConfigCopy.setRoot(bridgeConfig);\n    layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(\n        capnp::messageToFlatArray(bridgeConfigCopy)), \"sandstorm-http-bridge-config\"));\n  }\n\n  layers.add(kj::refcounted<SingletonNode>(\n      newLoopbackFuseNode(bridgePath, kj::maxValue), \"sandstorm-http-bridge\"));\n\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"dev\"));\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"tmp\"));\n  layers.add(kj::refcounted<SingletonNode>(kj::heap<EmptyNode>(), \"var\"));\n\n  // Empty /proc/cpuinfo will be overmounted by the supervisor.\n  layers.add(kj::refcounted<SingletonNode>(kj::refcounted<SimpleDataNode>(nullptr), \"proc/cpuinfo\"));\n\n  for (auto mapping: searchPath) {\n    kj::StringPtr sourcePath = mapping.getSourcePath();\n    kj::String ownSourcePath;\n    kj::StringPtr packagePath = mapping.getPackagePath();\n\n    // Interpret relative paths against the source dir (if it's not the current directory).\n    if (sourceDir.size() != 0 && !sourcePath.startsWith(\"/\")) {\n      ownSourcePath = kj::str(sourceDir, '/', sourcePath);\n      sourcePath = ownSourcePath;\n    }\n\n    // If this is a symlink mapped to virtual root, follow it, because it makes no sense for\n    // root to be a symlink.\n    if (packagePath.size() == 0) {\n      struct stat stats;\n      KJ_SYSCALL(lstat(sourcePath.cStr(), &stats), sourcePath);\n      if (S_ISLNK(stats.st_mode)) {\n        char* real;\n        KJ_SYSCALL(real = realpath(sourcePath.cStr(), NULL));\n        KJ_DEFER(free(real));\n        ownSourcePath = kj::str(real);\n        sourcePath = ownSourcePath;\n      }\n    }\n\n    // Create the filesystem node.\n    // We set a low TTL here, but note that the spk tool overrides it anyway.\n    kj::Own<fuse::Node> node = newLoopbackFuseNode(sourcePath, 1 * kj::SECONDS);\n\n    // If any contents are hidden, wrap in a hiding node.\n    auto hides = mapping.getHidePaths();\n    if (hides.size() > 0) {\n      std::set<kj::StringPtr> hideSet;\n      for (auto hide: hides) {\n        hideSet.insert(hide);\n      }\n      node = kj::refcounted<HidingNode>(kj::mv(node), kj::mv(hideSet));\n    }\n\n    // If the contents are mapped to a non-root location, wrap in a singleton node.\n    KJ_ASSERT(!packagePath.startsWith(\"/\"),\n              \"`packagePath` in source map should not start with '/'.\");\n    if (packagePath.size() > 0) {\n      node = kj::refcounted<SingletonNode>(kj::mv(node), packagePath);\n    }\n\n    layers.add(kj::mv(node));\n  }\n\n  auto merged = kj::refcounted<UnionNode>(layers.releaseAsArray());\n  return kj::refcounted<TrackingNode>(kj::mv(merged), nullptr, callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getHttpBridgeExe",
          "args": [],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "getHttpBridgeExe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1310-1316",
          "snippet": "kj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "packageDef.getBridgeConfig",
          "args": [],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getManifest",
          "args": [],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getSourceMap",
          "args": [],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usedFiles.insert",
          "args": [
            "kj::heapString(path)"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGHUP"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGTERM"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGQUIT"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGINT"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mount"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount->disownFd",
          "args": [],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "disownFd",
          "container": "FuseMount",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.h",
          "lines": "151-151",
          "snippet": "inline kj::AutoCloseFd disownFd() { return kj::mv(fd); }",
          "includes": [
            "#include <kj/refcount.h>",
            "#include <kj/function.h>",
            "#include <kj/io.h>",
            "#include <kj/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/refcount.h>\n#include <kj/function.h>\n#include <kj/io.h>\n#include <kj/time.h>\n\nFuseMount {\n  inline kj::AutoCloseFd disownFd() { return kj::mv(fd); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<FuseMount>",
          "args": [
            "mountDir",
            "\"\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "clientEnd"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(clientEnd, F_SETFL, flags | O_NONBLOCK)"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "clientEnd",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "flags = fcntl(clientEnd, F_GETFL)"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "clientEnd",
            "F_GETFL"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFd",
          "args": [
            "clientEnd",
            "[](kj::ArrayPtr<const kj::byte> bytes) {\n        // Got some data. Pipe it to stdout.\n        kj::FdOutputStream(STDOUT_FILENO).write(bytes.begin(), bytes.size());\n      }"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
          "lines": "61-118",
          "snippet": "kj::AutoCloseFd receiveFd(int sockFd,\n    kj::Function<void(kj::ArrayPtr<const kj::byte>)> dataCallback) {\n  // Receive the fuse FD from the socket.  recvmsg() is complicated...  :/\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  // Make sure we have space to receive a byte so that recvmsg() doesn't simply return\n  // immediately.\n  struct iovec iov;\n  memset(&iov, 0, sizeof(iov));\n  kj::byte buffer[1024];\n  iov.iov_base = &buffer;\n  iov.iov_len = sizeof(buffer);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  // Allocate space to receive a cmsg.\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_SPACE(sizeof(int))];\n  };\n  msg.msg_control = &cmsg;\n\n  // Wait for the message.\n  for (;;) {\n    msg.msg_controllen = sizeof(cmsgSpace);\n\n    ssize_t n;\n    KJ_SYSCALL(n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC));\n    KJ_ASSERT(n > 0, \"premature EOF while waiting for FD\");\n\n    for (size_t i: kj::range<size_t>(0, n)) {\n      if (buffer[i] == 0) {\n        // Yay, here's our zero byte.\n        if (i > 0) {\n          dataCallback(kj::arrayPtr(buffer, i));\n        }\n        if (n > i + 1) {\n          dataCallback(kj::arrayPtr(buffer + i + 1, n - i - 1));\n        }\n\n        KJ_ASSERT(msg.msg_controllen >= sizeof(cmsg), \"expected fd on socket\");\n\n        // We expect an SCM_RIGHTS message with a single FD.\n        KJ_ASSERT(cmsg.cmsg_level == SOL_SOCKET);\n        KJ_ASSERT(cmsg.cmsg_type == SCM_RIGHTS);\n        KJ_ASSERT(cmsg.cmsg_len == CMSG_LEN(sizeof(int)));\n\n        return kj::AutoCloseFd(*reinterpret_cast<int*>(CMSG_DATA(&cmsg)));\n      }\n    }\n\n    // No zero bytes; all data.\n    dataCallback(kj::arrayPtr(buffer, n));\n\n    KJ_ASSERT(msg.msg_controllen == 0, \"expected zero byte with fd\");\n  }\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <kj/debug.h>",
            "#include \"send-fd.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include <kj/debug.h>\n#include \"send-fd.h\"\n\nkj::AutoCloseFd receiveFd(int sockFd,\n    kj::Function<void(kj::ArrayPtr<const kj::byte>)> dataCallback) {\n  // Receive the fuse FD from the socket.  recvmsg() is complicated...  :/\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  // Make sure we have space to receive a byte so that recvmsg() doesn't simply return\n  // immediately.\n  struct iovec iov;\n  memset(&iov, 0, sizeof(iov));\n  kj::byte buffer[1024];\n  iov.iov_base = &buffer;\n  iov.iov_len = sizeof(buffer);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  // Allocate space to receive a cmsg.\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_SPACE(sizeof(int))];\n  };\n  msg.msg_control = &cmsg;\n\n  // Wait for the message.\n  for (;;) {\n    msg.msg_controllen = sizeof(cmsgSpace);\n\n    ssize_t n;\n    KJ_SYSCALL(n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC));\n    KJ_ASSERT(n > 0, \"premature EOF while waiting for FD\");\n\n    for (size_t i: kj::range<size_t>(0, n)) {\n      if (buffer[i] == 0) {\n        // Yay, here's our zero byte.\n        if (i > 0) {\n          dataCallback(kj::arrayPtr(buffer, i));\n        }\n        if (n > i + 1) {\n          dataCallback(kj::arrayPtr(buffer + i + 1, n - i - 1));\n        }\n\n        KJ_ASSERT(msg.msg_controllen >= sizeof(cmsg), \"expected fd on socket\");\n\n        // We expect an SCM_RIGHTS message with a single FD.\n        KJ_ASSERT(cmsg.cmsg_level == SOL_SOCKET);\n        KJ_ASSERT(cmsg.cmsg_type == SCM_RIGHTS);\n        KJ_ASSERT(cmsg.cmsg_len == CMSG_LEN(sizeof(int)));\n\n        return kj::AutoCloseFd(*reinterpret_cast<int*>(CMSG_DATA(&cmsg)));\n      }\n    }\n\n    // No zero bytes; all data.\n    dataCallback(kj::arrayPtr(buffer, n));\n\n    KJ_ASSERT(msg.msg_controllen == 0, \"expected zero byte with fd\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "bytes.begin()",
            "bytes.size()"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "msg.begin()",
            "msg.size()"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.begin",
          "args": [],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "(int)clientEnd"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "mountProc ? \"1\" : \"0\"",
            "\"\\n\""
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "msg.begin()",
            "msg.size()"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.begin",
          "args": [],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "(int)clientEnd"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "packageDef.getId()",
            "\"\\n\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getId",
          "args": [],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execl(serverBinary.cStr(), serverBinary.cStr(), \"dev\", (char*)nullptr)",
            "serverBinary"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "serverBinary.cStr()",
            "serverBinary.cStr()",
            "\"dev\"",
            "(char*)nullptr"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverBinary.cStr",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverBinary.cStr",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "serverEnd",
            "STDOUT_FILENO"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "serverEnd",
            "STDIN_FILENO"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, serverSocket)"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM | SOCK_CLOEXEC",
            "0",
            "serverSocket"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "candidate"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "candidate.cStr()",
            "F_OK"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidate.cStr",
          "args": [],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "candidate"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "stat(candidate.cStr(), &stats)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "candidate.cStr()",
            "&stats"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidate.cStr",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "candidate.cStr()",
            "F_OK"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidate.cStr",
          "args": [],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "*i",
            "\"/sandstorm\""
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensurePackageDefParsed",
          "args": [],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "ensurePackageDefParsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "354-361",
          "snippet": "void ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\nkj::Maybe<kj::Array<capnp::word>> data;\nkj::String serverBinary;\nkj::StringPtr mountDir;\nbool fuseCaching = false;\nbool mountProc = false;\n\nkj::MainBuilder::Validity doDev() {\n    ensurePackageDefParsed();\n\n    if (serverBinary == nullptr) {\n      // Try to find the server. First try looking where `spk` is installed.\n      KJ_IF_MAYBE(i, installHome) {\n        auto candidate = kj::str(*i, \"/sandstorm\");\n        if (access(candidate.cStr(), F_OK) == 0) {\n          struct stat stats;\n          KJ_SYSCALL(stat(candidate.cStr(), &stats));\n          if (S_ISREG(stats.st_mode) && stats.st_mode & S_IXUSR) {\n            // Indeed!\n            serverBinary = kj::mv(candidate);\n          }\n        }\n      }\n\n      if (serverBinary == nullptr) {\n        // Try checking for an init script.\n        kj::StringPtr candidate = \"/etc/init.d/sandstorm\";\n        if (access(candidate.cStr(), F_OK) == 0) {\n          serverBinary = kj::str(candidate);\n        }\n      }\n\n      if (serverBinary == nullptr) {\n        return \"Couldn't find Sandstorm server installation. Please use -s to specify it.\";\n      }\n    }\n\n    kj::AutoCloseFd fuseFd;\n    kj::Maybe<kj::AutoCloseFd> connection;\n    kj::Maybe<kj::Own<FuseMount>> fuseMount;\n\n    if (mountDir == nullptr) {\n      // call \"sandstorm dev\"\n\n      // Create a unix socket over which to receive the fuse FD.\n      int serverSocket[2];\n      KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, serverSocket));\n      kj::AutoCloseFd clientEnd(serverSocket[0]);\n      kj::AutoCloseFd serverEnd(serverSocket[1]);\n\n      // Run \"sandstorm dev\".\n      pid_t sandstormPid = fork();\n      if (sandstormPid == 0) {\n        dup2(serverEnd, STDIN_FILENO);\n        dup2(serverEnd, STDOUT_FILENO);\n\n        KJ_SYSCALL(execl(serverBinary.cStr(), serverBinary.cStr(), \"dev\", (char*)nullptr),\n                   serverBinary);\n        KJ_UNREACHABLE;\n      }\n\n      serverEnd = nullptr;\n\n      // Write the app ID to the socket.\n      {\n        auto msg = kj::str(packageDef.getId(), \"\\n\");\n        kj::FdOutputStream((int)clientEnd).write(msg.begin(), msg.size());\n      }\n\n      // Write the mountProc option to the socket.\n      {\n        auto msg = kj::str(mountProc ? \"1\" : \"0\", \"\\n\");\n        kj::FdOutputStream((int)clientEnd).write(msg.begin(), msg.size());\n      }\n\n      // The server connection starts by sending us the FUSE FD.\n      fuseFd = receiveFd(clientEnd, [](kj::ArrayPtr<const kj::byte> bytes) {\n        // Got some data. Pipe it to stdout.\n        kj::FdOutputStream(STDOUT_FILENO).write(bytes.begin(), bytes.size());\n      });\n\n      // Switch connection to async I/O.\n      {\n        int flags;\n        KJ_SYSCALL(flags = fcntl(clientEnd, F_GETFL));\n        if ((flags & O_NONBLOCK) == 0) {\n          KJ_SYSCALL(fcntl(clientEnd, F_SETFL, flags | O_NONBLOCK));\n        }\n      }\n\n      connection = kj::mv(clientEnd);\n    } else {\n      // Just mount directly.\n\n      auto mount = kj::heap<FuseMount>(mountDir, \"\");\n      fuseFd = mount->disownFd();\n      fuseMount = kj::mv(mount);\n    }\n\n    std::set<kj::String> usedFiles;\n\n    {\n      kj::UnixEventPort::captureSignal(SIGINT);\n      kj::UnixEventPort::captureSignal(SIGQUIT);\n      kj::UnixEventPort::captureSignal(SIGTERM);\n      kj::UnixEventPort::captureSignal(SIGHUP);\n\n      kj::UnixEventPort eventPort;\n      kj::EventLoop eventLoop(eventPort);\n      kj::WaitScope waitScope(eventLoop);\n\n      kj::Function<void(kj::StringPtr)> callback = [&](kj::StringPtr path) {\n        usedFiles.insert(kj::heapString(path));\n      };\n      auto rootNode = makeUnionFs(sourceDir, packageDef.getSourceMap(), packageDef.getManifest(),\n                                  packageDef.getBridgeConfig(), getHttpBridgeExe(), callback);\n\n      FuseOptions options;\n\n      // Caching improves performance significantly... but the ability to update code and see those\n      // updates live without restarting seems more important for this use case.\n      // TODO(perf): Implement active cache invalidation. FUSE has protocol support for it. Use\n      //   inotify at the other end to detect changes.\n      options.cacheForever = fuseCaching;\n\n      auto onSignal = eventPort.onSignal(SIGINT)\n          .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n          .exclusiveJoin(eventPort.onSignal(SIGTERM))\n          .exclusiveJoin(eventPort.onSignal(SIGHUP))\n          .then([&](siginfo_t&& sig) {\n        context.warning(kj::str(\"Requesting shutdown due to signal: \", strsignal(sig.si_signo)));\n\n        KJ_IF_MAYBE(c, connection) {\n          // Close pipe to request unmount.\n          KJ_SYSCALL(shutdown(*c, SHUT_WR));\n        }\n        fuseMount = nullptr;\n\n        return eventPort.onSignal(SIGINT)\n            .exclusiveJoin(eventPort.onSignal(SIGQUIT))\n            .exclusiveJoin(eventPort.onSignal(SIGTERM))\n            .exclusiveJoin(eventPort.onSignal(SIGHUP))\n            .then([&](siginfo_t&& sig) {\n          context.exitError(\"Received second signal. Aborting. You may want to restart Sandstorm.\");\n        });\n      }).eagerlyEvaluate(nullptr);\n\n      kj::Maybe<kj::Promise<void>> logPipe;\n      KJ_IF_MAYBE(c, connection) {\n        kj::Own<kj::UnixEventPort::FdObserver> logObserver =\n            kj::heap<kj::UnixEventPort::FdObserver>(eventPort, *c,\n                kj::UnixEventPort::FdObserver::OBSERVE_READ);\n        auto promise = pipeToStdout(*logObserver, *c);\n        logPipe = promise.attach(kj::mv(logObserver)).eagerlyEvaluate(nullptr);\n      }\n\n      if (connection == nullptr) {\n        context.warning(\"App mounted. Ctrl+C to disconnect.\");\n      } else {\n        context.warning(\"App is now available from Sandstorm server. Ctrl+C to disconnect.\");\n      }\n\n      bindFuse(eventPort, fuseFd, kj::mv(rootNode), options)\n          .then([&]() {\n            context.warning(\"Unmounted cleanly.\");\n            KJ_IF_MAYBE(m, fuseMount) {\n              m->get()->dontUnmount();\n            }\n          })\n          .wait(waitScope);\n\n      KJ_IF_MAYBE(p, logPipe) {\n        p->wait(waitScope);\n      }\n    }\n\n    // OK, we're done running. Output the file list.\n    if (packageDef.hasFileList()) {\n      context.warning(\"Updating file list.\");\n\n      // Merge with the existing file list.\n      auto path = packageDef.getFileList();\n      if (access(path.cStr(), F_OK) == 0) {\n        auto fileList = raiiOpen(packageDef.getFileList(), O_RDONLY);\n        auto sourceMap = packageDef.getSourceMap();\n        for (auto& line: splitLines(readAll(fileList))) {\n          auto mapping = mapFile(sourceDir, sourceMap, line);\n          if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0 &&\n              line != \"sandstorm-manifest\" &&\n              line != \"sandstorm-http-bridge\" &&\n              line != \"sandstorm-http-bridge-config\" &&\n              line != \"proc/cpuinfo\") {\n            context.warning(kj::str(\"No file found to satisfy requirement: \", line,\n                                    \", removing from sandstorm-files.list\"));\n          } else {\n            usedFiles.insert(kj::mv(line));\n          }\n        }\n      }\n\n      // Now write back out.\n      ReplacementFile newFileList(path);\n      auto content = kj::str(\n          \"# *** WARNING: GENERATED FILE ***\\n\"\n          \"# This file is automatically updated and rewritten in sorted order every time\\n\"\n          \"# the app runs in dev mode. You may manually add or remove files, but don't\\n\"\n          \"# expect comments or ordering to be retained.\\n\",\n          kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\"),\n          \"\\n\");\n      kj::FdOutputStream(newFileList.getFd()).write(content.begin(), content.size());\n      newFileList.commit();\n    } else {\n      // If alwaysInclude contains \".\" then the user doesn't care about the used files list, so\n      // don't print in that case.\n      bool includeAll = false;\n      for (auto alwaysInclude: packageDef.getAlwaysInclude()) {\n        if (alwaysInclude == \".\") {\n          includeAll = true;\n          break;\n        }\n      }\n\n      if (!includeAll) {\n        context.warning(\n            \"Your program used the following files. (If you would specify `fileList` in\\n\"\n            \"the package definition, I could write the list there.)\\n\\n\");\n        auto msg = kj::str(\n            kj::StringTree(KJ_MAP(file, usedFiles) { return kj::strTree(file); }, \"\\n\"), \"\\n\");\n        kj::FdOutputStream(STDOUT_FILENO).write(msg.begin(), msg.size());\n      }\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "enableMountProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1942-1945",
    "snippet": "kj::MainBuilder::Validity enableMountProc() {\n    mountProc = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool mountProc = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool mountProc = false;\n\nkj::MainBuilder::Validity enableMountProc() {\n    mountProc = true;\n    return true;\n  }"
  },
  {
    "function_name": "enableFuseCaching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1937-1940",
    "snippet": "kj::MainBuilder::Validity enableFuseCaching() {\n    fuseCaching = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool fuseCaching = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool fuseCaching = false;\n\nkj::MainBuilder::Validity enableFuseCaching() {\n    fuseCaching = true;\n    return true;\n  }"
  },
  {
    "function_name": "addImportPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1932-1935",
    "snippet": "kj::MainBuilder::Validity addImportPath(kj::StringPtr arg) {\n    importPath.add(kj::heapString(arg));\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "importPath.add",
          "args": [
            "kj::heapString(arg)"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "arg"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainBuilder::Validity addImportPath(kj::StringPtr arg) {\n    importPath.add(kj::heapString(arg));\n    return true;\n  }"
  },
  {
    "function_name": "setMountDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1924-1930",
    "snippet": "kj::MainBuilder::Validity setMountDir(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    mountDir = name;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::StringPtr mountDir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "name.cStr()",
            "F_OK"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::StringPtr mountDir;\n\nkj::MainBuilder::Validity setMountDir(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    mountDir = name;\n    return true;\n  }"
  },
  {
    "function_name": "setServerDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1916-1922",
    "snippet": "kj::MainBuilder::Validity setServerDir(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    serverBinary = kj::str(name, \"/sandstorm\");\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String serverBinary;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name",
            "\"/sandstorm\""
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "name.cStr()",
            "F_OK"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String serverBinary;\n\nkj::MainBuilder::Validity setServerDir(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    serverBinary = kj::str(name, \"/sandstorm\");\n    return true;\n  }"
  },
  {
    "function_name": "getDevMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1888-1914",
    "snippet": "kj::MainFunc getDevMain() {\n    return addCommonOptions(OptionSet::ALL_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Register an under-development app with a local Sandstorm server for testing \"\n            \"purposes, and optionally output a list of all files it depends on. While this \"\n            \"command is running, the app will replace the current package for the app's ID \"\n            \"installed on the server. Note that you do not need the private key corresponding \"\n            \"to the app ID for this, so that the key need not be distributed to all developers. \"\n            \"Your user account must be a member of the server's group, typically \\\"sandstorm\\\".\")\n        .addOptionWithArg({'s', \"server\"}, KJ_BIND_METHOD(*this, setServerDir), \"<dir>\",\n            \"Connect to the Sandstorm server installed in <dir>. Default is to detect based on \"\n            \"the location of the spk executable or, failing that, the location pointed to by \"\n            \"the installed init script.\")\n        .addOptionWithArg({'m', \"mount\"}, KJ_BIND_METHOD(*this, setMountDir), \"<dir>\",\n            \"Don't actually connect to the server. Mount the package at <dir>, so you can poke \"\n            \"at it.\")\n        .addOption({'c', \"cache\"}, KJ_BIND_METHOD(*this, enableFuseCaching),\n            \"Enable aggressive caching over the FUSE filesystem used to detect dependencies. \"\n            \"This may improve performance but means that you will have to restart `spk dev` \"\n            \"any time you make a change to your code.\")\n        .addOption({\"proc\"}, KJ_BIND_METHOD(*this, enableMountProc),\n            \"Mount /proc inside the sandbox. This can be useful for debugging. For security \"\n            \"reasons, this option is only available when you are developing an app; packaged \"\n            \"apps do not get access to /proc.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doDev)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::ALL_READONLY",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Register an under-development app with a local Sandstorm server for testing \"\n            \"purposes, and optionally output a list of all files it depends on. While this \"\n            \"command is running, the app will replace the current package for the app's ID \"\n            \"installed on the server. Note that you do not need the private key corresponding \"\n            \"to the app ID for this, so that the key need not be distributed to all developers. \"\n            \"Your user account must be a member of the server's group, typically \\\"sandstorm\\\".\")\n        .addOptionWithArg({'s', \"server\"}, KJ_BIND_METHOD(*this, setServerDir), \"<dir>\",\n            \"Connect to the Sandstorm server installed in <dir>. Default is to detect based on \"\n            \"the location of the spk executable or, failing that, the location pointed to by \"\n            \"the installed init script.\")\n        .addOptionWithArg({'m', \"mount\"}, KJ_BIND_METHOD(*this, setMountDir), \"<dir>\",\n            \"Don't actually connect to the server. Mount the package at <dir>, so you can poke \"\n            \"at it.\")\n        .addOption({'c', \"cache\"}, KJ_BIND_METHOD(*this, enableFuseCaching),\n            \"Enable aggressive caching over the FUSE filesystem used to detect dependencies. \"\n            \"This may improve performance but means that you will have to restart `spk dev` \"\n            \"any time you make a change to your code.\")\n        .addOption({\"proc\"}, KJ_BIND_METHOD(*this, enableMountProc),\n            \"Mount /proc inside the sandbox. This can be useful for debugging. For security \"\n            \"reasons, this option is only available when you are developing an app; packaged \"\n            \"apps do not get access to /proc.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doDev))"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doDev)"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doDev"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"proc\"}",
            "KJ_BIND_METHOD(*this, enableMountProc)",
            "\"Mount /proc inside the sandbox. This can be useful for debugging. For security \"\n            \"reasons, this option is only available when you are developing an app; packaged \"\n            \"apps do not get access to /proc.\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "enableMountProc"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'c', \"cache\"}",
            "KJ_BIND_METHOD(*this, enableFuseCaching)",
            "\"Enable aggressive caching over the FUSE filesystem used to detect dependencies. \"\n            \"This may improve performance but means that you will have to restart `spk dev` \"\n            \"any time you make a change to your code.\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "enableFuseCaching"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'m', \"mount\"}",
            "KJ_BIND_METHOD(*this, setMountDir)",
            "\"<dir>\"",
            "\"Don't actually connect to the server. Mount the package at <dir>, so you can poke \"\n            \"at it.\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setMountDir"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'s', \"server\"}",
            "KJ_BIND_METHOD(*this, setServerDir)",
            "\"<dir>\"",
            "\"Connect to the Sandstorm server installed in <dir>. Default is to detect based on \"\n            \"the location of the spk executable or, failing that, the location pointed to by \"\n            \"the installed init script.\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setServerDir"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Register an under-development app with a local Sandstorm server for testing \"\n            \"purposes, and optionally output a list of all files it depends on. While this \"\n            \"command is running, the app will replace the current package for the app's ID \"\n            \"installed on the server. Note that you do not need the private key corresponding \"\n            \"to the app ID for this, so that the key need not be distributed to all developers. \"\n            \"Your user account must be a member of the server's group, typically \\\"sandstorm\\\".\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainFunc getDevMain() {\n    return addCommonOptions(OptionSet::ALL_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Register an under-development app with a local Sandstorm server for testing \"\n            \"purposes, and optionally output a list of all files it depends on. While this \"\n            \"command is running, the app will replace the current package for the app's ID \"\n            \"installed on the server. Note that you do not need the private key corresponding \"\n            \"to the app ID for this, so that the key need not be distributed to all developers. \"\n            \"Your user account must be a member of the server's group, typically \\\"sandstorm\\\".\")\n        .addOptionWithArg({'s', \"server\"}, KJ_BIND_METHOD(*this, setServerDir), \"<dir>\",\n            \"Connect to the Sandstorm server installed in <dir>. Default is to detect based on \"\n            \"the location of the spk executable or, failing that, the location pointed to by \"\n            \"the installed init script.\")\n        .addOptionWithArg({'m', \"mount\"}, KJ_BIND_METHOD(*this, setMountDir), \"<dir>\",\n            \"Don't actually connect to the server. Mount the package at <dir>, so you can poke \"\n            \"at it.\")\n        .addOption({'c', \"cache\"}, KJ_BIND_METHOD(*this, enableFuseCaching),\n            \"Enable aggressive caching over the FUSE filesystem used to detect dependencies. \"\n            \"This may improve performance but means that you will have to restart `spk dev` \"\n            \"any time you make a change to your code.\")\n        .addOption({\"proc\"}, KJ_BIND_METHOD(*this, enableMountProc),\n            \"Mount /proc inside the sandbox. This can be useful for debugging. For security \"\n            \"reasons, this option is only available when you are developing an app; packaged \"\n            \"apps do not get access to /proc.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doDev)))\n        .build();\n  }"
  },
  {
    "function_name": "doVerify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1834-1878",
    "snippet": "kj::MainBuilder::Validity doVerify() {\n    kj::AutoCloseFd ownFd;\n    int spkfd;\n\n    if (spkfile == \"-\") {\n      spkfd = STDIN_FILENO;\n    } else {\n      ownFd = raiiOpen(spkfile, O_RDONLY);\n      spkfd = ownFd;\n    }\n\n    if (detailed) {\n      kj::AutoCloseFd tmpfile = openTemporary(\"/tmp/spk-verify-tmp\");\n      capnp::MallocMessageBuilder message;\n      auto info = message.getRoot<spk::VerifiedInfo>();\n      verifyImpl(spkfd, tmpfile, info, [&](kj::StringPtr problem) -> kj::String {\n        validationError(spkfile, problem);\n      });\n      tmpfile = nullptr;\n\n      AppIdJsonHandler appIdHandler;\n      PackageIdJsonHandler packageIdHandler;\n      OversizeDataHandler oversizeDataHandler;\n      OversizeTextHandler oversizeTextHandler;\n      capnp::JsonCodec json;\n      json.addTypeHandler(appIdHandler);\n      json.addTypeHandler(packageIdHandler);\n      json.addTypeHandler(oversizeDataHandler);\n      json.addTypeHandler(oversizeTextHandler);\n      json.setPrettyPrint(true);\n\n      auto text = json.encode(info);\n      kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n      kj::FdOutputStream(STDOUT_FILENO).write(\"\\n\", 1);\n      context.exit();\n    } else {\n      kj::AutoCloseFd tmpfile = raiiOpen(\"/dev/null\", O_WRONLY | O_CLOEXEC);;\n      auto appId = verifyImpl(spkfd, tmpfile, nullptr, [&](kj::StringPtr problem) -> kj::String {\n        validationError(spkfile, problem);\n      });\n      printAppId(appId);\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "bool detailed = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "appId"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "verifyImpl",
          "args": [
            "spkfd",
            "tmpfile",
            "nullptr",
            "[&](kj::StringPtr problem) -> kj::String {\n        validationError(spkfile, problem);\n      }"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "verifyImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1395-1586",
          "snippet": "static kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "spkfile",
            "problem"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "validationError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1355-1357",
          "snippet": "[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\n[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/dev/null\"",
            "O_WRONLY | O_CLOEXEC"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "\"\\n\"",
            "1"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.encode",
          "args": [
            "info"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.setPrettyPrint",
          "args": [
            "true"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.addTypeHandler",
          "args": [
            "oversizeTextHandler"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.addTypeHandler",
          "args": [
            "oversizeDataHandler"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.addTypeHandler",
          "args": [
            "packageIdHandler"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json.addTypeHandler",
          "args": [
            "appIdHandler"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<spk::VerifiedInfo>",
          "args": [],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openTemporary",
          "args": [
            "\"/tmp/spk-verify-tmp\""
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "openTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "232-241",
          "snippet": "kj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "spkfile",
            "O_RDONLY"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nbool detailed = true;\n\nkj::MainBuilder::Validity doVerify() {\n    kj::AutoCloseFd ownFd;\n    int spkfd;\n\n    if (spkfile == \"-\") {\n      spkfd = STDIN_FILENO;\n    } else {\n      ownFd = raiiOpen(spkfile, O_RDONLY);\n      spkfd = ownFd;\n    }\n\n    if (detailed) {\n      kj::AutoCloseFd tmpfile = openTemporary(\"/tmp/spk-verify-tmp\");\n      capnp::MallocMessageBuilder message;\n      auto info = message.getRoot<spk::VerifiedInfo>();\n      verifyImpl(spkfd, tmpfile, info, [&](kj::StringPtr problem) -> kj::String {\n        validationError(spkfile, problem);\n      });\n      tmpfile = nullptr;\n\n      AppIdJsonHandler appIdHandler;\n      PackageIdJsonHandler packageIdHandler;\n      OversizeDataHandler oversizeDataHandler;\n      OversizeTextHandler oversizeTextHandler;\n      capnp::JsonCodec json;\n      json.addTypeHandler(appIdHandler);\n      json.addTypeHandler(packageIdHandler);\n      json.addTypeHandler(oversizeDataHandler);\n      json.addTypeHandler(oversizeTextHandler);\n      json.setPrettyPrint(true);\n\n      auto text = json.encode(info);\n      kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n      kj::FdOutputStream(STDOUT_FILENO).write(\"\\n\", 1);\n      context.exit();\n    } else {\n      kj::AutoCloseFd tmpfile = raiiOpen(\"/dev/null\", O_WRONLY | O_CLOEXEC);;\n      auto appId = verifyImpl(spkfd, tmpfile, nullptr, [&](kj::StringPtr problem) -> kj::String {\n        validationError(spkfile, problem);\n      });\n      printAppId(appId);\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "setDetailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1829-1832",
    "snippet": "bool setDetailed() {\n    detailed = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool detailed = true;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool detailed = true;\n\nbool setDetailed() {\n    detailed = true;\n    return true;\n  }"
  },
  {
    "function_name": "getVerifyMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1812-1823",
    "snippet": "kj::MainFunc getVerifyMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Check that <spkfile>'s signature is valid. If so, print the app ID to stdout.\")\n        .addOption({'d', \"details\"}, KJ_BIND_METHOD(*this, setDetailed),\n            // `spk verify` now prints details by default, but the --details switch is left here for\n            // backwards compatibility for callers.\n            \"Print detailed metadata extracted from the app manifest. The output is intended to \"\n            \"be machine-parseable.  This flag is now enabled by default.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, setUnpackSpkfile))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doVerify))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);",
      "bool detailed = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doVerify)"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doVerify"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<spkfile>\"",
            "KJ_BIND_METHOD(*this, setUnpackSpkfile)"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUnpackSpkfile"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'d', \"details\"}",
            "KJ_BIND_METHOD(*this, setDetailed)",
            "// `spk verify` now prints details by default, but the --details switch is left here for// backwards compatibility for callers.\"Print detailed metadata extracted from the app manifest. The output is intended to \"\n            \"be machine-parseable.  This flag is now enabled by default.\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setDetailed"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Check that <spkfile>'s signature is valid. If so, print the app ID to stdout.\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\nbool detailed = true;\n\nkj::MainFunc getVerifyMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Check that <spkfile>'s signature is valid. If so, print the app ID to stdout.\")\n        .addOption({'d', \"details\"}, KJ_BIND_METHOD(*this, setDetailed),\n            // `spk verify` now prints details by default, but the --details switch is left here for\n            // backwards compatibility for callers.\n            \"Print detailed metadata extracted from the app manifest. The output is intended to \"\n            \"be machine-parseable.  This flag is now enabled by default.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, setUnpackSpkfile))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doVerify))\n        .build();\n  }"
  },
  {
    "function_name": "unpackDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1750-1807",
    "snippet": "static void unpackDir(capnp::List<spk::Archive::File>::Reader files, kj::StringPtr dirname) {\n    std::set<kj::StringPtr> seen;\n\n    for (auto file: files) {\n      kj::StringPtr name = file.getName();\n      KJ_REQUIRE(name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr,\n                 \"Archive contained invalid file name.\", name);\n\n      KJ_REQUIRE(seen.insert(name).second, \"Archive contained duplicate file name.\", name);\n\n      auto path = kj::str(dirname, '/', name);\n\n      KJ_ASSERT(access(path.cStr(), F_OK) != 0, \"Unpacked file already exists.\", path);\n\n      switch (file.which()) {\n        case spk::Archive::File::REGULAR: {\n          auto bytes = file.getRegular();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::EXECUTABLE: {\n          auto bytes = file.getExecutable();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::SYMLINK: {\n          KJ_SYSCALL(symlink(file.getSymlink().cStr(), path.cStr()), path);\n          break;\n        }\n\n        case spk::Archive::File::DIRECTORY: {\n          KJ_SYSCALL(mkdir(path.cStr(), 0777), path);\n          unpackDir(file.getDirectory(), path);\n          break;\n        }\n\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown file type in archive.\");\n      }\n\n      struct timespec times[2];\n      auto ns = file.getLastModificationTimeNs();\n      times[0].tv_sec = ns / 1000000000ll;\n      times[0].tv_nsec = ns % 1000000000ll;\n      if (times[0].tv_nsec < 0) {\n        // C division rounds towards zero. :(\n        ++times[0].tv_sec;\n        times[0].tv_nsec += 1000000000ll;\n      }\n      times[1] = times[0];  // Also use mtime as atime.\n      KJ_SYSCALL(utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW));\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String dirname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW)"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utimensat",
          "args": [
            "AT_FDCWD",
            "path.cStr()",
            "times",
            "AT_SYMLINK_NOFOLLOW"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getLastModificationTimeNs",
          "args": [],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown file type in archive.\""
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpackDir",
          "args": [
            "file.getDirectory()",
            "path"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "unpackDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1750-1807",
          "snippet": "static void unpackDir(capnp::List<spk::Archive::File>::Reader files, kj::StringPtr dirname) {\n    std::set<kj::StringPtr> seen;\n\n    for (auto file: files) {\n      kj::StringPtr name = file.getName();\n      KJ_REQUIRE(name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr,\n                 \"Archive contained invalid file name.\", name);\n\n      KJ_REQUIRE(seen.insert(name).second, \"Archive contained duplicate file name.\", name);\n\n      auto path = kj::str(dirname, '/', name);\n\n      KJ_ASSERT(access(path.cStr(), F_OK) != 0, \"Unpacked file already exists.\", path);\n\n      switch (file.which()) {\n        case spk::Archive::File::REGULAR: {\n          auto bytes = file.getRegular();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::EXECUTABLE: {\n          auto bytes = file.getExecutable();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::SYMLINK: {\n          KJ_SYSCALL(symlink(file.getSymlink().cStr(), path.cStr()), path);\n          break;\n        }\n\n        case spk::Archive::File::DIRECTORY: {\n          KJ_SYSCALL(mkdir(path.cStr(), 0777), path);\n          unpackDir(file.getDirectory(), path);\n          break;\n        }\n\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown file type in archive.\");\n      }\n\n      struct timespec times[2];\n      auto ns = file.getLastModificationTimeNs();\n      times[0].tv_sec = ns / 1000000000ll;\n      times[0].tv_nsec = ns % 1000000000ll;\n      if (times[0].tv_nsec < 0) {\n        // C division rounds towards zero. :(\n        ++times[0].tv_sec;\n        times[0].tv_nsec += 1000000000ll;\n      }\n      times[1] = times[0];  // Also use mtime as atime.\n      KJ_SYSCALL(utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW));\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "file.getDirectory",
          "args": [],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(path.cStr(), 0777)",
            "path"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path.cStr()",
            "0777"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "symlink(file.getSymlink().cStr(), path.cStr())",
            "path"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "file.getSymlink().cStr()",
            "path.cStr()"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "symlinkPointsInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "101-124",
          "snippet": "static bool symlinkPointsInto(kj::StringPtr symlink, kj::StringPtr targetPrefix) {\n  // Returns true if the given path names a symlink whose target has the given prefix, false if\n  // it points elsewhere or doesn't exist or isn't a symlink.\nretry:\n  char buffer[PATH_MAX];\n  ssize_t n = readlink(symlink.cStr(), buffer, sizeof(buffer) - 1);\n  if (n < 0) {\n    int error = errno;\n    switch (error) {\n      case ENOENT:\n      case ENOTDIR:\n      case EINVAL:\n        // File (or parent directory) dosen't exist or isn't a symlink.\n        return false;\n      case EINTR:\n        goto retry;\n      default:\n        KJ_FAIL_SYSCALL(\"readlink(symlink)\", error, symlink);\n    }\n  } else {\n    buffer[n] = '\\0';\n    return kj::StringPtr(buffer, n).startsWith(targetPrefix);\n  }\n}",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nstatic bool symlinkPointsInto(kj::StringPtr symlink, kj::StringPtr targetPrefix) {\n  // Returns true if the given path names a symlink whose target has the given prefix, false if\n  // it points elsewhere or doesn't exist or isn't a symlink.\nretry:\n  char buffer[PATH_MAX];\n  ssize_t n = readlink(symlink.cStr(), buffer, sizeof(buffer) - 1);\n  if (n < 0) {\n    int error = errno;\n    switch (error) {\n      case ENOENT:\n      case ENOTDIR:\n      case EINVAL:\n        // File (or parent directory) dosen't exist or isn't a symlink.\n        return false;\n      case EINTR:\n        goto retry;\n      default:\n        KJ_FAIL_SYSCALL(\"readlink(symlink)\", error, symlink);\n    }\n  } else {\n    buffer[n] = '\\0';\n    return kj::StringPtr(buffer, n).startsWith(targetPrefix);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getSymlink",
          "args": [],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getSymlink",
          "args": [],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "bytes.begin()",
            "bytes.size()"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.size",
          "args": [],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777)"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "path",
            "O_WRONLY | O_CREAT | O_EXCL",
            "0777"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "raiiOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "71-82",
          "snippet": "kj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.getExecutable",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "bytes.begin()",
            "bytes.size()"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666)"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getRegular",
          "args": [],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.which",
          "args": [],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "access(path.cStr(), F_OK) != 0",
            "\"Unpacked file already exists.\"",
            "path"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path.cStr()",
            "F_OK"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "dirname",
            "'/'",
            "name"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "seen.insert(name).second",
            "\"Archive contained duplicate file name.\"",
            "name"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seen.insert",
          "args": [
            "name"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr",
            "\"Archive contained invalid file name.\"",
            "name"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.findFirst",
          "args": [
            "'\\0'"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.findFirst",
          "args": [
            "'/'"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getName",
          "args": [],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String dirname;\n\nstatic void unpackDir(capnp::List<spk::Archive::File>::Reader files, kj::StringPtr dirname) {\n    std::set<kj::StringPtr> seen;\n\n    for (auto file: files) {\n      kj::StringPtr name = file.getName();\n      KJ_REQUIRE(name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr,\n                 \"Archive contained invalid file name.\", name);\n\n      KJ_REQUIRE(seen.insert(name).second, \"Archive contained duplicate file name.\", name);\n\n      auto path = kj::str(dirname, '/', name);\n\n      KJ_ASSERT(access(path.cStr(), F_OK) != 0, \"Unpacked file already exists.\", path);\n\n      switch (file.which()) {\n        case spk::Archive::File::REGULAR: {\n          auto bytes = file.getRegular();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::EXECUTABLE: {\n          auto bytes = file.getExecutable();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::SYMLINK: {\n          KJ_SYSCALL(symlink(file.getSymlink().cStr(), path.cStr()), path);\n          break;\n        }\n\n        case spk::Archive::File::DIRECTORY: {\n          KJ_SYSCALL(mkdir(path.cStr(), 0777), path);\n          unpackDir(file.getDirectory(), path);\n          break;\n        }\n\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown file type in archive.\");\n      }\n\n      struct timespec times[2];\n      auto ns = file.getLastModificationTimeNs();\n      times[0].tv_sec = ns / 1000000000ll;\n      times[0].tv_nsec = ns % 1000000000ll;\n      if (times[0].tv_nsec < 0) {\n        // C division rounds towards zero. :(\n        ++times[0].tv_sec;\n        times[0].tv_nsec += 1000000000ll;\n      }\n      times[1] = times[0];  // Also use mtime as atime.\n      KJ_SYSCALL(utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW));\n    }\n  }"
  },
  {
    "function_name": "unpackImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1716-1748",
    "snippet": "static kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;",
      "kj::String dirname;",
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpackDir",
          "args": [
            "archiveMessage.getRoot<spk::Archive>().getFiles()",
            "dirname"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "unpackDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1750-1807",
          "snippet": "static void unpackDir(capnp::List<spk::Archive::File>::Reader files, kj::StringPtr dirname) {\n    std::set<kj::StringPtr> seen;\n\n    for (auto file: files) {\n      kj::StringPtr name = file.getName();\n      KJ_REQUIRE(name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr,\n                 \"Archive contained invalid file name.\", name);\n\n      KJ_REQUIRE(seen.insert(name).second, \"Archive contained duplicate file name.\", name);\n\n      auto path = kj::str(dirname, '/', name);\n\n      KJ_ASSERT(access(path.cStr(), F_OK) != 0, \"Unpacked file already exists.\", path);\n\n      switch (file.which()) {\n        case spk::Archive::File::REGULAR: {\n          auto bytes = file.getRegular();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::EXECUTABLE: {\n          auto bytes = file.getExecutable();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::SYMLINK: {\n          KJ_SYSCALL(symlink(file.getSymlink().cStr(), path.cStr()), path);\n          break;\n        }\n\n        case spk::Archive::File::DIRECTORY: {\n          KJ_SYSCALL(mkdir(path.cStr(), 0777), path);\n          unpackDir(file.getDirectory(), path);\n          break;\n        }\n\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown file type in archive.\");\n      }\n\n      struct timespec times[2];\n      auto ns = file.getLastModificationTimeNs();\n      times[0].tv_sec = ns / 1000000000ll;\n      times[0].tv_nsec = ns % 1000000000ll;\n      if (times[0].tv_nsec < 0) {\n        // C division rounds towards zero. :(\n        ++times[0].tv_sec;\n        times[0].tv_nsec += 1000000000ll;\n      }\n      times[1] = times[0];  // Also use mtime as atime.\n      KJ_SYSCALL(utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW));\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String dirname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String dirname;\n\nstatic void unpackDir(capnp::List<spk::Archive::File>::Reader files, kj::StringPtr dirname) {\n    std::set<kj::StringPtr> seen;\n\n    for (auto file: files) {\n      kj::StringPtr name = file.getName();\n      KJ_REQUIRE(name.size() != 0 && name != \".\" && name != \"..\" &&\n                 name.findFirst('/') == nullptr && name.findFirst('\\0') == nullptr,\n                 \"Archive contained invalid file name.\", name);\n\n      KJ_REQUIRE(seen.insert(name).second, \"Archive contained duplicate file name.\", name);\n\n      auto path = kj::str(dirname, '/', name);\n\n      KJ_ASSERT(access(path.cStr(), F_OK) != 0, \"Unpacked file already exists.\", path);\n\n      switch (file.which()) {\n        case spk::Archive::File::REGULAR: {\n          auto bytes = file.getRegular();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0666))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::EXECUTABLE: {\n          auto bytes = file.getExecutable();\n          kj::FdOutputStream(raiiOpen(path, O_WRONLY | O_CREAT | O_EXCL, 0777))\n              .write(bytes.begin(), bytes.size());\n          break;\n        }\n\n        case spk::Archive::File::SYMLINK: {\n          KJ_SYSCALL(symlink(file.getSymlink().cStr(), path.cStr()), path);\n          break;\n        }\n\n        case spk::Archive::File::DIRECTORY: {\n          KJ_SYSCALL(mkdir(path.cStr(), 0777), path);\n          unpackDir(file.getDirectory(), path);\n          break;\n        }\n\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown file type in archive.\");\n      }\n\n      struct timespec times[2];\n      auto ns = file.getLastModificationTimeNs();\n      times[0].tv_sec = ns / 1000000000ll;\n      times[0].tv_nsec = ns % 1000000000ll;\n      if (times[0].tv_nsec < 0) {\n        // C division rounds towards zero. :(\n        ++times[0].tv_sec;\n        times[0].tv_nsec += 1000000000ll;\n      }\n      times[1] = times[0];  // Also use mtime as atime.\n      KJ_SYSCALL(utimensat(AT_FDCWD, path.cStr(), times, AT_SYMLINK_NOFOLLOW));\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "archiveMessage.getRoot<spk::Archive>",
          "args": [],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "archiveMessage.getRoot<spk::Archive>",
          "args": [],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpWords.size",
          "args": [],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "verifyImpl",
          "args": [
            "spkfd",
            "tmpfile",
            "nullptr",
            "kj::mv(validationError)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "verifyImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1395-1586",
          "snippet": "static kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "validationError"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openTemporary",
          "args": [
            "tmpNear"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "openTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "232-241",
          "snippet": "kj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\nkj::String dirname;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nstatic kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }"
  },
  {
    "function_name": "checkPgpSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1593-1714",
    "snippet": "static kj::String checkPgpSignature(\n      kj::StringPtr appIdString, kj::ArrayPtr<const byte> sig, kj::ArrayPtr<const byte> key,\n      kj::Function<kj::String(kj::StringPtr problem)>& validationError,\n      kj::Maybe<uid_t> sandboxUid = nullptr) {\n    auto expectedContent = kj::str(\n        \"I am the author of the Sandstorm.io app with the following ID: \",\n        appIdString);\n\n    char keyfile[] = \"/tmp/spk-pgp-key.XXXXXX\";\n    int keyfd;\n    KJ_SYSCALL(keyfd = mkstemp(keyfile));\n    KJ_DEFER(unlink(keyfile));\n    kj::FdOutputStream(kj::AutoCloseFd(keyfd)).write(key.begin(), key.size());\n\n    char sigfile[] = \"/tmp/spk-pgp-sig.XXXXXX\";\n    int sigfd;\n    KJ_SYSCALL(sigfd = mkstemp(sigfile));\n    KJ_DEFER(unlink(sigfile));\n    kj::FdOutputStream(kj::AutoCloseFd(sigfd)).write(sig.begin(), sig.size());\n\n    // GPG unfortunately DEMANDS to read from its \"home directory\", which is expected to contain\n    // user configuration. We actively don't want this: we want it to run in a reproducible manner.\n    // So we create a fake home.\n    char gpghome[] = \"/tmp/spk-fake-gpg-home.XXXXXX\";\n    if (mkdtemp(gpghome) == nullptr) {\n      KJ_FAIL_SYSCALL(\"mkdtemp(gpghome)\", errno, gpghome);\n    }\n    KJ_DEFER(recursivelyDelete(gpghome));\n\n    auto outPipe = Pipe::make();       // stdout -> signed text\n    auto messagePipe = Pipe::make();   // stderr -> human-readable messages\n    auto statusPipe = Pipe::make();    // fd 3 -> machine-readable messages\n\n    Subprocess::Options gpgOptions({\n        \"gpg\", \"--homedir\", gpghome, \"--status-fd\", \"3\", \"--no-default-keyring\",\n        \"--keyring\", keyfile, \"--decrypt\", sigfile});\n    gpgOptions.uid = sandboxUid;\n    gpgOptions.stdout = outPipe.writeEnd;\n    gpgOptions.stderr = messagePipe.writeEnd;\n    int moreFds[1] = { statusPipe.writeEnd };\n    gpgOptions.moreFds = moreFds;\n    Subprocess gpg(kj::mv(gpgOptions));\n\n    outPipe.writeEnd = nullptr;\n    messagePipe.writeEnd = nullptr;\n    statusPipe.writeEnd = nullptr;\n\n    // Gather output from GPG.\n    // TODO(cleanup): This really belongs in a library, perhaps in `Subprocess`.\n    kj::Vector<char> out, message, status;\n    bool outDone = false, messageDone = false, statusDone = false;\n    for (;;) {\n      kj::Vector<struct pollfd> pollfds;\n      typedef struct pollfd PollFd;\n      if (!outDone) pollfds.add(PollFd {outPipe.readEnd, POLLIN, 0});\n      if (!messageDone) pollfds.add(PollFd {messagePipe.readEnd, POLLIN, 0});\n      if (!statusDone) pollfds.add(PollFd {statusPipe.readEnd, POLLIN, 0});\n      if (pollfds.size() == 0) break;\n      KJ_SYSCALL(poll(pollfds.begin(), pollfds.size(), -1));\n      for (auto& item: pollfds) {\n        if (item.revents & POLLIN) {\n          // Data to read!\n          char buffer[1024];\n          size_t n = kj::FdInputStream(item.fd).read(buffer, 1, sizeof(buffer));\n          if (item.fd == outPipe.readEnd.get()) {\n            out.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            message.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            status.addAll(kj::arrayPtr(buffer, n));\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        } else if (item.revents != 0) {\n          // Woke up with no data available; must be EOF.\n          if (item.fd == outPipe.readEnd.get()) {\n            outDone = true;\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            messageDone = true;\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            statusDone = true;\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        }\n      }\n    }\n\n    if (gpg.waitForExitOrSignal() != 0) {\n      return validationError(kj::str(\n          \"SPK PGP signature check validation failed. GPG output follows.\\n\",\n          kj::implicitCast<kj::ArrayPtr<const char>>(message)));\n    }\n\n    auto content = trim(out);\n    if (content != expectedContent) {\n      return validationError(kj::str(\n          \"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \", expectedContent,\n          \"\\nActual:   \", content));\n    }\n\n    // Look for the VALIDSIG line which provides the PGP key fingerprint.\n    kj::String fingerprint;\n    for (auto& statusLine: split(status, '\\n')) {\n      auto words = splitSpace(statusLine);\n      if (words.size() >= 3 &&\n          kj::heapString(words[0]) == \"[GNUPG:]\" &&\n          kj::heapString(words[1]) == \"VALIDSIG\") {\n        // This is the line we're looking for!\n\n        // words[11] is privacy-key-fpr, i.e. the fingerprint of the user's main key rather than\n        // the subkey used for this signature. The docs suggest it might not be present. words[2]\n        // is always the fingerprint of the exact key that did the signing, so fall back to that\n        // if needed.\n        return kj::heapString(words.size() > 11 ? words[11] : words[2]);\n      }\n    }\n\n    KJ_FAIL_ASSERT(\"couldn't find expected '[GNUPG:] VALIDSIG' line in GPG status output\",\n                   kj::str(status.asPtr()));\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Array<capnp::word>> data;",
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);",
      "friend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);",
      "byte buffer[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"couldn't find expected '[GNUPG:] VALIDSIG' line in GPG status output\"",
            "kj::str(status.asPtr())"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "status.asPtr()"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.asPtr",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "words.size() > 11 ? words[11] : words[2]"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.size",
          "args": [],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "words[1]"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "words[0]"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splitSpace",
          "args": [
            "statusLine"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "splitSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "430-446",
          "snippet": "kj::Vector<kj::ArrayPtr<const char>> splitSpace(kj::ArrayPtr<const char> input) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (isspace(input[i])) {\n      if (i > start) {\n        result.add(input.slice(start, i));\n      }\n      start = i + 1;\n    }\n  }\n  if (input.size() > start) {\n    result.add(input.slice(start, input.size()));\n  }\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Vector<kj::ArrayPtr<const char>> splitSpace(kj::ArrayPtr<const char> input) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (isspace(input[i])) {\n      if (i > start) {\n        result.add(input.slice(start, i));\n      }\n      start = i + 1;\n    }\n  }\n  if (input.size() > start) {\n    result.add(input.slice(start, input.size()));\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "status",
            "'\\n'"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "kj::str(\n          \"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \", expectedContent,\n          \"\\nActual:   \", content)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \"",
            "expectedContent",
            "\"\\nActual:   \"",
            "content"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "out"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "kj::str(\n          \"SPK PGP signature check validation failed. GPG output follows.\\n\",\n          kj::implicitCast<kj::ArrayPtr<const char>>(message))"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"SPK PGP signature check validation failed. GPG output follows.\\n\"",
            "kj::implicitCast<kj::ArrayPtr<const char>>(message)"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<kj::ArrayPtr<const char>>",
          "args": [
            "message"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpg.waitForExitOrSignal",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1010-1019",
          "snippet": "int Subprocess::waitForExitOrSignal() {\n  KJ_REQUIRE(pid != 0, \"already waited for this child\");\n  int status;\n  KJ_SYSCALL(waitpid(pid, &status, 0));\n  KJ_IF_MAYBE(s, subprocessSet) {\n    s->alreadyReaped(pid);\n  }\n  pid = 0;\n  return status;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExitOrSignal() {\n    KJ_REQUIRE(pid != 0, \"already waited for this child\");\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0));\n    KJ_IF_MAYBE(s, subprocessSet) {\n      s->alreadyReaped(pid);\n    }\n    pid = 0;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"unexpected FD returned by poll()?\""
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statusPipe.readEnd.get",
          "args": [],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "messagePipe.readEnd.get",
          "args": [],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outPipe.readEnd.get",
          "args": [],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"unexpected FD returned by poll()?\""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.addAll",
          "args": [
            "kj::arrayPtr(buffer, n)"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "n"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statusPipe.readEnd.get",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.addAll",
          "args": [
            "kj::arrayPtr(buffer, n)"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "n"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "messagePipe.readEnd.get",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.addAll",
          "args": [
            "kj::arrayPtr(buffer, n)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "n"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outPipe.readEnd.get",
          "args": [],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "buffer",
            "1",
            "sizeof(buffer)"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "item.fd"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "poll(pollfds.begin(), pollfds.size(), -1)"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "pollfds.begin()",
            "pollfds.size()",
            "-1"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollfds.begin",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollfds.add",
          "args": [
            "PollFd {statusPipe.readEnd, POLLIN, 0}"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollfds.add",
          "args": [
            "PollFd {messagePipe.readEnd, POLLIN, 0}"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollfds.add",
          "args": [
            "PollFd {outPipe.readEnd, POLLIN, 0}"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "recursivelyDelete(gpghome)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyDelete",
          "args": [
            "gpghome"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "299-313",
          "snippet": "void recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mkdtemp(gpghome)\"",
            "errno",
            "gpghome"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "gpghome"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "sig.begin()",
            "sig.size()"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig.begin",
          "args": [],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "kj::AutoCloseFd(sigfd)"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "sigfd"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "unlink(sigfile)"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "sigfile"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigfd = mkstemp(sigfile)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "sigfile"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "key.begin()",
            "key.size()"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.begin",
          "args": [],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "kj::AutoCloseFd(keyfd)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "keyfd"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "unlink(keyfile)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "keyfile"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "keyfd = mkstemp(keyfile)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "keyfile"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"I am the author of the Sandstorm.io app with the following ID: \"",
            "appIdString"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\nfriend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);\nbyte buffer[1024];\n\nstatic kj::String checkPgpSignature(\n      kj::StringPtr appIdString, kj::ArrayPtr<const byte> sig, kj::ArrayPtr<const byte> key,\n      kj::Function<kj::String(kj::StringPtr problem)>& validationError,\n      kj::Maybe<uid_t> sandboxUid = nullptr) {\n    auto expectedContent = kj::str(\n        \"I am the author of the Sandstorm.io app with the following ID: \",\n        appIdString);\n\n    char keyfile[] = \"/tmp/spk-pgp-key.XXXXXX\";\n    int keyfd;\n    KJ_SYSCALL(keyfd = mkstemp(keyfile));\n    KJ_DEFER(unlink(keyfile));\n    kj::FdOutputStream(kj::AutoCloseFd(keyfd)).write(key.begin(), key.size());\n\n    char sigfile[] = \"/tmp/spk-pgp-sig.XXXXXX\";\n    int sigfd;\n    KJ_SYSCALL(sigfd = mkstemp(sigfile));\n    KJ_DEFER(unlink(sigfile));\n    kj::FdOutputStream(kj::AutoCloseFd(sigfd)).write(sig.begin(), sig.size());\n\n    // GPG unfortunately DEMANDS to read from its \"home directory\", which is expected to contain\n    // user configuration. We actively don't want this: we want it to run in a reproducible manner.\n    // So we create a fake home.\n    char gpghome[] = \"/tmp/spk-fake-gpg-home.XXXXXX\";\n    if (mkdtemp(gpghome) == nullptr) {\n      KJ_FAIL_SYSCALL(\"mkdtemp(gpghome)\", errno, gpghome);\n    }\n    KJ_DEFER(recursivelyDelete(gpghome));\n\n    auto outPipe = Pipe::make();       // stdout -> signed text\n    auto messagePipe = Pipe::make();   // stderr -> human-readable messages\n    auto statusPipe = Pipe::make();    // fd 3 -> machine-readable messages\n\n    Subprocess::Options gpgOptions({\n        \"gpg\", \"--homedir\", gpghome, \"--status-fd\", \"3\", \"--no-default-keyring\",\n        \"--keyring\", keyfile, \"--decrypt\", sigfile});\n    gpgOptions.uid = sandboxUid;\n    gpgOptions.stdout = outPipe.writeEnd;\n    gpgOptions.stderr = messagePipe.writeEnd;\n    int moreFds[1] = { statusPipe.writeEnd };\n    gpgOptions.moreFds = moreFds;\n    Subprocess gpg(kj::mv(gpgOptions));\n\n    outPipe.writeEnd = nullptr;\n    messagePipe.writeEnd = nullptr;\n    statusPipe.writeEnd = nullptr;\n\n    // Gather output from GPG.\n    // TODO(cleanup): This really belongs in a library, perhaps in `Subprocess`.\n    kj::Vector<char> out, message, status;\n    bool outDone = false, messageDone = false, statusDone = false;\n    for (;;) {\n      kj::Vector<struct pollfd> pollfds;\n      typedef struct pollfd PollFd;\n      if (!outDone) pollfds.add(PollFd {outPipe.readEnd, POLLIN, 0});\n      if (!messageDone) pollfds.add(PollFd {messagePipe.readEnd, POLLIN, 0});\n      if (!statusDone) pollfds.add(PollFd {statusPipe.readEnd, POLLIN, 0});\n      if (pollfds.size() == 0) break;\n      KJ_SYSCALL(poll(pollfds.begin(), pollfds.size(), -1));\n      for (auto& item: pollfds) {\n        if (item.revents & POLLIN) {\n          // Data to read!\n          char buffer[1024];\n          size_t n = kj::FdInputStream(item.fd).read(buffer, 1, sizeof(buffer));\n          if (item.fd == outPipe.readEnd.get()) {\n            out.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            message.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            status.addAll(kj::arrayPtr(buffer, n));\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        } else if (item.revents != 0) {\n          // Woke up with no data available; must be EOF.\n          if (item.fd == outPipe.readEnd.get()) {\n            outDone = true;\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            messageDone = true;\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            statusDone = true;\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        }\n      }\n    }\n\n    if (gpg.waitForExitOrSignal() != 0) {\n      return validationError(kj::str(\n          \"SPK PGP signature check validation failed. GPG output follows.\\n\",\n          kj::implicitCast<kj::ArrayPtr<const char>>(message)));\n    }\n\n    auto content = trim(out);\n    if (content != expectedContent) {\n      return validationError(kj::str(\n          \"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \", expectedContent,\n          \"\\nActual:   \", content));\n    }\n\n    // Look for the VALIDSIG line which provides the PGP key fingerprint.\n    kj::String fingerprint;\n    for (auto& statusLine: split(status, '\\n')) {\n      auto words = splitSpace(statusLine);\n      if (words.size() >= 3 &&\n          kj::heapString(words[0]) == \"[GNUPG:]\" &&\n          kj::heapString(words[1]) == \"VALIDSIG\") {\n        // This is the line we're looking for!\n\n        // words[11] is privacy-key-fpr, i.e. the fingerprint of the user's main key rather than\n        // the subkey used for this signature. The docs suggest it might not be present. words[2]\n        // is always the fingerprint of the exact key that did the signing, so fall back to that\n        // if needed.\n        return kj::heapString(words.size() > 11 ? words[11] : words[2]);\n      }\n    }\n\n    KJ_FAIL_ASSERT(\"couldn't find expected '[GNUPG:] VALIDSIG' line in GPG status output\",\n                   kj::str(status.asPtr()));\n  }"
  },
  {
    "function_name": "requireHttpUrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1588-1591",
    "snippet": "static void requireHttpUrl(kj::StringPtr url) {\n    KJ_REQUIRE(url.startsWith(\"http://\") || url.startsWith(\"https://\"),\n               \"web URLs must be HTTP\", url);\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "url.startsWith(\"http://\") || url.startsWith(\"https://\")",
            "\"web URLs must be HTTP\"",
            "url"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.startsWith",
          "args": [
            "\"https://\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.startsWith",
          "args": [
            "\"http://\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstatic void requireHttpUrl(kj::StringPtr url) {\n    KJ_REQUIRE(url.startsWith(\"http://\") || url.startsWith(\"https://\"),\n               \"web URLs must be HTTP\", url);\n  }"
  },
  {
    "function_name": "verifyImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1395-1586",
    "snippet": "static kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Array<capnp::word>> data;",
      "byte buffer[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"SPK contains no manifest file.\""
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->setAuthorPgpKeyFingerprint",
          "args": [
            "checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError)"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkPgpSignature",
          "args": [
            "appIdString",
            "author.getPgpSignature()",
            "metadata.getPgpKeyring()",
            "validationError"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "checkPgpSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1593-1714",
          "snippet": "static kj::String checkPgpSignature(\n      kj::StringPtr appIdString, kj::ArrayPtr<const byte> sig, kj::ArrayPtr<const byte> key,\n      kj::Function<kj::String(kj::StringPtr problem)>& validationError,\n      kj::Maybe<uid_t> sandboxUid = nullptr) {\n    auto expectedContent = kj::str(\n        \"I am the author of the Sandstorm.io app with the following ID: \",\n        appIdString);\n\n    char keyfile[] = \"/tmp/spk-pgp-key.XXXXXX\";\n    int keyfd;\n    KJ_SYSCALL(keyfd = mkstemp(keyfile));\n    KJ_DEFER(unlink(keyfile));\n    kj::FdOutputStream(kj::AutoCloseFd(keyfd)).write(key.begin(), key.size());\n\n    char sigfile[] = \"/tmp/spk-pgp-sig.XXXXXX\";\n    int sigfd;\n    KJ_SYSCALL(sigfd = mkstemp(sigfile));\n    KJ_DEFER(unlink(sigfile));\n    kj::FdOutputStream(kj::AutoCloseFd(sigfd)).write(sig.begin(), sig.size());\n\n    // GPG unfortunately DEMANDS to read from its \"home directory\", which is expected to contain\n    // user configuration. We actively don't want this: we want it to run in a reproducible manner.\n    // So we create a fake home.\n    char gpghome[] = \"/tmp/spk-fake-gpg-home.XXXXXX\";\n    if (mkdtemp(gpghome) == nullptr) {\n      KJ_FAIL_SYSCALL(\"mkdtemp(gpghome)\", errno, gpghome);\n    }\n    KJ_DEFER(recursivelyDelete(gpghome));\n\n    auto outPipe = Pipe::make();       // stdout -> signed text\n    auto messagePipe = Pipe::make();   // stderr -> human-readable messages\n    auto statusPipe = Pipe::make();    // fd 3 -> machine-readable messages\n\n    Subprocess::Options gpgOptions({\n        \"gpg\", \"--homedir\", gpghome, \"--status-fd\", \"3\", \"--no-default-keyring\",\n        \"--keyring\", keyfile, \"--decrypt\", sigfile});\n    gpgOptions.uid = sandboxUid;\n    gpgOptions.stdout = outPipe.writeEnd;\n    gpgOptions.stderr = messagePipe.writeEnd;\n    int moreFds[1] = { statusPipe.writeEnd };\n    gpgOptions.moreFds = moreFds;\n    Subprocess gpg(kj::mv(gpgOptions));\n\n    outPipe.writeEnd = nullptr;\n    messagePipe.writeEnd = nullptr;\n    statusPipe.writeEnd = nullptr;\n\n    // Gather output from GPG.\n    // TODO(cleanup): This really belongs in a library, perhaps in `Subprocess`.\n    kj::Vector<char> out, message, status;\n    bool outDone = false, messageDone = false, statusDone = false;\n    for (;;) {\n      kj::Vector<struct pollfd> pollfds;\n      typedef struct pollfd PollFd;\n      if (!outDone) pollfds.add(PollFd {outPipe.readEnd, POLLIN, 0});\n      if (!messageDone) pollfds.add(PollFd {messagePipe.readEnd, POLLIN, 0});\n      if (!statusDone) pollfds.add(PollFd {statusPipe.readEnd, POLLIN, 0});\n      if (pollfds.size() == 0) break;\n      KJ_SYSCALL(poll(pollfds.begin(), pollfds.size(), -1));\n      for (auto& item: pollfds) {\n        if (item.revents & POLLIN) {\n          // Data to read!\n          char buffer[1024];\n          size_t n = kj::FdInputStream(item.fd).read(buffer, 1, sizeof(buffer));\n          if (item.fd == outPipe.readEnd.get()) {\n            out.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            message.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            status.addAll(kj::arrayPtr(buffer, n));\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        } else if (item.revents != 0) {\n          // Woke up with no data available; must be EOF.\n          if (item.fd == outPipe.readEnd.get()) {\n            outDone = true;\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            messageDone = true;\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            statusDone = true;\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        }\n      }\n    }\n\n    if (gpg.waitForExitOrSignal() != 0) {\n      return validationError(kj::str(\n          \"SPK PGP signature check validation failed. GPG output follows.\\n\",\n          kj::implicitCast<kj::ArrayPtr<const char>>(message)));\n    }\n\n    auto content = trim(out);\n    if (content != expectedContent) {\n      return validationError(kj::str(\n          \"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \", expectedContent,\n          \"\\nActual:   \", content));\n    }\n\n    // Look for the VALIDSIG line which provides the PGP key fingerprint.\n    kj::String fingerprint;\n    for (auto& statusLine: split(status, '\\n')) {\n      auto words = splitSpace(statusLine);\n      if (words.size() >= 3 &&\n          kj::heapString(words[0]) == \"[GNUPG:]\" &&\n          kj::heapString(words[1]) == \"VALIDSIG\") {\n        // This is the line we're looking for!\n\n        // words[11] is privacy-key-fpr, i.e. the fingerprint of the user's main key rather than\n        // the subkey used for this signature. The docs suggest it might not be present. words[2]\n        // is always the fingerprint of the exact key that did the signing, so fall back to that\n        // if needed.\n        return kj::heapString(words.size() > 11 ? words[11] : words[2]);\n      }\n    }\n\n    KJ_FAIL_ASSERT(\"couldn't find expected '[GNUPG:] VALIDSIG' line in GPG status output\",\n                   kj::str(status.asPtr()));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Array<capnp::word>> data;",
            "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);",
            "friend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);",
            "byte buffer[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\nfriend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);\nbyte buffer[1024];\n\nstatic kj::String checkPgpSignature(\n      kj::StringPtr appIdString, kj::ArrayPtr<const byte> sig, kj::ArrayPtr<const byte> key,\n      kj::Function<kj::String(kj::StringPtr problem)>& validationError,\n      kj::Maybe<uid_t> sandboxUid = nullptr) {\n    auto expectedContent = kj::str(\n        \"I am the author of the Sandstorm.io app with the following ID: \",\n        appIdString);\n\n    char keyfile[] = \"/tmp/spk-pgp-key.XXXXXX\";\n    int keyfd;\n    KJ_SYSCALL(keyfd = mkstemp(keyfile));\n    KJ_DEFER(unlink(keyfile));\n    kj::FdOutputStream(kj::AutoCloseFd(keyfd)).write(key.begin(), key.size());\n\n    char sigfile[] = \"/tmp/spk-pgp-sig.XXXXXX\";\n    int sigfd;\n    KJ_SYSCALL(sigfd = mkstemp(sigfile));\n    KJ_DEFER(unlink(sigfile));\n    kj::FdOutputStream(kj::AutoCloseFd(sigfd)).write(sig.begin(), sig.size());\n\n    // GPG unfortunately DEMANDS to read from its \"home directory\", which is expected to contain\n    // user configuration. We actively don't want this: we want it to run in a reproducible manner.\n    // So we create a fake home.\n    char gpghome[] = \"/tmp/spk-fake-gpg-home.XXXXXX\";\n    if (mkdtemp(gpghome) == nullptr) {\n      KJ_FAIL_SYSCALL(\"mkdtemp(gpghome)\", errno, gpghome);\n    }\n    KJ_DEFER(recursivelyDelete(gpghome));\n\n    auto outPipe = Pipe::make();       // stdout -> signed text\n    auto messagePipe = Pipe::make();   // stderr -> human-readable messages\n    auto statusPipe = Pipe::make();    // fd 3 -> machine-readable messages\n\n    Subprocess::Options gpgOptions({\n        \"gpg\", \"--homedir\", gpghome, \"--status-fd\", \"3\", \"--no-default-keyring\",\n        \"--keyring\", keyfile, \"--decrypt\", sigfile});\n    gpgOptions.uid = sandboxUid;\n    gpgOptions.stdout = outPipe.writeEnd;\n    gpgOptions.stderr = messagePipe.writeEnd;\n    int moreFds[1] = { statusPipe.writeEnd };\n    gpgOptions.moreFds = moreFds;\n    Subprocess gpg(kj::mv(gpgOptions));\n\n    outPipe.writeEnd = nullptr;\n    messagePipe.writeEnd = nullptr;\n    statusPipe.writeEnd = nullptr;\n\n    // Gather output from GPG.\n    // TODO(cleanup): This really belongs in a library, perhaps in `Subprocess`.\n    kj::Vector<char> out, message, status;\n    bool outDone = false, messageDone = false, statusDone = false;\n    for (;;) {\n      kj::Vector<struct pollfd> pollfds;\n      typedef struct pollfd PollFd;\n      if (!outDone) pollfds.add(PollFd {outPipe.readEnd, POLLIN, 0});\n      if (!messageDone) pollfds.add(PollFd {messagePipe.readEnd, POLLIN, 0});\n      if (!statusDone) pollfds.add(PollFd {statusPipe.readEnd, POLLIN, 0});\n      if (pollfds.size() == 0) break;\n      KJ_SYSCALL(poll(pollfds.begin(), pollfds.size(), -1));\n      for (auto& item: pollfds) {\n        if (item.revents & POLLIN) {\n          // Data to read!\n          char buffer[1024];\n          size_t n = kj::FdInputStream(item.fd).read(buffer, 1, sizeof(buffer));\n          if (item.fd == outPipe.readEnd.get()) {\n            out.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            message.addAll(kj::arrayPtr(buffer, n));\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            status.addAll(kj::arrayPtr(buffer, n));\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        } else if (item.revents != 0) {\n          // Woke up with no data available; must be EOF.\n          if (item.fd == outPipe.readEnd.get()) {\n            outDone = true;\n          } else if (item.fd == messagePipe.readEnd.get()) {\n            messageDone = true;\n          } else if (item.fd == statusPipe.readEnd.get()) {\n            statusDone = true;\n          } else {\n            KJ_FAIL_ASSERT(\"unexpected FD returned by poll()?\");\n          }\n        }\n      }\n    }\n\n    if (gpg.waitForExitOrSignal() != 0) {\n      return validationError(kj::str(\n          \"SPK PGP signature check validation failed. GPG output follows.\\n\",\n          kj::implicitCast<kj::ArrayPtr<const char>>(message)));\n    }\n\n    auto content = trim(out);\n    if (content != expectedContent) {\n      return validationError(kj::str(\n          \"SPK PGP signature signed incorrect text.\"\n          \"\\nExpected: \", expectedContent,\n          \"\\nActual:   \", content));\n    }\n\n    // Look for the VALIDSIG line which provides the PGP key fingerprint.\n    kj::String fingerprint;\n    for (auto& statusLine: split(status, '\\n')) {\n      auto words = splitSpace(statusLine);\n      if (words.size() >= 3 &&\n          kj::heapString(words[0]) == \"[GNUPG:]\" &&\n          kj::heapString(words[1]) == \"VALIDSIG\") {\n        // This is the line we're looking for!\n\n        // words[11] is privacy-key-fpr, i.e. the fingerprint of the user's main key rather than\n        // the subkey used for this signature. The docs suggest it might not be present. words[2]\n        // is always the fingerprint of the exact key that did the signing, so fall back to that\n        // if needed.\n        return kj::heapString(words.size() > 11 ? words[11] : words[2]);\n      }\n    }\n\n    KJ_FAIL_ASSERT(\"couldn't find expected '[GNUPG:] VALIDSIG' line in GPG status output\",\n                   kj::str(status.asPtr()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "metadata.getPgpKeyring",
          "args": [],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "author.getPgpSignature",
          "args": [],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"author's PGP signature is present but no PGP keyring is provided\""
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.hasPgpKeyring",
          "args": [],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "author.hasPgpSignature",
          "args": [],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.getAuthor",
          "args": [],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requireHttpUrl",
          "args": [
            "metadata.getCodeUrl()"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "requireHttpUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1588-1591",
          "snippet": "static void requireHttpUrl(kj::StringPtr url) {\n    KJ_REQUIRE(url.startsWith(\"http://\") || url.startsWith(\"https://\"),\n               \"web URLs must be HTTP\", url);\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstatic void requireHttpUrl(kj::StringPtr url) {\n    KJ_REQUIRE(url.startsWith(\"http://\") || url.startsWith(\"https://\"),\n               \"web URLs must be HTTP\", url);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "metadata.getCodeUrl",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.hasCodeUrl",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.getWebsite",
          "args": [],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.hasWebsite",
          "args": [],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->setMetadata",
          "args": [
            "metadata"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifest.getMetadata",
          "args": [],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->setMarketingVersion",
          "args": [
            "manifest.getAppMarketingVersion()"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifest.getAppMarketingVersion",
          "args": [],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->setVersion",
          "args": [
            "manifest.getAppVersion()"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifest.getAppVersion",
          "args": [],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->setTitle",
          "args": [
            "manifest.getAppTitle()"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifest.getAppTitle",
          "args": [],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "packageId.begin()",
            "packageIdBytes.begin()",
            "packageIdBytes.size()"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageIdBytes.size",
          "args": [],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packageIdBytes.begin",
          "args": [],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageId.begin",
          "args": [],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "packageId.size() == packageIdBytes.size()"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::AnyStruct::Builder",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::AnyStruct::Builder",
          "args": [
            "info->initPackageId()"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->initPackageId",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "appId.begin()",
            "publicKey",
            "sizeof(publicKey)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appId.begin",
          "args": [],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "appId.size() == sizeof(publicKey)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::AnyStruct::Builder",
          "args": [],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::AnyStruct::Builder",
          "args": [
            "info->initAppId()"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info->initAppId",
          "args": [],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifestMessage.getRoot<spk::Manifest>",
          "args": [],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<const capnp::word*>(data.begin())",
            "data.size() / sizeof(capnp::word)"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const capnp::word*>",
          "args": [
            "data.begin()"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getRegular",
          "args": [],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"sandstorm-manifest is not a regular file\""
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.isRegular",
          "args": [],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getName",
          "args": [],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "archiveMessage.getRoot<spk::Archive>",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "archiveMessage.getRoot<spk::Archive>",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstorm::appIdString",
          "args": [
            "publicKey"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "applyAppidReplacements",
          "args": [
            "publicKey",
            "packageIdBytes"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Signature didn't match package contents.\""
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "expectedHash",
            "hash",
            "crypto_hash_sha512_BYTES"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha512_final",
          "args": [
            "&hashState",
            "hash"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "packageHash",
            "PACKAGE_ID_BYTE_SIZE"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child.waitForSuccess",
          "args": [],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "993-996",
          "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmpOut.write",
          "args": [
            "buffer",
            "n"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "totalRead <= APP_SIZE_LIMIT",
            "\"App too big after decompress.\""
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha512_update",
          "args": [
            "&hashState",
            "buffer",
            "n"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.tryRead",
          "args": [
            "buffer",
            "1",
            "sizeof(buffer)"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha512_init",
          "args": [
            "&hashState"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Wrong signature size.\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Invalid signature.\""
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_open",
          "args": [
            "expectedHash",
            "&hashLength",
            "sigBytes",
            "sizeof(sigBytes)",
            "publicKey"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sigBytes",
            "sigReader.begin()",
            "sizeof(sigBytes)"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigReader.begin",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Invalid signature format.\""
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.getSignature",
          "args": [],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "publicKey",
            "pkReader.begin()",
            "sizeof(publicKey)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pkReader.begin",
          "args": [],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Invalid public key.\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.getPublicKey",
          "args": [],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signatureMessage.getRoot<spk::Signature>",
          "args": [],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipe.readEnd"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "\"Does not appear to be an .spk (bad magic number).\""
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "expectedMagic"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "magic",
            "expectedMagic.size()"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "spkPipe.readEnd.get()"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spkPipe.readEnd.get",
          "args": [],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spk::MAGIC_NUMBER.get",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_hash_sha256_final(&packageHashState, packageHash)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha256_final",
          "args": [
            "&packageHashState",
            "packageHash"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_hash_sha256_update(&packageHashState, buffer, n) == 0"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha256_update",
          "args": [
            "&packageHashState",
            "buffer",
            "n"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = read(spkfd, buffer, sizeof(buffer))"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "spkfd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "spkPipe.writeEnd"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_hash_sha256_init(&packageHashState) == 0"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha256_init",
          "args": [
            "&packageHashState"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Maybe<kj::Array<capnp::word>> data;\nbyte buffer[1024];\n\nstatic kj::String verifyImpl(\n      int spkfd, int tmpfile, kj::Maybe<spk::VerifiedInfo::Builder> maybeInfo,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // Read package form spkfd, check the validity and signature, and return the appId. Also write\n    // the uncompressed archive to `tmpfile`.\n\n    // We need to compute the hash of the input. The input could be a pipe (not a file), therefore\n    // we need to read it in chunks, hash the content, and write back out to the pipe that xz will\n    // use as input below. We'll do all that in a thread to keep the code simple.\n    byte packageHash[crypto_hash_sha256_BYTES];\n    Pipe spkPipe = Pipe::make();\n    auto hashThread = new kj::Thread([&]() {\n      crypto_hash_sha256_state packageHashState;\n      KJ_ASSERT(crypto_hash_sha256_init(&packageHashState) == 0);\n\n      byte buffer[8192];\n      kj::FdOutputStream out(kj::mv(spkPipe.writeEnd));\n      for (;;) {\n        ssize_t n;\n        KJ_SYSCALL(n = read(spkfd, buffer, sizeof(buffer)));\n        if (n == 0) break;\n        KJ_ASSERT(crypto_hash_sha256_update(&packageHashState, buffer, n) == 0);\n        out.write(buffer, n);\n      }\n\n      KJ_ASSERT(crypto_hash_sha256_final(&packageHashState, packageHash));\n    });\n\n    // Check the magic number.\n    auto expectedMagic = spk::MAGIC_NUMBER.get();\n    byte magic[expectedMagic.size()];\n    kj::FdInputStream(spkPipe.readEnd.get()).read(magic, expectedMagic.size());\n    for (uint i: kj::indices(expectedMagic)) {\n      if (magic[i] != expectedMagic[i]) {\n        return validationError(\"Does not appear to be an .spk (bad magic number).\");\n      }\n    }\n\n    // Decompress the remaining bytes in the SPK using xz.\n    Pipe pipe = Pipe::make();\n\n    Subprocess::Options childOptions({\"xz\", \"-dc\"});\n    childOptions.stdin = spkPipe.readEnd;\n    childOptions.stdout = pipe.writeEnd;\n    Subprocess child(kj::mv(childOptions));\n\n    spkPipe.readEnd = nullptr;\n    pipe.writeEnd = nullptr;\n    kj::FdInputStream in(kj::mv(pipe.readEnd));\n\n    // Read in the signature.\n    byte publicKey[crypto_sign_PUBLICKEYBYTES];\n    byte sigBytes[crypto_hash_sha512_BYTES + crypto_sign_BYTES];\n    {\n      // TODO(security): Set a small limit on signature size?\n      capnp::InputStreamMessageReader signatureMessage(in);\n      auto signature = signatureMessage.getRoot<spk::Signature>();\n      auto pkReader = signature.getPublicKey();\n      if (pkReader.size() != sizeof(publicKey)) {\n        return validationError(\"Invalid public key.\");\n      }\n      memcpy(publicKey, pkReader.begin(), sizeof(publicKey));\n      auto sigReader = signature.getSignature();\n      if (sigReader.size() != sizeof(sigBytes)) {\n        return validationError(\"Invalid signature format.\");\n      }\n      memcpy(sigBytes, sigReader.begin(), sizeof(sigBytes));\n    }\n\n    // Verify the signature.\n    byte expectedHash[sizeof(sigBytes)];\n    unsigned long long hashLength = 0;  // will be overwritten later\n    int result = crypto_sign_open(\n        expectedHash, &hashLength, sigBytes, sizeof(sigBytes), publicKey);\n    if (result != 0) {\n      return validationError(\"Invalid signature.\");\n    }\n    if (hashLength != crypto_hash_sha512_BYTES) {\n      return validationError(\"Wrong signature size.\");\n    }\n\n    // Copy archive part to a temp file, computing hash in the meantime.\n    crypto_hash_sha512_state hashState;\n    crypto_hash_sha512_init(&hashState);\n    kj::FdOutputStream tmpOut(tmpfile);\n    uint64_t totalRead = 0;\n    for (;;) {\n      byte buffer[8192];\n      size_t n = in.tryRead(buffer, 1, sizeof(buffer));\n      if (n == 0) break;\n      crypto_hash_sha512_update(&hashState, buffer, n);\n      totalRead += n;\n      KJ_REQUIRE(totalRead <= APP_SIZE_LIMIT, \"App too big after decompress.\");\n      tmpOut.write(buffer, n);\n    }\n\n    child.waitForSuccess();\n    hashThread = nullptr;  // joins thread\n\n    // The spk pipe thread should have exited now, completing the hash.\n    static_assert(PACKAGE_ID_BYTE_SIZE <= crypto_hash_sha256_BYTES, \"package ID size changed?\");\n    auto packageIdBytes = kj::arrayPtr(packageHash, PACKAGE_ID_BYTE_SIZE);\n\n    // Check that hashes match.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512_final(&hashState, hash);\n    if (memcmp(expectedHash, hash, crypto_hash_sha512_BYTES) != 0) {\n      return validationError(\"Signature didn't match package contents.\");\n    }\n\n    // Get the canonical app ID based on the replacements table (see appid-replacements.capnp).\n    // This also throws if the key is revoked.\n    applyAppidReplacements(publicKey, packageIdBytes);\n\n    auto appIdString = sandstorm::appIdString(publicKey);\n\n    KJ_IF_MAYBE(info, maybeInfo) {\n      // mmap the temp file.\n      MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n\n      // Set up archive reader.\n      kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n      capnp::ReaderOptions options;\n      options.traversalLimitInWords = tmpWords.size();\n      capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n      bool foundManifest = false;\n      for (auto file: archiveMessage.getRoot<spk::Archive>().getFiles()) {\n        if (file.getName() == \"sandstorm-manifest\") {\n          if (!file.isRegular()) {\n            return validationError(\"sandstorm-manifest is not a regular file\");\n          }\n\n          auto data = file.getRegular();\n\n          capnp::ReaderOptions manifestLimits;\n          manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n\n          // Data fields are always word-aligned.\n          capnp::FlatArrayMessageReader manifestMessage(\n              kj::arrayPtr(reinterpret_cast<const capnp::word*>(data.begin()),\n                           data.size() / sizeof(capnp::word)), manifestLimits);\n\n          auto manifest = manifestMessage.getRoot<spk::Manifest>();\n\n          // TODO(someday): Support localization properly?\n\n          {\n            auto appId = capnp::AnyStruct::Builder(info->initAppId()).getDataSection();\n            KJ_ASSERT(appId.size() == sizeof(publicKey));\n            memcpy(appId.begin(), publicKey, sizeof(publicKey));\n          }\n          {\n            auto packageId = capnp::AnyStruct::Builder(info->initPackageId()).getDataSection();\n            KJ_ASSERT(packageId.size() == packageIdBytes.size());\n            memcpy(packageId.begin(), packageIdBytes.begin(), packageIdBytes.size());\n          }\n\n          info->setTitle(manifest.getAppTitle());\n          info->setVersion(manifest.getAppVersion());\n          info->setMarketingVersion(manifest.getAppMarketingVersion());\n          auto metadata = manifest.getMetadata();\n          info->setMetadata(metadata);\n\n          // Validate some things.\n          if (metadata.hasWebsite()) requireHttpUrl(metadata.getWebsite());\n          if (metadata.hasCodeUrl()) requireHttpUrl(metadata.getCodeUrl());\n\n          // Check author PGP key.\n          auto author = metadata.getAuthor();\n          if (author.hasPgpSignature()) {\n            if (!metadata.hasPgpKeyring()) {\n              return validationError(\n                  \"author's PGP signature is present but no PGP keyring is provided\");\n            }\n\n            info->setAuthorPgpKeyFingerprint(checkPgpSignature(appIdString,\n                author.getPgpSignature(), metadata.getPgpKeyring(), validationError));\n          }\n\n          foundManifest = true;\n          break;\n        }\n      }\n\n      if (!foundManifest) {\n        return validationError(\"SPK contains no manifest file.\");\n      }\n    }\n\n    return appIdString;\n  }"
  },
  {
    "function_name": "doUnpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1359-1388",
    "snippet": "kj::MainBuilder::Validity doUnpack() {\n    if (dirname == nullptr) {\n      return \"must specify directory name when filename doesn't end with \\\".spk\\\"\";\n    }\n    if (access(dirname.cStr(), F_OK) == 0) {\n      return \"output directory already exists\";\n    }\n    KJ_SYSCALL(mkdir(dirname.cStr(), 0777), dirname);\n\n    kj::AutoCloseFd ownFd;\n    int spkfd;\n\n    kj::StringPtr tmpNear;\n    if (spkfile == \"-\") {\n      spkfd = STDIN_FILENO;\n      tmpNear = \"/tmp/spk-unpack\";\n    } else {\n      ownFd = raiiOpen(spkfile, O_RDONLY);\n      spkfd = ownFd;\n      tmpNear = spkfile;\n    }\n\n    printAppId(unpackImpl(spkfd, dirname, tmpNear,\n        [&](kj::StringPtr problem) -> kj::String {\n      rmdir(dirname.cStr());\n      validationError(spkfile, problem);\n    }));\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "kj::String dirname;",
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "unpackImpl(spkfd, dirname, tmpNear,\n        [&](kj::StringPtr problem) -> kj::String {\n      rmdir(dirname.cStr());\n      validationError(spkfile, problem);\n    })"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "unpackImpl",
          "args": [
            "spkfd",
            "dirname",
            "tmpNear",
            "[&](kj::StringPtr problem) -> kj::String {\n      rmdir(dirname.cStr());\n      validationError(spkfile, problem);\n    }"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "unpackImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1716-1748",
          "snippet": "static kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;",
            "kj::String dirname;",
            "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\nkj::String dirname;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nstatic kj::String unpackImpl(\n      int spkfd, kj::StringPtr dirname, kj::StringPtr tmpNear,\n      kj::Function<kj::String(kj::StringPtr problem)> validationError) {\n    // TODO(security):  We could at this point chroot into the output directory and unshare\n    //   various resources for extra security, if not for the fact that we need to invoke xz\n    //   later on.  Maybe link against the xz library so that we don't have to exec it?\n\n    auto tmpfile = openTemporary(tmpNear);\n    auto appId = verifyImpl(spkfd, tmpfile, nullptr, kj::mv(validationError));\n\n    // mmap the temp file.\n    MemoryMapping tmpMapping(tmpfile, \"(temp file)\");\n    tmpfile = nullptr;  // We have the mapping now; don't need the fd.\n\n    // Set up archive reader.\n    kj::ArrayPtr<const capnp::word> tmpWords = tmpMapping;\n    capnp::ReaderOptions options;\n    options.traversalLimitInWords = tmpWords.size();\n\n    // We've observed that apps which use npm can have insanely deep directory trees due to npm's\n    // insane approach to dependency management. We've seen at least one app creep over the default\n    // nesting limit of 64, so we double it to 128. (We can't just set this to infinity for the\n    // same security reasons this limit exists in the first place.)\n    options.nestingLimit = 128;\n\n    capnp::FlatArrayMessageReader archiveMessage(tmpWords, options);\n\n    // Unpack.\n    unpackDir(archiveMessage.getRoot<spk::Archive>().getFiles(), dirname);\n\n    // Note the appid.\n    return appId;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "validationError",
          "args": [
            "spkfile",
            "problem"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "validationError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1355-1357",
          "snippet": "[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\n[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dirname.cStr()"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.cStr",
          "args": [],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "spkfile",
            "O_RDONLY"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(dirname.cStr(), 0777)",
            "dirname"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dirname.cStr()",
            "0777"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.cStr",
          "args": [],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "dirname.cStr()",
            "F_OK"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.cStr",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nkj::String dirname;\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainBuilder::Validity doUnpack() {\n    if (dirname == nullptr) {\n      return \"must specify directory name when filename doesn't end with \\\".spk\\\"\";\n    }\n    if (access(dirname.cStr(), F_OK) == 0) {\n      return \"output directory already exists\";\n    }\n    KJ_SYSCALL(mkdir(dirname.cStr(), 0777), dirname);\n\n    kj::AutoCloseFd ownFd;\n    int spkfd;\n\n    kj::StringPtr tmpNear;\n    if (spkfile == \"-\") {\n      spkfd = STDIN_FILENO;\n      tmpNear = \"/tmp/spk-unpack\";\n    } else {\n      ownFd = raiiOpen(spkfile, O_RDONLY);\n      spkfd = ownFd;\n      tmpNear = spkfile;\n    }\n\n    printAppId(unpackImpl(spkfd, dirname, tmpNear,\n        [&](kj::StringPtr problem) -> kj::String {\n      rmdir(dirname.cStr());\n      validationError(spkfile, problem);\n    }));\n\n    return true;\n  }"
  },
  {
    "function_name": "validationError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1355-1357",
    "snippet": "[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"*** \", filename, \": \", problem)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"*** \"",
            "filename",
            "\": \"",
            "problem"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\n[[noreturn]] void validationError(kj::StringPtr filename, kj::StringPtr problem) {\n    context.exitError(kj::str(\"*** \", filename, \": \", problem));\n  }"
  },
  {
    "function_name": "setUnpackDirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1346-1353",
    "snippet": "kj::MainBuilder::Validity setUnpackDirname(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) == 0) {\n      return \"Already exists.\";\n    }\n\n    dirname = kj::heapString(name);\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String dirname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "name.cStr()",
            "F_OK"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String dirname;\n\nkj::MainBuilder::Validity setUnpackDirname(kj::StringPtr name) {\n    if (access(name.cStr(), F_OK) == 0) {\n      return \"Already exists.\";\n    }\n\n    dirname = kj::heapString(name);\n    return true;\n  }"
  },
  {
    "function_name": "setUnpackSpkfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1333-1344",
    "snippet": "kj::MainBuilder::Validity setUnpackSpkfile(kj::StringPtr name) {\n    if (name != \"-\" && access(name.cStr(), F_OK) < 0) {\n      return \"Not found.\";\n    }\n\n    spkfile = kj::heapString(name);\n    if (spkfile.endsWith(\".spk\")) {\n      dirname = kj::heapString(spkfile.slice(0, spkfile.size() - 4));\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;",
      "kj::String dirname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "spkfile.slice(0, spkfile.size() - 4)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spkfile.slice",
          "args": [
            "0",
            "spkfile.size() - 4"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spkfile.size",
          "args": [],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "spkfile.endsWith",
          "args": [
            "\".spk\""
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "name.cStr()",
            "F_OK"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\nkj::String dirname;\n\nkj::MainBuilder::Validity setUnpackSpkfile(kj::StringPtr name) {\n    if (name != \"-\" && access(name.cStr(), F_OK) < 0) {\n      return \"Not found.\";\n    }\n\n    spkfile = kj::heapString(name);\n    if (spkfile.endsWith(\".spk\")) {\n      dirname = kj::heapString(spkfile.slice(0, spkfile.size() - 4));\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "getUnpackMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1322-1331",
    "snippet": "kj::MainFunc getUnpackMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Check that <spkfile>'s signature is valid.  If so, unpack it to <outdir> and \"\n            \"print the app ID.  If <outdir> is not specified, it will be \"\n            \"chosen by removing the suffix \\\".spk\\\" from the input file name.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, setUnpackSpkfile))\n        .expectOptionalArg(\"<outdir>\", KJ_BIND_METHOD(*this, setUnpackDirname))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doUnpack))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doUnpack)"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doUnpack"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<outdir>\"",
            "KJ_BIND_METHOD(*this, setUnpackDirname)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUnpackDirname"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<spkfile>\"",
            "KJ_BIND_METHOD(*this, setUnpackSpkfile)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUnpackSpkfile"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Check that <spkfile>'s signature is valid.  If so, unpack it to <outdir> and \"\n            \"print the app ID.  If <outdir> is not specified, it will be \"\n            \"chosen by removing the suffix \\\".spk\\\" from the input file name.\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\n\nkj::MainFunc getUnpackMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Check that <spkfile>'s signature is valid.  If so, unpack it to <outdir> and \"\n            \"print the app ID.  If <outdir> is not specified, it will be \"\n            \"chosen by removing the suffix \\\".spk\\\" from the input file name.\")\n        .expectArg(\"<spkfile>\", KJ_BIND_METHOD(*this, setUnpackSpkfile))\n        .expectOptionalArg(\"<outdir>\", KJ_BIND_METHOD(*this, setUnpackDirname))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doUnpack))\n        .build();\n  }"
  },
  {
    "function_name": "getHttpBridgeExe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1310-1316",
    "snippet": "kj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return kj::heapString",
          "args": [
            "\"/bin/sandstorm-http-bridge\""
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "exePath.slice(0, *slashPos)",
            "\"/bin/sandstorm-http-bridge\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exePath.slice",
          "args": [
            "0",
            "*slashPos"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "slashPos",
            "exePath.findLast('/')"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exePath.findLast",
          "args": [
            "'/'"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }"
  },
  {
    "function_name": "initNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1270-1308",
    "snippet": "void initNode(ArchiveNode& node, kj::StringPtr srcPath, FileMapping&& mapping,\n                const spk::SourceMap::Reader& sourceMap, bool recursive) {\n    if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n      // Nothing here.\n      return;\n    }\n\n    if (recursive && (mapping.sourcePaths.size() == 0 || isDirectory(mapping.sourcePaths[0]))) {\n      // Primary match is a directory, so merge all of the matching directories.\n      std::set<kj::String> seen;\n      for (auto& child: mapping.virtualChildren) {\n        seen.insert(kj::mv(child));\n      }\n      for (auto& target: mapping.sourcePaths) {\n        if (isDirectory(target)) {\n          // This is one of the directories to be merged. List it.\n          for (auto& child: listDirectory(target)) {\n            if (child != \".\" && child != \"..\") {\n              seen.insert(kj::mv(child));\n            }\n          }\n        }\n      }\n\n      for (auto& child: seen) {\n        // Note that this child node could be hidden. We need to use mapFile() on it directly\n        // in order to make sure it maps to a real file.\n        auto subPath = srcPath.size() == 0 ?\n            kj::str(child) : kj::str(srcPath, '/', child);\n        auto subMapping = mapFile(sourceDir, sourceMap, subPath);\n        initNode(node.followPath(child), subPath, kj::mv(subMapping), sourceMap,\n                 recursive);\n      }\n    }\n\n    if (mapping.sourcePaths.size() > 0) {\n      node.setTarget(kj::mv(mapping.sourcePaths[0]));\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node.setTarget",
          "args": [
            "kj::mv(mapping.sourcePaths[0])"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "setTarget",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1139-1149",
          "snippet": "uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n  KJ_REQUIRE(state.is<Passive>());\n\n  ++iteration;\n  target = newTarget;\n\n  // If the previous target was a promise target, fulfill it.\n  state.get<Passive>()->fulfill(kj::mv(newTarget));\n\n  return iteration;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n    KJ_REQUIRE(state.is<Passive>());\n  \n    ++iteration;\n    target = newTarget;\n  \n    // If the previous target was a promise target, fulfill it.\n    state.get<Passive>()->fulfill(kj::mv(newTarget));\n  \n    return iteration;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mapping.sourcePaths[0]"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping.sourcePaths.size",
          "args": [],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initNode",
          "args": [
            "node.followPath(child)",
            "subPath",
            "kj::mv(subMapping)",
            "sourceMap",
            "recursive"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "initNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1270-1308",
          "snippet": "void initNode(ArchiveNode& node, kj::StringPtr srcPath, FileMapping&& mapping,\n                const spk::SourceMap::Reader& sourceMap, bool recursive) {\n    if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n      // Nothing here.\n      return;\n    }\n\n    if (recursive && (mapping.sourcePaths.size() == 0 || isDirectory(mapping.sourcePaths[0]))) {\n      // Primary match is a directory, so merge all of the matching directories.\n      std::set<kj::String> seen;\n      for (auto& child: mapping.virtualChildren) {\n        seen.insert(kj::mv(child));\n      }\n      for (auto& target: mapping.sourcePaths) {\n        if (isDirectory(target)) {\n          // This is one of the directories to be merged. List it.\n          for (auto& child: listDirectory(target)) {\n            if (child != \".\" && child != \"..\") {\n              seen.insert(kj::mv(child));\n            }\n          }\n        }\n      }\n\n      for (auto& child: seen) {\n        // Note that this child node could be hidden. We need to use mapFile() on it directly\n        // in order to make sure it maps to a real file.\n        auto subPath = srcPath.size() == 0 ?\n            kj::str(child) : kj::str(srcPath, '/', child);\n        auto subMapping = mapFile(sourceDir, sourceMap, subPath);\n        initNode(node.followPath(child), subPath, kj::mv(subMapping), sourceMap,\n                 recursive);\n      }\n    }\n\n    if (mapping.sourcePaths.size() > 0) {\n      node.setTarget(kj::mv(mapping.sourcePaths[0]));\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "subMapping"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.followPath",
          "args": [
            "child"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapFile",
          "args": [
            "sourceDir",
            "sourceMap",
            "subPath"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "mapFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "726-787",
          "snippet": "FileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nFileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "srcPath",
            "'/'",
            "child"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "child"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seen.insert",
          "args": [
            "kj::mv(child)"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "child"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listDirectory",
          "args": [
            "target"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "292-297",
          "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "isDirectory",
          "args": [
            "target"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "isDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "243-247",
          "snippet": "bool isDirectory(kj::StringPtr path) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  return S_ISDIR(stats.st_mode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nbool isDirectory(kj::StringPtr path) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  return S_ISDIR(stats.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seen.insert",
          "args": [
            "kj::mv(child)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "child"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nvoid initNode(ArchiveNode& node, kj::StringPtr srcPath, FileMapping&& mapping,\n                const spk::SourceMap::Reader& sourceMap, bool recursive) {\n    if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n      // Nothing here.\n      return;\n    }\n\n    if (recursive && (mapping.sourcePaths.size() == 0 || isDirectory(mapping.sourcePaths[0]))) {\n      // Primary match is a directory, so merge all of the matching directories.\n      std::set<kj::String> seen;\n      for (auto& child: mapping.virtualChildren) {\n        seen.insert(kj::mv(child));\n      }\n      for (auto& target: mapping.sourcePaths) {\n        if (isDirectory(target)) {\n          // This is one of the directories to be merged. List it.\n          for (auto& child: listDirectory(target)) {\n            if (child != \".\" && child != \"..\") {\n              seen.insert(kj::mv(child));\n            }\n          }\n        }\n      }\n\n      for (auto& child: seen) {\n        // Note that this child node could be hidden. We need to use mapFile() on it directly\n        // in order to make sure it maps to a real file.\n        auto subPath = srcPath.size() == 0 ?\n            kj::str(child) : kj::str(srcPath, '/', child);\n        auto subMapping = mapFile(sourceDir, sourceMap, subPath);\n        initNode(node.followPath(child), subPath, kj::mv(subMapping), sourceMap,\n                 recursive);\n      }\n    }\n\n    if (mapping.sourcePaths.size() > 0) {\n      node.setTarget(kj::mv(mapping.sourcePaths[0]));\n    }\n  }"
  },
  {
    "function_name": "addNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1224-1268",
    "snippet": "void addNode(ArchiveNode& root, kj::StringPtr path, const spk::SourceMap::Reader& sourceMap,\n               bool recursive) {\n    if (path.startsWith(\"/\")) {\n      context.exitError(kj::str(\"Destination (in-package) path must not start with '/': \", path));\n    }\n    if (path == \".\") {\n      path = \"\";\n    }\n\n    auto& node = root.followPath(path);\n    if (path == \"sandstorm-manifest\") {\n      // Serialize the manifest.\n      auto manifestReader = packageDef.getManifest();\n      capnp::MallocMessageBuilder manifestMessage(manifestReader.totalSize().wordCount + 4);\n      manifestMessage.setRoot(manifestReader);\n      node.setData(capnp::messageToFlatArray(manifestMessage));\n    } else if (path == \"sandstorm-http-bridge-config\") {\n      // Serialize the bridgeConfig.\n      auto bridgeConfigReader = packageDef.getBridgeConfig();\n      capnp::MallocMessageBuilder bridgeConfigMessage(bridgeConfigReader.totalSize().wordCount + 4);\n      bridgeConfigMessage.setRoot(bridgeConfigReader);\n      node.setData(capnp::messageToFlatArray(bridgeConfigMessage));\n    } else if (path == \"sandstorm-http-bridge\") {\n      node.setTarget(getHttpBridgeExe());\n    } else if (path == \"proc/cpuinfo\") {\n      // Empty /proc/cpuinfo will be overmounted by the supervisor.\n      node.setData(nullptr);\n    } else {\n      if (path.size() == 0 && recursive) {\n        addNode(root, \"sandstorm-manifest\", sourceMap, true);\n        if (packageDef.hasBridgeConfig() ||\n            isHttpBridgeCommand(packageDef.getManifest().getContinueCommand())) {\n          addNode(root, \"sandstorm-http-bridge-config\", sourceMap, true);\n          addNode(root, \"sandstorm-http-bridge\", sourceMap, true);\n        }\n      }\n\n      auto mapping = mapFile(sourceDir, sourceMap, path);\n      if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n        context.exitError(kj::str(\"No file found to satisfy requirement: \", path));\n      } else {\n        initNode(node, path, kj::mv(mapping), sourceMap, recursive);\n      }\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "initNode",
          "args": [
            "node",
            "path",
            "kj::mv(mapping)",
            "sourceMap",
            "recursive"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "initNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1270-1308",
          "snippet": "void initNode(ArchiveNode& node, kj::StringPtr srcPath, FileMapping&& mapping,\n                const spk::SourceMap::Reader& sourceMap, bool recursive) {\n    if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n      // Nothing here.\n      return;\n    }\n\n    if (recursive && (mapping.sourcePaths.size() == 0 || isDirectory(mapping.sourcePaths[0]))) {\n      // Primary match is a directory, so merge all of the matching directories.\n      std::set<kj::String> seen;\n      for (auto& child: mapping.virtualChildren) {\n        seen.insert(kj::mv(child));\n      }\n      for (auto& target: mapping.sourcePaths) {\n        if (isDirectory(target)) {\n          // This is one of the directories to be merged. List it.\n          for (auto& child: listDirectory(target)) {\n            if (child != \".\" && child != \"..\") {\n              seen.insert(kj::mv(child));\n            }\n          }\n        }\n      }\n\n      for (auto& child: seen) {\n        // Note that this child node could be hidden. We need to use mapFile() on it directly\n        // in order to make sure it maps to a real file.\n        auto subPath = srcPath.size() == 0 ?\n            kj::str(child) : kj::str(srcPath, '/', child);\n        auto subMapping = mapFile(sourceDir, sourceMap, subPath);\n        initNode(node.followPath(child), subPath, kj::mv(subMapping), sourceMap,\n                 recursive);\n      }\n    }\n\n    if (mapping.sourcePaths.size() > 0) {\n      node.setTarget(kj::mv(mapping.sourcePaths[0]));\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nvoid initNode(ArchiveNode& node, kj::StringPtr srcPath, FileMapping&& mapping,\n                const spk::SourceMap::Reader& sourceMap, bool recursive) {\n    if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n      // Nothing here.\n      return;\n    }\n\n    if (recursive && (mapping.sourcePaths.size() == 0 || isDirectory(mapping.sourcePaths[0]))) {\n      // Primary match is a directory, so merge all of the matching directories.\n      std::set<kj::String> seen;\n      for (auto& child: mapping.virtualChildren) {\n        seen.insert(kj::mv(child));\n      }\n      for (auto& target: mapping.sourcePaths) {\n        if (isDirectory(target)) {\n          // This is one of the directories to be merged. List it.\n          for (auto& child: listDirectory(target)) {\n            if (child != \".\" && child != \"..\") {\n              seen.insert(kj::mv(child));\n            }\n          }\n        }\n      }\n\n      for (auto& child: seen) {\n        // Note that this child node could be hidden. We need to use mapFile() on it directly\n        // in order to make sure it maps to a real file.\n        auto subPath = srcPath.size() == 0 ?\n            kj::str(child) : kj::str(srcPath, '/', child);\n        auto subMapping = mapFile(sourceDir, sourceMap, subPath);\n        initNode(node.followPath(child), subPath, kj::mv(subMapping), sourceMap,\n                 recursive);\n      }\n    }\n\n    if (mapping.sourcePaths.size() > 0) {\n      node.setTarget(kj::mv(mapping.sourcePaths[0]));\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mapping"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"No file found to satisfy requirement: \", path)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"No file found to satisfy requirement: \"",
            "path"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping.virtualChildren.size",
          "args": [],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapFile",
          "args": [
            "sourceDir",
            "sourceMap",
            "path"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "mapFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "726-787",
          "snippet": "FileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nFileMapping mapFile(kj::StringPtr sourceDir, spk::SourceMap::Reader sourceMap, kj::StringPtr name) {\n  kj::Vector<kj::String> matches;\n  kj::Vector<kj::String> virtualChildren;\n\n  for (auto dir: sourceMap.getSearchPath()) {\n    auto virtualPath = dir.getPackagePath();\n    KJ_IF_MAYBE(subPath, tryRemovePathPrefix(name, virtualPath)) {\n      // If the path is some file or subdirectory inside the virtual path...\n      if (subPath->size() > 0) {\n        // ... then check to see if it's hidden.\n        bool hidden = false;\n        for (auto hide: dir.getHidePaths()) {\n          if (tryRemovePathPrefix(*subPath, hide) != nullptr) {\n            hidden = true;\n            break;\n          }\n        }\n        if (hidden) continue;\n      }\n\n      // Not hidden, so now check if this path exists.\n      auto sourcePath = dir.getSourcePath();\n      auto candidate = joinPaths(sourcePath, *subPath);\n\n      // Prepend `sourceDir` to relative paths.\n      candidate = joinPaths(sourceDir, candidate);\n\n      if (faccessat(AT_FDCWD, candidate.cStr(), F_OK, AT_SYMLINK_NOFOLLOW) == 0) {\n        // Found!\n\n        if (name.size() == 0) {\n          // This is a root mapping. In this case we follow symlinks eagerly.\n          struct stat stats;\n          KJ_SYSCALL(lstat(candidate.cStr(), &stats));\n          if (S_ISLNK(stats.st_mode)) {\n            char* real;\n            KJ_SYSCALL(real = realpath(candidate.cStr(), NULL));\n            KJ_DEFER(free(real));\n            candidate = kj::str(real);\n          }\n        }\n\n        matches.add(kj::mv(candidate));\n      }\n    } else {\n      // virtualPath is not a prefix of `name`, but is `name` a prefix of `virtualPath`?\n      KJ_IF_MAYBE(child, tryRemovePathPrefix(virtualPath, name)) {\n        // Yep.\n        KJ_IF_MAYBE(slashPos, child->findFirst('/')) {\n          virtualChildren.add(kj::heapString(child->slice(0, *slashPos)));\n        } else {\n          virtualChildren.add(kj::heapString(*child));\n        }\n      }\n    }\n  }\n\n  return FileMapping {\n    matches.releaseAsArray(),\n    virtualChildren.releaseAsArray()\n  };\n}"
        }
      },
      {
        "call_info": {
          "callee": "addNode",
          "args": [
            "root",
            "\"sandstorm-http-bridge\"",
            "sourceMap",
            "true"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "addNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1224-1268",
          "snippet": "void addNode(ArchiveNode& root, kj::StringPtr path, const spk::SourceMap::Reader& sourceMap,\n               bool recursive) {\n    if (path.startsWith(\"/\")) {\n      context.exitError(kj::str(\"Destination (in-package) path must not start with '/': \", path));\n    }\n    if (path == \".\") {\n      path = \"\";\n    }\n\n    auto& node = root.followPath(path);\n    if (path == \"sandstorm-manifest\") {\n      // Serialize the manifest.\n      auto manifestReader = packageDef.getManifest();\n      capnp::MallocMessageBuilder manifestMessage(manifestReader.totalSize().wordCount + 4);\n      manifestMessage.setRoot(manifestReader);\n      node.setData(capnp::messageToFlatArray(manifestMessage));\n    } else if (path == \"sandstorm-http-bridge-config\") {\n      // Serialize the bridgeConfig.\n      auto bridgeConfigReader = packageDef.getBridgeConfig();\n      capnp::MallocMessageBuilder bridgeConfigMessage(bridgeConfigReader.totalSize().wordCount + 4);\n      bridgeConfigMessage.setRoot(bridgeConfigReader);\n      node.setData(capnp::messageToFlatArray(bridgeConfigMessage));\n    } else if (path == \"sandstorm-http-bridge\") {\n      node.setTarget(getHttpBridgeExe());\n    } else if (path == \"proc/cpuinfo\") {\n      // Empty /proc/cpuinfo will be overmounted by the supervisor.\n      node.setData(nullptr);\n    } else {\n      if (path.size() == 0 && recursive) {\n        addNode(root, \"sandstorm-manifest\", sourceMap, true);\n        if (packageDef.hasBridgeConfig() ||\n            isHttpBridgeCommand(packageDef.getManifest().getContinueCommand())) {\n          addNode(root, \"sandstorm-http-bridge-config\", sourceMap, true);\n          addNode(root, \"sandstorm-http-bridge\", sourceMap, true);\n        }\n      }\n\n      auto mapping = mapFile(sourceDir, sourceMap, path);\n      if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n        context.exitError(kj::str(\"No file found to satisfy requirement: \", path));\n      } else {\n        initNode(node, path, kj::mv(mapping), sourceMap, recursive);\n      }\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "isHttpBridgeCommand",
          "args": [
            "packageDef.getManifest().getContinueCommand()"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "isHttpBridgeCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1212-1222",
          "snippet": "bool isHttpBridgeCommand(spk::Manifest::Command::Reader command) {\n    // Hacky heuristic to decide if the package uses sandstorm-http-bridge.\n    auto argv = command.getArgv();\n    if (argv.size() == 0) return false;\n\n    auto exe = argv[0];\n\n    return exe == \"/sandstorm-http-bridge\" ||\n           exe == \"./sandstorm-http-bridge\" ||\n           exe == \"sandstorm-http-bridge\";\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool isHttpBridgeCommand(spk::Manifest::Command::Reader command) {\n    // Hacky heuristic to decide if the package uses sandstorm-http-bridge.\n    auto argv = command.getArgv();\n    if (argv.size() == 0) return false;\n\n    auto exe = argv[0];\n\n    return exe == \"/sandstorm-http-bridge\" ||\n           exe == \"./sandstorm-http-bridge\" ||\n           exe == \"sandstorm-http-bridge\";\n  }"
        }
      },
      {
        "call_info": {
          "callee": "packageDef.getManifest",
          "args": [],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getManifest",
          "args": [],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.hasBridgeConfig",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setData",
          "args": [
            "nullptr"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setTarget",
          "args": [
            "getHttpBridgeExe()"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "setTarget",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1139-1149",
          "snippet": "uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n  KJ_REQUIRE(state.is<Passive>());\n\n  ++iteration;\n  target = newTarget;\n\n  // If the previous target was a promise target, fulfill it.\n  state.get<Passive>()->fulfill(kj::mv(newTarget));\n\n  return iteration;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n    KJ_REQUIRE(state.is<Passive>());\n  \n    ++iteration;\n    target = newTarget;\n  \n    // If the previous target was a promise target, fulfill it.\n    state.get<Passive>()->fulfill(kj::mv(newTarget));\n  \n    return iteration;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getHttpBridgeExe",
          "args": [],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "getHttpBridgeExe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1310-1316",
          "snippet": "kj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String getHttpBridgeExe() {\n    KJ_IF_MAYBE(slashPos, exePath.findLast('/')) {\n      return kj::str(exePath.slice(0, *slashPos), \"/bin/sandstorm-http-bridge\");\n    } else {\n      return kj::heapString(\"/bin/sandstorm-http-bridge\");\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "node.setData",
          "args": [
            "capnp::messageToFlatArray(bridgeConfigMessage)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::messageToFlatArray",
          "args": [
            "bridgeConfigMessage"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bridgeConfigMessage.setRoot",
          "args": [
            "bridgeConfigReader"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "setRoot",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "66-69",
          "snippet": "bool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRoot(kj::StringPtr arg) {\n    root = arg;\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bridgeConfigReader.totalSize",
          "args": [],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getBridgeConfig",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setData",
          "args": [
            "capnp::messageToFlatArray(manifestMessage)"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::messageToFlatArray",
          "args": [
            "manifestMessage"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifestReader.totalSize",
          "args": [],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getManifest",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "path"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"Destination (in-package) path must not start with '/': \", path)"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Destination (in-package) path must not start with '/': \"",
            "path"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.startsWith",
          "args": [
            "\"/\""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nvoid addNode(ArchiveNode& root, kj::StringPtr path, const spk::SourceMap::Reader& sourceMap,\n               bool recursive) {\n    if (path.startsWith(\"/\")) {\n      context.exitError(kj::str(\"Destination (in-package) path must not start with '/': \", path));\n    }\n    if (path == \".\") {\n      path = \"\";\n    }\n\n    auto& node = root.followPath(path);\n    if (path == \"sandstorm-manifest\") {\n      // Serialize the manifest.\n      auto manifestReader = packageDef.getManifest();\n      capnp::MallocMessageBuilder manifestMessage(manifestReader.totalSize().wordCount + 4);\n      manifestMessage.setRoot(manifestReader);\n      node.setData(capnp::messageToFlatArray(manifestMessage));\n    } else if (path == \"sandstorm-http-bridge-config\") {\n      // Serialize the bridgeConfig.\n      auto bridgeConfigReader = packageDef.getBridgeConfig();\n      capnp::MallocMessageBuilder bridgeConfigMessage(bridgeConfigReader.totalSize().wordCount + 4);\n      bridgeConfigMessage.setRoot(bridgeConfigReader);\n      node.setData(capnp::messageToFlatArray(bridgeConfigMessage));\n    } else if (path == \"sandstorm-http-bridge\") {\n      node.setTarget(getHttpBridgeExe());\n    } else if (path == \"proc/cpuinfo\") {\n      // Empty /proc/cpuinfo will be overmounted by the supervisor.\n      node.setData(nullptr);\n    } else {\n      if (path.size() == 0 && recursive) {\n        addNode(root, \"sandstorm-manifest\", sourceMap, true);\n        if (packageDef.hasBridgeConfig() ||\n            isHttpBridgeCommand(packageDef.getManifest().getContinueCommand())) {\n          addNode(root, \"sandstorm-http-bridge-config\", sourceMap, true);\n          addNode(root, \"sandstorm-http-bridge\", sourceMap, true);\n        }\n      }\n\n      auto mapping = mapFile(sourceDir, sourceMap, path);\n      if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n        context.exitError(kj::str(\"No file found to satisfy requirement: \", path));\n      } else {\n        initNode(node, path, kj::mv(mapping), sourceMap, recursive);\n      }\n    }\n  }"
  },
  {
    "function_name": "isHttpBridgeCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1212-1222",
    "snippet": "bool isHttpBridgeCommand(spk::Manifest::Command::Reader command) {\n    // Hacky heuristic to decide if the package uses sandstorm-http-bridge.\n    auto argv = command.getArgv();\n    if (argv.size() == 0) return false;\n\n    auto exe = argv[0];\n\n    return exe == \"/sandstorm-http-bridge\" ||\n           exe == \"./sandstorm-http-bridge\" ||\n           exe == \"sandstorm-http-bridge\";\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv.size",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "command.getArgv",
          "args": [],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool isHttpBridgeCommand(spk::Manifest::Command::Reader command) {\n    // Hacky heuristic to decide if the package uses sandstorm-http-bridge.\n    auto argv = command.getArgv();\n    if (argv.size() == 0) return false;\n\n    auto exe = argv[0];\n\n    return exe == \"/sandstorm-http-bridge\" ||\n           exe == \"./sandstorm-http-bridge\" ||\n           exe == \"sandstorm-http-bridge\";\n  }"
  },
  {
    "function_name": "packChildren",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1183-1196",
    "snippet": "capnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "std::map<kj::String, ArchiveNode> children;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "child.second.pack",
          "args": [
            "childBuilder",
            "context",
            "defaultMTime"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1073-1181",
          "snippet": "class ArchiveNode {\n    // A tree of files.\n  public:\n    ArchiveNode() {}\n\n    inline void setTarget(kj::String&& target) { this->target = kj::mv(target); }\n    inline void setData(kj::Array<capnp::word>&& data) { this->data = kj::mv(data); }\n\n    ArchiveNode& followPath(kj::StringPtr path) {\n      if (path == nullptr) return *this;\n\n      kj::String pathPart;\n      KJ_IF_MAYBE(slashPos, path.findFirst('/')) {\n        pathPart = kj::heapString(path.slice(0, *slashPos));\n        path = path.slice(*slashPos + 1);\n      } else {\n        pathPart = kj::heapString(path);\n        path = nullptr;\n      }\n\n      return children[kj::mv(pathPart)].followPath(path);\n    }\n\n    void pack(spk::Archive::File::Builder builder, kj::ProcessContext& context,\n              struct timespec defaultMTime) {\n      auto orphanage = capnp::Orphanage::getForMessageContaining(builder);\n\n      KJ_IF_MAYBE(d, data) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n        auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(d->begin()),\n                                  d->size() * sizeof(capnp::word));\n        builder.adoptRegular(orphanage.referenceExternalData(bytes));\n        return;\n      }\n\n      struct stat stats;\n\n      if (target == nullptr) {\n        stats.st_mode = S_IFDIR;\n        stats.st_mtim = defaultMTime;\n      } else {\n        KJ_SYSCALL(lstat(target.cStr(), &stats), target);\n      }\n\n      auto mtime = stats.st_mtim.tv_sec * kj::SECONDS + stats.st_mtim.tv_nsec * kj::NANOSECONDS;\n      builder.setLastModificationTimeNs(mtime / kj::NANOSECONDS);\n\n      if (S_ISREG(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n\n        kj::AutoCloseFd fd = raiiOpen(target, O_RDONLY);\n        size_t size = getFileSize(fd, target);\n\n        if (size >= (1ull << 29)) {\n          context.exitError(kj::str(target, \": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\"));\n        }\n\n        // Reading the entirety of a file into memory can take up a sizable\n        // chunk of RAM, so we'd prefer to not pay that cost if we don't need\n        // it.\n        //\n        // MemoryMapping doesn't keep a copy in RAM, but it does keep an mmap()\n        // to the file open until we clean up the whole arena, which can wind\n        // up taking a lot of file table entries.  In particular, VirtualBox\n        // shared folders cannot handle >4096 concurrent mmap()s of files from\n        // the host.  So we have to be cautious using MemoryMapping for all files.\n        //\n        // It is generally the case that most files are small, but most of your\n        // data is in large files.  This suggests the following heuristic as a\n        // compromise: use MemoryMapping for files larger than 128k (specific\n        // number adjustable) and read the whole file into memory for anything\n        // smaller.  So we do that.\n        if (size > 1ull << 17) {\n          // File larger than 128k, mmap preferred\n          mapping = MemoryMapping(kj::mv(fd), target);\n          auto content = orphanage.referenceExternalData(mapping);\n          if (stats.st_mode & S_IXUSR) {\n            builder.adoptExecutable(kj::mv(content));\n          } else {\n            builder.adoptRegular(kj::mv(content));\n          }\n        } else {\n          // Small file; direct read preferable.\n          ::capnp::Data::Builder buf = nullptr;\n          if (stats.st_mode & S_IXUSR) {\n            buf = builder.initExecutable(size);\n          } else {\n            buf = builder.initRegular(size);\n          }\n          kj::FdInputStream stream(kj::mv(fd));\n          stream.read(buf.begin(), size);\n        }\n\n      } else if (S_ISLNK(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got symlink, expected directory\", target);\n\n        auto symlink = builder.initSymlink(stats.st_size);\n\n        ssize_t linkSize;\n        KJ_SYSCALL(linkSize = readlink(target.cStr(), symlink.begin(), stats.st_size), target);\n      } else if (S_ISDIR(stats.st_mode)) {\n        builder.adoptDirectory(packChildren(orphanage, context, defaultMTime));\n      } else {\n        context.warning(kj::str(\"Cannot pack irregular file: \", target));\n        builder.initRegular(0);\n      }\n    }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<kj::String, ArchiveNode> children;",
            "MemoryMapping mapping;",
            "kj::Maybe<kj::Array<capnp::word>> data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstd::map<kj::String, ArchiveNode> children;\nMemoryMapping mapping;\nkj::Maybe<kj::Array<capnp::word>> data;\n\nclass ArchiveNode {\n    // A tree of files.\n  public:\n    ArchiveNode() {}\n\n    inline void setTarget(kj::String&& target) { this->target = kj::mv(target); }\n    inline void setData(kj::Array<capnp::word>&& data) { this->data = kj::mv(data); }\n\n    ArchiveNode& followPath(kj::StringPtr path) {\n      if (path == nullptr) return *this;\n\n      kj::String pathPart;\n      KJ_IF_MAYBE(slashPos, path.findFirst('/')) {\n        pathPart = kj::heapString(path.slice(0, *slashPos));\n        path = path.slice(*slashPos + 1);\n      } else {\n        pathPart = kj::heapString(path);\n        path = nullptr;\n      }\n\n      return children[kj::mv(pathPart)].followPath(path);\n    }\n\n    void pack(spk::Archive::File::Builder builder, kj::ProcessContext& context,\n              struct timespec defaultMTime) {\n      auto orphanage = capnp::Orphanage::getForMessageContaining(builder);\n\n      KJ_IF_MAYBE(d, data) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n        auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(d->begin()),\n                                  d->size() * sizeof(capnp::word));\n        builder.adoptRegular(orphanage.referenceExternalData(bytes));\n        return;\n      }\n\n      struct stat stats;\n\n      if (target == nullptr) {\n        stats.st_mode = S_IFDIR;\n        stats.st_mtim = defaultMTime;\n      } else {\n        KJ_SYSCALL(lstat(target.cStr(), &stats), target);\n      }\n\n      auto mtime = stats.st_mtim.tv_sec * kj::SECONDS + stats.st_mtim.tv_nsec * kj::NANOSECONDS;\n      builder.setLastModificationTimeNs(mtime / kj::NANOSECONDS);\n\n      if (S_ISREG(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n\n        kj::AutoCloseFd fd = raiiOpen(target, O_RDONLY);\n        size_t size = getFileSize(fd, target);\n\n        if (size >= (1ull << 29)) {\n          context.exitError(kj::str(target, \": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\"));\n        }\n\n        // Reading the entirety of a file into memory can take up a sizable\n        // chunk of RAM, so we'd prefer to not pay that cost if we don't need\n        // it.\n        //\n        // MemoryMapping doesn't keep a copy in RAM, but it does keep an mmap()\n        // to the file open until we clean up the whole arena, which can wind\n        // up taking a lot of file table entries.  In particular, VirtualBox\n        // shared folders cannot handle >4096 concurrent mmap()s of files from\n        // the host.  So we have to be cautious using MemoryMapping for all files.\n        //\n        // It is generally the case that most files are small, but most of your\n        // data is in large files.  This suggests the following heuristic as a\n        // compromise: use MemoryMapping for files larger than 128k (specific\n        // number adjustable) and read the whole file into memory for anything\n        // smaller.  So we do that.\n        if (size > 1ull << 17) {\n          // File larger than 128k, mmap preferred\n          mapping = MemoryMapping(kj::mv(fd), target);\n          auto content = orphanage.referenceExternalData(mapping);\n          if (stats.st_mode & S_IXUSR) {\n            builder.adoptExecutable(kj::mv(content));\n          } else {\n            builder.adoptRegular(kj::mv(content));\n          }\n        } else {\n          // Small file; direct read preferable.\n          ::capnp::Data::Builder buf = nullptr;\n          if (stats.st_mode & S_IXUSR) {\n            buf = builder.initExecutable(size);\n          } else {\n            buf = builder.initRegular(size);\n          }\n          kj::FdInputStream stream(kj::mv(fd));\n          stream.read(buf.begin(), size);\n        }\n\n      } else if (S_ISLNK(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got symlink, expected directory\", target);\n\n        auto symlink = builder.initSymlink(stats.st_size);\n\n        ssize_t linkSize;\n        KJ_SYSCALL(linkSize = readlink(target.cStr(), symlink.begin(), stats.st_size), target);\n      } else if (S_ISDIR(stats.st_mode)) {\n        builder.adoptDirectory(packChildren(orphanage, context, defaultMTime));\n      } else {\n        context.warning(kj::str(\"Cannot pack irregular file: \", target));\n        builder.initRegular(0);\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "childBuilder.setName",
          "args": [
            "child.first"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.get",
          "args": [],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<capnp::List<spk::Archive::File>>",
          "args": [
            "children.size()"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "children.size",
          "args": [],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstd::map<kj::String, ArchiveNode> children;\n\ncapnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }"
  },
  {
    "function_name": "pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1073-1181",
    "snippet": "class ArchiveNode {\n    // A tree of files.\n  public:\n    ArchiveNode() {}\n\n    inline void setTarget(kj::String&& target) { this->target = kj::mv(target); }\n    inline void setData(kj::Array<capnp::word>&& data) { this->data = kj::mv(data); }\n\n    ArchiveNode& followPath(kj::StringPtr path) {\n      if (path == nullptr) return *this;\n\n      kj::String pathPart;\n      KJ_IF_MAYBE(slashPos, path.findFirst('/')) {\n        pathPart = kj::heapString(path.slice(0, *slashPos));\n        path = path.slice(*slashPos + 1);\n      } else {\n        pathPart = kj::heapString(path);\n        path = nullptr;\n      }\n\n      return children[kj::mv(pathPart)].followPath(path);\n    }\n\n    void pack(spk::Archive::File::Builder builder, kj::ProcessContext& context,\n              struct timespec defaultMTime) {\n      auto orphanage = capnp::Orphanage::getForMessageContaining(builder);\n\n      KJ_IF_MAYBE(d, data) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n        auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(d->begin()),\n                                  d->size() * sizeof(capnp::word));\n        builder.adoptRegular(orphanage.referenceExternalData(bytes));\n        return;\n      }\n\n      struct stat stats;\n\n      if (target == nullptr) {\n        stats.st_mode = S_IFDIR;\n        stats.st_mtim = defaultMTime;\n      } else {\n        KJ_SYSCALL(lstat(target.cStr(), &stats), target);\n      }\n\n      auto mtime = stats.st_mtim.tv_sec * kj::SECONDS + stats.st_mtim.tv_nsec * kj::NANOSECONDS;\n      builder.setLastModificationTimeNs(mtime / kj::NANOSECONDS);\n\n      if (S_ISREG(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n\n        kj::AutoCloseFd fd = raiiOpen(target, O_RDONLY);\n        size_t size = getFileSize(fd, target);\n\n        if (size >= (1ull << 29)) {\n          context.exitError(kj::str(target, \": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\"));\n        }\n\n        // Reading the entirety of a file into memory can take up a sizable\n        // chunk of RAM, so we'd prefer to not pay that cost if we don't need\n        // it.\n        //\n        // MemoryMapping doesn't keep a copy in RAM, but it does keep an mmap()\n        // to the file open until we clean up the whole arena, which can wind\n        // up taking a lot of file table entries.  In particular, VirtualBox\n        // shared folders cannot handle >4096 concurrent mmap()s of files from\n        // the host.  So we have to be cautious using MemoryMapping for all files.\n        //\n        // It is generally the case that most files are small, but most of your\n        // data is in large files.  This suggests the following heuristic as a\n        // compromise: use MemoryMapping for files larger than 128k (specific\n        // number adjustable) and read the whole file into memory for anything\n        // smaller.  So we do that.\n        if (size > 1ull << 17) {\n          // File larger than 128k, mmap preferred\n          mapping = MemoryMapping(kj::mv(fd), target);\n          auto content = orphanage.referenceExternalData(mapping);\n          if (stats.st_mode & S_IXUSR) {\n            builder.adoptExecutable(kj::mv(content));\n          } else {\n            builder.adoptRegular(kj::mv(content));\n          }\n        } else {\n          // Small file; direct read preferable.\n          ::capnp::Data::Builder buf = nullptr;\n          if (stats.st_mode & S_IXUSR) {\n            buf = builder.initExecutable(size);\n          } else {\n            buf = builder.initRegular(size);\n          }\n          kj::FdInputStream stream(kj::mv(fd));\n          stream.read(buf.begin(), size);\n        }\n\n      } else if (S_ISLNK(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got symlink, expected directory\", target);\n\n        auto symlink = builder.initSymlink(stats.st_size);\n\n        ssize_t linkSize;\n        KJ_SYSCALL(linkSize = readlink(target.cStr(), symlink.begin(), stats.st_size), target);\n      } else if (S_ISDIR(stats.st_mode)) {\n        builder.adoptDirectory(packChildren(orphanage, context, defaultMTime));\n      } else {\n        context.warning(kj::str(\"Cannot pack irregular file: \", target));\n        builder.initRegular(0);\n      }\n    }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "std::map<kj::String, ArchiveNode> children;",
      "MemoryMapping mapping;",
      "kj::Maybe<kj::Array<capnp::word>> data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.initRegular",
          "args": [
            "0"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\"Cannot pack irregular file: \", target)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Cannot pack irregular file: \"",
            "target"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptDirectory",
          "args": [
            "packChildren(orphanage, context, defaultMTime)"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packChildren",
          "args": [
            "orphanage",
            "context",
            "defaultMTime"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "packChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1183-1196",
          "snippet": "capnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<kj::String, ArchiveNode> children;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstd::map<kj::String, ArchiveNode> children;\n\ncapnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "linkSize = readlink(target.cStr(), symlink.begin(), stats.st_size)",
            "target"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "target.cStr()",
            "symlink.begin()",
            "stats.st_size"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink.begin",
          "args": [],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.cStr",
          "args": [],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initSymlink",
          "args": [
            "stats.st_size"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "children.empty()",
            "\"got symlink, expected directory\"",
            "target"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "children.empty",
          "args": [],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "stats.st_mode"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.read",
          "args": [
            "buf.begin()",
            "size"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SimpleDataFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "529-533",
          "snippet": "kj::Array<uint8_t> read(uint64_t offset0, uint32_t size0) override {\n    auto offset = kj::min(data.size(), offset0);\n    auto size = kj::min(data.size() - offset, size0);\n    return kj::heapArray(data.slice(offset, offset + size));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nSimpleDataFile {\n  kj::Array<uint8_t> read(uint64_t offset0, uint32_t size0) override {\n      auto offset = kj::min(data.size(), offset0);\n      auto size = kj::min(data.size() - offset, size0);\n      return kj::heapArray(data.slice(offset, offset + size));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf.begin",
          "args": [],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRegular",
          "args": [
            "size"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initExecutable",
          "args": [
            "size"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptRegular",
          "args": [
            "kj::mv(content)"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "content"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptExecutable",
          "args": [
            "kj::mv(content)"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "content"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.referenceExternalData",
          "args": [
            "mapping"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryMapping",
          "args": [
            "kj::mv(fd)",
            "target"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryMapping",
          "container": "MemoryMapping",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "105-116",
          "snippet": "MemoryMapping::MemoryMapping(int fd, kj::StringPtr filename): content(nullptr) {\n  size_t size = getFileSize(fd, filename);\n\n  if (size != 0) {\n    void* ptr = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (ptr == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n    }\n\n    content = kj::arrayPtr(reinterpret_cast<byte*>(ptr), size);\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nMemoryMapping {\n  MemoryMapping::MemoryMapping(int fd, kj::StringPtr filename): content(nullptr) {\n    size_t size = getFileSize(fd, filename);\n  \n    if (size != 0) {\n      void* ptr = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);\n      if (ptr == MAP_FAILED) {\n        KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n      }\n  \n      content = kj::arrayPtr(reinterpret_cast<byte*>(ptr), size);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fd"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(target, \": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\")"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "target",
            "\": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getFileSize",
          "args": [
            "fd",
            "target"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "getFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "98-103",
          "snippet": "size_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nsize_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "target",
            "O_RDONLY"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "children.empty()",
            "\"got file, expected directory\"",
            "target"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "children.empty",
          "args": [],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setLastModificationTimeNs",
          "args": [
            "mtime / kj::NANOSECONDS"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(target.cStr(), &stats)",
            "target"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "target.cStr()",
            "&stats"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.cStr",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptRegular",
          "args": [
            "orphanage.referenceExternalData(bytes)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.referenceExternalData",
          "args": [
            "bytes"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<const kj::byte*>(d->begin())",
            "d->size() * sizeof(capnp::word)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->size",
          "args": [],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const kj::byte*>",
          "args": [
            "d->begin()"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->begin",
          "args": [],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "children.empty()",
            "\"got file, expected directory\"",
            "target"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "children.empty",
          "args": [],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "builder"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pathPart"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "*slashPos + 1"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path.slice(0, *slashPos)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "0",
            "*slashPos"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "slashPos",
            "path.findFirst('/')"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.findFirst",
          "args": [
            "'/'"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "data"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "target"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstd::map<kj::String, ArchiveNode> children;\nMemoryMapping mapping;\nkj::Maybe<kj::Array<capnp::word>> data;\n\nclass ArchiveNode {\n    // A tree of files.\n  public:\n    ArchiveNode() {}\n\n    inline void setTarget(kj::String&& target) { this->target = kj::mv(target); }\n    inline void setData(kj::Array<capnp::word>&& data) { this->data = kj::mv(data); }\n\n    ArchiveNode& followPath(kj::StringPtr path) {\n      if (path == nullptr) return *this;\n\n      kj::String pathPart;\n      KJ_IF_MAYBE(slashPos, path.findFirst('/')) {\n        pathPart = kj::heapString(path.slice(0, *slashPos));\n        path = path.slice(*slashPos + 1);\n      } else {\n        pathPart = kj::heapString(path);\n        path = nullptr;\n      }\n\n      return children[kj::mv(pathPart)].followPath(path);\n    }\n\n    void pack(spk::Archive::File::Builder builder, kj::ProcessContext& context,\n              struct timespec defaultMTime) {\n      auto orphanage = capnp::Orphanage::getForMessageContaining(builder);\n\n      KJ_IF_MAYBE(d, data) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n        auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(d->begin()),\n                                  d->size() * sizeof(capnp::word));\n        builder.adoptRegular(orphanage.referenceExternalData(bytes));\n        return;\n      }\n\n      struct stat stats;\n\n      if (target == nullptr) {\n        stats.st_mode = S_IFDIR;\n        stats.st_mtim = defaultMTime;\n      } else {\n        KJ_SYSCALL(lstat(target.cStr(), &stats), target);\n      }\n\n      auto mtime = stats.st_mtim.tv_sec * kj::SECONDS + stats.st_mtim.tv_nsec * kj::NANOSECONDS;\n      builder.setLastModificationTimeNs(mtime / kj::NANOSECONDS);\n\n      if (S_ISREG(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got file, expected directory\", target);\n\n        kj::AutoCloseFd fd = raiiOpen(target, O_RDONLY);\n        size_t size = getFileSize(fd, target);\n\n        if (size >= (1ull << 29)) {\n          context.exitError(kj::str(target, \": file too large. The spk format currently only \"\n            \"supports files up to 512MB in size. Please let the Sandstorm developers know \"\n            \"if you have a strong reason for needing larger files.\"));\n        }\n\n        // Reading the entirety of a file into memory can take up a sizable\n        // chunk of RAM, so we'd prefer to not pay that cost if we don't need\n        // it.\n        //\n        // MemoryMapping doesn't keep a copy in RAM, but it does keep an mmap()\n        // to the file open until we clean up the whole arena, which can wind\n        // up taking a lot of file table entries.  In particular, VirtualBox\n        // shared folders cannot handle >4096 concurrent mmap()s of files from\n        // the host.  So we have to be cautious using MemoryMapping for all files.\n        //\n        // It is generally the case that most files are small, but most of your\n        // data is in large files.  This suggests the following heuristic as a\n        // compromise: use MemoryMapping for files larger than 128k (specific\n        // number adjustable) and read the whole file into memory for anything\n        // smaller.  So we do that.\n        if (size > 1ull << 17) {\n          // File larger than 128k, mmap preferred\n          mapping = MemoryMapping(kj::mv(fd), target);\n          auto content = orphanage.referenceExternalData(mapping);\n          if (stats.st_mode & S_IXUSR) {\n            builder.adoptExecutable(kj::mv(content));\n          } else {\n            builder.adoptRegular(kj::mv(content));\n          }\n        } else {\n          // Small file; direct read preferable.\n          ::capnp::Data::Builder buf = nullptr;\n          if (stats.st_mode & S_IXUSR) {\n            buf = builder.initExecutable(size);\n          } else {\n            buf = builder.initRegular(size);\n          }\n          kj::FdInputStream stream(kj::mv(fd));\n          stream.read(buf.begin(), size);\n        }\n\n      } else if (S_ISLNK(stats.st_mode)) {\n        KJ_ASSERT(children.empty(), \"got symlink, expected directory\", target);\n\n        auto symlink = builder.initSymlink(stats.st_size);\n\n        ssize_t linkSize;\n        KJ_SYSCALL(linkSize = readlink(target.cStr(), symlink.begin(), stats.st_size), target);\n      } else if (S_ISDIR(stats.st_mode)) {\n        builder.adoptDirectory(packChildren(orphanage, context, defaultMTime));\n      } else {\n        context.warning(kj::str(\"Cannot pack irregular file: \", target));\n        builder.initRegular(0);\n      }\n    }"
  },
  {
    "function_name": "packToTempFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "1033-1071",
    "snippet": "kj::AutoCloseFd packToTempFile() {\n    // Read in the file list.\n    ArchiveNode root;\n\n    // Set up special files that will be over-mounted by the supervisor.\n    root.followPath(\"dev\");\n    root.followPath(\"tmp\");\n    root.followPath(\"var\");\n    root.followPath(\"proc\").followPath(\"cpuinfo\").setData(nullptr);\n\n    auto sourceMap = packageDef.getSourceMap();\n\n    if (packageDef.hasFileList()) {\n      auto fileListFile = packageDef.getFileList();\n      if (access(fileListFile.cStr(), F_OK) != 0) {\n        context.exitInfo(kj::str(\"\\\"\", fileListFile,\n            \"\\\" does not exist. Have you run `spk dev` yet?\"));\n      }\n\n      for (auto& line: splitLines(readAll(raiiOpen(fileListFile, O_RDONLY)))) {\n        addNode(root, line, sourceMap, false);\n      }\n    }\n    for (auto file: packageDef.getAlwaysInclude()) {\n      addNode(root, file, sourceMap, true);\n    }\n\n    auto tmpfile = openTemporary(spkfile);\n\n    // Write the archive.\n    capnp::MallocMessageBuilder archiveMessage;\n    auto archive = archiveMessage.getRoot<spk::Archive>();\n    struct timespec defaultMTime;\n    KJ_SYSCALL(clock_gettime(CLOCK_REALTIME, &defaultMTime));\n    archive.adoptFiles(root.packChildren(archiveMessage.getOrphanage(), context, defaultMTime));\n    capnp::writeMessageToFd(tmpfile, archiveMessage);\n\n    return tmpfile;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capnp::writeMessageToFd",
          "args": [
            "tmpfile",
            "archiveMessage"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "archive.adoptFiles",
          "args": [
            "root.packChildren(archiveMessage.getOrphanage(), context, defaultMTime)"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.packChildren",
          "args": [
            "archiveMessage.getOrphanage()",
            "context",
            "defaultMTime"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "packChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1183-1196",
          "snippet": "capnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<kj::String, ArchiveNode> children;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nstd::map<kj::String, ArchiveNode> children;\n\ncapnp::Orphan<capnp::List<spk::Archive::File>> packChildren(\n        capnp::Orphanage orphanage, kj::ProcessContext& context, struct timespec defaultMTime) {\n      auto orphan = orphanage.newOrphan<capnp::List<spk::Archive::File>>(children.size());\n      auto builder = orphan.get();\n\n      uint i = 0;\n      for (auto& child: children) {\n        auto childBuilder = builder[i++];\n        childBuilder.setName(child.first);\n        child.second.pack(childBuilder, context, defaultMTime);\n      }\n\n      return orphan;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "archiveMessage.getOrphanage",
          "args": [],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "clock_gettime(CLOCK_REALTIME, &defaultMTime)"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_REALTIME",
            "&defaultMTime"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "archiveMessage.getRoot<spk::Archive>",
          "args": [],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openTemporary",
          "args": [
            "spkfile"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "openTemporary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "232-241",
          "snippet": "kj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addNode",
          "args": [
            "root",
            "file",
            "sourceMap",
            "true"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "addNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1224-1268",
          "snippet": "void addNode(ArchiveNode& root, kj::StringPtr path, const spk::SourceMap::Reader& sourceMap,\n               bool recursive) {\n    if (path.startsWith(\"/\")) {\n      context.exitError(kj::str(\"Destination (in-package) path must not start with '/': \", path));\n    }\n    if (path == \".\") {\n      path = \"\";\n    }\n\n    auto& node = root.followPath(path);\n    if (path == \"sandstorm-manifest\") {\n      // Serialize the manifest.\n      auto manifestReader = packageDef.getManifest();\n      capnp::MallocMessageBuilder manifestMessage(manifestReader.totalSize().wordCount + 4);\n      manifestMessage.setRoot(manifestReader);\n      node.setData(capnp::messageToFlatArray(manifestMessage));\n    } else if (path == \"sandstorm-http-bridge-config\") {\n      // Serialize the bridgeConfig.\n      auto bridgeConfigReader = packageDef.getBridgeConfig();\n      capnp::MallocMessageBuilder bridgeConfigMessage(bridgeConfigReader.totalSize().wordCount + 4);\n      bridgeConfigMessage.setRoot(bridgeConfigReader);\n      node.setData(capnp::messageToFlatArray(bridgeConfigMessage));\n    } else if (path == \"sandstorm-http-bridge\") {\n      node.setTarget(getHttpBridgeExe());\n    } else if (path == \"proc/cpuinfo\") {\n      // Empty /proc/cpuinfo will be overmounted by the supervisor.\n      node.setData(nullptr);\n    } else {\n      if (path.size() == 0 && recursive) {\n        addNode(root, \"sandstorm-manifest\", sourceMap, true);\n        if (packageDef.hasBridgeConfig() ||\n            isHttpBridgeCommand(packageDef.getManifest().getContinueCommand())) {\n          addNode(root, \"sandstorm-http-bridge-config\", sourceMap, true);\n          addNode(root, \"sandstorm-http-bridge\", sourceMap, true);\n        }\n      }\n\n      auto mapping = mapFile(sourceDir, sourceMap, path);\n      if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n        context.exitError(kj::str(\"No file found to satisfy requirement: \", path));\n      } else {\n        initNode(node, path, kj::mv(mapping), sourceMap, recursive);\n      }\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nvoid addNode(ArchiveNode& root, kj::StringPtr path, const spk::SourceMap::Reader& sourceMap,\n               bool recursive) {\n    if (path.startsWith(\"/\")) {\n      context.exitError(kj::str(\"Destination (in-package) path must not start with '/': \", path));\n    }\n    if (path == \".\") {\n      path = \"\";\n    }\n\n    auto& node = root.followPath(path);\n    if (path == \"sandstorm-manifest\") {\n      // Serialize the manifest.\n      auto manifestReader = packageDef.getManifest();\n      capnp::MallocMessageBuilder manifestMessage(manifestReader.totalSize().wordCount + 4);\n      manifestMessage.setRoot(manifestReader);\n      node.setData(capnp::messageToFlatArray(manifestMessage));\n    } else if (path == \"sandstorm-http-bridge-config\") {\n      // Serialize the bridgeConfig.\n      auto bridgeConfigReader = packageDef.getBridgeConfig();\n      capnp::MallocMessageBuilder bridgeConfigMessage(bridgeConfigReader.totalSize().wordCount + 4);\n      bridgeConfigMessage.setRoot(bridgeConfigReader);\n      node.setData(capnp::messageToFlatArray(bridgeConfigMessage));\n    } else if (path == \"sandstorm-http-bridge\") {\n      node.setTarget(getHttpBridgeExe());\n    } else if (path == \"proc/cpuinfo\") {\n      // Empty /proc/cpuinfo will be overmounted by the supervisor.\n      node.setData(nullptr);\n    } else {\n      if (path.size() == 0 && recursive) {\n        addNode(root, \"sandstorm-manifest\", sourceMap, true);\n        if (packageDef.hasBridgeConfig() ||\n            isHttpBridgeCommand(packageDef.getManifest().getContinueCommand())) {\n          addNode(root, \"sandstorm-http-bridge-config\", sourceMap, true);\n          addNode(root, \"sandstorm-http-bridge\", sourceMap, true);\n        }\n      }\n\n      auto mapping = mapFile(sourceDir, sourceMap, path);\n      if (mapping.sourcePaths.size() == 0 && mapping.virtualChildren.size() == 0) {\n        context.exitError(kj::str(\"No file found to satisfy requirement: \", path));\n      } else {\n        initNode(node, path, kj::mv(mapping), sourceMap, recursive);\n      }\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "packageDef.getAlwaysInclude",
          "args": [],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splitLines",
          "args": [
            "readAll(raiiOpen(fileListFile, O_RDONLY))"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "splitLines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "387-414",
          "snippet": "kj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "raiiOpen(fileListFile, O_RDONLY)"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "383-385",
          "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "fileListFile",
            "O_RDONLY"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitInfo",
          "args": [
            "kj::str(\"\\\"\", fileListFile,\n            \"\\\" does not exist. Have you run `spk dev` yet?\")"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\\\"\"",
            "fileListFile",
            "\"\\\" does not exist. Have you run `spk dev` yet?\""
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fileListFile.cStr()",
            "F_OK"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileListFile.cStr",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getFileList",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.hasFileList",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageDef.getSourceMap",
          "args": [],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "nullptr"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "\"cpuinfo\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "\"proc\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "\"var\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "\"tmp\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.followPath",
          "args": [
            "\"dev\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\n\nkj::AutoCloseFd packToTempFile() {\n    // Read in the file list.\n    ArchiveNode root;\n\n    // Set up special files that will be over-mounted by the supervisor.\n    root.followPath(\"dev\");\n    root.followPath(\"tmp\");\n    root.followPath(\"var\");\n    root.followPath(\"proc\").followPath(\"cpuinfo\").setData(nullptr);\n\n    auto sourceMap = packageDef.getSourceMap();\n\n    if (packageDef.hasFileList()) {\n      auto fileListFile = packageDef.getFileList();\n      if (access(fileListFile.cStr(), F_OK) != 0) {\n        context.exitInfo(kj::str(\"\\\"\", fileListFile,\n            \"\\\" does not exist. Have you run `spk dev` yet?\"));\n      }\n\n      for (auto& line: splitLines(readAll(raiiOpen(fileListFile, O_RDONLY)))) {\n        addNode(root, line, sourceMap, false);\n      }\n    }\n    for (auto file: packageDef.getAlwaysInclude()) {\n      addNode(root, file, sourceMap, true);\n    }\n\n    auto tmpfile = openTemporary(spkfile);\n\n    // Write the archive.\n    capnp::MallocMessageBuilder archiveMessage;\n    auto archive = archiveMessage.getRoot<spk::Archive>();\n    struct timespec defaultMTime;\n    KJ_SYSCALL(clock_gettime(CLOCK_REALTIME, &defaultMTime));\n    archive.adoptFiles(root.packChildren(archiveMessage.getOrphanage(), context, defaultMTime));\n    capnp::writeMessageToFd(tmpfile, archiveMessage);\n\n    return tmpfile;\n  }"
  },
  {
    "function_name": "doPack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "971-1031",
    "snippet": "kj::MainBuilder::Validity doPack() {\n    ensurePackageDefParsed();\n\n    spk::KeyFile::Reader key = lookupKey(packageDef.getId());\n\n    kj::AutoCloseFd tmpfile = packToTempFile();\n\n    // Map the temp file back in.\n    MemoryMapping tmpMapping(tmpfile, spkfile);\n    kj::ArrayPtr<const byte> tmpData = tmpMapping;\n\n    if (tmpData.size() > APP_SIZE_LIMIT) {\n      context.exitError(kj::str(\n          \"App exceeds uncompressed size limit of \", APP_SIZE_LIMIT >> 30, \" GiB. This limit \"\n          \"exists for the safety of hosts, but if you feel there is a strong case for allowing \"\n          \"larger apps, please contact the Sandstorm developers.\"));\n    }\n\n    // Hash it.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512(hash, tmpData.begin(), tmpData.size());\n\n    // Generate the signature.\n    capnp::MallocMessageBuilder signatureMessage;\n    spk::Signature::Builder signature = signatureMessage.getRoot<spk::Signature>();\n    signature.setPublicKey(key.getPublicKey());\n    unsigned long long siglen = crypto_hash_sha512_BYTES + crypto_sign_BYTES;\n    crypto_sign(signature.initSignature(siglen).begin(), &siglen,\n                hash, sizeof(hash), key.getPrivateKey().begin());\n\n    // Now write the whole thing out.\n    {\n      auto finalFile = raiiOpen(spkfile, O_WRONLY | O_CREAT | O_TRUNC);\n\n      // Write magic number uncompressed.\n      auto magic = spk::MAGIC_NUMBER.get();\n      kj::FdOutputStream(finalFile.get()).write(magic.begin(), magic.size());\n\n      // Pipe content through xz compressor.\n      auto pipe = Pipe::make();\n      Subprocess::Options childOptions({\"xz\", \"--threads=0\", \"--compress\", \"--stdout\"});\n      childOptions.stdin = pipe.readEnd.get();\n      childOptions.stdout = finalFile.get();\n      Subprocess child(kj::mv(childOptions));\n      pipe.readEnd = nullptr;\n\n      // Write signature and archive out to the pipe, then close the pipe.\n      {\n        kj::FdOutputStream out(kj::mv(pipe.writeEnd));\n        capnp::writeMessage(out, signatureMessage);\n        out.write(tmpData.begin(), tmpData.size());\n      }\n\n      // Wait until xz is done compressing.\n      child.waitForSuccess();\n    }\n\n    printAppId(key.getPublicKey());\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "key.getPublicKey()"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "key.getPublicKey",
          "args": [],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child.waitForSuccess",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "993-996",
          "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "tmpData.begin()",
            "tmpData.size()"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmpData.size",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmpData.begin",
          "args": [],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::writeMessage",
          "args": [
            "out",
            "signatureMessage"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipe.writeEnd"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalFile.get",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.readEnd.get",
          "args": [],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "magic.begin()",
            "magic.size()"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic.begin",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "finalFile.get()"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalFile.get",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spk::MAGIC_NUMBER.get",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "spkfile",
            "O_WRONLY | O_CREAT | O_TRUNC"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign",
          "args": [
            "signature.initSignature(siglen).begin()",
            "&siglen",
            "hash",
            "sizeof(hash)",
            "key.getPrivateKey().begin()"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPrivateKey",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPrivateKey",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.initSignature",
          "args": [],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.initSignature",
          "args": [
            "siglen"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature.setPublicKey",
          "args": [
            "key.getPublicKey()"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPublicKey",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signatureMessage.getRoot<spk::Signature>",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_sha512",
          "args": [
            "hash",
            "tmpData.begin()",
            "tmpData.size()"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpData.begin",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n          \"App exceeds uncompressed size limit of \", APP_SIZE_LIMIT >> 30, \" GiB. This limit \"\n          \"exists for the safety of hosts, but if you feel there is a strong case for allowing \"\n          \"larger apps, please contact the Sandstorm developers.\")"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"App exceeds uncompressed size limit of \"",
            "APP_SIZE_LIMIT >> 30",
            "\" GiB. This limit \"\n          \"exists for the safety of hosts, but if you feel there is a strong case for allowing \"\n          \"larger apps, please contact the Sandstorm developers.\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packToTempFile",
          "args": [],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "packToTempFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "1033-1071",
          "snippet": "kj::AutoCloseFd packToTempFile() {\n    // Read in the file list.\n    ArchiveNode root;\n\n    // Set up special files that will be over-mounted by the supervisor.\n    root.followPath(\"dev\");\n    root.followPath(\"tmp\");\n    root.followPath(\"var\");\n    root.followPath(\"proc\").followPath(\"cpuinfo\").setData(nullptr);\n\n    auto sourceMap = packageDef.getSourceMap();\n\n    if (packageDef.hasFileList()) {\n      auto fileListFile = packageDef.getFileList();\n      if (access(fileListFile.cStr(), F_OK) != 0) {\n        context.exitInfo(kj::str(\"\\\"\", fileListFile,\n            \"\\\" does not exist. Have you run `spk dev` yet?\"));\n      }\n\n      for (auto& line: splitLines(readAll(raiiOpen(fileListFile, O_RDONLY)))) {\n        addNode(root, line, sourceMap, false);\n      }\n    }\n    for (auto file: packageDef.getAlwaysInclude()) {\n      addNode(root, file, sourceMap, true);\n    }\n\n    auto tmpfile = openTemporary(spkfile);\n\n    // Write the archive.\n    capnp::MallocMessageBuilder archiveMessage;\n    auto archive = archiveMessage.getRoot<spk::Archive>();\n    struct timespec defaultMTime;\n    KJ_SYSCALL(clock_gettime(CLOCK_REALTIME, &defaultMTime));\n    archive.adoptFiles(root.packChildren(archiveMessage.getOrphanage(), context, defaultMTime));\n    capnp::writeMessageToFd(tmpfile, archiveMessage);\n\n    return tmpfile;\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::String spkfile;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\n\nkj::AutoCloseFd packToTempFile() {\n    // Read in the file list.\n    ArchiveNode root;\n\n    // Set up special files that will be over-mounted by the supervisor.\n    root.followPath(\"dev\");\n    root.followPath(\"tmp\");\n    root.followPath(\"var\");\n    root.followPath(\"proc\").followPath(\"cpuinfo\").setData(nullptr);\n\n    auto sourceMap = packageDef.getSourceMap();\n\n    if (packageDef.hasFileList()) {\n      auto fileListFile = packageDef.getFileList();\n      if (access(fileListFile.cStr(), F_OK) != 0) {\n        context.exitInfo(kj::str(\"\\\"\", fileListFile,\n            \"\\\" does not exist. Have you run `spk dev` yet?\"));\n      }\n\n      for (auto& line: splitLines(readAll(raiiOpen(fileListFile, O_RDONLY)))) {\n        addNode(root, line, sourceMap, false);\n      }\n    }\n    for (auto file: packageDef.getAlwaysInclude()) {\n      addNode(root, file, sourceMap, true);\n    }\n\n    auto tmpfile = openTemporary(spkfile);\n\n    // Write the archive.\n    capnp::MallocMessageBuilder archiveMessage;\n    auto archive = archiveMessage.getRoot<spk::Archive>();\n    struct timespec defaultMTime;\n    KJ_SYSCALL(clock_gettime(CLOCK_REALTIME, &defaultMTime));\n    archive.adoptFiles(root.packChildren(archiveMessage.getOrphanage(), context, defaultMTime));\n    capnp::writeMessageToFd(tmpfile, archiveMessage);\n\n    return tmpfile;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "lookupKey",
          "args": [
            "packageDef.getId()"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "lookupKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "411-447",
          "snippet": "spk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryMapping mapping;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nspk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "packageDef.getId",
          "args": [],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensurePackageDefParsed",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ensurePackageDefParsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "354-361",
          "snippet": "void ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\n\nkj::MainBuilder::Validity doPack() {\n    ensurePackageDefParsed();\n\n    spk::KeyFile::Reader key = lookupKey(packageDef.getId());\n\n    kj::AutoCloseFd tmpfile = packToTempFile();\n\n    // Map the temp file back in.\n    MemoryMapping tmpMapping(tmpfile, spkfile);\n    kj::ArrayPtr<const byte> tmpData = tmpMapping;\n\n    if (tmpData.size() > APP_SIZE_LIMIT) {\n      context.exitError(kj::str(\n          \"App exceeds uncompressed size limit of \", APP_SIZE_LIMIT >> 30, \" GiB. This limit \"\n          \"exists for the safety of hosts, but if you feel there is a strong case for allowing \"\n          \"larger apps, please contact the Sandstorm developers.\"));\n    }\n\n    // Hash it.\n    byte hash[crypto_hash_sha512_BYTES];\n    crypto_hash_sha512(hash, tmpData.begin(), tmpData.size());\n\n    // Generate the signature.\n    capnp::MallocMessageBuilder signatureMessage;\n    spk::Signature::Builder signature = signatureMessage.getRoot<spk::Signature>();\n    signature.setPublicKey(key.getPublicKey());\n    unsigned long long siglen = crypto_hash_sha512_BYTES + crypto_sign_BYTES;\n    crypto_sign(signature.initSignature(siglen).begin(), &siglen,\n                hash, sizeof(hash), key.getPrivateKey().begin());\n\n    // Now write the whole thing out.\n    {\n      auto finalFile = raiiOpen(spkfile, O_WRONLY | O_CREAT | O_TRUNC);\n\n      // Write magic number uncompressed.\n      auto magic = spk::MAGIC_NUMBER.get();\n      kj::FdOutputStream(finalFile.get()).write(magic.begin(), magic.size());\n\n      // Pipe content through xz compressor.\n      auto pipe = Pipe::make();\n      Subprocess::Options childOptions({\"xz\", \"--threads=0\", \"--compress\", \"--stdout\"});\n      childOptions.stdin = pipe.readEnd.get();\n      childOptions.stdout = finalFile.get();\n      Subprocess child(kj::mv(childOptions));\n      pipe.readEnd = nullptr;\n\n      // Write signature and archive out to the pipe, then close the pipe.\n      {\n        kj::FdOutputStream out(kj::mv(pipe.writeEnd));\n        capnp::writeMessage(out, signatureMessage);\n        out.write(tmpData.begin(), tmpData.size());\n      }\n\n      // Wait until xz is done compressing.\n      child.waitForSuccess();\n    }\n\n    printAppId(key.getPublicKey());\n\n    return true;\n  }"
  },
  {
    "function_name": "setSpkfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "966-969",
    "snippet": "kj::MainBuilder::Validity setSpkfile(kj::StringPtr name) {\n    spkfile = kj::heapString(name);\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::String spkfile;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String spkfile;\n\nkj::MainBuilder::Validity setSpkfile(kj::StringPtr name) {\n    spkfile = kj::heapString(name);\n    return true;\n  }"
  },
  {
    "function_name": "getPackMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "957-964",
    "snippet": "kj::MainFunc getPackMain() {\n    return addCommonOptions(OptionSet::ALL_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Package the app as an spk, writing it to <output>.\")\n        .expectArg(\"<output>\", KJ_BIND_METHOD(*this, setSpkfile))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doPack)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::ALL_READONLY",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Package the app as an spk, writing it to <output>.\")\n        .expectArg(\"<output>\", KJ_BIND_METHOD(*this, setSpkfile))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doPack))"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doPack)"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doPack"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<output>\"",
            "KJ_BIND_METHOD(*this, setSpkfile)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setSpkfile"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Package the app as an spk, writing it to <output>.\""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainFunc getPackMain() {\n    return addCommonOptions(OptionSet::ALL_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Package the app as an spk, writing it to <output>.\")\n        .expectArg(\"<output>\", KJ_BIND_METHOD(*this, setSpkfile))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doPack)))\n        .build();\n  }"
  },
  {
    "function_name": "doInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "640-951",
    "snippet": "kj::MainBuilder::Validity doInit() {\n    if (httpPort == 0 && !usesRawApi) {\n      return \"You must specify at least one of -p or -r.\";\n    }\n\n    kj::String searchPath;\n    if (sourcePathForInit.size() == 0) {\n      if (includeAllForInit) {\n        return \"When using -A you must specify at least one -I.\";\n      }\n\n      searchPath = kj::str(\n          \"      ( sourcePath = \\\".\\\" ),  # Search this directory first.\\n\"\n          \"      ( sourcePath = \\\"/\\\",    # Then search the system root directory.\\n\"\n          \"        hidePaths = [ \\\"home\\\", \\\"proc\\\", \\\"sys\\\",\\n\"\n          \"                      \\\"etc/passwd\\\", \\\"etc/hosts\\\", \\\"etc/host.conf\\\",\\n\"\n          \"                      \\\"etc/nsswitch.conf\\\", \\\"etc/resolv.conf\\\" ]\\n\"\n          \"        # You probably don't want the app pulling files from these places,\\n\"\n          \"        # so we hide them. Note that /dev, /var, and /tmp are implicitly\\n\"\n          \"        # hidden because Sandstorm itself provides them.\\n\"\n          \"      )\\n\");\n    } else {\n      searchPath = kj::str(\n          \"      ( sourcePath = \\\"\",\n          kj::strArray(sourcePathForInit, \"\\\" ),\\n      ( sourcePath = \\\"\"),\n          \"\\\" )\\n\"\n          );\n    }\n\n    if (outputFile == nullptr) {\n      outputFile = \"sandstorm-pkgdef.capnp\";\n      if (access(outputFile.cStr(), F_OK) == 0) {\n        return \"`sandstorm-pkgdef.capnp` already exists\";\n      }\n    }\n\n    kj::String ownAppId;\n    if (appIdForInit == nullptr) {\n      ownAppId = generateKey();\n      appIdForInit = ownAppId;\n    }\n\n    auto argv = kj::str(\"\\\"\", kj::strArray(commandArgs, \"\\\", \\\"\"), \"\\\"\");\n\n    if (httpPort != 0) {\n      argv = kj::str(\"\\\"/sandstorm-http-bridge\\\", \\\"\", httpPort, \"\\\", \\\"--\\\", \", kj::mv(argv));\n    }\n\n    kj::AutoCloseFd outFd;\n    if (outputFile == \"-\") {\n      int fd;\n      KJ_SYSCALL(fd = dup(STDOUT_FILENO));\n      outFd = kj::AutoCloseFd(fd);\n    } else {\n      outFd = raiiOpen(outputFile, O_WRONLY | O_TRUNC | O_CREAT);\n    }\n\n    kj::FdOutputStream out(kj::mv(outFd));\n\n    auto content = kj::str(\n        \"@0x\", kj::hex(generateCapnpId()), \";\\n\"\n        \"\\n\"\n        \"using Spk = import \\\"/sandstorm/package.capnp\\\";\\n\"\n        \"# This imports:\\n\"\n        \"#   $SANDSTORM_HOME/latest/usr/include/sandstorm/package.capnp\\n\"\n        \"# Check out that file to see the full, documented package definition format.\\n\"\n        \"\\n\"\n        \"const pkgdef :Spk.PackageDefinition = (\\n\"\n        \"  # The package definition. Note that the spk tool looks specifically for the\\n\"\n        \"  # \\\"pkgdef\\\" constant.\\n\"\n        \"\\n\"\n        \"  id = \\\"\", appIdForInit, \"\\\",\\n\"\n        \"  # Your app ID is actually its public key. The private key was placed in\\n\"\n        \"  # your keyring. All updates must be signed with the same key.\\n\"\n        \"\\n\"\n        \"  manifest = (\\n\"\n        \"    # This manifest is included in your app package to tell Sandstorm\\n\"\n        \"    # about your app.\\n\"\n        \"\\n\"\n        \"    appTitle = (defaultText = \\\"Example App\\\"),\\n\"\n        \"\\n\"\n        \"    appVersion = 0,  # Increment this for every release.\\n\"\n        \"\\n\"\n        \"    appMarketingVersion = (defaultText = \\\"0.0.0\\\"),\\n\"\n        \"    # Human-readable representation of appVersion. Should match the way you\\n\"\n        \"    # identify versions of your app in documentation and marketing.\\n\"\n        \"\\n\"\n        \"    actions = [\\n\"\n        \"      # Define your \\\"new document\\\" handlers here.\\n\"\n        \"      ( nounPhrase = (defaultText = \\\"instance\\\"),\\n\"\n        \"        command = .myCommand\\n\"\n        \"        # The command to run when starting for the first time. (\\\".myCommand\\\"\\n\"\n        \"        # is just a constant defined at the bottom of the file.)\\n\"\n        \"      )\\n\"\n        \"    ],\\n\"\n        \"\\n\"\n        \"    continueCommand = .myCommand,\\n\"\n        \"    # This is the command called to start your app back up after it has been\\n\"\n        \"    # shut down for inactivity. Here we're using the same command as for\\n\"\n        \"    # starting a new instance, but you could use different commands for each\\n\"\n        \"    # case.\\n\"\n        \"\\n\"\n        \"    metadata = (\\n\"\n        \"      # Data which is not needed specifically to execute the app, but is useful\\n\"\n        \"      # for purposes like marketing and display.  These fields are documented at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#add-required-metadata\\n\"\n        \"      # and (in deeper detail) in the sandstorm source code, in the Metadata section of\\n\"\n        \"      # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n        \"      icons = (\\n\"\n        \"        # Various icons to represent the app in various contexts.\\n\"\n        \"        #appGrid = (svg = embed \\\"path/to/appgrid-128x128.svg\\\"),\\n\"\n        \"        #grain = (svg = embed \\\"path/to/grain-24x24.svg\\\"),\\n\"\n        \"        #market = (svg = embed \\\"path/to/market-150x150.svg\\\"),\\n\"\n        \"        #marketBig = (svg = embed \\\"path/to/market-big-300x300.svg\\\"),\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      website = \\\"http://example.com\\\",\\n\"\n        \"      # This should be the app's main website url.\\n\"\n        \"\\n\"\n        \"      codeUrl = \\\"http://example.com\\\",\\n\"\n        \"      # URL of the app's source code repository, e.g. a GitHub URL.\\n\"\n        \"      # Required if you specify a license requiring redistributing code, but optional otherwise.\\n\"\n        \"\\n\"\n        \"      license = (none = void),\\n\"\n        \"      # The license this package is distributed under.  See\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#license\\n\"\n        \"\\n\"\n        \"      categories = [],\\n\"\n        \"      # A list of categories/genres to which this app belongs, sorted with best fit first.\\n\"\n        \"      # See the list of categories at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#categories\\n\"\n        \"\\n\"\n        \"      author = (\\n\"\n        \"        # Fields relating to the author of this app.\\n\"\n        \"\\n\"\n        \"        contactEmail = \\\"youremail@example.com\\\",\\n\"\n        \"        # Email address to contact for any issues with this app. This includes end-user support\\n\"\n        \"        # requests as well as app store administrator requests, so it is very important that this be a\\n\"\n        \"        # valid address with someone paying attention to it.\\n\"\n        \"\\n\"\n        \"        #pgpSignature = embed \\\"path/to/pgp-signature\\\",\\n\"\n        \"        # PGP signature attesting responsibility for the app ID. This is a binary-format detached\\n\"\n        \"        # signature of the following ASCII message (not including the quotes, no newlines, and\\n\"\n        \"        # replacing <app-id> with the standard base-32 text format of the app's ID):\\n\"\n        \"        #\\n\"\n        \"        # \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\"\\n\"\n        \"        #\\n\"\n        \"        # You can create a signature file using `gpg` like so:\\n\"\n        \"        #\\n\"\n        \"        #     echo -n \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\" | gpg --sign > pgp-signature\\n\"\n        \"        #\\n\"\n        \"        # Further details including how to set up GPG and how to use keybase.io can be found\\n\"\n        \"        # at https://docs.sandstorm.io/en/latest/developing/publishing-apps/#verify-your-identity\\n\"\n        \"\\n\"\n        \"        upstreamAuthor = \\\"Example App Team\\\",\\n\"\n        \"        # Name of the original primary author of this app, if it is different from the person who\\n\"\n        \"        # produced the Sandstorm package. Setting this implies that the author connected to the PGP\\n\"\n        \"        # signature only \\\"packaged\\\" the app for Sandstorm, rather than developing the app.\\n\"\n        \"        # Remove this line if you consider yourself as the author of the app.\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      #pgpKeyring = embed \\\"path/to/pgp-keyring\\\",\\n\"\n        \"      # A keyring in GPG keyring format containing all public keys needed to verify PGP signatures in\\n\"\n        \"      # this manifest (as of this writing, there is only one: `author.pgpSignature`).\\n\"\n        \"      #\\n\"\n        \"      # To generate a keyring containing just your public key, do:\\n\"\n        \"      #\\n\"\n        \"      #     gpg --export <key-id> > keyring\\n\"\n        \"      #\\n\"\n        \"      # Where `<key-id>` is a PGP key ID or email address associated with the key.\\n\"\n        \"\\n\"\n        \"      #description = (defaultText = embed \\\"path/to/description.md\\\"),\\n\"\n        \"      # The app's description in Github-flavored Markdown format, to be displayed e.g.\\n\"\n        \"      # in an app store. Note that the Markdown is not permitted to contain HTML nor image tags (but\\n\"\n        \"      # you can include a list of screenshots separately).\\n\"\n        \"\\n\"\n        \"      shortDescription = (defaultText = \\\"one-to-three words\\\"),\\n\"\n        \"      # A very short (one-to-three words) description of what the app does. For example,\\n\"\n        \"      # \\\"Document editor\\\", or \\\"Notetaking\\\", or \\\"Email client\\\". This will be displayed under the app\\n\"\n        \"      # title in the grid view in the app market.\\n\"\n        \"\\n\"\n        \"      screenshots = [\\n\"\n        \"        # Screenshots to use for marketing purposes.  Examples below.\\n\"\n        \"        # Sizes are given in device-independent pixels, so if you took these\\n\"\n        \"        # screenshots on a Retina-style high DPI screen, divide each dimension by two.\\n\"\n        \"\\n\"\n        \"        #(width = 746, height = 795, jpeg = embed \\\"path/to/screenshot-1.jpeg\\\"),\\n\"\n        \"        #(width = 640, height = 480, png = embed \\\"path/to/screenshot-2.png\\\"),\\n\"\n        \"      ],\\n\"\n        \"      #changeLog = (defaultText = embed \\\"path/to/sandstorm-specific/changelog.md\\\"),\\n\"\n        \"      # Documents the history of changes in Github-flavored markdown format (with the same restrictions\\n\"\n        \"      # as govern `description`). We recommend formatting this with an H1 heading for each version\\n\"\n        \"      # followed by a bullet list of changes.\\n\"\n        \"    ),\\n\"\n        \"  ),\\n\"\n        \"\\n\"\n        \"  sourceMap = (\\n\",\n        includeAllForInit\n        ? \"    # The following directories will be copied into your package.\\n\"\n        : \"    # Here we defined where to look for files to copy into your package. The\\n\"\n          \"    # `spk dev` command actually figures out what files your app needs\\n\"\n          \"    # automatically by running it on a FUSE filesystem. So, the mappings\\n\"\n          \"    # here are only to tell it where to find files that the app wants.\\n\",\n        \"    searchPath = [\\n\",\n               searchPath,\n        \"    ]\\n\"\n        \"  ),\\n\"\n        \"\\n\",\n        includeAllForInit\n        ? \"  alwaysInclude = [ \\\".\\\" ],\\n\"\n          \"  # This says that we always want to include all files from the source map.\\n\"\n          \"  # (An alternative is to automatically detect dependencies by watching what\\n\"\n          \"  # the app opens while running in dev mode. To see what that looks like,\\n\"\n          \"  # run `spk init` without the -A option.)\\n\"\n        : \"  fileList = \\\"sandstorm-files.list\\\",\\n\"\n          \"  # `spk dev` will write a list of all the files your app uses to this file.\\n\"\n          \"  # You should review it later, before shipping your app.\\n\"\n          \"\\n\"\n          \"  alwaysInclude = [],\\n\"\n          \"  # Fill this list with more names of files or directories that should be\\n\"\n          \"  # included in your package, even if not listed in sandstorm-files.list.\\n\"\n          \"  # Use this to force-include stuff that you know you need but which may\\n\"\n          \"  # not have been detected as a dependency during `spk dev`. If you list\\n\"\n          \"  # a directory here, its entire contents will be included recursively.\\n\",\n          \"\\n\"\n          \"  #bridgeConfig = (\\n\"\n          \"  #  # Used for integrating permissions and roles into the Sandstorm shell\\n\"\n          \"  #  # and for sandstorm-http-bridge to pass to your app.\\n\"\n          \"  #  # Uncomment this block and adjust the permissions and roles to make\\n\"\n          \"  #  # sense for your app.\\n\"\n          \"  #  # For more information, see high-level documentation at\\n\"\n          \"  #  # https://docs.sandstorm.io/en/latest/developing/auth/\\n\"\n          \"  #  # and advanced details in the \\\"BridgeConfig\\\" section of\\n\"\n          \"  #  # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n          \"  #  viewInfo = (\\n\"\n          \"  #    # For details on the viewInfo field, consult \\\"ViewInfo\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #\\n\"\n          \"  #    permissions = [\\n\"\n          \"  #    # Permissions which a user may or may not possess.  A user's current\\n\"\n          \"  #    # permissions are passed to the app as a comma-separated list of `name`\\n\"\n          \"  #    # fields in the X-Sandstorm-Permissions header with each request.\\n\"\n          \"  #    #\\n\"\n          \"  #    # IMPORTANT: only ever append to this list!  Reordering or removing fields\\n\"\n          \"  #    # will change behavior and permissions for existing grains!  To deprecate a\\n\"\n          \"  #    # permission, or for more information, see \\\"PermissionDef\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #      (\\n\"\n          \"  #        name = \\\"editor\\\",\\n\"\n          \"  #        # Name of the permission, used as an identifier for the permission in cases where string\\n\"\n          \"  #        # names are preferred.  Used in sandstorm-http-bridge's X-Sandstorm-Permissions HTTP header.\\n\"\n          \"  #\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Display name of the permission, e.g. to display in a checklist of permissions\\n\"\n          \"  #        # that may be assigned when sharing.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"grants ability to modify data\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #    roles = [\\n\"\n          \"  #      # Roles are logical collections of permissions.  For instance, your app may have\\n\"\n          \"  #      # a \\\"viewer\\\" role and an \\\"editor\\\" role\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Name of the role.  Shown in the Sandstorm UI to indicate which users have which roles.\\n\"\n          \"  #\\n\"\n          \"  #        permissions  = [true],\\n\"\n          \"  #        # An array indicating which permissions this role carries.\\n\"\n          \"  #        # It should be the same length as the permissions array in\\n\"\n          \"  #        # viewInfo, and the order of the lists must match.\\n\"\n          \"  #\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can make changes to the document\\\"),\\n\"\n          \"  #        # Brief explanatory text to show in the sharing UI indicating\\n\"\n          \"  #        # what a user assigned this role will be able to do with the grain.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"editors may view all site data and change settings.\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"viewer\\\"),\\n\"\n          \"  #        permissions  = [false],\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can view the document\\\"),\\n\"\n          \"  #        description = (defaultText = \\\"viewers may view what other users have written.\\\"),\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #  ),\\n\"\n          \"  #  #apiPath = \\\"/api\\\",\\n\"\n          \"  #  # Apps can export an API to the world.  The API is to be used primarily by Javascript\\n\"\n          \"  #  # code and native apps, so it can't serve out regular HTML to browsers.  If a request\\n\"\n          \"  #  # comes in to your app's API, sandstorm-http-bridge will prefix the request's path with\\n\"\n          \"  #  # this string, if specified.\\n\"\n          \"  #),\\n\"\n        \");\\n\"\n        \"\\n\"\n        \"const myCommand :Spk.Manifest.Command = (\\n\"\n        \"  # Here we define the command used to start up your server.\\n\"\n        \"  argv = [\", argv, \"],\\n\"\n        \"  environ = [\\n\"\n        \"    # Note that this defines the *entire* environment seen by your app.\\n\"\n        \"    (key = \\\"PATH\\\", value = \\\"/usr/local/bin:/usr/bin:/bin\\\"),\\n\"\n        \"    (key = \\\"SANDSTORM\\\", value = \\\"1\\\"),\\n\"\n        \"    # Export SANDSTORM=1 into the environment, so that apps running within Sandstorm\\n\"\n        \"    # can detect if $SANDSTORM=\\\"1\\\" at runtime, switching UI and/or backend to use\\n\"\n        \"    # the app's Sandstorm-specific integration code.\\n\"\n        \"  ]\\n\"\n        \");\\n\");\n\n    out.write(content.begin(), content.size());\n\n    context.exitInfo(kj::str(\"wrote: \", outputFile));\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::StringPtr outputFile = nullptr;",
      "kj::StringPtr appIdForInit = nullptr;",
      "kj::Vector<kj::StringPtr> commandArgs;",
      "kj::Vector<kj::StringPtr> sourcePathForInit;",
      "uint16_t httpPort = 0;",
      "bool usesRawApi = false;",
      "bool includeAllForInit = false;",
      "kj::Maybe<kj::Array<capnp::word>> data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exitInfo",
          "args": [
            "kj::str(\"wrote: \", outputFile)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"wrote: \"",
            "outputFile"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "content.begin()",
            "content.size()"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"@0x\"",
            "kj::hex(generateCapnpId())",
            "\";\\n\"\n        \"\\n\"\n        \"using Spk = import \\\"/sandstorm/package.capnp\\\";\\n\"\n        \"# This imports:\\n\"\n        \"#   $SANDSTORM_HOME/latest/usr/include/sandstorm/package.capnp\\n\"\n        \"# Check out that file to see the full, documented package definition format.\\n\"\n        \"\\n\"\n        \"const pkgdef :Spk.PackageDefinition = (\\n\"\n        \"  # The package definition. Note that the spk tool looks specifically for the\\n\"\n        \"  # \\\"pkgdef\\\" constant.\\n\"\n        \"\\n\"\n        \"  id = \\\"\"",
            "appIdForInit",
            "\"\\\",\\n\"\n        \"  # Your app ID is actually its public key. The private key was placed in\\n\"\n        \"  # your keyring. All updates must be signed with the same key.\\n\"\n        \"\\n\"\n        \"  manifest = (\\n\"\n        \"    # This manifest is included in your app package to tell Sandstorm\\n\"\n        \"    # about your app.\\n\"\n        \"\\n\"\n        \"    appTitle = (defaultText = \\\"Example App\\\"),\\n\"\n        \"\\n\"\n        \"    appVersion = 0,  # Increment this for every release.\\n\"\n        \"\\n\"\n        \"    appMarketingVersion = (defaultText = \\\"0.0.0\\\"),\\n\"\n        \"    # Human-readable representation of appVersion. Should match the way you\\n\"\n        \"    # identify versions of your app in documentation and marketing.\\n\"\n        \"\\n\"\n        \"    actions = [\\n\"\n        \"      # Define your \\\"new document\\\" handlers here.\\n\"\n        \"      ( nounPhrase = (defaultText = \\\"instance\\\"),\\n\"\n        \"        command = .myCommand\\n\"\n        \"        # The command to run when starting for the first time. (\\\".myCommand\\\"\\n\"\n        \"        # is just a constant defined at the bottom of the file.)\\n\"\n        \"      )\\n\"\n        \"    ],\\n\"\n        \"\\n\"\n        \"    continueCommand = .myCommand,\\n\"\n        \"    # This is the command called to start your app back up after it has been\\n\"\n        \"    # shut down for inactivity. Here we're using the same command as for\\n\"\n        \"    # starting a new instance, but you could use different commands for each\\n\"\n        \"    # case.\\n\"\n        \"\\n\"\n        \"    metadata = (\\n\"\n        \"      # Data which is not needed specifically to execute the app, but is useful\\n\"\n        \"      # for purposes like marketing and display.  These fields are documented at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#add-required-metadata\\n\"\n        \"      # and (in deeper detail) in the sandstorm source code, in the Metadata section of\\n\"\n        \"      # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n        \"      icons = (\\n\"\n        \"        # Various icons to represent the app in various contexts.\\n\"\n        \"        #appGrid = (svg = embed \\\"path/to/appgrid-128x128.svg\\\"),\\n\"\n        \"        #grain = (svg = embed \\\"path/to/grain-24x24.svg\\\"),\\n\"\n        \"        #market = (svg = embed \\\"path/to/market-150x150.svg\\\"),\\n\"\n        \"        #marketBig = (svg = embed \\\"path/to/market-big-300x300.svg\\\"),\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      website = \\\"http://example.com\\\",\\n\"\n        \"      # This should be the app's main website url.\\n\"\n        \"\\n\"\n        \"      codeUrl = \\\"http://example.com\\\",\\n\"\n        \"      # URL of the app's source code repository, e.g. a GitHub URL.\\n\"\n        \"      # Required if you specify a license requiring redistributing code, but optional otherwise.\\n\"\n        \"\\n\"\n        \"      license = (none = void),\\n\"\n        \"      # The license this package is distributed under.  See\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#license\\n\"\n        \"\\n\"\n        \"      categories = [],\\n\"\n        \"      # A list of categories/genres to which this app belongs, sorted with best fit first.\\n\"\n        \"      # See the list of categories at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#categories\\n\"\n        \"\\n\"\n        \"      author = (\\n\"\n        \"        # Fields relating to the author of this app.\\n\"\n        \"\\n\"\n        \"        contactEmail = \\\"youremail@example.com\\\",\\n\"\n        \"        # Email address to contact for any issues with this app. This includes end-user support\\n\"\n        \"        # requests as well as app store administrator requests, so it is very important that this be a\\n\"\n        \"        # valid address with someone paying attention to it.\\n\"\n        \"\\n\"\n        \"        #pgpSignature = embed \\\"path/to/pgp-signature\\\",\\n\"\n        \"        # PGP signature attesting responsibility for the app ID. This is a binary-format detached\\n\"\n        \"        # signature of the following ASCII message (not including the quotes, no newlines, and\\n\"\n        \"        # replacing <app-id> with the standard base-32 text format of the app's ID):\\n\"\n        \"        #\\n\"\n        \"        # \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\"\\n\"\n        \"        #\\n\"\n        \"        # You can create a signature file using `gpg` like so:\\n\"\n        \"        #\\n\"\n        \"        #     echo -n \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\" | gpg --sign > pgp-signature\\n\"\n        \"        #\\n\"\n        \"        # Further details including how to set up GPG and how to use keybase.io can be found\\n\"\n        \"        # at https://docs.sandstorm.io/en/latest/developing/publishing-apps/#verify-your-identity\\n\"\n        \"\\n\"\n        \"        upstreamAuthor = \\\"Example App Team\\\",\\n\"\n        \"        # Name of the original primary author of this app, if it is different from the person who\\n\"\n        \"        # produced the Sandstorm package. Setting this implies that the author connected to the PGP\\n\"\n        \"        # signature only \\\"packaged\\\" the app for Sandstorm, rather than developing the app.\\n\"\n        \"        # Remove this line if you consider yourself as the author of the app.\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      #pgpKeyring = embed \\\"path/to/pgp-keyring\\\",\\n\"\n        \"      # A keyring in GPG keyring format containing all public keys needed to verify PGP signatures in\\n\"\n        \"      # this manifest (as of this writing, there is only one: `author.pgpSignature`).\\n\"\n        \"      #\\n\"\n        \"      # To generate a keyring containing just your public key, do:\\n\"\n        \"      #\\n\"\n        \"      #     gpg --export <key-id> > keyring\\n\"\n        \"      #\\n\"\n        \"      # Where `<key-id>` is a PGP key ID or email address associated with the key.\\n\"\n        \"\\n\"\n        \"      #description = (defaultText = embed \\\"path/to/description.md\\\"),\\n\"\n        \"      # The app's description in Github-flavored Markdown format, to be displayed e.g.\\n\"\n        \"      # in an app store. Note that the Markdown is not permitted to contain HTML nor image tags (but\\n\"\n        \"      # you can include a list of screenshots separately).\\n\"\n        \"\\n\"\n        \"      shortDescription = (defaultText = \\\"one-to-three words\\\"),\\n\"\n        \"      # A very short (one-to-three words) description of what the app does. For example,\\n\"\n        \"      # \\\"Document editor\\\", or \\\"Notetaking\\\", or \\\"Email client\\\". This will be displayed under the app\\n\"\n        \"      # title in the grid view in the app market.\\n\"\n        \"\\n\"\n        \"      screenshots = [\\n\"\n        \"        # Screenshots to use for marketing purposes.  Examples below.\\n\"\n        \"        # Sizes are given in device-independent pixels, so if you took these\\n\"\n        \"        # screenshots on a Retina-style high DPI screen, divide each dimension by two.\\n\"\n        \"\\n\"\n        \"        #(width = 746, height = 795, jpeg = embed \\\"path/to/screenshot-1.jpeg\\\"),\\n\"\n        \"        #(width = 640, height = 480, png = embed \\\"path/to/screenshot-2.png\\\"),\\n\"\n        \"      ],\\n\"\n        \"      #changeLog = (defaultText = embed \\\"path/to/sandstorm-specific/changelog.md\\\"),\\n\"\n        \"      # Documents the history of changes in Github-flavored markdown format (with the same restrictions\\n\"\n        \"      # as govern `description`). We recommend formatting this with an H1 heading for each version\\n\"\n        \"      # followed by a bullet list of changes.\\n\"\n        \"    ),\\n\"\n        \"  ),\\n\"\n        \"\\n\"\n        \"  sourceMap = (\\n\"",
            "includeAllForInit\n        ? \"    # The following directories will be copied into your package.\\n\"\n        : \"    # Here we defined where to look for files to copy into your package. The\\n\"\n          \"    # `spk dev` command actually figures out what files your app needs\\n\"\n          \"    # automatically by running it on a FUSE filesystem. So, the mappings\\n\"\n          \"    # here are only to tell it where to find files that the app wants.\\n\"",
            "\"    searchPath = [\\n\"",
            "searchPath",
            "\"    ]\\n\"\n        \"  ),\\n\"\n        \"\\n\"",
            "includeAllForInit\n        ? \"  alwaysInclude = [ \\\".\\\" ],\\n\"\n          \"  # This says that we always want to include all files from the source map.\\n\"\n          \"  # (An alternative is to automatically detect dependencies by watching what\\n\"\n          \"  # the app opens while running in dev mode. To see what that looks like,\\n\"\n          \"  # run `spk init` without the -A option.)\\n\"\n        : \"  fileList = \\\"sandstorm-files.list\\\",\\n\"\n          \"  # `spk dev` will write a list of all the files your app uses to this file.\\n\"\n          \"  # You should review it later, before shipping your app.\\n\"\n          \"\\n\"\n          \"  alwaysInclude = [],\\n\"\n          \"  # Fill this list with more names of files or directories that should be\\n\"\n          \"  # included in your package, even if not listed in sandstorm-files.list.\\n\"\n          \"  # Use this to force-include stuff that you know you need but which may\\n\"\n          \"  # not have been detected as a dependency during `spk dev`. If you list\\n\"\n          \"  # a directory here, its entire contents will be included recursively.\\n\"",
            "\"\\n\"\n          \"  #bridgeConfig = (\\n\"\n          \"  #  # Used for integrating permissions and roles into the Sandstorm shell\\n\"\n          \"  #  # and for sandstorm-http-bridge to pass to your app.\\n\"\n          \"  #  # Uncomment this block and adjust the permissions and roles to make\\n\"\n          \"  #  # sense for your app.\\n\"\n          \"  #  # For more information, see high-level documentation at\\n\"\n          \"  #  # https://docs.sandstorm.io/en/latest/developing/auth/\\n\"\n          \"  #  # and advanced details in the \\\"BridgeConfig\\\" section of\\n\"\n          \"  #  # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n          \"  #  viewInfo = (\\n\"\n          \"  #    # For details on the viewInfo field, consult \\\"ViewInfo\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #\\n\"\n          \"  #    permissions = [\\n\"\n          \"  #    # Permissions which a user may or may not possess.  A user's current\\n\"\n          \"  #    # permissions are passed to the app as a comma-separated list of `name`\\n\"\n          \"  #    # fields in the X-Sandstorm-Permissions header with each request.\\n\"\n          \"  #    #\\n\"\n          \"  #    # IMPORTANT: only ever append to this list!  Reordering or removing fields\\n\"\n          \"  #    # will change behavior and permissions for existing grains!  To deprecate a\\n\"\n          \"  #    # permission, or for more information, see \\\"PermissionDef\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #      (\\n\"\n          \"  #        name = \\\"editor\\\",\\n\"\n          \"  #        # Name of the permission, used as an identifier for the permission in cases where string\\n\"\n          \"  #        # names are preferred.  Used in sandstorm-http-bridge's X-Sandstorm-Permissions HTTP header.\\n\"\n          \"  #\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Display name of the permission, e.g. to display in a checklist of permissions\\n\"\n          \"  #        # that may be assigned when sharing.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"grants ability to modify data\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #    roles = [\\n\"\n          \"  #      # Roles are logical collections of permissions.  For instance, your app may have\\n\"\n          \"  #      # a \\\"viewer\\\" role and an \\\"editor\\\" role\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Name of the role.  Shown in the Sandstorm UI to indicate which users have which roles.\\n\"\n          \"  #\\n\"\n          \"  #        permissions  = [true],\\n\"\n          \"  #        # An array indicating which permissions this role carries.\\n\"\n          \"  #        # It should be the same length as the permissions array in\\n\"\n          \"  #        # viewInfo, and the order of the lists must match.\\n\"\n          \"  #\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can make changes to the document\\\"),\\n\"\n          \"  #        # Brief explanatory text to show in the sharing UI indicating\\n\"\n          \"  #        # what a user assigned this role will be able to do with the grain.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"editors may view all site data and change settings.\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"viewer\\\"),\\n\"\n          \"  #        permissions  = [false],\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can view the document\\\"),\\n\"\n          \"  #        description = (defaultText = \\\"viewers may view what other users have written.\\\"),\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #  ),\\n\"\n          \"  #  #apiPath = \\\"/api\\\",\\n\"\n          \"  #  # Apps can export an API to the world.  The API is to be used primarily by Javascript\\n\"\n          \"  #  # code and native apps, so it can't serve out regular HTML to browsers.  If a request\\n\"\n          \"  #  # comes in to your app's API, sandstorm-http-bridge will prefix the request's path with\\n\"\n          \"  #  # this string, if specified.\\n\"\n          \"  #),\\n\"\n        \");\\n\"\n        \"\\n\"\n        \"const myCommand :Spk.Manifest.Command = (\\n\"\n        \"  # Here we define the command used to start up your server.\\n\"\n        \"  argv = [\"",
            "argv",
            "\"],\\n\"\n        \"  environ = [\\n\"\n        \"    # Note that this defines the *entire* environment seen by your app.\\n\"\n        \"    (key = \\\"PATH\\\", value = \\\"/usr/local/bin:/usr/bin:/bin\\\"),\\n\"\n        \"    (key = \\\"SANDSTORM\\\", value = \\\"1\\\"),\\n\"\n        \"    # Export SANDSTORM=1 into the environment, so that apps running within Sandstorm\\n\"\n        \"    # can detect if $SANDSTORM=\\\"1\\\" at runtime, switching UI and/or backend to use\\n\"\n        \"    # the app's Sandstorm-specific integration code.\\n\"\n        \"  ]\\n\"\n        \");\\n\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "generateCapnpId()"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generateCapnpId",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "generateCapnpId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "627-638",
          "snippet": "uint64_t generateCapnpId() {\n    uint64_t result;\n\n    int fd;\n    KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n    ssize_t n;\n    KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n    KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n\n    return result | (1ull << 63);\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nuint64_t generateCapnpId() {\n    uint64_t result;\n\n    int fd;\n    KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n    ssize_t n;\n    KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n    KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n\n    return result | (1ull << 63);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "outputFile",
            "O_WRONLY | O_TRUNC | O_CREAT"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = dup(STDOUT_FILENO)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\\\"/sandstorm-http-bridge\\\", \\\"\"",
            "httpPort",
            "\"\\\", \\\"--\\\", \"",
            "kj::mv(argv)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "argv"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"\\\"\"",
            "kj::strArray(commandArgs, \"\\\", \\\"\")",
            "\"\\\"\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "commandArgs",
            "\"\\\", \\\"\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generateKey",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "generateKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "463-475",
          "snippet": "kj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "outputFile.cStr()",
            "F_OK"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outputFile.cStr",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"      ( sourcePath = \\\"\"",
            "kj::strArray(sourcePathForInit, \"\\\" ),\\n      ( sourcePath = \\\"\")",
            "\"\\\" )\\n\""
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "sourcePathForInit",
            "\"\\\" ),\\n      ( sourcePath = \\\"\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"      ( sourcePath = \\\".\\\" ),  # Search this directory first.\\n\"\n          \"      ( sourcePath = \\\"/\\\",    # Then search the system root directory.\\n\"\n          \"        hidePaths = [ \\\"home\\\", \\\"proc\\\", \\\"sys\\\",\\n\"\n          \"                      \\\"etc/passwd\\\", \\\"etc/hosts\\\", \\\"etc/host.conf\\\",\\n\"\n          \"                      \\\"etc/nsswitch.conf\\\", \\\"etc/resolv.conf\\\" ]\\n\"\n          \"        # You probably don't want the app pulling files from these places,\\n\"\n          \"        # so we hide them. Note that /dev, /var, and /tmp are implicitly\\n\"\n          \"        # hidden because Sandstorm itself provides them.\\n\"\n          \"      )\\n\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::StringPtr outputFile = nullptr;\nkj::StringPtr appIdForInit = nullptr;\nkj::Vector<kj::StringPtr> commandArgs;\nkj::Vector<kj::StringPtr> sourcePathForInit;\nuint16_t httpPort = 0;\nbool usesRawApi = false;\nbool includeAllForInit = false;\nkj::Maybe<kj::Array<capnp::word>> data;\n\nkj::MainBuilder::Validity doInit() {\n    if (httpPort == 0 && !usesRawApi) {\n      return \"You must specify at least one of -p or -r.\";\n    }\n\n    kj::String searchPath;\n    if (sourcePathForInit.size() == 0) {\n      if (includeAllForInit) {\n        return \"When using -A you must specify at least one -I.\";\n      }\n\n      searchPath = kj::str(\n          \"      ( sourcePath = \\\".\\\" ),  # Search this directory first.\\n\"\n          \"      ( sourcePath = \\\"/\\\",    # Then search the system root directory.\\n\"\n          \"        hidePaths = [ \\\"home\\\", \\\"proc\\\", \\\"sys\\\",\\n\"\n          \"                      \\\"etc/passwd\\\", \\\"etc/hosts\\\", \\\"etc/host.conf\\\",\\n\"\n          \"                      \\\"etc/nsswitch.conf\\\", \\\"etc/resolv.conf\\\" ]\\n\"\n          \"        # You probably don't want the app pulling files from these places,\\n\"\n          \"        # so we hide them. Note that /dev, /var, and /tmp are implicitly\\n\"\n          \"        # hidden because Sandstorm itself provides them.\\n\"\n          \"      )\\n\");\n    } else {\n      searchPath = kj::str(\n          \"      ( sourcePath = \\\"\",\n          kj::strArray(sourcePathForInit, \"\\\" ),\\n      ( sourcePath = \\\"\"),\n          \"\\\" )\\n\"\n          );\n    }\n\n    if (outputFile == nullptr) {\n      outputFile = \"sandstorm-pkgdef.capnp\";\n      if (access(outputFile.cStr(), F_OK) == 0) {\n        return \"`sandstorm-pkgdef.capnp` already exists\";\n      }\n    }\n\n    kj::String ownAppId;\n    if (appIdForInit == nullptr) {\n      ownAppId = generateKey();\n      appIdForInit = ownAppId;\n    }\n\n    auto argv = kj::str(\"\\\"\", kj::strArray(commandArgs, \"\\\", \\\"\"), \"\\\"\");\n\n    if (httpPort != 0) {\n      argv = kj::str(\"\\\"/sandstorm-http-bridge\\\", \\\"\", httpPort, \"\\\", \\\"--\\\", \", kj::mv(argv));\n    }\n\n    kj::AutoCloseFd outFd;\n    if (outputFile == \"-\") {\n      int fd;\n      KJ_SYSCALL(fd = dup(STDOUT_FILENO));\n      outFd = kj::AutoCloseFd(fd);\n    } else {\n      outFd = raiiOpen(outputFile, O_WRONLY | O_TRUNC | O_CREAT);\n    }\n\n    kj::FdOutputStream out(kj::mv(outFd));\n\n    auto content = kj::str(\n        \"@0x\", kj::hex(generateCapnpId()), \";\\n\"\n        \"\\n\"\n        \"using Spk = import \\\"/sandstorm/package.capnp\\\";\\n\"\n        \"# This imports:\\n\"\n        \"#   $SANDSTORM_HOME/latest/usr/include/sandstorm/package.capnp\\n\"\n        \"# Check out that file to see the full, documented package definition format.\\n\"\n        \"\\n\"\n        \"const pkgdef :Spk.PackageDefinition = (\\n\"\n        \"  # The package definition. Note that the spk tool looks specifically for the\\n\"\n        \"  # \\\"pkgdef\\\" constant.\\n\"\n        \"\\n\"\n        \"  id = \\\"\", appIdForInit, \"\\\",\\n\"\n        \"  # Your app ID is actually its public key. The private key was placed in\\n\"\n        \"  # your keyring. All updates must be signed with the same key.\\n\"\n        \"\\n\"\n        \"  manifest = (\\n\"\n        \"    # This manifest is included in your app package to tell Sandstorm\\n\"\n        \"    # about your app.\\n\"\n        \"\\n\"\n        \"    appTitle = (defaultText = \\\"Example App\\\"),\\n\"\n        \"\\n\"\n        \"    appVersion = 0,  # Increment this for every release.\\n\"\n        \"\\n\"\n        \"    appMarketingVersion = (defaultText = \\\"0.0.0\\\"),\\n\"\n        \"    # Human-readable representation of appVersion. Should match the way you\\n\"\n        \"    # identify versions of your app in documentation and marketing.\\n\"\n        \"\\n\"\n        \"    actions = [\\n\"\n        \"      # Define your \\\"new document\\\" handlers here.\\n\"\n        \"      ( nounPhrase = (defaultText = \\\"instance\\\"),\\n\"\n        \"        command = .myCommand\\n\"\n        \"        # The command to run when starting for the first time. (\\\".myCommand\\\"\\n\"\n        \"        # is just a constant defined at the bottom of the file.)\\n\"\n        \"      )\\n\"\n        \"    ],\\n\"\n        \"\\n\"\n        \"    continueCommand = .myCommand,\\n\"\n        \"    # This is the command called to start your app back up after it has been\\n\"\n        \"    # shut down for inactivity. Here we're using the same command as for\\n\"\n        \"    # starting a new instance, but you could use different commands for each\\n\"\n        \"    # case.\\n\"\n        \"\\n\"\n        \"    metadata = (\\n\"\n        \"      # Data which is not needed specifically to execute the app, but is useful\\n\"\n        \"      # for purposes like marketing and display.  These fields are documented at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#add-required-metadata\\n\"\n        \"      # and (in deeper detail) in the sandstorm source code, in the Metadata section of\\n\"\n        \"      # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n        \"      icons = (\\n\"\n        \"        # Various icons to represent the app in various contexts.\\n\"\n        \"        #appGrid = (svg = embed \\\"path/to/appgrid-128x128.svg\\\"),\\n\"\n        \"        #grain = (svg = embed \\\"path/to/grain-24x24.svg\\\"),\\n\"\n        \"        #market = (svg = embed \\\"path/to/market-150x150.svg\\\"),\\n\"\n        \"        #marketBig = (svg = embed \\\"path/to/market-big-300x300.svg\\\"),\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      website = \\\"http://example.com\\\",\\n\"\n        \"      # This should be the app's main website url.\\n\"\n        \"\\n\"\n        \"      codeUrl = \\\"http://example.com\\\",\\n\"\n        \"      # URL of the app's source code repository, e.g. a GitHub URL.\\n\"\n        \"      # Required if you specify a license requiring redistributing code, but optional otherwise.\\n\"\n        \"\\n\"\n        \"      license = (none = void),\\n\"\n        \"      # The license this package is distributed under.  See\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#license\\n\"\n        \"\\n\"\n        \"      categories = [],\\n\"\n        \"      # A list of categories/genres to which this app belongs, sorted with best fit first.\\n\"\n        \"      # See the list of categories at\\n\"\n        \"      # https://docs.sandstorm.io/en/latest/developing/publishing-apps/#categories\\n\"\n        \"\\n\"\n        \"      author = (\\n\"\n        \"        # Fields relating to the author of this app.\\n\"\n        \"\\n\"\n        \"        contactEmail = \\\"youremail@example.com\\\",\\n\"\n        \"        # Email address to contact for any issues with this app. This includes end-user support\\n\"\n        \"        # requests as well as app store administrator requests, so it is very important that this be a\\n\"\n        \"        # valid address with someone paying attention to it.\\n\"\n        \"\\n\"\n        \"        #pgpSignature = embed \\\"path/to/pgp-signature\\\",\\n\"\n        \"        # PGP signature attesting responsibility for the app ID. This is a binary-format detached\\n\"\n        \"        # signature of the following ASCII message (not including the quotes, no newlines, and\\n\"\n        \"        # replacing <app-id> with the standard base-32 text format of the app's ID):\\n\"\n        \"        #\\n\"\n        \"        # \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\"\\n\"\n        \"        #\\n\"\n        \"        # You can create a signature file using `gpg` like so:\\n\"\n        \"        #\\n\"\n        \"        #     echo -n \\\"I am the author of the Sandstorm.io app with the following ID: <app-id>\\\" | gpg --sign > pgp-signature\\n\"\n        \"        #\\n\"\n        \"        # Further details including how to set up GPG and how to use keybase.io can be found\\n\"\n        \"        # at https://docs.sandstorm.io/en/latest/developing/publishing-apps/#verify-your-identity\\n\"\n        \"\\n\"\n        \"        upstreamAuthor = \\\"Example App Team\\\",\\n\"\n        \"        # Name of the original primary author of this app, if it is different from the person who\\n\"\n        \"        # produced the Sandstorm package. Setting this implies that the author connected to the PGP\\n\"\n        \"        # signature only \\\"packaged\\\" the app for Sandstorm, rather than developing the app.\\n\"\n        \"        # Remove this line if you consider yourself as the author of the app.\\n\"\n        \"      ),\\n\"\n        \"\\n\"\n        \"      #pgpKeyring = embed \\\"path/to/pgp-keyring\\\",\\n\"\n        \"      # A keyring in GPG keyring format containing all public keys needed to verify PGP signatures in\\n\"\n        \"      # this manifest (as of this writing, there is only one: `author.pgpSignature`).\\n\"\n        \"      #\\n\"\n        \"      # To generate a keyring containing just your public key, do:\\n\"\n        \"      #\\n\"\n        \"      #     gpg --export <key-id> > keyring\\n\"\n        \"      #\\n\"\n        \"      # Where `<key-id>` is a PGP key ID or email address associated with the key.\\n\"\n        \"\\n\"\n        \"      #description = (defaultText = embed \\\"path/to/description.md\\\"),\\n\"\n        \"      # The app's description in Github-flavored Markdown format, to be displayed e.g.\\n\"\n        \"      # in an app store. Note that the Markdown is not permitted to contain HTML nor image tags (but\\n\"\n        \"      # you can include a list of screenshots separately).\\n\"\n        \"\\n\"\n        \"      shortDescription = (defaultText = \\\"one-to-three words\\\"),\\n\"\n        \"      # A very short (one-to-three words) description of what the app does. For example,\\n\"\n        \"      # \\\"Document editor\\\", or \\\"Notetaking\\\", or \\\"Email client\\\". This will be displayed under the app\\n\"\n        \"      # title in the grid view in the app market.\\n\"\n        \"\\n\"\n        \"      screenshots = [\\n\"\n        \"        # Screenshots to use for marketing purposes.  Examples below.\\n\"\n        \"        # Sizes are given in device-independent pixels, so if you took these\\n\"\n        \"        # screenshots on a Retina-style high DPI screen, divide each dimension by two.\\n\"\n        \"\\n\"\n        \"        #(width = 746, height = 795, jpeg = embed \\\"path/to/screenshot-1.jpeg\\\"),\\n\"\n        \"        #(width = 640, height = 480, png = embed \\\"path/to/screenshot-2.png\\\"),\\n\"\n        \"      ],\\n\"\n        \"      #changeLog = (defaultText = embed \\\"path/to/sandstorm-specific/changelog.md\\\"),\\n\"\n        \"      # Documents the history of changes in Github-flavored markdown format (with the same restrictions\\n\"\n        \"      # as govern `description`). We recommend formatting this with an H1 heading for each version\\n\"\n        \"      # followed by a bullet list of changes.\\n\"\n        \"    ),\\n\"\n        \"  ),\\n\"\n        \"\\n\"\n        \"  sourceMap = (\\n\",\n        includeAllForInit\n        ? \"    # The following directories will be copied into your package.\\n\"\n        : \"    # Here we defined where to look for files to copy into your package. The\\n\"\n          \"    # `spk dev` command actually figures out what files your app needs\\n\"\n          \"    # automatically by running it on a FUSE filesystem. So, the mappings\\n\"\n          \"    # here are only to tell it where to find files that the app wants.\\n\",\n        \"    searchPath = [\\n\",\n               searchPath,\n        \"    ]\\n\"\n        \"  ),\\n\"\n        \"\\n\",\n        includeAllForInit\n        ? \"  alwaysInclude = [ \\\".\\\" ],\\n\"\n          \"  # This says that we always want to include all files from the source map.\\n\"\n          \"  # (An alternative is to automatically detect dependencies by watching what\\n\"\n          \"  # the app opens while running in dev mode. To see what that looks like,\\n\"\n          \"  # run `spk init` without the -A option.)\\n\"\n        : \"  fileList = \\\"sandstorm-files.list\\\",\\n\"\n          \"  # `spk dev` will write a list of all the files your app uses to this file.\\n\"\n          \"  # You should review it later, before shipping your app.\\n\"\n          \"\\n\"\n          \"  alwaysInclude = [],\\n\"\n          \"  # Fill this list with more names of files or directories that should be\\n\"\n          \"  # included in your package, even if not listed in sandstorm-files.list.\\n\"\n          \"  # Use this to force-include stuff that you know you need but which may\\n\"\n          \"  # not have been detected as a dependency during `spk dev`. If you list\\n\"\n          \"  # a directory here, its entire contents will be included recursively.\\n\",\n          \"\\n\"\n          \"  #bridgeConfig = (\\n\"\n          \"  #  # Used for integrating permissions and roles into the Sandstorm shell\\n\"\n          \"  #  # and for sandstorm-http-bridge to pass to your app.\\n\"\n          \"  #  # Uncomment this block and adjust the permissions and roles to make\\n\"\n          \"  #  # sense for your app.\\n\"\n          \"  #  # For more information, see high-level documentation at\\n\"\n          \"  #  # https://docs.sandstorm.io/en/latest/developing/auth/\\n\"\n          \"  #  # and advanced details in the \\\"BridgeConfig\\\" section of\\n\"\n          \"  #  # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/package.capnp\\n\"\n          \"  #  viewInfo = (\\n\"\n          \"  #    # For details on the viewInfo field, consult \\\"ViewInfo\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #\\n\"\n          \"  #    permissions = [\\n\"\n          \"  #    # Permissions which a user may or may not possess.  A user's current\\n\"\n          \"  #    # permissions are passed to the app as a comma-separated list of `name`\\n\"\n          \"  #    # fields in the X-Sandstorm-Permissions header with each request.\\n\"\n          \"  #    #\\n\"\n          \"  #    # IMPORTANT: only ever append to this list!  Reordering or removing fields\\n\"\n          \"  #    # will change behavior and permissions for existing grains!  To deprecate a\\n\"\n          \"  #    # permission, or for more information, see \\\"PermissionDef\\\" in\\n\"\n          \"  #    # https://github.com/sandstorm-io/sandstorm/blob/master/src/sandstorm/grain.capnp\\n\"\n          \"  #      (\\n\"\n          \"  #        name = \\\"editor\\\",\\n\"\n          \"  #        # Name of the permission, used as an identifier for the permission in cases where string\\n\"\n          \"  #        # names are preferred.  Used in sandstorm-http-bridge's X-Sandstorm-Permissions HTTP header.\\n\"\n          \"  #\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Display name of the permission, e.g. to display in a checklist of permissions\\n\"\n          \"  #        # that may be assigned when sharing.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"grants ability to modify data\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #    roles = [\\n\"\n          \"  #      # Roles are logical collections of permissions.  For instance, your app may have\\n\"\n          \"  #      # a \\\"viewer\\\" role and an \\\"editor\\\" role\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"editor\\\"),\\n\"\n          \"  #        # Name of the role.  Shown in the Sandstorm UI to indicate which users have which roles.\\n\"\n          \"  #\\n\"\n          \"  #        permissions  = [true],\\n\"\n          \"  #        # An array indicating which permissions this role carries.\\n\"\n          \"  #        # It should be the same length as the permissions array in\\n\"\n          \"  #        # viewInfo, and the order of the lists must match.\\n\"\n          \"  #\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can make changes to the document\\\"),\\n\"\n          \"  #        # Brief explanatory text to show in the sharing UI indicating\\n\"\n          \"  #        # what a user assigned this role will be able to do with the grain.\\n\"\n          \"  #\\n\"\n          \"  #        description = (defaultText = \\\"editors may view all site data and change settings.\\\"),\\n\"\n          \"  #        # Prose describing what this role means, suitable for a tool tip or similar help text.\\n\"\n          \"  #      ),\\n\"\n          \"  #      (\\n\"\n          \"  #        title = (defaultText = \\\"viewer\\\"),\\n\"\n          \"  #        permissions  = [false],\\n\"\n          \"  #        verbPhrase = (defaultText = \\\"can view the document\\\"),\\n\"\n          \"  #        description = (defaultText = \\\"viewers may view what other users have written.\\\"),\\n\"\n          \"  #      ),\\n\"\n          \"  #    ],\\n\"\n          \"  #  ),\\n\"\n          \"  #  #apiPath = \\\"/api\\\",\\n\"\n          \"  #  # Apps can export an API to the world.  The API is to be used primarily by Javascript\\n\"\n          \"  #  # code and native apps, so it can't serve out regular HTML to browsers.  If a request\\n\"\n          \"  #  # comes in to your app's API, sandstorm-http-bridge will prefix the request's path with\\n\"\n          \"  #  # this string, if specified.\\n\"\n          \"  #),\\n\"\n        \");\\n\"\n        \"\\n\"\n        \"const myCommand :Spk.Manifest.Command = (\\n\"\n        \"  # Here we define the command used to start up your server.\\n\"\n        \"  argv = [\", argv, \"],\\n\"\n        \"  environ = [\\n\"\n        \"    # Note that this defines the *entire* environment seen by your app.\\n\"\n        \"    (key = \\\"PATH\\\", value = \\\"/usr/local/bin:/usr/bin:/bin\\\"),\\n\"\n        \"    (key = \\\"SANDSTORM\\\", value = \\\"1\\\"),\\n\"\n        \"    # Export SANDSTORM=1 into the environment, so that apps running within Sandstorm\\n\"\n        \"    # can detect if $SANDSTORM=\\\"1\\\" at runtime, switching UI and/or backend to use\\n\"\n        \"    # the app's Sandstorm-specific integration code.\\n\"\n        \"  ]\\n\"\n        \");\\n\");\n\n    out.write(content.begin(), content.size());\n\n    context.exitInfo(kj::str(\"wrote: \", outputFile));\n  }"
  },
  {
    "function_name": "generateCapnpId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "627-638",
    "snippet": "uint64_t generateCapnpId() {\n    uint64_t result;\n\n    int fd;\n    KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n    ssize_t n;\n    KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n    KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n\n    return result | (1ull << 63);\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n == sizeof(result)",
            "\"Incomplete read from /dev/urandom.\"",
            "n"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = read(fd, &result, sizeof(result))",
            "\"/dev/urandom\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&result",
            "sizeof(result)"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = open(\"/dev/urandom\", O_RDONLY)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nuint64_t generateCapnpId() {\n    uint64_t result;\n\n    int fd;\n    KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n    ssize_t n;\n    KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n    KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n\n    return result | (1ull << 63);\n  }"
  },
  {
    "function_name": "addCommandArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "622-625",
    "snippet": "kj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n    commandArgs.add(arg);\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Vector<kj::StringPtr> commandArgs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "commandArgs.add",
          "args": [
            "arg"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Vector<kj::StringPtr> commandArgs;\n\nkj::MainBuilder::Validity addCommandArg(kj::StringPtr arg) {\n    commandArgs.add(arg);\n    return true;\n  }"
  },
  {
    "function_name": "setUsesRawApi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "614-620",
    "snippet": "kj::MainBuilder::Validity setUsesRawApi() {\n    if (httpPort != 0) {\n      return \"You can't specify both -p and -r.\";\n    }\n    usesRawApi = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint16_t httpPort = 0;",
      "bool usesRawApi = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nuint16_t httpPort = 0;\nbool usesRawApi = false;\n\nkj::MainBuilder::Validity setUsesRawApi() {\n    if (httpPort != 0) {\n      return \"You can't specify both -p and -r.\";\n    }\n    usesRawApi = true;\n    return true;\n  }"
  },
  {
    "function_name": "setIncludeAllForInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "609-612",
    "snippet": "kj::MainBuilder::Validity setIncludeAllForInit() {\n    includeAllForInit = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool includeAllForInit = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nbool includeAllForInit = false;\n\nkj::MainBuilder::Validity setIncludeAllForInit() {\n    includeAllForInit = true;\n    return true;\n  }"
  },
  {
    "function_name": "addSourcePathForInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "604-607",
    "snippet": "kj::MainBuilder::Validity addSourcePathForInit(kj::StringPtr arg) {\n    sourcePathForInit.add(arg);\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Vector<kj::StringPtr> sourcePathForInit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sourcePathForInit.add",
          "args": [
            "arg"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::Vector<kj::StringPtr> sourcePathForInit;\n\nkj::MainBuilder::Validity addSourcePathForInit(kj::StringPtr arg) {\n    sourcePathForInit.add(arg);\n    return true;\n  }"
  },
  {
    "function_name": "setPortForInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "587-602",
    "snippet": "kj::MainBuilder::Validity setPortForInit(kj::StringPtr arg) {\n    if (usesRawApi) {\n      return \"You can't specify both -p and -r.\";\n    }\n    KJ_IF_MAYBE(i, parseUInt(arg, 10)) {\n      if (*i < 1 || *i > 65535) {\n        return \"port out-of-range\";\n      } else if (*i < 1024) {\n        return \"Ports under 1024 are priveleged and cannot be used by a Sandstorm app.\";\n      }\n      httpPort = *i;\n      return true;\n    } else {\n      return \"invalid port\";\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint16_t httpPort = 0;",
      "bool usesRawApi = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "i",
            "parseUInt(arg, 10)"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseUInt",
          "args": [
            "arg",
            "10"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "parseUInt64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "223-230",
          "snippet": "kj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nuint16_t httpPort = 0;\nbool usesRawApi = false;\n\nkj::MainBuilder::Validity setPortForInit(kj::StringPtr arg) {\n    if (usesRawApi) {\n      return \"You can't specify both -p and -r.\";\n    }\n    KJ_IF_MAYBE(i, parseUInt(arg, 10)) {\n      if (*i < 1 || *i > 65535) {\n        return \"port out-of-range\";\n      } else if (*i < 1024) {\n        return \"Ports under 1024 are priveleged and cannot be used by a Sandstorm app.\";\n      }\n      httpPort = *i;\n      return true;\n    } else {\n      return \"invalid port\";\n    }\n  }"
  },
  {
    "function_name": "setAppIdForInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "577-585",
    "snippet": "kj::MainBuilder::Validity setAppIdForInit(kj::StringPtr arg) {\n    for (char c: arg) {\n      if (!isalnum(c)) {\n        return \"invalid app ID\";\n      }\n    }\n    appIdForInit = arg;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::StringPtr appIdForInit = nullptr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "c"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::StringPtr appIdForInit = nullptr;\n\nkj::MainBuilder::Validity setAppIdForInit(kj::StringPtr arg) {\n    for (char c: arg) {\n      if (!isalnum(c)) {\n        return \"invalid app ID\";\n      }\n    }\n    appIdForInit = arg;\n    return true;\n  }"
  },
  {
    "function_name": "setOutputFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "572-575",
    "snippet": "kj::MainBuilder::Validity setOutputFile(kj::StringPtr arg) {\n    outputFile = arg;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::StringPtr outputFile = nullptr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::StringPtr outputFile = nullptr;\n\nkj::MainBuilder::Validity setOutputFile(kj::StringPtr arg) {\n    outputFile = arg;\n    return true;\n  }"
  },
  {
    "function_name": "getInitMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "533-562",
    "snippet": "kj::MainFunc getInitMain() {\n    return addCommonOptions(OptionSet::KEYS,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Initialize the current directory as a Sandstorm package source directory by \"\n            \"writing a `sandstorm-pkgdef.capnp` with a newly-created app ID. <command> \"\n            \"specifies the command used to start your app.\")\n        .addOptionWithArg({'o', \"output\"}, KJ_BIND_METHOD(*this, setOutputFile), \"<filename>\",\n            \"Write to <filename> instead of `sandstorm-pkgdef.capnp`. Use `-o -` to write to \"\n            \"standard output.\")\n        .addOptionWithArg({'i', \"app-id\"}, KJ_BIND_METHOD(*this, setAppIdForInit), \"<app-id>\",\n            \"Use <app-id> as the application ID rather than generate a new one.\")\n        .addOptionWithArg({'p', \"port\"}, KJ_BIND_METHOD(*this, setPortForInit), \"<port>\",\n            \"Set the HTTP port on which your server runs -- that is, the port which <command> \"\n            \"will bind to. Your app will be set up to use Sandstorm's HTTP bridge instead of \"\n            \"using the raw Sandstorm APIs.\")\n        .addOptionWithArg({'I', \"source-path\"}, KJ_BIND_METHOD(*this, addSourcePathForInit), \"<path>\",\n            \"Add <path> to the path from which files are pulled into the binary. You may \"\n            \"specify this multiple times to set up a search path. If no paths are given, the \"\n            \"default is to seach '.' (current directory) followed by '/' (root), with some \"\n            \"sensitive directories hidden from '/'.\")\n        .addOption({'A', \"include-all\"}, KJ_BIND_METHOD(*this, setIncludeAllForInit),\n            \"Arrange to include all contents of the directories specified with -I rather than \"\n            \"determine needed files dynamically while running in dev mode.\")\n        .addOption({'r', \"raw\"}, KJ_BIND_METHOD(*this, setUsesRawApi),\n            \"Specifies that your app directly implements the raw Sandstorm API and does \"\n            \"not require the HTTP bridge.\")\n        .expectOneOrMoreArgs(\"-- <command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doInit)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::KEYS",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Initialize the current directory as a Sandstorm package source directory by \"\n            \"writing a `sandstorm-pkgdef.capnp` with a newly-created app ID. <command> \"\n            \"specifies the command used to start your app.\")\n        .addOptionWithArg({'o', \"output\"}, KJ_BIND_METHOD(*this, setOutputFile), \"<filename>\",\n            \"Write to <filename> instead of `sandstorm-pkgdef.capnp`. Use `-o -` to write to \"\n            \"standard output.\")\n        .addOptionWithArg({'i', \"app-id\"}, KJ_BIND_METHOD(*this, setAppIdForInit), \"<app-id>\",\n            \"Use <app-id> as the application ID rather than generate a new one.\")\n        .addOptionWithArg({'p', \"port\"}, KJ_BIND_METHOD(*this, setPortForInit), \"<port>\",\n            \"Set the HTTP port on which your server runs -- that is, the port which <command> \"\n            \"will bind to. Your app will be set up to use Sandstorm's HTTP bridge instead of \"\n            \"using the raw Sandstorm APIs.\")\n        .addOptionWithArg({'I', \"source-path\"}, KJ_BIND_METHOD(*this, addSourcePathForInit), \"<path>\",\n            \"Add <path> to the path from which files are pulled into the binary. You may \"\n            \"specify this multiple times to set up a search path. If no paths are given, the \"\n            \"default is to seach '.' (current directory) followed by '/' (root), with some \"\n            \"sensitive directories hidden from '/'.\")\n        .addOption({'A', \"include-all\"}, KJ_BIND_METHOD(*this, setIncludeAllForInit),\n            \"Arrange to include all contents of the directories specified with -I rather than \"\n            \"determine needed files dynamically while running in dev mode.\")\n        .addOption({'r', \"raw\"}, KJ_BIND_METHOD(*this, setUsesRawApi),\n            \"Specifies that your app directly implements the raw Sandstorm API and does \"\n            \"not require the HTTP bridge.\")\n        .expectOneOrMoreArgs(\"-- <command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doInit))"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doInit)"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doInit"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"-- <command>\"",
            "KJ_BIND_METHOD(*this, addCommandArg)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addCommandArg"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'r', \"raw\"}",
            "KJ_BIND_METHOD(*this, setUsesRawApi)",
            "\"Specifies that your app directly implements the raw Sandstorm API and does \"\n            \"not require the HTTP bridge.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUsesRawApi"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'A', \"include-all\"}",
            "KJ_BIND_METHOD(*this, setIncludeAllForInit)",
            "\"Arrange to include all contents of the directories specified with -I rather than \"\n            \"determine needed files dynamically while running in dev mode.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setIncludeAllForInit"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'I', \"source-path\"}",
            "KJ_BIND_METHOD(*this, addSourcePathForInit)",
            "\"<path>\"",
            "\"Add <path> to the path from which files are pulled into the binary. You may \"\n            \"specify this multiple times to set up a search path. If no paths are given, the \"\n            \"default is to seach '.' (current directory) followed by '/' (root), with some \"\n            \"sensitive directories hidden from '/'.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSourcePathForInit"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'p', \"port\"}",
            "KJ_BIND_METHOD(*this, setPortForInit)",
            "\"<port>\"",
            "\"Set the HTTP port on which your server runs -- that is, the port which <command> \"\n            \"will bind to. Your app will be set up to use Sandstorm's HTTP bridge instead of \"\n            \"using the raw Sandstorm APIs.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setPortForInit"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'i', \"app-id\"}",
            "KJ_BIND_METHOD(*this, setAppIdForInit)",
            "\"<app-id>\"",
            "\"Use <app-id> as the application ID rather than generate a new one.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setAppIdForInit"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'o', \"output\"}",
            "KJ_BIND_METHOD(*this, setOutputFile)",
            "\"<filename>\"",
            "\"Write to <filename> instead of `sandstorm-pkgdef.capnp`. Use `-o -` to write to \"\n            \"standard output.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setOutputFile"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Initialize the current directory as a Sandstorm package source directory by \"\n            \"writing a `sandstorm-pkgdef.capnp` with a newly-created app ID. <command> \"\n            \"specifies the command used to start your app.\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainFunc getInitMain() {\n    return addCommonOptions(OptionSet::KEYS,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Initialize the current directory as a Sandstorm package source directory by \"\n            \"writing a `sandstorm-pkgdef.capnp` with a newly-created app ID. <command> \"\n            \"specifies the command used to start your app.\")\n        .addOptionWithArg({'o', \"output\"}, KJ_BIND_METHOD(*this, setOutputFile), \"<filename>\",\n            \"Write to <filename> instead of `sandstorm-pkgdef.capnp`. Use `-o -` to write to \"\n            \"standard output.\")\n        .addOptionWithArg({'i', \"app-id\"}, KJ_BIND_METHOD(*this, setAppIdForInit), \"<app-id>\",\n            \"Use <app-id> as the application ID rather than generate a new one.\")\n        .addOptionWithArg({'p', \"port\"}, KJ_BIND_METHOD(*this, setPortForInit), \"<port>\",\n            \"Set the HTTP port on which your server runs -- that is, the port which <command> \"\n            \"will bind to. Your app will be set up to use Sandstorm's HTTP bridge instead of \"\n            \"using the raw Sandstorm APIs.\")\n        .addOptionWithArg({'I', \"source-path\"}, KJ_BIND_METHOD(*this, addSourcePathForInit), \"<path>\",\n            \"Add <path> to the path from which files are pulled into the binary. You may \"\n            \"specify this multiple times to set up a search path. If no paths are given, the \"\n            \"default is to seach '.' (current directory) followed by '/' (root), with some \"\n            \"sensitive directories hidden from '/'.\")\n        .addOption({'A', \"include-all\"}, KJ_BIND_METHOD(*this, setIncludeAllForInit),\n            \"Arrange to include all contents of the directories specified with -I rather than \"\n            \"determine needed files dynamically while running in dev mode.\")\n        .addOption({'r', \"raw\"}, KJ_BIND_METHOD(*this, setUsesRawApi),\n            \"Specifies that your app directly implements the raw Sandstorm API and does \"\n            \"not require the HTTP bridge.\")\n        .expectOneOrMoreArgs(\"-- <command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doInit)))\n        .build();\n  }"
  },
  {
    "function_name": "getKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "517-529",
    "snippet": "kj::MainBuilder::Validity getKey(kj::StringPtr appid) {\n    if (isatty(STDOUT_FILENO)) {\n      return \"The output is binary. You want to redirect it to a file. Pipe through cat if you \"\n             \"really intended to write it to your terminal. :)\";\n    }\n\n    auto key = lookupKey(appid, false);  // Don't get a replacement; get the original.\n    capnp::MallocMessageBuilder builder(key.totalSize().wordCount + 4);\n    builder.setRoot(key);\n    capnp::writeMessageToFd(STDOUT_FILENO, builder);\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capnp::writeMessageToFd",
          "args": [
            "STDOUT_FILENO",
            "builder"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setRoot",
          "args": [
            "key"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "setRoot",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "66-69",
          "snippet": "bool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRoot(kj::StringPtr arg) {\n    root = arg;\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.totalSize",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookupKey",
          "args": [
            "appid",
            "false"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainBuilder::Validity getKey(kj::StringPtr appid) {\n    if (isatty(STDOUT_FILENO)) {\n      return \"The output is binary. You want to redirect it to a file. Pipe through cat if you \"\n             \"really intended to write it to your terminal. :)\";\n    }\n\n    auto key = lookupKey(appid, false);  // Don't get a replacement; get the original.\n    capnp::MallocMessageBuilder builder(key.totalSize().wordCount + 4);\n    builder.setRoot(key);\n    capnp::writeMessageToFd(STDOUT_FILENO, builder);\n\n    return true;\n  }"
  },
  {
    "function_name": "getGetkeyMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "505-515",
    "snippet": "kj::MainFunc getGetkeyMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Get the the keys with the given app IDs from your keyring and write them as \"\n            \"Cap'n Proto message to stdout. The output is a valid keyring containing only the \"\n            \"IDs requested. Note that keyrings can be combined via concatenation, so someone \"\n            \"else can add these keys to their own keyring using a command like:\\n\"\n            \"    cat keys >> ~/.sandstorm-keyring\")\n        .expectOneOrMoreArgs(\"<appid>\", KJ_BIND_METHOD(*this, getKey)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::KEYS_READONLY",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Get the the keys with the given app IDs from your keyring and write them as \"\n            \"Cap'n Proto message to stdout. The output is a valid keyring containing only the \"\n            \"IDs requested. Note that keyrings can be combined via concatenation, so someone \"\n            \"else can add these keys to their own keyring using a command like:\\n\"\n            \"    cat keys >> ~/.sandstorm-keyring\")\n        .expectOneOrMoreArgs(\"<appid>\", KJ_BIND_METHOD(*this, getKey))"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<appid>\"",
            "KJ_BIND_METHOD(*this, getKey)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getKey"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Get the the keys with the given app IDs from your keyring and write them as \"\n            \"Cap'n Proto message to stdout. The output is a valid keyring containing only the \"\n            \"IDs requested. Note that keyrings can be combined via concatenation, so someone \"\n            \"else can add these keys to their own keyring using a command like:\\n\"\n            \"    cat keys >> ~/.sandstorm-keyring\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nkj::MainFunc getGetkeyMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Get the the keys with the given app IDs from your keyring and write them as \"\n            \"Cap'n Proto message to stdout. The output is a valid keyring containing only the \"\n            \"IDs requested. Note that keyrings can be combined via concatenation, so someone \"\n            \"else can add these keys to their own keyring using a command like:\\n\"\n            \"    cat keys >> ~/.sandstorm-keyring\")\n        .expectOneOrMoreArgs(\"<appid>\", KJ_BIND_METHOD(*this, getKey)))\n        .build();\n  }"
  },
  {
    "function_name": "doListkeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "491-503",
    "snippet": "kj::MainBuilder::Validity doListkeys() {\n    MemoryMapping mapping(openKeyring(O_RDONLY), \"(keyring)\");\n\n    kj::ArrayPtr<const capnp::word> words = mapping;\n\n    while (words.size() > 0) {\n      capnp::FlatArrayMessageReader reader(words);\n      printAppId(reader.getRoot<spk::KeyFile>().getPublicKey());\n      words = kj::arrayPtr(reader.getEnd(), words.end());\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reader.getEnd()",
            "words.end()"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.end",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getEnd",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "reader.getRoot<spk::KeyFile>().getPublicKey()"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getRoot<spk::KeyFile>",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<spk::KeyFile>",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.size",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openKeyring",
          "args": [
            "O_RDONLY"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "openKeyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "389-409",
          "snippet": "kj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nkj::MainBuilder::Validity doListkeys() {\n    MemoryMapping mapping(openKeyring(O_RDONLY), \"(keyring)\");\n\n    kj::ArrayPtr<const capnp::word> words = mapping;\n\n    while (words.size() > 0) {\n      capnp::FlatArrayMessageReader reader(words);\n      printAppId(reader.getRoot<spk::KeyFile>().getPublicKey());\n      words = kj::arrayPtr(reader.getEnd(), words.end());\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "getListkeysMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "483-489",
    "snippet": "kj::MainFunc getListkeysMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"List the app IDs corresponding to each key on your keyring.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doListkeys)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::KEYS_READONLY",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"List the app IDs corresponding to each key on your keyring.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doListkeys))"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doListkeys)"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doListkeys"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"List the app IDs corresponding to each key on your keyring.\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainFunc getListkeysMain() {\n    return addCommonOptions(OptionSet::KEYS_READONLY,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"List the app IDs corresponding to each key on your keyring.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doListkeys)))\n        .build();\n  }"
  },
  {
    "function_name": "doKeygen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "477-481",
    "snippet": "kj::MainBuilder::Validity doKeygen() {\n    printAppId(generateKey());\n\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "generateKey()"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "generateKey",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "generateKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "463-475",
          "snippet": "kj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainBuilder::Validity doKeygen() {\n    printAppId(generateKey());\n\n    return true;\n  }"
  },
  {
    "function_name": "generateKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "463-475",
    "snippet": "kj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "builder.getPublicKey()"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.getPublicKey",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::writeMessageToFd",
          "args": [
            "openKeyring(O_WRONLY | O_APPEND | O_CREAT)",
            "message"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openKeyring",
          "args": [
            "O_WRONLY | O_APPEND | O_CREAT"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "openKeyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "389-409",
          "snippet": "kj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "result == 0",
            "\"crypto_sign_keypair failed\"",
            "result"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_keypair",
          "args": [
            "builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin()",
            "builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin()"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initPrivateKey",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initPrivateKey",
          "args": [
            "crypto_sign_SECRETKEYBYTES"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initPublicKey",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initPublicKey",
          "args": [
            "crypto_sign_PUBLICKEYBYTES"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<spk::KeyFile>",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::String generateKey() {\n    capnp::MallocMessageBuilder message(32);\n    spk::KeyFile::Builder builder = message.getRoot<spk::KeyFile>();\n\n    int result = crypto_sign_keypair(\n        builder.initPublicKey(crypto_sign_PUBLICKEYBYTES).begin(),\n        builder.initPrivateKey(crypto_sign_SECRETKEYBYTES).begin());\n    KJ_ASSERT(result == 0, \"crypto_sign_keypair failed\", result);\n\n    capnp::writeMessageToFd(openKeyring(O_WRONLY | O_APPEND | O_CREAT), message);\n\n    return appIdString(builder.getPublicKey());\n  }"
  },
  {
    "function_name": "getKeygenMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "451-461",
    "snippet": "kj::MainFunc getKeygenMain() {\n    return addCommonOptions(OptionSet::KEYS,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Create a new app ID and signing key and store it to your keyring. It will then be \"\n            \"used by the `pack` command to sign your app package. Note that when starting a new \"\n            \"app, it's better to use `spk init`. Only use `keygen` when you need to replace the \"\n            \"key on an existing app, e.g. because you're forking it. See `spk help` for more \"\n            \"info about keyrings.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doKeygen)))\n        .build();\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCommonOptions",
          "args": [
            "OptionSet::KEYS",
            "kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Create a new app ID and signing key and store it to your keyring. It will then be \"\n            \"used by the `pack` command to sign your app package. Note that when starting a new \"\n            \"app, it's better to use `spk init`. Only use `keygen` when you need to replace the \"\n            \"key on an existing app, e.g. because you're forking it. See `spk help` for more \"\n            \"info about keyrings.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doKeygen))"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doKeygen)"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doKeygen"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Create a new app ID and signing key and store it to your keyring. It will then be \"\n            \"used by the `pack` command to sign your app package. Note that when starting a new \"\n            \"app, it's better to use `spk init`. Only use `keygen` when you need to replace the \"\n            \"key on an existing app, e.g. because you're forking it. See `spk help` for more \"\n            \"info about keyrings.\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainFunc getKeygenMain() {\n    return addCommonOptions(OptionSet::KEYS,\n        kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n            \"Create a new app ID and signing key and store it to your keyring. It will then be \"\n            \"used by the `pack` command to sign your app package. Note that when starting a new \"\n            \"app, it's better to use `spk init`. Only use `keygen` when you need to replace the \"\n            \"key on an existing app, e.g. because you're forking it. See `spk help` for more \"\n            \"info about keyrings.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, doKeygen)))\n        .build();\n  }"
  },
  {
    "function_name": "lookupKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "411-447",
    "snippet": "spk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MemoryMapping mapping;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES",
            "\"Invalid key in keyring.\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPrivateKey",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPrivateKey",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPublicKey",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getPublicKey",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second->getRoot<spk::KeyFile>",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(appid, \": key not found in keyring\")"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "appid",
            "\": key not found in keyring\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyMap.end",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyMap.find",
          "args": [
            "kj::str(appid)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "appid"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyMap.insert",
          "args": [
            "std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader))"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "appIdString(key.getPublicKey())",
            "kj::mv(reader)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reader"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "key.getPublicKey()"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.getPublicKey",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reader->getEnd()",
            "words.end()"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.end",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader->getEnd",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader->getRoot<spk::KeyFile>",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<capnp::FlatArrayMessageReader>",
          "args": [
            "words"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.size",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mapping"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<MemoryMapping>",
          "args": [
            "openKeyring(O_RDONLY)",
            "\"(keyring)\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openKeyring",
          "args": [
            "O_RDONLY"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "openKeyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "389-409",
          "snippet": "kj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"the requested key is obsolete\"",
            "appid",
            "replacement"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPublicKeyForApp",
          "args": [
            "appidBytes"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tryParseAppId(appid, appidBytes)",
            "\"invalid appid\"",
            "appid"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParseAppId",
          "args": [
            "appid",
            "appidBytes"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "tryParseAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "180-183",
          "snippet": "bool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nbool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nMemoryMapping mapping;\n\nspk::KeyFile::Reader lookupKey(kj::StringPtr appid, bool withReplacements = true) {\n    // We actually want to sign packages using the current replacement key for the app ID.\n    byte appidBytes[APP_ID_BYTE_SIZE];\n    KJ_REQUIRE(tryParseAppId(appid, appidBytes), \"invalid appid\", appid);\n    auto replacement = appIdString(getPublicKeyForApp(appidBytes));\n    if (withReplacements) {\n      appid = replacement;\n    } else {\n      if (appid != replacement) {\n        KJ_LOG(WARNING, \"the requested key is obsolete\", appid, replacement);\n      }\n    }\n\n    if (keyringMapping == nullptr) {\n      auto mapping = kj::heap<MemoryMapping>(openKeyring(O_RDONLY), \"(keyring)\");\n      kj::ArrayPtr<const capnp::word> words = *mapping;\n      keyringMapping = kj::mv(mapping);\n\n      while (words.size() > 0) {\n        auto reader = kj::heap<capnp::FlatArrayMessageReader>(words);\n        auto key = reader->getRoot<spk::KeyFile>();\n        words = kj::arrayPtr(reader->getEnd(), words.end());\n        keyMap.insert(std::make_pair(appIdString(key.getPublicKey()), kj::mv(reader)));\n      }\n    }\n\n    auto iter = keyMap.find(kj::str(appid));\n    if (iter == keyMap.end()) {\n      context.exitError(kj::str(appid, \": key not found in keyring\"));\n    } else {\n      auto key = iter->second->getRoot<spk::KeyFile>();\n      KJ_REQUIRE(key.getPublicKey().size() == crypto_sign_PUBLICKEYBYTES &&\n                 key.getPrivateKey().size() == crypto_sign_SECRETKEYBYTES,\n                 \"Invalid key in keyring.\");\n      return key;\n    }\n  }"
  },
  {
    "function_name": "openKeyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "389-409",
    "snippet": "kj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "filename",
            "flags",
            "0600"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "raiiOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "71-82",
          "snippet": "kj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\")"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** WARNING: Keys are being added to:\\n\"",
            "\"**   \"",
            "filename",
            "\"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "home",
            "\"/.sandstorm-keyring\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "home != nullptr",
            "\"$HOME is not set!\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"HOME\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::AutoCloseFd openKeyring(int flags) {\n    kj::StringPtr filename;\n    kj::String ownFilename;\n    if (keyringPath == nullptr) {\n      const char* home = getenv(\"HOME\");\n      KJ_REQUIRE(home != nullptr, \"$HOME is not set!\");\n      ownFilename = kj::str(home, \"/.sandstorm-keyring\");\n      filename = ownFilename;\n    } else {\n      filename = keyringPath;\n    }\n    if (!quiet && (flags & O_ACCMODE) != O_RDONLY) {\n      context.warning(kj::str(\n          \"** WARNING: Keys are being added to:\\n\",\n          \"**   \", filename, \"\\n\"\n          \"** Please make a backup of this file and keep it safe. If you lose your keys,\\n\"\n          \"** you won't be able to update your app. If someone steals your keys, they\\n\"\n          \"** will be able to post updates for your app. (Use -q to quiet this warning.)\"));\n    }\n    return raiiOpen(filename, flags, 0600);\n  }"
  },
  {
    "function_name": "setQuiet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "384-387",
    "snippet": "kj::MainBuilder::Validity setQuiet() {\n    quiet = true;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainBuilder::Validity setQuiet() {\n    quiet = true;\n    return true;\n  }"
  },
  {
    "function_name": "setKeyringPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "376-382",
    "snippet": "kj::MainBuilder::Validity setKeyringPath(kj::StringPtr arg) {\n    if (access(arg.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    keyringPath = arg;\n    return true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "arg.cStr()",
            "F_OK"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.cStr",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nkj::MainBuilder::Validity setKeyringPath(kj::StringPtr arg) {\n    if (access(arg.cStr(), F_OK) != 0) {\n      return \"not found\";\n    }\n    keyringPath = arg;\n    return true;\n  }"
  },
  {
    "function_name": "printAppId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "369-374",
    "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printAppId",
          "args": [
            "appIdString(publicKey)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "printAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "369-374",
          "snippet": "void printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "publicKey"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "publicKey.size() == crypto_sign_PUBLICKEYBYTES"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "publicKey.size",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::ArrayPtr<const byte> publicKey) {\n    static_assert(crypto_sign_PUBLICKEYBYTES == 32, \"Signing algorithm changed?\");\n    KJ_REQUIRE(publicKey.size() == crypto_sign_PUBLICKEYBYTES);\n\n    printAppId(appIdString(publicKey));\n  }"
  },
  {
    "function_name": "printAppId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "363-367",
    "snippet": "void printAppId(kj::StringPtr appId) {\n    kj::String msg = kj::str(appId, \"\\n\");\n    kj::FdOutputStream out(STDOUT_FILENO);\n    out.write(msg.begin(), msg.size());\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "msg.begin()",
            "msg.size()"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.size",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.begin",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "appId",
            "\"\\n\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid printAppId(kj::StringPtr appId) {\n    kj::String msg = kj::str(appId, \"\\n\");\n    kj::FdOutputStream out(STDOUT_FILENO);\n    out.write(msg.begin(), msg.size());\n  }"
  },
  {
    "function_name": "ensurePackageDefParsed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "354-361",
    "snippet": "void ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"sandstorm-pkgdef.capnp: \", *e)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"sandstorm-pkgdef.capnp: \"",
            "*e"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "e",
            "valid.getError()"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid.getError",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPackageDef",
          "args": [
            "\"sandstorm-pkgdef.capnp:pkgdef\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nvoid ensurePackageDefParsed() {\n    if (!sawPkgDef) {\n      auto valid = setPackageDef(\"sandstorm-pkgdef.capnp:pkgdef\");\n      KJ_IF_MAYBE(e, valid.getError()) {\n        context.exitError(kj::str(\"sandstorm-pkgdef.capnp: \", *e));\n      }\n    }\n  }"
  },
  {
    "function_name": "commit",
    "container": "ReplacementFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "145-149",
    "snippet": "void commit() {\n    fd = nullptr;\n    KJ_SYSCALL(rename(replacementName.cStr(), name.cStr()));\n    committed = true;\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "rename(replacementName.cStr(), name.cStr())"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "replacementName.cStr()",
            "name.cStr()"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementName.cStr",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nReplacementFile {\n  void commit() {\n      fd = nullptr;\n      KJ_SYSCALL(rename(replacementName.cStr(), name.cStr()));\n      committed = true;\n    }\n}"
  },
  {
    "function_name": "getFd",
    "container": "ReplacementFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "143-143",
    "snippet": "inline int getFd() { return fd; }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nReplacementFile {\n  inline int getFd() { return fd; }\n}"
  },
  {
    "function_name": "ReplacementFile",
    "container": "ReplacementFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "127-132",
    "snippet": "explicit ReplacementFile(kj::StringPtr name): name(name) {\n    int fd_;\n    replacementName = kj::str(name, \".XXXXXX\");\n    KJ_SYSCALL(fd_ = mkstemp(replacementName.begin()));\n    fd = kj::AutoCloseFd(fd_);\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd_"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd_ = mkstemp(replacementName.begin())"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "replacementName.begin()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementName.begin",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name",
            "\".XXXXXX\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nReplacementFile {\n  explicit ReplacementFile(kj::StringPtr name): name(name) {\n      int fd_;\n      replacementName = kj::str(name, \".XXXXXX\");\n      KJ_SYSCALL(fd_ = mkstemp(replacementName.begin()));\n      fd = kj::AutoCloseFd(fd_);\n    }\n}"
  },
  {
    "function_name": "decode",
    "container": "OversizeTextHandler",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "113-117",
    "snippet": "capnp::Orphan<capnp::Text> decode(\n      const capnp::JsonCodec& codec, capnp::JsonValue::Reader input,\n      capnp::Orphanage orphanage) const override {\n    KJ_UNIMPLEMENTED(\"OversizeTextHandler::decode\");\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"OversizeTextHandler::decode\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nOversizeTextHandler {\n  capnp::Orphan<capnp::Text> decode(\n        const capnp::JsonCodec& codec, capnp::JsonValue::Reader input,\n        capnp::Orphanage orphanage) const override {\n      KJ_UNIMPLEMENTED(\"OversizeTextHandler::decode\");\n    }\n}"
  },
  {
    "function_name": "encode",
    "container": "OversizeTextHandler",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "102-111",
    "snippet": "void encode(const capnp::JsonCodec& codec, capnp::Text::Reader input,\n              capnp::JsonValue::Builder output) const override {\n    if (input.size() > 256) {\n      auto call = output.initCall();\n      call.setFunction(\"LargeTextBlob\");\n      call.initParams(1)[0].setNumber(input.size());\n    } else {\n      output.setString(input);\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.setString",
          "args": [
            "input"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "input.size()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "1"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.setFunction",
          "args": [
            "\"LargeTextBlob\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.initCall",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nOversizeTextHandler {\n  void encode(const capnp::JsonCodec& codec, capnp::Text::Reader input,\n                capnp::JsonValue::Builder output) const override {\n      if (input.size() > 256) {\n        auto call = output.initCall();\n        call.setFunction(\"LargeTextBlob\");\n        call.initParams(1)[0].setNumber(input.size());\n      } else {\n        output.setString(input);\n      }\n    }\n}"
  },
  {
    "function_name": "decode",
    "container": "OversizeDataHandler",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "93-97",
    "snippet": "capnp::Orphan<capnp::Data> decode(\n      const capnp::JsonCodec& codec, capnp::JsonValue::Reader input,\n      capnp::Orphanage orphanage) const override {\n    KJ_UNIMPLEMENTED(\"OversizeDataHandler::decode\");\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"OversizeDataHandler::decode\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nOversizeDataHandler {\n  capnp::Orphan<capnp::Data> decode(\n        const capnp::JsonCodec& codec, capnp::JsonValue::Reader input,\n        capnp::Orphanage orphanage) const override {\n      KJ_UNIMPLEMENTED(\"OversizeDataHandler::decode\");\n    }\n}"
  },
  {
    "function_name": "encode",
    "container": "OversizeDataHandler",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
    "lines": "80-91",
    "snippet": "void encode(const capnp::JsonCodec& codec, capnp::Data::Reader input,\n              capnp::JsonValue::Builder output) const override {\n    if (input.size() > 256) {\n      auto call = output.initCall();\n      call.setFunction(\"LargeDataBlob\");\n      call.initParams(1)[0].setNumber(input.size());\n    } else {\n      auto call = output.initCall();\n      call.setFunction(\"Base64\");\n      call.initParams(1)[0].setString(base64Encode(input, false));\n    }\n  }",
    "includes": [
      "#include \"appid-replacements.h\"",
      "#include \"id-to-text.h\"",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"union-fs.h\"",
      "#include \"fuse.h\"",
      "#include \"version.h\"",
      "#include <sodium/crypto_generichash_blake2b.h>",
      "#include <sandstorm/app-index/submit.capnp.h>",
      "#include <poll.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <capnp/dynamic.h>",
      "#include <capnp/schema-parser.h>",
      "#include <sys/xattr.h>",
      "#include <map>",
      "#include <set>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <sandstorm/appid-replacements.capnp.h>",
      "#include <sandstorm/package.capnp.h>",
      "#include <errno.h>",
      "#include <sys/mman.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sodium/crypto_hash_sha512.h>",
      "#include <sodium/crypto_hash_sha256.h>",
      "#include <sodium/crypto_sign.h>",
      "#include <capnp/compat/json.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"spk.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "friend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "base64Encode(input, false)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64Encode",
          "args": [
            "input",
            "false"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "base64Encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "630-670",
          "snippet": "kj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "1"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.setFunction",
          "args": [
            "\"Base64\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.initCall",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "input.size()"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "call.initParams",
          "args": [
            "1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.setFunction",
          "args": [
            "\"LargeDataBlob\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.initCall",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend void verifySpk(int spkfd, int tmpfile, spk::VerifiedInfo::Builder output);\n\nOversizeDataHandler {\n  void encode(const capnp::JsonCodec& codec, capnp::Data::Reader input,\n                capnp::JsonValue::Builder output) const override {\n      if (input.size() > 256) {\n        auto call = output.initCall();\n        call.setFunction(\"LargeDataBlob\");\n        call.initParams(1)[0].setNumber(input.size());\n      } else {\n        auto call = output.initCall();\n        call.setFunction(\"Base64\");\n        call.initParams(1)[0].setString(base64Encode(input, false));\n      }\n    }\n}"
  }
]