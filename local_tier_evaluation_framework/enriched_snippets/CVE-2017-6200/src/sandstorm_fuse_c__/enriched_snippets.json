[
  {
    "function_name": "~FuseMount",
    "container": "FuseMount",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1107-1128",
    "snippet": "FuseMount::~FuseMount() noexcept(false) {\n  if (path == nullptr) return;\n\n  pid_t pid = fork();\n  if (pid == 0) {\n    // KJ likes to adjust the signal mask.  Fix it.\n    sigset_t emptySet;\n    KJ_SYSCALL(sigemptyset(&emptySet));\n    KJ_SYSCALL(sigprocmask(SIG_SETMASK, &emptySet, nullptr));\n\n    KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"-u\", \"--\", path.cStr(),\n                      (char*)nullptr));\n\n    KJ_UNREACHABLE;\n  } else {\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0)) { return; }\n    KJ_ASSERT(WIFEXITED(status) && WEXITSTATUS(status) == 0, \"fusermount failed\") {\n      return;\n    }\n  }\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "WIFEXITED(status) && WEXITSTATUS(status) == 0",
            "\"fusermount failed\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitpid(pid, &status, 0)"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execlp(\"fusermount\", \"fusermount\", \"-u\", \"--\", path.cStr(),\n                      (char*)nullptr)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"fusermount\"",
            "\"fusermount\"",
            "\"-u\"",
            "\"--\"",
            "path.cStr()",
            "(char*)nullptr"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &emptySet, nullptr)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&emptySet",
            "nullptr"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&emptySet)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&emptySet"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseMount {\n  FuseMount::~FuseMount() noexcept(false) {\n    if (path == nullptr) return;\n  \n    pid_t pid = fork();\n    if (pid == 0) {\n      // KJ likes to adjust the signal mask.  Fix it.\n      sigset_t emptySet;\n      KJ_SYSCALL(sigemptyset(&emptySet));\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &emptySet, nullptr));\n  \n      KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"-u\", \"--\", path.cStr(),\n                        (char*)nullptr));\n  \n      KJ_UNREACHABLE;\n    } else {\n      int status;\n      KJ_SYSCALL(waitpid(pid, &status, 0)) { return; }\n      KJ_ASSERT(WIFEXITED(status) && WEXITSTATUS(status) == 0, \"fusermount failed\") {\n        return;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "FuseMount",
    "container": "FuseMount",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1067-1105",
    "snippet": "FuseMount::FuseMount(kj::StringPtr path, kj::StringPtr options): path(kj::heapString(path)) {\n  int sockets[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, sockets));\n\n  kj::AutoCloseFd clientEnd(sockets[0]);\n  kj::AutoCloseFd serverEnd(sockets[1]);\n\n  pid_t pid = fork();\n  if (pid == 0) {\n    clientEnd = nullptr;\n\n    // KJ likes to adjust the signal mask.  Fix it.\n    sigset_t emptySet;\n    KJ_SYSCALL(sigemptyset(&emptySet));\n    KJ_SYSCALL(sigprocmask(SIG_SETMASK, &emptySet, nullptr));\n\n    // Set Unix socket FD over which FUSE device FD should be returned.\n    KJ_SYSCALL(setenv(\"_FUSE_COMMFD\", kj::str((int)serverEnd).cStr(), true));\n\n    if (options.size() > 0) {\n      KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"-o\", options.cStr(), \"--\", path.cStr(),\n                        (char*)nullptr));\n    } else {\n      KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"--\", path.cStr(), (char*)nullptr));\n    }\n\n    KJ_UNREACHABLE;\n  } else {\n    serverEnd = nullptr;\n    int childStatus;\n\n    {\n      KJ_DEFER(KJ_SYSCALL(waitpid(pid, &childStatus, 0)) {break;});\n      fd = receiveFd(clientEnd);\n    }\n\n    KJ_ASSERT(WIFEXITED(childStatus) && WEXITSTATUS(childStatus) == 0, \"fusermount failed\");\n  }\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "WIFEXITED(childStatus) && WEXITSTATUS(childStatus) == 0",
            "\"fusermount failed\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "childStatus"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "childStatus"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiveFd",
          "args": [
            "clientEnd"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
          "lines": "55-59",
          "snippet": "kj::AutoCloseFd receiveFd(int sockFd) {\n  return receiveFd(sockFd, [](kj::ArrayPtr<const kj::byte>) {\n    KJ_FAIL_REQUIRE(\"Got unexpected data on unix socket while waiting for a file descriptor.\");\n  });\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <kj/debug.h>",
            "#include \"send-fd.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include <kj/debug.h>\n#include \"send-fd.h\"\n\nkj::AutoCloseFd receiveFd(int sockFd) {\n  return receiveFd(sockFd, [](kj::ArrayPtr<const kj::byte>) {\n    KJ_FAIL_REQUIRE(\"Got unexpected data on unix socket while waiting for a file descriptor.\");\n  });\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "KJ_SYSCALL(waitpid(pid, &childStatus, 0)){break;}"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitpid(pid, &childStatus, 0)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&childStatus",
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execlp(\"fusermount\", \"fusermount\", \"--\", path.cStr(), (char*)nullptr)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"fusermount\"",
            "\"fusermount\"",
            "\"--\"",
            "path.cStr()",
            "(char*)nullptr"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execlp(\"fusermount\", \"fusermount\", \"-o\", options.cStr(), \"--\", path.cStr(),\n                        (char*)nullptr)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"fusermount\"",
            "\"fusermount\"",
            "\"-o\"",
            "options.cStr()",
            "\"--\"",
            "path.cStr()",
            "(char*)nullptr"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.cStr",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.size",
          "args": [],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setenv(\"_FUSE_COMMFD\", kj::str((int)serverEnd).cStr(), true)"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"_FUSE_COMMFD\"",
            "kj::str((int)serverEnd).cStr()",
            "true"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "(int)serverEnd"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &emptySet, nullptr)"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&emptySet",
            "nullptr"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&emptySet)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&emptySet"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, SOCK_STREAM, 0, sockets)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "sockets"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseMount {\n  FuseMount::FuseMount(kj::StringPtr path, kj::StringPtr options): path(kj::heapString(path)) {\n    int sockets[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, sockets));\n  \n    kj::AutoCloseFd clientEnd(sockets[0]);\n    kj::AutoCloseFd serverEnd(sockets[1]);\n  \n    pid_t pid = fork();\n    if (pid == 0) {\n      clientEnd = nullptr;\n  \n      // KJ likes to adjust the signal mask.  Fix it.\n      sigset_t emptySet;\n      KJ_SYSCALL(sigemptyset(&emptySet));\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &emptySet, nullptr));\n  \n      // Set Unix socket FD over which FUSE device FD should be returned.\n      KJ_SYSCALL(setenv(\"_FUSE_COMMFD\", kj::str((int)serverEnd).cStr(), true));\n  \n      if (options.size() > 0) {\n        KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"-o\", options.cStr(), \"--\", path.cStr(),\n                          (char*)nullptr));\n      } else {\n        KJ_SYSCALL(execlp(\"fusermount\", \"fusermount\", \"--\", path.cStr(), (char*)nullptr));\n      }\n  \n      KJ_UNREACHABLE;\n    } else {\n      serverEnd = nullptr;\n      int childStatus;\n  \n      {\n        KJ_DEFER(KJ_SYSCALL(waitpid(pid, &childStatus, 0)) {break;});\n        fd = receiveFd(clientEnd);\n      }\n  \n      KJ_ASSERT(WIFEXITED(childStatus) && WEXITSTATUS(childStatus) == 0, \"fusermount failed\");\n    }\n  }\n}"
  },
  {
    "function_name": "newLoopbackFuseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1061-1063",
    "snippet": "kj::Own<fuse::Node> newLoopbackFuseNode(kj::StringPtr path, kj::Duration cacheTtl) {\n  return kj::refcounted<NodeImpl>(path, cacheTtl);\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<NodeImpl>",
          "args": [
            "path",
            "cacheTtl"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nkj::Own<fuse::Node> newLoopbackFuseNode(kj::StringPtr path, kj::Duration cacheTtl) {\n  return kj::refcounted<NodeImpl>(path, cacheTtl);\n}"
  },
  {
    "function_name": "updateStats",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1048-1056",
    "snippet": "void updateStats() {\n    struct timespec ts;\n    KJ_SYSCALL(clock_gettime(CLOCK_MONOTONIC, &ts));\n    uint64_t time = toNanos(ts);\n    if (time >= statsExpirationTime) {\n      statsExpirationTime = time + ttl / kj::NANOSECONDS;\n      KJ_SYSCALL(lstat(path.cStr(), &stats), path);\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(path.cStr(), &stats)",
            "path"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toNanos",
          "args": [
            "ts"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "toNanos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "844-846",
          "snippet": "inline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\ninline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "clock_gettime(CLOCK_MONOTONIC, &ts)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_MONOTONIC",
            "&ts"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  void updateStats() {\n      struct timespec ts;\n      KJ_SYSCALL(clock_gettime(CLOCK_MONOTONIC, &ts));\n      uint64_t time = toNanos(ts);\n      if (time >= statsExpirationTime) {\n        statsExpirationTime = time + ttl / kj::NANOSECONDS;\n        KJ_SYSCALL(lstat(path.cStr(), &stats), path);\n      }\n    }\n}"
  },
  {
    "function_name": "readlink",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1034-1040",
    "snippet": "kj::String readlink() override {\n    char buffer[PATH_MAX + 1];\n    int n;\n    KJ_SYSCALL(n = ::readlink(path.cStr(), buffer, PATH_MAX));\n    buffer[n] = '\\0';\n    return kj::heapString(buffer);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "buffer"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = ::readlink(path.cStr(), buffer, PATH_MAX)"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::readlink",
          "args": [
            "path.cStr()",
            "buffer",
            "PATH_MAX"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::String readlink() override {\n      char buffer[PATH_MAX + 1];\n      int n;\n      KJ_SYSCALL(n = ::readlink(path.cStr(), buffer, PATH_MAX));\n      buffer[n] = '\\0';\n      return kj::heapString(buffer);\n    }\n}"
  },
  {
    "function_name": "openAsDirectory",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1029-1032",
    "snippet": "kj::Maybe<kj::Own<fuse::Directory>> openAsDirectory() override {\n    kj::Own<fuse::Directory> result = kj::refcounted<DirectoryImpl>(path);\n    return kj::mv(result);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<DirectoryImpl>",
          "args": [
            "path"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<kj::Own<fuse::Directory>> openAsDirectory() override {\n      kj::Own<fuse::Directory> result = kj::refcounted<DirectoryImpl>(path);\n      return kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "openAsFile",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "1024-1027",
    "snippet": "kj::Maybe<kj::Own<fuse::File>> openAsFile() override {\n    kj::Own<fuse::File> result =  kj::refcounted<FileImpl>(path);\n    return kj::mv(result);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<FileImpl>",
          "args": [
            "path"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<kj::Own<fuse::File>> openAsFile() override {\n      kj::Own<fuse::File> result =  kj::refcounted<FileImpl>(path);\n      return kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "getAttributes",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "989-1022",
    "snippet": "GetAttributesResults getAttributes() override {\n    updateStats();\n\n    auto results = GetAttributesResults { };\n    auto& attrs = results.attributes;\n    attrs.inodeNumber = stats.st_ino;\n\n    switch (stats.st_mode & S_IFMT) {\n      case S_IFBLK:  attrs.type = fuse::Node::Type::BLOCK_DEVICE; break;\n      case S_IFCHR:  attrs.type = fuse::Node::Type::CHARACTER_DEVICE; break;\n      case S_IFDIR:  attrs.type = fuse::Node::Type::DIRECTORY; break;\n      case S_IFIFO:  attrs.type = fuse::Node::Type::FIFO; break;\n      case S_IFLNK:  attrs.type = fuse::Node::Type::SYMLINK; break;\n      case S_IFREG:  attrs.type = fuse::Node::Type::REGULAR; break;\n      case S_IFSOCK: attrs.type = fuse::Node::Type::SOCKET; break;\n      default:       attrs.type = fuse::Node::Type::UNKNOWN; break;\n    }\n\n    attrs.permissions = stats.st_mode & ~S_IFMT;\n    attrs.linkCount = stats.st_nlink;\n    attrs.ownerId = stats.st_uid;\n    attrs.groupId = stats.st_gid;\n    attrs.deviceMajor = major(stats.st_rdev);\n    attrs.deviceMinor = minor(stats.st_rdev);\n    attrs.size = stats.st_size;\n    attrs.blockCount = stats.st_blocks;\n    attrs.blockSize = stats.st_blksize;\n    attrs.lastAccessTime = toNanos(stats.st_atim);\n    attrs.lastModificationTime = toNanos(stats.st_mtim);\n    attrs.lastStatusChangeTime = toNanos(stats.st_ctim);\n    results.ttl = ttl / kj::NANOSECONDS;\n\n    return kj::mv(results);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "results"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toNanos",
          "args": [
            "stats.st_ctim"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "toNanos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "844-846",
          "snippet": "inline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\ninline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "stats.st_rdev"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "stats.st_rdev"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updateStats",
          "args": [],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "updateStats",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "1048-1056",
          "snippet": "void updateStats() {\n    struct timespec ts;\n    KJ_SYSCALL(clock_gettime(CLOCK_MONOTONIC, &ts));\n    uint64_t time = toNanos(ts);\n    if (time >= statsExpirationTime) {\n      statsExpirationTime = time + ttl / kj::NANOSECONDS;\n      KJ_SYSCALL(lstat(path.cStr(), &stats), path);\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  void updateStats() {\n      struct timespec ts;\n      KJ_SYSCALL(clock_gettime(CLOCK_MONOTONIC, &ts));\n      uint64_t time = toNanos(ts);\n      if (time >= statsExpirationTime) {\n        statsExpirationTime = time + ttl / kj::NANOSECONDS;\n        KJ_SYSCALL(lstat(path.cStr(), &stats), path);\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  GetAttributesResults getAttributes() override {\n      updateStats();\n  \n      auto results = GetAttributesResults { };\n      auto& attrs = results.attributes;\n      attrs.inodeNumber = stats.st_ino;\n  \n      switch (stats.st_mode & S_IFMT) {\n        case S_IFBLK:  attrs.type = fuse::Node::Type::BLOCK_DEVICE; break;\n        case S_IFCHR:  attrs.type = fuse::Node::Type::CHARACTER_DEVICE; break;\n        case S_IFDIR:  attrs.type = fuse::Node::Type::DIRECTORY; break;\n        case S_IFIFO:  attrs.type = fuse::Node::Type::FIFO; break;\n        case S_IFLNK:  attrs.type = fuse::Node::Type::SYMLINK; break;\n        case S_IFREG:  attrs.type = fuse::Node::Type::REGULAR; break;\n        case S_IFSOCK: attrs.type = fuse::Node::Type::SOCKET; break;\n        default:       attrs.type = fuse::Node::Type::UNKNOWN; break;\n      }\n  \n      attrs.permissions = stats.st_mode & ~S_IFMT;\n      attrs.linkCount = stats.st_nlink;\n      attrs.ownerId = stats.st_uid;\n      attrs.groupId = stats.st_gid;\n      attrs.deviceMajor = major(stats.st_rdev);\n      attrs.deviceMinor = minor(stats.st_rdev);\n      attrs.size = stats.st_size;\n      attrs.blockCount = stats.st_blocks;\n      attrs.blockSize = stats.st_blksize;\n      attrs.lastAccessTime = toNanos(stats.st_atim);\n      attrs.lastModificationTime = toNanos(stats.st_mtim);\n      attrs.lastStatusChangeTime = toNanos(stats.st_ctim);\n      results.ttl = ttl / kj::NANOSECONDS;\n  \n      return kj::mv(results);\n    }\n}"
  },
  {
    "function_name": "lookup",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "973-987",
    "snippet": "kj::Maybe<LookupResults> lookup(kj::StringPtr name) override {\n    KJ_REQUIRE(name != \".\" && name != \"..\", \"Please implement . and .. at a higher level.\");\n\n    auto fullPath = kj::str(path, '/', name);\n    struct stat new_stats;\n    auto n = lstat(fullPath.cStr(), &new_stats);\n\n    if (n < 0 && errno == ENOENT) {\n      return nullptr;\n    } else {\n      uint64_t xttl = ttl / kj::NANOSECONDS;\n\n      return LookupResults { kj::refcounted<NodeImpl>(kj::mv(fullPath), ttl), xttl };\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<NodeImpl>",
          "args": [
            "kj::mv(fullPath)",
            "ttl"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fullPath"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "fullPath.cStr()",
            "&new_stats"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fullPath.cStr",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "'/'",
            "name"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "name != \".\" && name != \"..\"",
            "\"Please implement . and .. at a higher level.\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<LookupResults> lookup(kj::StringPtr name) override {\n      KJ_REQUIRE(name != \".\" && name != \"..\", \"Please implement . and .. at a higher level.\");\n  \n      auto fullPath = kj::str(path, '/', name);\n      struct stat new_stats;\n      auto n = lstat(fullPath.cStr(), &new_stats);\n  \n      if (n < 0 && errno == ENOENT) {\n        return nullptr;\n      } else {\n        uint64_t xttl = ttl / kj::NANOSECONDS;\n  \n        return LookupResults { kj::refcounted<NodeImpl>(kj::mv(fullPath), ttl), xttl };\n      }\n    }\n}"
  },
  {
    "function_name": "addRef",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "968-970",
    "snippet": "kj::Own<fuse::Node> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Own<fuse::Node> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "NodeImpl",
    "container": "NodeImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "965-966",
    "snippet": "NodeImpl(kj::StringPtr path, kj::Duration ttl)\n    : path(kj::heapString(path)), ttl(ttl) { }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  NodeImpl(kj::StringPtr path, kj::Duration ttl)\n      : path(kj::heapString(path)), ttl(ttl) { }\n}"
  },
  {
    "function_name": "read",
    "container": "DirectoryImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "910-956",
    "snippet": "kj::Array<Entry> read(uint64_t offset, uint32_t requestedCount) override {\n    if (offset != currentOffset) {\n      seekdir(dir, offset);\n      currentOffset = offset;\n    }\n\n    KJ_REQUIRE(requestedCount < 8192, \"readdir too large\", requestedCount);\n\n    kj::Vector<struct dirent> entries(requestedCount);\n\n    uint count = 0;\n    for (; count < requestedCount; count++) {\n      struct dirent* ent = readdir(dir);\n      if (ent == nullptr) {\n        // End of directory.\n        break;\n      }\n\n      currentOffset = ent->d_off;\n\n      entries.add(*ent);\n    }\n\n    auto result = kj::heapArray<Entry>(count);\n\n    for (size_t i: kj::indices(entries)) {\n      auto& entry = entries[i];\n\n      result[i].inodeNumber = entry.d_ino;\n      result[i].nextOffset = entry.d_off;\n\n      switch (entry.d_type) {\n        case DT_BLK:  result[i].type = fuse::Node::Type::BLOCK_DEVICE; break;\n        case DT_CHR:  result[i].type = fuse::Node::Type::CHARACTER_DEVICE; break;\n        case DT_DIR:  result[i].type = fuse::Node::Type::DIRECTORY; break;\n        case DT_FIFO: result[i].type = fuse::Node::Type::FIFO; break;\n        case DT_LNK:  result[i].type = fuse::Node::Type::SYMLINK; break;\n        case DT_REG:  result[i].type = fuse::Node::Type::REGULAR; break;\n        case DT_SOCK: result[i].type = fuse::Node::Type::SOCKET; break;\n        default:      result[i].type = fuse::Node::Type::UNKNOWN; break;\n      }\n\n      result[i].name = kj::str(entry.d_name);\n    }\n\n    return kj::mv(result);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "entry.d_name"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "entries"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<Entry>",
          "args": [
            "count"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entries.add",
          "args": [
            "*ent"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "requestedCount < 8192",
            "\"readdir too large\"",
            "requestedCount"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seekdir",
          "args": [
            "dir",
            "offset"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nDirectoryImpl {\n  kj::Array<Entry> read(uint64_t offset, uint32_t requestedCount) override {\n      if (offset != currentOffset) {\n        seekdir(dir, offset);\n        currentOffset = offset;\n      }\n  \n      KJ_REQUIRE(requestedCount < 8192, \"readdir too large\", requestedCount);\n  \n      kj::Vector<struct dirent> entries(requestedCount);\n  \n      uint count = 0;\n      for (; count < requestedCount; count++) {\n        struct dirent* ent = readdir(dir);\n        if (ent == nullptr) {\n          // End of directory.\n          break;\n        }\n  \n        currentOffset = ent->d_off;\n  \n        entries.add(*ent);\n      }\n  \n      auto result = kj::heapArray<Entry>(count);\n  \n      for (size_t i: kj::indices(entries)) {\n        auto& entry = entries[i];\n  \n        result[i].inodeNumber = entry.d_ino;\n        result[i].nextOffset = entry.d_off;\n  \n        switch (entry.d_type) {\n          case DT_BLK:  result[i].type = fuse::Node::Type::BLOCK_DEVICE; break;\n          case DT_CHR:  result[i].type = fuse::Node::Type::CHARACTER_DEVICE; break;\n          case DT_DIR:  result[i].type = fuse::Node::Type::DIRECTORY; break;\n          case DT_FIFO: result[i].type = fuse::Node::Type::FIFO; break;\n          case DT_LNK:  result[i].type = fuse::Node::Type::SYMLINK; break;\n          case DT_REG:  result[i].type = fuse::Node::Type::REGULAR; break;\n          case DT_SOCK: result[i].type = fuse::Node::Type::SOCKET; break;\n          default:      result[i].type = fuse::Node::Type::UNKNOWN; break;\n        }\n  \n        result[i].name = kj::str(entry.d_name);\n      }\n  \n      return kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "addRef",
    "container": "DirectoryImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "905-907",
    "snippet": "kj::Own<fuse::Directory> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nDirectoryImpl {\n  kj::Own<fuse::Directory> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "DirectoryImpl",
    "container": "DirectoryImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "893-899",
    "snippet": "DirectoryImpl(kj::StringPtr path) {\n    dir = opendir(path.cStr());\n    if (dir == nullptr) {\n      int error = errno;\n      KJ_FAIL_SYSCALL(\"opendir()\", error, path);\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"opendir()\"",
            "error",
            "path"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "path.cStr()"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nDirectoryImpl {\n  DirectoryImpl(kj::StringPtr path) {\n      dir = opendir(path.cStr());\n      if (dir == nullptr) {\n        int error = errno;\n        KJ_FAIL_SYSCALL(\"opendir()\", error, path);\n      }\n    }\n}"
  },
  {
    "function_name": "read",
    "container": "FileImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "861-885",
    "snippet": "kj::Array<uint8_t> read(uint64_t offset, uint32_t size) override {\n    KJ_REQUIRE(size < (1 << 22), \"read too large\", size);\n\n    auto result = kj::heapArray<uint8_t>(size);\n\n    kj::byte* ptr = result.begin();\n\n    while (size > 0) {\n      ssize_t n;\n      KJ_SYSCALL(n = pread(fd, ptr, size, offset));\n      if (n == 0) {\n        break;\n      }\n      ptr += n;\n      offset += n;\n      size -= n;\n    }\n\n    if (size > 0) {\n      // Oops, we hit EOF before filling the buffer. Truncate.\n      return kj::heapArray<uint8_t>(result.slice(0, result.size() - size));\n    } else {\n      return result;\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapArray<uint8_t>",
          "args": [
            "result.slice(0, result.size() - size)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.slice",
          "args": [
            "0",
            "result.size() - size"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = pread(fd, ptr, size, offset)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "ptr",
            "size",
            "offset"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<uint8_t>",
          "args": [
            "size"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size < (1 << 22)",
            "\"read too large\"",
            "size"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFileImpl {\n  kj::Array<uint8_t> read(uint64_t offset, uint32_t size) override {\n      KJ_REQUIRE(size < (1 << 22), \"read too large\", size);\n  \n      auto result = kj::heapArray<uint8_t>(size);\n  \n      kj::byte* ptr = result.begin();\n  \n      while (size > 0) {\n        ssize_t n;\n        KJ_SYSCALL(n = pread(fd, ptr, size, offset));\n        if (n == 0) {\n          break;\n        }\n        ptr += n;\n        offset += n;\n        size -= n;\n      }\n  \n      if (size > 0) {\n        // Oops, we hit EOF before filling the buffer. Truncate.\n        return kj::heapArray<uint8_t>(result.slice(0, result.size() - size));\n      } else {\n        return result;\n      }\n    }\n}"
  },
  {
    "function_name": "addRef",
    "container": "FileImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "856-858",
    "snippet": "kj::Own<fuse::File> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFileImpl {\n  kj::Own<fuse::File> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "FileImpl",
    "container": "FileImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "850-854",
    "snippet": "explicit FileImpl(kj::StringPtr path) {\n    int ifd;\n    KJ_SYSCALL(ifd = open(path.cStr(), O_RDONLY), path);\n    fd = kj::AutoCloseFd(ifd);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "ifd"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ifd = open(path.cStr(), O_RDONLY)",
            "path"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path.cStr()",
            "O_RDONLY"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFileImpl {\n  explicit FileImpl(kj::StringPtr path) {\n      int ifd;\n      KJ_SYSCALL(ifd = open(path.cStr(), O_RDONLY), path);\n      fd = kj::AutoCloseFd(ifd);\n    }\n}"
  },
  {
    "function_name": "toNanos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "844-846",
    "snippet": "inline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\ninline int64_t toNanos(const struct timespec& ts) {\n  return ts.tv_sec * 1000000000ll + ts.tv_nsec;\n}"
  },
  {
    "function_name": "bindFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "833-838",
    "snippet": "kj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driverPtr->run",
          "args": [
            "kj::mv(driver)"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "108-244",
          "snippet": "bool BackupMain::run(kj::StringPtr grainDir) {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n  // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  // Create files / directories before we potentially change the UID, so that they are created\n  // with the right owner.\n  if (restore) {\n    KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n  } else if (filename != \"-\") {\n    // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n    KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n  }\n\n  if (sandboxUid == nullptr) {\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n  } else {\n    KJ_SYSCALL(seteuid(0));\n    KJ_SYSCALL(unshare(CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Mount root read-only.\n  bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n\n  if (access(\"/tmp/dev/null\", F_OK) != 0) {\n    // Looks like we need to bind in /dev.\n    KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Hide sensitive directories.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n\n  // Mount inner tmpfs.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n\n  // Bind in the grain's `data` (=`sandbox`).\n  KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n  bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n       MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n\n  // Bind in the grain's `log`. When restoring, we discard the log.\n  if (!restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n    bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n  }\n\n  // Bind in the file.\n  if (restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n  // See supervisor-main.c++ for more discussion.\n  {\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/tmp\"));\n  }\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    KJ_SYSCALL(setresuid(*u, *u, *u));\n  }\n\n  // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n  //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n  //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n  //   supervisor.c++...\n\n  if (!restore) {\n    // Read stdin to metadata file.\n    kj::FdInputStream in(STDIN_FILENO);\n    kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n    pump(in, out);\n  }\n\n  {\n    // Drop crapabilities.\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n    umask(0007);\n  }\n\n  // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n  //   to zip/unzip.\n  if (restore) {\n    Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n\n    // Read metadata file to stdout.\n    kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n    kj::FdOutputStream out(STDOUT_FILENO);\n    pump(in, out);\n  } else {\n    Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n    auto inPipe = Pipe::make();\n    zipOptions.stdin = inPipe.readEnd;\n    Subprocess zip(kj::mv(zipOptions));\n    inPipe.readEnd = nullptr;\n\n    {\n      kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n      for (auto& entry: listDirectory(\".\")) {\n        findFilesToZip(entry, out);\n      }\n    }\n\n    zip.waitForSuccess();\n  }\n\n  return true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [
            "#define PR_SET_NO_NEW_PRIVS 38"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nBackupMain {\n  bool BackupMain::run(kj::StringPtr grainDir) {\n    // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n    // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n    // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n    KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n  \n    // Create files / directories before we potentially change the UID, so that they are created\n    // with the right owner.\n    if (restore) {\n      KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n    } else if (filename != \"-\") {\n      // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n      KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n    }\n  \n    if (sandboxUid == nullptr) {\n      uid_t uid = getuid();\n      gid_t gid = getgid();\n  \n      KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n      writeSetgroupsIfPresent(\"deny\\n\");\n      writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n      writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n    } else {\n      KJ_SYSCALL(seteuid(0));\n      KJ_SYSCALL(unshare(CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    }\n  \n    // To really unshare the mount namespace, we also have to make sure all mounts are private.\n    // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n    // are undocumented.  :(\n    KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n  \n    // Mount root read-only.\n    bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n  \n    if (access(\"/tmp/dev/null\", F_OK) != 0) {\n      // Looks like we need to bind in /dev.\n      KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Hide sensitive directories.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  \n    // Mount inner tmpfs.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n  \n    // Bind in the grain's `data` (=`sandbox`).\n    KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n    bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n         MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n  \n    // Bind in the grain's `log`. When restoring, we discard the log.\n    if (!restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n      bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n    }\n  \n    // Bind in the file.\n    if (restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n      KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n    // See supervisor-main.c++ for more discussion.\n    {\n      auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n      KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n      KJ_SYSCALL(fchdir(oldRootDir));\n      KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n      KJ_SYSCALL(chdir(\"/tmp\"));\n    }\n  \n    KJ_IF_MAYBE(u, sandboxUid) {\n      KJ_SYSCALL(setresuid(*u, *u, *u));\n    }\n  \n    // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n    //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n    //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n    //   supervisor.c++...\n  \n    if (!restore) {\n      // Read stdin to metadata file.\n      kj::FdInputStream in(STDIN_FILENO);\n      kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n      pump(in, out);\n    }\n  \n    {\n      // Drop crapabilities.\n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n      umask(0007);\n    }\n  \n    // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n    //   to zip/unzip.\n    if (restore) {\n      Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n  \n      // Read metadata file to stdout.\n      kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n      kj::FdOutputStream out(STDOUT_FILENO);\n      pump(in, out);\n    } else {\n      Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n      auto inPipe = Pipe::make();\n      zipOptions.stdin = inPipe.readEnd;\n      Subprocess zip(kj::mv(zipOptions));\n      inPipe.readEnd = nullptr;\n  \n      {\n        kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n        for (auto& entry: listDirectory(\".\")) {\n          findFilesToZip(entry, out);\n        }\n      }\n  \n      zip.waitForSuccess();\n    }\n  \n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "driver"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driverPtr->run",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "58-64",
          "snippet": "kj::Promise<void> run() {\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    abortReadLoop = kj::mv(paf.fulfiller);\n\n    // Wait for readLoop() to report disconnect, but fail early if aborted.\n    return readLoop().exclusiveJoin(kj::mv(paf.promise));\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Promise<void> run() {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      abortReadLoop = kj::mv(paf.fulfiller);\n  \n      // Wait for readLoop() to report disconnect, but fail early if aborted.\n      return readLoop().exclusiveJoin(kj::mv(paf.promise));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver.get",
          "args": [],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<FuseDriver>",
          "args": [
            "eventPort",
            "fuseFd",
            "kj::mv(root)",
            "options"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "root"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nkj::Promise<void> bindFuse(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node> root,\n                           FuseOptions options) {\n  auto driver = kj::heap<FuseDriver>(eventPort, fuseFd, kj::mv(root), options);\n  FuseDriver* driverPtr = driver.get();\n  return driverPtr->run().attach(kj::mv(driver));\n}"
  },
  {
    "function_name": "translateAttrs",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "801-830",
    "snippet": "void translateAttrs(fuse::Node::Attributes& src, struct fuse_attr* dst) {\n    memset(dst, 0, sizeof(*dst));\n\n    dst->ino = src.inodeNumber;\n    dst->size = src.size;\n    dst->blocks = src.blockCount;\n\n    splitTime(src.lastAccessTime, &dst->atime, &dst->atimensec);\n    splitTime(src.lastModificationTime, &dst->mtime, &dst->mtimensec);\n    splitTime(src.lastStatusChangeTime, &dst->ctime, &dst->ctimensec);\n\n    dst->mode = src.permissions;\n\n    switch (src.type) {\n      case fuse::Node::Type::UNKNOWN:                                break;\n      case fuse::Node::Type::BLOCK_DEVICE:     dst->mode |= S_IFBLK; break;\n      case fuse::Node::Type::CHARACTER_DEVICE: dst->mode |= S_IFCHR; break;\n      case fuse::Node::Type::DIRECTORY:        dst->mode |= S_IFDIR; break;\n      case fuse::Node::Type::FIFO:             dst->mode |= S_IFIFO; break;\n      case fuse::Node::Type::SYMLINK:          dst->mode |= S_IFLNK; break;\n      case fuse::Node::Type::REGULAR:          dst->mode |= S_IFREG; break;\n      case fuse::Node::Type::SOCKET:           dst->mode |= S_IFSOCK; break;\n    }\n\n    dst->nlink = src.linkCount;\n    dst->uid = src.ownerId;\n    dst->gid = src.groupId;\n    dst->rdev = makedev(src.deviceMajor, src.deviceMinor);\n    dst->blksize = src.blockSize;\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "src.deviceMajor",
            "src.deviceMinor"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splitTime",
          "args": [
            "src.lastStatusChangeTime",
            "&dst->ctime",
            "&dst->ctimensec"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "splitTime",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "785-799",
          "snippet": "void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n    // The FUSE interface appears to use unsigned values even for absolute times, implying it\n    // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n    // declared the types wrong and the kernel will actually interpret them as signed.\n\n    int32_t signedNsec = time % 1000000000ll;\n    time = time / 1000000000ll;\n    if (signedNsec < 0) {\n      ++time;\n      signedNsec += 1000000000ll;\n    }\n\n    *secs = time;\n    *nsecs = signedNsec;\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n      // The FUSE interface appears to use unsigned values even for absolute times, implying it\n      // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n      // declared the types wrong and the kernel will actually interpret them as signed.\n  \n      int32_t signedNsec = time % 1000000000ll;\n      time = time / 1000000000ll;\n      if (signedNsec < 0) {\n        ++time;\n        signedNsec += 1000000000ll;\n      }\n  \n      *secs = time;\n      *nsecs = signedNsec;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "sizeof(*dst)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void translateAttrs(fuse::Node::Attributes& src, struct fuse_attr* dst) {\n      memset(dst, 0, sizeof(*dst));\n  \n      dst->ino = src.inodeNumber;\n      dst->size = src.size;\n      dst->blocks = src.blockCount;\n  \n      splitTime(src.lastAccessTime, &dst->atime, &dst->atimensec);\n      splitTime(src.lastModificationTime, &dst->mtime, &dst->mtimensec);\n      splitTime(src.lastStatusChangeTime, &dst->ctime, &dst->ctimensec);\n  \n      dst->mode = src.permissions;\n  \n      switch (src.type) {\n        case fuse::Node::Type::UNKNOWN:                                break;\n        case fuse::Node::Type::BLOCK_DEVICE:     dst->mode |= S_IFBLK; break;\n        case fuse::Node::Type::CHARACTER_DEVICE: dst->mode |= S_IFCHR; break;\n        case fuse::Node::Type::DIRECTORY:        dst->mode |= S_IFDIR; break;\n        case fuse::Node::Type::FIFO:             dst->mode |= S_IFIFO; break;\n        case fuse::Node::Type::SYMLINK:          dst->mode |= S_IFLNK; break;\n        case fuse::Node::Type::REGULAR:          dst->mode |= S_IFREG; break;\n        case fuse::Node::Type::SOCKET:           dst->mode |= S_IFSOCK; break;\n      }\n  \n      dst->nlink = src.linkCount;\n      dst->uid = src.ownerId;\n      dst->gid = src.groupId;\n      dst->rdev = makedev(src.deviceMajor, src.deviceMinor);\n      dst->blksize = src.blockSize;\n    }\n}"
  },
  {
    "function_name": "splitTime",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "785-799",
    "snippet": "void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n    // The FUSE interface appears to use unsigned values even for absolute times, implying it\n    // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n    // declared the types wrong and the kernel will actually interpret them as signed.\n\n    int32_t signedNsec = time % 1000000000ll;\n    time = time / 1000000000ll;\n    if (signedNsec < 0) {\n      ++time;\n      signedNsec += 1000000000ll;\n    }\n\n    *secs = time;\n    *nsecs = signedNsec;\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n      // The FUSE interface appears to use unsigned values even for absolute times, implying it\n      // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n      // declared the types wrong and the kernel will actually interpret them as signed.\n  \n      int32_t signedNsec = time % 1000000000ll;\n      time = time / 1000000000ll;\n      if (signedNsec < 0) {\n        ++time;\n        signedNsec += 1000000000ll;\n      }\n  \n      *secs = time;\n      *nsecs = signedNsec;\n    }\n}"
  },
  {
    "function_name": "splitTime",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "780-783",
    "snippet": "void splitTime(uint64_t time, uint64_t* secs, uint32_t* nsecs) {\n    *secs = time / 1000000000llu;\n    *nsecs = time % 1000000000llu;\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void splitTime(uint64_t time, uint64_t* secs, uint32_t* nsecs) {\n      *secs = time / 1000000000llu;\n      *nsecs = time % 1000000000llu;\n    }\n}"
  },
  {
    "function_name": "consumeString",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "772-778",
    "snippet": "kj::StringPtr consumeString(kj::ArrayPtr<const kj::byte>& bytes) {\n    const char* ptr = reinterpret_cast<const char*>(bytes.begin());\n    size_t len = strnlen(ptr, bytes.size());\n    KJ_REQUIRE(len < bytes.size());\n    bytes = bytes.slice(len + 1, bytes.size());\n    return kj::StringPtr(ptr, len);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "ptr",
            "len"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.slice",
          "args": [
            "len + 1",
            "bytes.size()"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.size",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "len < bytes.size()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "ptr",
            "bytes.size()"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "bytes.begin()"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::StringPtr consumeString(kj::ArrayPtr<const kj::byte>& bytes) {\n      const char* ptr = reinterpret_cast<const char*>(bytes.begin());\n      size_t len = strnlen(ptr, bytes.size());\n      KJ_REQUIRE(len < bytes.size());\n      bytes = bytes.slice(len + 1, bytes.size());\n      return kj::StringPtr(ptr, len);\n    }\n}"
  },
  {
    "function_name": "consumeStruct",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "764-770",
    "snippet": "T consumeStruct(kj::ArrayPtr<const kj::byte>& bytes) {\n    T result;\n    KJ_REQUIRE(bytes.size() >= sizeof(result));\n    memcpy(&result, bytes.begin(), sizeof(result));\n    bytes = bytes.slice(sizeof(result), bytes.size());\n    return result;\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bytes.slice",
          "args": [
            "sizeof(result)",
            "bytes.size()"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.size",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&result",
            "bytes.begin()",
            "sizeof(result)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "bytes.size() >= sizeof(result)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  T consumeStruct(kj::ArrayPtr<const kj::byte>& bytes) {\n      T result;\n      KJ_REQUIRE(bytes.size() >= sizeof(result));\n      memcpy(&result, bytes.begin(), sizeof(result));\n      bytes = bytes.slice(sizeof(result), bytes.size());\n      return result;\n    }\n}"
  },
  {
    "function_name": "dispatch",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "391-758",
    "snippet": "bool dispatch(struct fuse_in_header& header, kj::ArrayPtr<const kj::byte> body) {\n    auto nodeIter = nodeMap.find(header.nodeid);\n    KJ_REQUIRE(header.nodeid == 0 || nodeIter != nodeMap.end(),\n        \"Kernel asked for unknown node ID.\", header.nodeid);\n\n    switch (header.opcode) {\n      case FUSE_INIT: {\n        auto initBody = consumeStruct<struct fuse_init_in>(body);\n        KJ_REQUIRE(initBody.major == 7);\n        KJ_REQUIRE(initBody.minor >= 20);\n\n        auto reply = allocResponse<struct fuse_init_out>();\n        reply->body.major = 7;\n        reply->body.minor = 20;\n        reply->body.max_readahead = 65536;\n        reply->body.max_write = 65536;\n\n#ifdef FUSE_COMPAT_22_INIT_OUT_SIZE\n        // Compatibility with pre-2.15 kernels.\n        reply->bodySize = FUSE_COMPAT_22_INIT_OUT_SIZE;\n#endif\n\n        sendReply(header.unique, kj::mv(reply));\n        break;\n      }\n\n      case FUSE_DESTROY:\n        return false;\n\n      case FUSE_FORGET: {\n        auto requestBody = consumeStruct<struct fuse_forget_in>(body);\n        if ((nodeIter->second.refcount -= requestBody.nlookup) == 0) {\n          nodeMap.erase(nodeIter);\n        }\n        break;\n      }\n\n      case FUSE_BATCH_FORGET: {\n        auto requestBody = consumeStruct<struct fuse_batch_forget_in>(body);\n\n        for (uint i = 0; i < requestBody.count; i++) {\n          auto item = consumeStruct<struct fuse_forget_one>(body);\n          auto iter2 = nodeMap.find(item.nodeid);\n          KJ_REQUIRE(iter2 != nodeMap.end());\n          if ((iter2->second.refcount -= item.nlookup) == 0) {\n            nodeMap.erase(iter2);\n          }\n        }\n        break;\n      }\n\n      case FUSE_LOOKUP: {\n        auto name = consumeString(body);\n        auto requestId = header.unique;\n        uint64_t parentId = header.nodeid;\n        kj::String ownName = kj::heapString(name);\n\n        performReplyTask(requestId, EIO,\n            [this, parentId, nodeIter, KJ_MVCAP(ownName)]() mutable -> kj::Own<ResponseBase> {\n          auto maybeLookupResult = nodeIter->second.node->lookup(ownName.slice(0));\n          KJ_IF_MAYBE(lookupResult, maybeLookupResult) {\n            auto result = lookupResult->node->getAttributes();\n            auto attributes = result.attributes;\n\n            auto reply = allocResponse<struct fuse_entry_out>();\n\n            uint64_t inode = attributes.inodeNumber;\n            auto insertResult = childMap.insert(std::make_pair(\n                ChildKey { parentId, ownName }, ChildInfo()));\n\n            // Make sure the StringPtr in the key points at the String in the value.\n            if (insertResult.second) {\n              // This is a newly-inserted entry.\n              insertResult.first->second.name = kj::mv(ownName);\n            } else {\n              // Existing entry. Check consistency.\n              KJ_ASSERT(insertResult.first->second.name.begin() ==\n                        insertResult.first->first.name.begin());\n            }\n\n            if (insertResult.second || insertResult.first->second.inode != inode) {\n              // Either we've never looked up this child before, or the inode number has changed\n              // since we looked it up so we assume it has been replaced by a new node.\n              //\n              // TODO(someday): It would be better to detect when a node has been replaced by\n              //   comparing the capabilities, though this requires \"join\" support (level 4 RPC).\n              reply->body.nodeid = nodeIdCounter++;\n              insertResult.first->second.nodeId = reply->body.nodeid;\n              insertResult.first->second.inode = inode;\n            } else {\n              // This appears to be exactly the same child we returned previously. Use the same\n              // node ID.\n              reply->body.nodeid = insertResult.first->second.nodeId;\n            }\n\n            reply->body.generation = 0;\n            reply->newObject = ObjToInsert(reply->body.nodeid, kj::mv(lookupResult->node));\n\n            translateAttrs(attributes, &reply->body.attr);\n            if (options.cacheForever) {\n              reply->body.entry_valid = 365 * kj::DAYS / kj::SECONDS;\n              reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n            } else {\n              splitTime(lookupResult->ttl,\n                  &reply->body.entry_valid, &reply->body.entry_valid_nsec);\n              splitTime(result.ttl,\n                  &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n            }\n            return kj::mv(reply);\n          } else {\n            auto reply = kj::heap<ResponseBase>();\n            reply->header.error = -ENOENT;  // Has to be negative. Just because.\n            return kj::mv(reply);\n          }\n        });\n        break;\n      }\n\n      case FUSE_GETATTR: {\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto response = nodeIter->second.node->getAttributes();\n\n          auto reply = allocResponse<struct fuse_attr_out>();\n          if (options.cacheForever) {\n            reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n          } else {\n            splitTime(response.ttl, &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n          }\n          translateAttrs(response.attributes, &reply->body.attr);\n          return kj::mv(reply);\n        });\n        break;\n      }\n\n      case FUSE_READLINK:\n        // No input.\n        performReplyTask(header.unique, EINVAL, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto link = nodeIter->second.node->readlink();\n          auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(link.begin()), link.size());\n          return allocResponse<void>(kj::mv(link), bytes);\n        });\n        break;\n\n      case FUSE_OPEN: {\n        auto request = consumeStruct<struct fuse_open_in>(body);\n\n        if ((request.flags & O_ACCMODE) != O_RDONLY) {\n          sendError(header.unique, EROFS);\n          break;\n        }\n\n        // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n        //   perhaps we ought to assume this should always succeed and thus pipeline it?\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto response = nodeIter->second.node->openAsFile();\n          KJ_IF_MAYBE(file, response) {\n            auto reply = allocResponse<struct fuse_open_out>();\n            reply->body.fh = handleCounter++;\n            reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*file));\n\n            // TODO(someday):  Fill in open_flags, especially \"nonseekable\"?  See FOPEN_* in fuse.h.\n            if (options.cacheForever) reply->body.open_flags |= FOPEN_KEEP_CACHE;\n            return kj::mv(reply);\n          } else {\n            KJ_FAIL_REQUIRE(\"not a file\");\n          }\n        });\n        break;\n      }\n\n      case FUSE_READ: {\n        auto request = consumeStruct<struct fuse_read_in>(body);\n\n        auto iter2 = fileMap.find(request.fh);\n        KJ_REQUIRE(iter2 != fileMap.end(), \"Kernel requested invalid file handle?\");\n\n        performReplyTask(header.unique, EIO,\n            [this, KJ_MVCAP(request), iter2]() -> kj::Own<ResponseBase> {\n          auto bytes = iter2->second.cap->read(request.offset, request.size);\n          kj::ArrayPtr<kj::byte> slice = bytes.asPtr();\n          return allocResponse<void>(kj::mv(bytes), slice);\n        });\n        break;\n      }\n\n      case FUSE_RELEASE: {\n        // TODO(someday): When we support writes, we'll need to flush them here and possibly return\n        //   an error.\n        auto request = consumeStruct<struct fuse_release_in>(body);\n        KJ_REQUIRE(fileMap.erase(request.fh) == 1, \"Kernel released invalid file handle?\");\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n      }\n\n      case FUSE_OPENDIR: {\n        auto request = consumeStruct<struct fuse_open_in>(body);\n\n        if ((request.flags & O_ACCMODE) != O_RDONLY) {\n          sendError(header.unique, EROFS);\n          break;\n        }\n\n        // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n        //   perhaps we ought to assume this should always succeed and thus pipeline it?\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto maybeDirectory = nodeIter->second.node->openAsDirectory();\n          KJ_IF_MAYBE(directory, maybeDirectory) {\n            auto reply = allocResponse<struct fuse_open_out>();\n            reply->body.fh = handleCounter++;\n            reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*directory));\n            return kj::mv(reply);\n          } else {\n            KJ_FAIL_REQUIRE(\"not a directory\");\n          }\n        });\n        break;\n      }\n\n      case FUSE_READDIR: {\n        auto request = consumeStruct<struct fuse_read_in>(body);\n\n        auto iter2 = directoryMap.find(request.fh);\n        KJ_REQUIRE(iter2 != directoryMap.end(), \"Kernel requested invalid directory handle?\");\n\n        // Annoyingly, request.size is actually a size, in bytes. How many entries fit into that\n        // size is dependent on the entry names as well as the size of fuse_dirent. It would be\n        // annoying for implementations to have to compute this, so instead we make an estimate\n        // based on the assumption that the average file name is between 8 and 16 characters.  If\n        // file names turn out to be shorter, this may mean we produce a short read, but that\n        // appears to be OK -- the kernel will only assume EOF if the result is completely empty.\n        // If file names turn out to be longer, we may end up truncating the resulting list and\n        // then re-requesting it.  Someday we could implement some sort of streaming here to fix\n        // this, but that will be pretty ugly and it probably doesn't actually matter that much.\n\n        auto requestedSize = request.size;\n        auto requestedOffset = request.offset;\n\n        performReplyTask(header.unique, EIO,\n            [this, requestedSize, requestedOffset, iter2]() -> kj::Own<ResponseBase> {\n          auto entries = iter2->second.cap->read(\n              requestedOffset,\n              requestedSize / (sizeof(struct fuse_dirent) + 16));\n\n          size_t totalBytes = 0;\n          for (auto& entry: entries) {\n            // Carefully check whether we'll go over the requested size if we add this entry.  If\n            // so, break now.\n            size_t next = totalBytes + FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + entry.name.size());\n            if (next > requestedSize) {\n              break;\n            }\n            totalBytes = next;\n          }\n\n          auto bytes = kj::heapArray<kj::byte>(totalBytes);\n          kj::byte* pos = bytes.begin();\n          memset(pos, 0, bytes.size());\n\n          for (auto& entry: entries) {\n            auto& dirent = *reinterpret_cast<struct fuse_dirent*>(pos);\n            auto& name = entry.name;\n\n            dirent.ino = entry.inodeNumber;\n            dirent.off = entry.nextOffset;\n            dirent.namelen = name.size();\n            dirent.type = DT_UNKNOWN;\n            switch (entry.type) {\n              case fuse::Node::Type::UNKNOWN:                                 break;\n              case fuse::Node::Type::BLOCK_DEVICE:     dirent.type = DT_BLK ; break;\n              case fuse::Node::Type::CHARACTER_DEVICE: dirent.type = DT_CHR ; break;\n              case fuse::Node::Type::DIRECTORY:        dirent.type = DT_DIR ; break;\n              case fuse::Node::Type::FIFO:             dirent.type = DT_FIFO; break;\n              case fuse::Node::Type::SYMLINK:          dirent.type = DT_LNK ; break;\n              case fuse::Node::Type::REGULAR:          dirent.type = DT_REG ; break;\n              case fuse::Node::Type::SOCKET:           dirent.type = DT_SOCK; break;\n            }\n\n            memcpy(dirent.name, name.begin(), name.size());\n            pos += FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + name.size());\n\n            // Check if we truncated the list.\n            if (pos == bytes.end()) {\n              break;\n            }\n          }\n\n          KJ_ASSERT(pos == bytes.end());\n\n          auto bytesPtr = bytes.asPtr();  // Don't inline; param construction order is undefined.\n          return allocResponse<void>(kj::mv(bytes), bytesPtr);\n        });\n        break;\n      }\n\n      case FUSE_RELEASEDIR: {\n        // Presumably since directories aren't writable there's no possibility of close() errors.\n        auto request = consumeStruct<struct fuse_release_in>(body);\n        KJ_REQUIRE(directoryMap.erase(request.fh) == 1,\n                   \"Kernel released invalid directory handle?\");\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n      }\n\n      case FUSE_ACCESS: {\n        // If the node exists then F_OK and R_OK are implied. W_OK\n        auto request = consumeStruct<struct fuse_access_in>(body);\n\n        auto mask = request.mask;\n\n        if (request.mask & ~(R_OK | X_OK | F_OK)) {\n          // Some bit other than read/execute is being checked (presumably, W_OK). This is a\n          // read-only filesystem.\n          sendError(header.unique, EROFS);\n        } else if (request.mask != 0) {\n          // Need to check permissions.\n          performReplyTask(header.unique, EACCES,\n              [this, nodeIter, mask]() -> kj::Own<ResponseBase> {\n            auto result = nodeIter->second.node->getAttributes();\n            auto attributes = result.attributes;\n            // TODO(someday):  Account for uid/gid?  Currently irrelevant.\n            if (mask & R_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IROTH);\n            }\n            if (mask & X_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IXOTH);\n            }\n\n            return allocEmptyResponse();\n          });\n        } else {\n          sendReply(header.unique, allocEmptyResponse());\n        }\n\n        break;\n      }\n\n      case FUSE_INTERRUPT: {\n        // We deal with tasks sequentially, so whatever task this call was intended to interrupt\n        // has in fact already completed. Therefore there's nothing for us to do.\n        break;\n      }\n\n      case FUSE_FLUSH:\n        // This seems to be called on close() even for files opened read-only.\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n\n        // TODO(someday): Missing read-only syscalls: statfs, getxaddr, listxaddr, locking,\n        //     readdirplus (we currently set protocol version to pre-readdirplus to avoid it)\n        // TODO(someday): Write calls.\n\n      case FUSE_STATFS:\n      case FUSE_GETXATTR:\n      case FUSE_LISTXATTR:\n      case FUSE_GETLK:\n      case FUSE_SETLK:\n      case FUSE_SETLKW:\n      case CUSE_INIT:\n        sendError(header.unique, ENOSYS);\n\n      default:\n        // All other opcodes involve writes.\n        sendError(header.unique, EROFS);\n        break;\n    }\n\n    return true;\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendError",
          "args": [
            "header.unique",
            "EROFS"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "sendError",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "294-299",
          "snippet": "void sendError(uint64_t requestId, int error) {\n    auto response = kj::heap<ResponseBase>();\n    response->header.error = -error;  // Has to be negative. Just because.\n    response->header.unique = requestId;\n    writeResponse(kj::mv(response));\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void sendError(uint64_t requestId, int error) {\n      auto response = kj::heap<ResponseBase>();\n      response->header.error = -error;  // Has to be negative. Just because.\n      response->header.unique = requestId;\n      writeResponse(kj::mv(response));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendReply",
          "args": [
            "header.unique",
            "allocEmptyResponse()"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "sendReply",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "289-292",
          "snippet": "void sendReply(uint64_t requestId, kj::Own<ResponseBase>&& response) {\n    response->header.unique = requestId;\n    writeResponse(kj::mv(response));\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void sendReply(uint64_t requestId, kj::Own<ResponseBase>&& response) {\n      response->header.unique = requestId;\n      writeResponse(kj::mv(response));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocEmptyResponse",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "allocEmptyResponse",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "251-253",
          "snippet": "kj::Own<ResponseBase> allocEmptyResponse() {\n    return kj::heap<ResponseBase>();\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Own<ResponseBase> allocEmptyResponse() {\n      return kj::heap<ResponseBase>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "performReplyTask",
          "args": [
            "header.unique",
            "EACCES",
            "[this, nodeIter, mask]() -> kj::Own<ResponseBase> {\n            auto result = nodeIter->second.node->getAttributes();\n            auto attributes = result.attributes;\n            // TODO(someday):  Account for uid/gid?  Currently irrelevant.\n            if (mask & R_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IROTH);\n            }\n            if (mask & X_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IXOTH);\n            }\n\n            return allocEmptyResponse();\n          }"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "performReplyTask",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "261-287",
          "snippet": "void performReplyTask(uint64_t requestId, int defaultError, Function&& task) {\n    kj::Maybe<kj::Own<ResponseBase>> maybeResponse;\n    auto exception = kj::runCatchingExceptions(\n        [&maybeResponse, requestId, KJ_MVCAP(task)]() mutable {\n      auto taskResponse = task(); // This is allowed to be an error response.\n      taskResponse->header.unique = requestId;\n      maybeResponse = kj::mv(taskResponse);\n    });\n\n    KJ_IF_MAYBE(e, exception) {\n      auto errorResponse = kj::heap<ResponseBase>();\n      errorResponse->header.error = -defaultError; // TODO(someday): Real error numbers.\n      errorResponse->header.unique = requestId;\n      maybeResponse = kj::mv(errorResponse);\n    }\n\n    KJ_IF_MAYBE (response, maybeResponse) {\n      auto writeException = kj::runCatchingExceptions([KJ_MVCAP(response), this] () {\n        writeResponse(kj::mv(*response));\n      });\n\n      KJ_IF_MAYBE(e, writeException) {\n        // We only get here if the write failed. Abort.\n        abortReadLoop->reject(kj::mv(*e));\n      }\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void performReplyTask(uint64_t requestId, int defaultError, Function&& task) {\n      kj::Maybe<kj::Own<ResponseBase>> maybeResponse;\n      auto exception = kj::runCatchingExceptions(\n          [&maybeResponse, requestId, KJ_MVCAP(task)]() mutable {\n        auto taskResponse = task(); // This is allowed to be an error response.\n        taskResponse->header.unique = requestId;\n        maybeResponse = kj::mv(taskResponse);\n      });\n  \n      KJ_IF_MAYBE(e, exception) {\n        auto errorResponse = kj::heap<ResponseBase>();\n        errorResponse->header.error = -defaultError; // TODO(someday): Real error numbers.\n        errorResponse->header.unique = requestId;\n        maybeResponse = kj::mv(errorResponse);\n      }\n  \n      KJ_IF_MAYBE (response, maybeResponse) {\n        auto writeException = kj::runCatchingExceptions([KJ_MVCAP(response), this] () {\n          writeResponse(kj::mv(*response));\n        });\n  \n        KJ_IF_MAYBE(e, writeException) {\n          // We only get here if the write failed. Abort.\n          abortReadLoop->reject(kj::mv(*e));\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "attributes.permissions & S_IXOTH"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "attributes.permissions & S_IROTH"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeIter->second.node->getAttributes",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "getAttributes",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "989-1022",
          "snippet": "GetAttributesResults getAttributes() override {\n    updateStats();\n\n    auto results = GetAttributesResults { };\n    auto& attrs = results.attributes;\n    attrs.inodeNumber = stats.st_ino;\n\n    switch (stats.st_mode & S_IFMT) {\n      case S_IFBLK:  attrs.type = fuse::Node::Type::BLOCK_DEVICE; break;\n      case S_IFCHR:  attrs.type = fuse::Node::Type::CHARACTER_DEVICE; break;\n      case S_IFDIR:  attrs.type = fuse::Node::Type::DIRECTORY; break;\n      case S_IFIFO:  attrs.type = fuse::Node::Type::FIFO; break;\n      case S_IFLNK:  attrs.type = fuse::Node::Type::SYMLINK; break;\n      case S_IFREG:  attrs.type = fuse::Node::Type::REGULAR; break;\n      case S_IFSOCK: attrs.type = fuse::Node::Type::SOCKET; break;\n      default:       attrs.type = fuse::Node::Type::UNKNOWN; break;\n    }\n\n    attrs.permissions = stats.st_mode & ~S_IFMT;\n    attrs.linkCount = stats.st_nlink;\n    attrs.ownerId = stats.st_uid;\n    attrs.groupId = stats.st_gid;\n    attrs.deviceMajor = major(stats.st_rdev);\n    attrs.deviceMinor = minor(stats.st_rdev);\n    attrs.size = stats.st_size;\n    attrs.blockCount = stats.st_blocks;\n    attrs.blockSize = stats.st_blksize;\n    attrs.lastAccessTime = toNanos(stats.st_atim);\n    attrs.lastModificationTime = toNanos(stats.st_mtim);\n    attrs.lastStatusChangeTime = toNanos(stats.st_ctim);\n    results.ttl = ttl / kj::NANOSECONDS;\n\n    return kj::mv(results);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  GetAttributesResults getAttributes() override {\n      updateStats();\n  \n      auto results = GetAttributesResults { };\n      auto& attrs = results.attributes;\n      attrs.inodeNumber = stats.st_ino;\n  \n      switch (stats.st_mode & S_IFMT) {\n        case S_IFBLK:  attrs.type = fuse::Node::Type::BLOCK_DEVICE; break;\n        case S_IFCHR:  attrs.type = fuse::Node::Type::CHARACTER_DEVICE; break;\n        case S_IFDIR:  attrs.type = fuse::Node::Type::DIRECTORY; break;\n        case S_IFIFO:  attrs.type = fuse::Node::Type::FIFO; break;\n        case S_IFLNK:  attrs.type = fuse::Node::Type::SYMLINK; break;\n        case S_IFREG:  attrs.type = fuse::Node::Type::REGULAR; break;\n        case S_IFSOCK: attrs.type = fuse::Node::Type::SOCKET; break;\n        default:       attrs.type = fuse::Node::Type::UNKNOWN; break;\n      }\n  \n      attrs.permissions = stats.st_mode & ~S_IFMT;\n      attrs.linkCount = stats.st_nlink;\n      attrs.ownerId = stats.st_uid;\n      attrs.groupId = stats.st_gid;\n      attrs.deviceMajor = major(stats.st_rdev);\n      attrs.deviceMinor = minor(stats.st_rdev);\n      attrs.size = stats.st_size;\n      attrs.blockCount = stats.st_blocks;\n      attrs.blockSize = stats.st_blksize;\n      attrs.lastAccessTime = toNanos(stats.st_atim);\n      attrs.lastModificationTime = toNanos(stats.st_mtim);\n      attrs.lastStatusChangeTime = toNanos(stats.st_ctim);\n      results.ttl = ttl / kj::NANOSECONDS;\n  \n      return kj::mv(results);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumeStruct<struct fuse_access_in>",
          "args": [
            "body"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "consumeStruct",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "764-770",
          "snippet": "T consumeStruct(kj::ArrayPtr<const kj::byte>& bytes) {\n    T result;\n    KJ_REQUIRE(bytes.size() >= sizeof(result));\n    memcpy(&result, bytes.begin(), sizeof(result));\n    bytes = bytes.slice(sizeof(result), bytes.size());\n    return result;\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  T consumeStruct(kj::ArrayPtr<const kj::byte>& bytes) {\n      T result;\n      KJ_REQUIRE(bytes.size() >= sizeof(result));\n      memcpy(&result, bytes.begin(), sizeof(result));\n      bytes = bytes.slice(sizeof(result), bytes.size());\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "directoryMap.erase(request.fh) == 1",
            "\"Kernel released invalid directory handle?\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directoryMap.erase",
          "args": [
            "request.fh"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocResponse<void>",
          "args": [
            "kj::mv(bytes)",
            "bytesPtr"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "allocResponse",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "256-258",
          "snippet": "kj::Own<ResponseBase> allocResponse(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content) {\n    return kj::heap<ResponseWithContent<T, ContentOwner>>(kj::mv(owner), content);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Own<ResponseBase> allocResponse(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content) {\n      return kj::heap<ResponseWithContent<T, ContentOwner>>(kj::mv(owner), content);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bytes"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.asPtr",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "pos == bytes.end()"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.end",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.end",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_DIRENT_ALIGN",
          "args": [
            "FUSE_NAME_OFFSET + name.size()"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.size",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dirent.name",
            "name.begin()",
            "name.size()"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.begin",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct fuse_dirent*>",
          "args": [
            "pos"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pos",
            "0",
            "bytes.size()"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::byte>",
          "args": [
            "totalBytes"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_DIRENT_ALIGN",
          "args": [
            "FUSE_NAME_OFFSET + entry.name.size()"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter2->second.cap->read",
          "args": [
            "requestedOffset",
            "requestedSize / (sizeof(struct fuse_dirent) + 16)"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "DirectoryImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "910-956",
          "snippet": "kj::Array<Entry> read(uint64_t offset, uint32_t requestedCount) override {\n    if (offset != currentOffset) {\n      seekdir(dir, offset);\n      currentOffset = offset;\n    }\n\n    KJ_REQUIRE(requestedCount < 8192, \"readdir too large\", requestedCount);\n\n    kj::Vector<struct dirent> entries(requestedCount);\n\n    uint count = 0;\n    for (; count < requestedCount; count++) {\n      struct dirent* ent = readdir(dir);\n      if (ent == nullptr) {\n        // End of directory.\n        break;\n      }\n\n      currentOffset = ent->d_off;\n\n      entries.add(*ent);\n    }\n\n    auto result = kj::heapArray<Entry>(count);\n\n    for (size_t i: kj::indices(entries)) {\n      auto& entry = entries[i];\n\n      result[i].inodeNumber = entry.d_ino;\n      result[i].nextOffset = entry.d_off;\n\n      switch (entry.d_type) {\n        case DT_BLK:  result[i].type = fuse::Node::Type::BLOCK_DEVICE; break;\n        case DT_CHR:  result[i].type = fuse::Node::Type::CHARACTER_DEVICE; break;\n        case DT_DIR:  result[i].type = fuse::Node::Type::DIRECTORY; break;\n        case DT_FIFO: result[i].type = fuse::Node::Type::FIFO; break;\n        case DT_LNK:  result[i].type = fuse::Node::Type::SYMLINK; break;\n        case DT_REG:  result[i].type = fuse::Node::Type::REGULAR; break;\n        case DT_SOCK: result[i].type = fuse::Node::Type::SOCKET; break;\n        default:      result[i].type = fuse::Node::Type::UNKNOWN; break;\n      }\n\n      result[i].name = kj::str(entry.d_name);\n    }\n\n    return kj::mv(result);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nDirectoryImpl {\n  kj::Array<Entry> read(uint64_t offset, uint32_t requestedCount) override {\n      if (offset != currentOffset) {\n        seekdir(dir, offset);\n        currentOffset = offset;\n      }\n  \n      KJ_REQUIRE(requestedCount < 8192, \"readdir too large\", requestedCount);\n  \n      kj::Vector<struct dirent> entries(requestedCount);\n  \n      uint count = 0;\n      for (; count < requestedCount; count++) {\n        struct dirent* ent = readdir(dir);\n        if (ent == nullptr) {\n          // End of directory.\n          break;\n        }\n  \n        currentOffset = ent->d_off;\n  \n        entries.add(*ent);\n      }\n  \n      auto result = kj::heapArray<Entry>(count);\n  \n      for (size_t i: kj::indices(entries)) {\n        auto& entry = entries[i];\n  \n        result[i].inodeNumber = entry.d_ino;\n        result[i].nextOffset = entry.d_off;\n  \n        switch (entry.d_type) {\n          case DT_BLK:  result[i].type = fuse::Node::Type::BLOCK_DEVICE; break;\n          case DT_CHR:  result[i].type = fuse::Node::Type::CHARACTER_DEVICE; break;\n          case DT_DIR:  result[i].type = fuse::Node::Type::DIRECTORY; break;\n          case DT_FIFO: result[i].type = fuse::Node::Type::FIFO; break;\n          case DT_LNK:  result[i].type = fuse::Node::Type::SYMLINK; break;\n          case DT_REG:  result[i].type = fuse::Node::Type::REGULAR; break;\n          case DT_SOCK: result[i].type = fuse::Node::Type::SOCKET; break;\n          default:      result[i].type = fuse::Node::Type::UNKNOWN; break;\n        }\n  \n        result[i].name = kj::str(entry.d_name);\n      }\n  \n      return kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "iter2 != directoryMap.end()",
            "\"Kernel requested invalid directory handle?\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directoryMap.end",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directoryMap.find",
          "args": [
            "request.fh"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"not a directory\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjToInsert",
          "args": [
            "reply->body.fh",
            "kj::mv(*directory)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ObjToInsert",
          "container": "FuseDriver::ObjToInsert",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "153-155",
          "snippet": "ObjToInsert(uint64_t id, kj::Own<fuse::Directory>&& directory): id(id) {\n      obj.init<kj::Own<fuse::Directory>>(kj::mv(directory));\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ObjToInsert {\n    ObjToInsert(uint64_t id, kj::Own<fuse::Directory>&& directory): id(id) {\n          obj.init<kj::Own<fuse::Directory>>(kj::mv(directory));\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*directory"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeIter->second.node->openAsDirectory",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "openAsDirectory",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "1029-1032",
          "snippet": "kj::Maybe<kj::Own<fuse::Directory>> openAsDirectory() override {\n    kj::Own<fuse::Directory> result = kj::refcounted<DirectoryImpl>(path);\n    return kj::mv(result);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<kj::Own<fuse::Directory>> openAsDirectory() override {\n      kj::Own<fuse::Directory> result = kj::refcounted<DirectoryImpl>(path);\n      return kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "fileMap.erase(request.fh) == 1",
            "\"Kernel released invalid file handle?\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileMap.erase",
          "args": [
            "request.fh"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bytes"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.asPtr",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "performReplyTask",
          "args": [
            "header.unique",
            "EIO,\n            [this, KJ_MVCAP(request), iter2]("
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "iter2 != fileMap.end()",
            "\"Kernel requested invalid file handle?\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileMap.end",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileMap.find",
          "args": [
            "request.fh"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"not a file\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*file"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeIter->second.node->openAsFile",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "openAsFile",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "1024-1027",
          "snippet": "kj::Maybe<kj::Own<fuse::File>> openAsFile() override {\n    kj::Own<fuse::File> result =  kj::refcounted<FileImpl>(path);\n    return kj::mv(result);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<kj::Own<fuse::File>> openAsFile() override {\n      kj::Own<fuse::File> result =  kj::refcounted<FileImpl>(path);\n      return kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "link"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<const kj::byte*>(link.begin())",
            "link.size()"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const kj::byte*>",
          "args": [
            "link.begin()"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link.begin",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeIter->second.node->readlink",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "readlink",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "1034-1040",
          "snippet": "kj::String readlink() override {\n    char buffer[PATH_MAX + 1];\n    int n;\n    KJ_SYSCALL(n = ::readlink(path.cStr(), buffer, PATH_MAX));\n    buffer[n] = '\\0';\n    return kj::heapString(buffer);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::String readlink() override {\n      char buffer[PATH_MAX + 1];\n      int n;\n      KJ_SYSCALL(n = ::readlink(path.cStr(), buffer, PATH_MAX));\n      buffer[n] = '\\0';\n      return kj::heapString(buffer);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translateAttrs",
          "args": [
            "response.attributes",
            "&reply->body.attr"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "translateAttrs",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "801-830",
          "snippet": "void translateAttrs(fuse::Node::Attributes& src, struct fuse_attr* dst) {\n    memset(dst, 0, sizeof(*dst));\n\n    dst->ino = src.inodeNumber;\n    dst->size = src.size;\n    dst->blocks = src.blockCount;\n\n    splitTime(src.lastAccessTime, &dst->atime, &dst->atimensec);\n    splitTime(src.lastModificationTime, &dst->mtime, &dst->mtimensec);\n    splitTime(src.lastStatusChangeTime, &dst->ctime, &dst->ctimensec);\n\n    dst->mode = src.permissions;\n\n    switch (src.type) {\n      case fuse::Node::Type::UNKNOWN:                                break;\n      case fuse::Node::Type::BLOCK_DEVICE:     dst->mode |= S_IFBLK; break;\n      case fuse::Node::Type::CHARACTER_DEVICE: dst->mode |= S_IFCHR; break;\n      case fuse::Node::Type::DIRECTORY:        dst->mode |= S_IFDIR; break;\n      case fuse::Node::Type::FIFO:             dst->mode |= S_IFIFO; break;\n      case fuse::Node::Type::SYMLINK:          dst->mode |= S_IFLNK; break;\n      case fuse::Node::Type::REGULAR:          dst->mode |= S_IFREG; break;\n      case fuse::Node::Type::SOCKET:           dst->mode |= S_IFSOCK; break;\n    }\n\n    dst->nlink = src.linkCount;\n    dst->uid = src.ownerId;\n    dst->gid = src.groupId;\n    dst->rdev = makedev(src.deviceMajor, src.deviceMinor);\n    dst->blksize = src.blockSize;\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void translateAttrs(fuse::Node::Attributes& src, struct fuse_attr* dst) {\n      memset(dst, 0, sizeof(*dst));\n  \n      dst->ino = src.inodeNumber;\n      dst->size = src.size;\n      dst->blocks = src.blockCount;\n  \n      splitTime(src.lastAccessTime, &dst->atime, &dst->atimensec);\n      splitTime(src.lastModificationTime, &dst->mtime, &dst->mtimensec);\n      splitTime(src.lastStatusChangeTime, &dst->ctime, &dst->ctimensec);\n  \n      dst->mode = src.permissions;\n  \n      switch (src.type) {\n        case fuse::Node::Type::UNKNOWN:                                break;\n        case fuse::Node::Type::BLOCK_DEVICE:     dst->mode |= S_IFBLK; break;\n        case fuse::Node::Type::CHARACTER_DEVICE: dst->mode |= S_IFCHR; break;\n        case fuse::Node::Type::DIRECTORY:        dst->mode |= S_IFDIR; break;\n        case fuse::Node::Type::FIFO:             dst->mode |= S_IFIFO; break;\n        case fuse::Node::Type::SYMLINK:          dst->mode |= S_IFLNK; break;\n        case fuse::Node::Type::REGULAR:          dst->mode |= S_IFREG; break;\n        case fuse::Node::Type::SOCKET:           dst->mode |= S_IFSOCK; break;\n      }\n  \n      dst->nlink = src.linkCount;\n      dst->uid = src.ownerId;\n      dst->gid = src.groupId;\n      dst->rdev = makedev(src.deviceMajor, src.deviceMinor);\n      dst->blksize = src.blockSize;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "splitTime",
          "args": [
            "response.ttl",
            "&reply->body.attr_valid",
            "&reply->body.attr_valid_nsec"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "splitTime",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "785-799",
          "snippet": "void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n    // The FUSE interface appears to use unsigned values even for absolute times, implying it\n    // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n    // declared the types wrong and the kernel will actually interpret them as signed.\n\n    int32_t signedNsec = time % 1000000000ll;\n    time = time / 1000000000ll;\n    if (signedNsec < 0) {\n      ++time;\n      signedNsec += 1000000000ll;\n    }\n\n    *secs = time;\n    *nsecs = signedNsec;\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void splitTime(int64_t time, uint64_t* secs, uint32_t* nsecs) {\n      // The FUSE interface appears to use unsigned values even for absolute times, implying it\n      // cannot represent times before 1970.  I'm going to go ahead and assume that they just\n      // declared the types wrong and the kernel will actually interpret them as signed.\n  \n      int32_t signedNsec = time % 1000000000ll;\n      time = time / 1000000000ll;\n      if (signedNsec < 0) {\n        ++time;\n        signedNsec += 1000000000ll;\n      }\n  \n      *secs = time;\n      *nsecs = signedNsec;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<ResponseBase>",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "lookupResult->node"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "insertResult.first->second.name.begin() ==\n                        insertResult.first->first.name.begin()"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insertResult.first->first.name.begin",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insertResult.first->second.name.begin",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ownName"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "childMap.insert",
          "args": [
            "std::make_pair(\n                ChildKey { parentId, ownName }, ChildInfo())"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "ChildKey { parentId, ownName }",
            "ChildInfo()"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ChildInfo",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeIter->second.node->lookup",
          "args": [
            "ownName.slice(0)"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "lookup",
          "container": "NodeImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "973-987",
          "snippet": "kj::Maybe<LookupResults> lookup(kj::StringPtr name) override {\n    KJ_REQUIRE(name != \".\" && name != \"..\", \"Please implement . and .. at a higher level.\");\n\n    auto fullPath = kj::str(path, '/', name);\n    struct stat new_stats;\n    auto n = lstat(fullPath.cStr(), &new_stats);\n\n    if (n < 0 && errno == ENOENT) {\n      return nullptr;\n    } else {\n      uint64_t xttl = ttl / kj::NANOSECONDS;\n\n      return LookupResults { kj::refcounted<NodeImpl>(kj::mv(fullPath), ttl), xttl };\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nNodeImpl {\n  kj::Maybe<LookupResults> lookup(kj::StringPtr name) override {\n      KJ_REQUIRE(name != \".\" && name != \"..\", \"Please implement . and .. at a higher level.\");\n  \n      auto fullPath = kj::str(path, '/', name);\n      struct stat new_stats;\n      auto n = lstat(fullPath.cStr(), &new_stats);\n  \n      if (n < 0 && errno == ENOENT) {\n        return nullptr;\n      } else {\n        uint64_t xttl = ttl / kj::NANOSECONDS;\n  \n        return LookupResults { kj::refcounted<NodeImpl>(kj::mv(fullPath), ttl), xttl };\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ownName.slice",
          "args": [
            "0"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consumeString",
          "args": [
            "body"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "consumeString",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "772-778",
          "snippet": "kj::StringPtr consumeString(kj::ArrayPtr<const kj::byte>& bytes) {\n    const char* ptr = reinterpret_cast<const char*>(bytes.begin());\n    size_t len = strnlen(ptr, bytes.size());\n    KJ_REQUIRE(len < bytes.size());\n    bytes = bytes.slice(len + 1, bytes.size());\n    return kj::StringPtr(ptr, len);\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::StringPtr consumeString(kj::ArrayPtr<const kj::byte>& bytes) {\n      const char* ptr = reinterpret_cast<const char*>(bytes.begin());\n      size_t len = strnlen(ptr, bytes.size());\n      KJ_REQUIRE(len < bytes.size());\n      bytes = bytes.slice(len + 1, bytes.size());\n      return kj::StringPtr(ptr, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeMap.erase",
          "args": [
            "iter2"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "iter2 != nodeMap.end()"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.end",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.find",
          "args": [
            "item.nodeid"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.erase",
          "args": [
            "nodeIter"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reply"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "initBody.minor >= 20"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "initBody.major == 7"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "header.nodeid == 0 || nodeIter != nodeMap.end()",
            "\"Kernel asked for unknown node ID.\"",
            "header.nodeid"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.end",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.find",
          "args": [
            "header.nodeid"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  bool dispatch(struct fuse_in_header& header, kj::ArrayPtr<const kj::byte> body) {\n      auto nodeIter = nodeMap.find(header.nodeid);\n      KJ_REQUIRE(header.nodeid == 0 || nodeIter != nodeMap.end(),\n          \"Kernel asked for unknown node ID.\", header.nodeid);\n  \n      switch (header.opcode) {\n        case FUSE_INIT: {\n          auto initBody = consumeStruct<struct fuse_init_in>(body);\n          KJ_REQUIRE(initBody.major == 7);\n          KJ_REQUIRE(initBody.minor >= 20);\n  \n          auto reply = allocResponse<struct fuse_init_out>();\n          reply->body.major = 7;\n          reply->body.minor = 20;\n          reply->body.max_readahead = 65536;\n          reply->body.max_write = 65536;\n  \n  #ifdef FUSE_COMPAT_22_INIT_OUT_SIZE\n          // Compatibility with pre-2.15 kernels.\n          reply->bodySize = FUSE_COMPAT_22_INIT_OUT_SIZE;\n  #endif\n  \n          sendReply(header.unique, kj::mv(reply));\n          break;\n        }\n  \n        case FUSE_DESTROY:\n          return false;\n  \n        case FUSE_FORGET: {\n          auto requestBody = consumeStruct<struct fuse_forget_in>(body);\n          if ((nodeIter->second.refcount -= requestBody.nlookup) == 0) {\n            nodeMap.erase(nodeIter);\n          }\n          break;\n        }\n  \n        case FUSE_BATCH_FORGET: {\n          auto requestBody = consumeStruct<struct fuse_batch_forget_in>(body);\n  \n          for (uint i = 0; i < requestBody.count; i++) {\n            auto item = consumeStruct<struct fuse_forget_one>(body);\n            auto iter2 = nodeMap.find(item.nodeid);\n            KJ_REQUIRE(iter2 != nodeMap.end());\n            if ((iter2->second.refcount -= item.nlookup) == 0) {\n              nodeMap.erase(iter2);\n            }\n          }\n          break;\n        }\n  \n        case FUSE_LOOKUP: {\n          auto name = consumeString(body);\n          auto requestId = header.unique;\n          uint64_t parentId = header.nodeid;\n          kj::String ownName = kj::heapString(name);\n  \n          performReplyTask(requestId, EIO,\n              [this, parentId, nodeIter, KJ_MVCAP(ownName)]() mutable -> kj::Own<ResponseBase> {\n            auto maybeLookupResult = nodeIter->second.node->lookup(ownName.slice(0));\n            KJ_IF_MAYBE(lookupResult, maybeLookupResult) {\n              auto result = lookupResult->node->getAttributes();\n              auto attributes = result.attributes;\n  \n              auto reply = allocResponse<struct fuse_entry_out>();\n  \n              uint64_t inode = attributes.inodeNumber;\n              auto insertResult = childMap.insert(std::make_pair(\n                  ChildKey { parentId, ownName }, ChildInfo()));\n  \n              // Make sure the StringPtr in the key points at the String in the value.\n              if (insertResult.second) {\n                // This is a newly-inserted entry.\n                insertResult.first->second.name = kj::mv(ownName);\n              } else {\n                // Existing entry. Check consistency.\n                KJ_ASSERT(insertResult.first->second.name.begin() ==\n                          insertResult.first->first.name.begin());\n              }\n  \n              if (insertResult.second || insertResult.first->second.inode != inode) {\n                // Either we've never looked up this child before, or the inode number has changed\n                // since we looked it up so we assume it has been replaced by a new node.\n                //\n                // TODO(someday): It would be better to detect when a node has been replaced by\n                //   comparing the capabilities, though this requires \"join\" support (level 4 RPC).\n                reply->body.nodeid = nodeIdCounter++;\n                insertResult.first->second.nodeId = reply->body.nodeid;\n                insertResult.first->second.inode = inode;\n              } else {\n                // This appears to be exactly the same child we returned previously. Use the same\n                // node ID.\n                reply->body.nodeid = insertResult.first->second.nodeId;\n              }\n  \n              reply->body.generation = 0;\n              reply->newObject = ObjToInsert(reply->body.nodeid, kj::mv(lookupResult->node));\n  \n              translateAttrs(attributes, &reply->body.attr);\n              if (options.cacheForever) {\n                reply->body.entry_valid = 365 * kj::DAYS / kj::SECONDS;\n                reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n              } else {\n                splitTime(lookupResult->ttl,\n                    &reply->body.entry_valid, &reply->body.entry_valid_nsec);\n                splitTime(result.ttl,\n                    &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n              }\n              return kj::mv(reply);\n            } else {\n              auto reply = kj::heap<ResponseBase>();\n              reply->header.error = -ENOENT;  // Has to be negative. Just because.\n              return kj::mv(reply);\n            }\n          });\n          break;\n        }\n  \n        case FUSE_GETATTR: {\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto response = nodeIter->second.node->getAttributes();\n  \n            auto reply = allocResponse<struct fuse_attr_out>();\n            if (options.cacheForever) {\n              reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n            } else {\n              splitTime(response.ttl, &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n            }\n            translateAttrs(response.attributes, &reply->body.attr);\n            return kj::mv(reply);\n          });\n          break;\n        }\n  \n        case FUSE_READLINK:\n          // No input.\n          performReplyTask(header.unique, EINVAL, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto link = nodeIter->second.node->readlink();\n            auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(link.begin()), link.size());\n            return allocResponse<void>(kj::mv(link), bytes);\n          });\n          break;\n  \n        case FUSE_OPEN: {\n          auto request = consumeStruct<struct fuse_open_in>(body);\n  \n          if ((request.flags & O_ACCMODE) != O_RDONLY) {\n            sendError(header.unique, EROFS);\n            break;\n          }\n  \n          // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n          //   perhaps we ought to assume this should always succeed and thus pipeline it?\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto response = nodeIter->second.node->openAsFile();\n            KJ_IF_MAYBE(file, response) {\n              auto reply = allocResponse<struct fuse_open_out>();\n              reply->body.fh = handleCounter++;\n              reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*file));\n  \n              // TODO(someday):  Fill in open_flags, especially \"nonseekable\"?  See FOPEN_* in fuse.h.\n              if (options.cacheForever) reply->body.open_flags |= FOPEN_KEEP_CACHE;\n              return kj::mv(reply);\n            } else {\n              KJ_FAIL_REQUIRE(\"not a file\");\n            }\n          });\n          break;\n        }\n  \n        case FUSE_READ: {\n          auto request = consumeStruct<struct fuse_read_in>(body);\n  \n          auto iter2 = fileMap.find(request.fh);\n          KJ_REQUIRE(iter2 != fileMap.end(), \"Kernel requested invalid file handle?\");\n  \n          performReplyTask(header.unique, EIO,\n              [this, KJ_MVCAP(request), iter2]() -> kj::Own<ResponseBase> {\n            auto bytes = iter2->second.cap->read(request.offset, request.size);\n            kj::ArrayPtr<kj::byte> slice = bytes.asPtr();\n            return allocResponse<void>(kj::mv(bytes), slice);\n          });\n          break;\n        }\n  \n        case FUSE_RELEASE: {\n          // TODO(someday): When we support writes, we'll need to flush them here and possibly return\n          //   an error.\n          auto request = consumeStruct<struct fuse_release_in>(body);\n          KJ_REQUIRE(fileMap.erase(request.fh) == 1, \"Kernel released invalid file handle?\");\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n        }\n  \n        case FUSE_OPENDIR: {\n          auto request = consumeStruct<struct fuse_open_in>(body);\n  \n          if ((request.flags & O_ACCMODE) != O_RDONLY) {\n            sendError(header.unique, EROFS);\n            break;\n          }\n  \n          // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n          //   perhaps we ought to assume this should always succeed and thus pipeline it?\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto maybeDirectory = nodeIter->second.node->openAsDirectory();\n            KJ_IF_MAYBE(directory, maybeDirectory) {\n              auto reply = allocResponse<struct fuse_open_out>();\n              reply->body.fh = handleCounter++;\n              reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*directory));\n              return kj::mv(reply);\n            } else {\n              KJ_FAIL_REQUIRE(\"not a directory\");\n            }\n          });\n          break;\n        }\n  \n        case FUSE_READDIR: {\n          auto request = consumeStruct<struct fuse_read_in>(body);\n  \n          auto iter2 = directoryMap.find(request.fh);\n          KJ_REQUIRE(iter2 != directoryMap.end(), \"Kernel requested invalid directory handle?\");\n  \n          // Annoyingly, request.size is actually a size, in bytes. How many entries fit into that\n          // size is dependent on the entry names as well as the size of fuse_dirent. It would be\n          // annoying for implementations to have to compute this, so instead we make an estimate\n          // based on the assumption that the average file name is between 8 and 16 characters.  If\n          // file names turn out to be shorter, this may mean we produce a short read, but that\n          // appears to be OK -- the kernel will only assume EOF if the result is completely empty.\n          // If file names turn out to be longer, we may end up truncating the resulting list and\n          // then re-requesting it.  Someday we could implement some sort of streaming here to fix\n          // this, but that will be pretty ugly and it probably doesn't actually matter that much.\n  \n          auto requestedSize = request.size;\n          auto requestedOffset = request.offset;\n  \n          performReplyTask(header.unique, EIO,\n              [this, requestedSize, requestedOffset, iter2]() -> kj::Own<ResponseBase> {\n            auto entries = iter2->second.cap->read(\n                requestedOffset,\n                requestedSize / (sizeof(struct fuse_dirent) + 16));\n  \n            size_t totalBytes = 0;\n            for (auto& entry: entries) {\n              // Carefully check whether we'll go over the requested size if we add this entry.  If\n              // so, break now.\n              size_t next = totalBytes + FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + entry.name.size());\n              if (next > requestedSize) {\n                break;\n              }\n              totalBytes = next;\n            }\n  \n            auto bytes = kj::heapArray<kj::byte>(totalBytes);\n            kj::byte* pos = bytes.begin();\n            memset(pos, 0, bytes.size());\n  \n            for (auto& entry: entries) {\n              auto& dirent = *reinterpret_cast<struct fuse_dirent*>(pos);\n              auto& name = entry.name;\n  \n              dirent.ino = entry.inodeNumber;\n              dirent.off = entry.nextOffset;\n              dirent.namelen = name.size();\n              dirent.type = DT_UNKNOWN;\n              switch (entry.type) {\n                case fuse::Node::Type::UNKNOWN:                                 break;\n                case fuse::Node::Type::BLOCK_DEVICE:     dirent.type = DT_BLK ; break;\n                case fuse::Node::Type::CHARACTER_DEVICE: dirent.type = DT_CHR ; break;\n                case fuse::Node::Type::DIRECTORY:        dirent.type = DT_DIR ; break;\n                case fuse::Node::Type::FIFO:             dirent.type = DT_FIFO; break;\n                case fuse::Node::Type::SYMLINK:          dirent.type = DT_LNK ; break;\n                case fuse::Node::Type::REGULAR:          dirent.type = DT_REG ; break;\n                case fuse::Node::Type::SOCKET:           dirent.type = DT_SOCK; break;\n              }\n  \n              memcpy(dirent.name, name.begin(), name.size());\n              pos += FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + name.size());\n  \n              // Check if we truncated the list.\n              if (pos == bytes.end()) {\n                break;\n              }\n            }\n  \n            KJ_ASSERT(pos == bytes.end());\n  \n            auto bytesPtr = bytes.asPtr();  // Don't inline; param construction order is undefined.\n            return allocResponse<void>(kj::mv(bytes), bytesPtr);\n          });\n          break;\n        }\n  \n        case FUSE_RELEASEDIR: {\n          // Presumably since directories aren't writable there's no possibility of close() errors.\n          auto request = consumeStruct<struct fuse_release_in>(body);\n          KJ_REQUIRE(directoryMap.erase(request.fh) == 1,\n                     \"Kernel released invalid directory handle?\");\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n        }\n  \n        case FUSE_ACCESS: {\n          // If the node exists then F_OK and R_OK are implied. W_OK\n          auto request = consumeStruct<struct fuse_access_in>(body);\n  \n          auto mask = request.mask;\n  \n          if (request.mask & ~(R_OK | X_OK | F_OK)) {\n            // Some bit other than read/execute is being checked (presumably, W_OK). This is a\n            // read-only filesystem.\n            sendError(header.unique, EROFS);\n          } else if (request.mask != 0) {\n            // Need to check permissions.\n            performReplyTask(header.unique, EACCES,\n                [this, nodeIter, mask]() -> kj::Own<ResponseBase> {\n              auto result = nodeIter->second.node->getAttributes();\n              auto attributes = result.attributes;\n              // TODO(someday):  Account for uid/gid?  Currently irrelevant.\n              if (mask & R_OK) {\n                KJ_REQUIRE(attributes.permissions & S_IROTH);\n              }\n              if (mask & X_OK) {\n                KJ_REQUIRE(attributes.permissions & S_IXOTH);\n              }\n  \n              return allocEmptyResponse();\n            });\n          } else {\n            sendReply(header.unique, allocEmptyResponse());\n          }\n  \n          break;\n        }\n  \n        case FUSE_INTERRUPT: {\n          // We deal with tasks sequentially, so whatever task this call was intended to interrupt\n          // has in fact already completed. Therefore there's nothing for us to do.\n          break;\n        }\n  \n        case FUSE_FLUSH:\n          // This seems to be called on close() even for files opened read-only.\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n  \n          // TODO(someday): Missing read-only syscalls: statfs, getxaddr, listxaddr, locking,\n          //     readdirplus (we currently set protocol version to pre-readdirplus to avoid it)\n          // TODO(someday): Write calls.\n  \n        case FUSE_STATFS:\n        case FUSE_GETXATTR:\n        case FUSE_LISTXATTR:\n        case FUSE_GETLK:\n        case FUSE_SETLK:\n        case FUSE_SETLKW:\n        case CUSE_INIT:\n          sendError(header.unique, ENOSYS);\n  \n        default:\n          // All other opcodes involve writes.\n          sendError(header.unique, EROFS);\n          break;\n      }\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "readLoop",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "347-389",
    "snippet": "kj::Promise<void> readLoop() {\n    for (;;) {\n      ssize_t bytesRead = read(fuseFd, buffer, sizeof(buffer));\n\n      if (bytesRead < 0) {\n        int error = errno;\n        switch (errno) {\n          case EINTR:\n            continue;\n          case ENOENT:\n            // libfuse simply retries on ENOENT. Comment says that ENOENT means \"the operation\n            // was interrupted\", but I can't tell what that's supposed to mean. It makes sense\n            // for write() but what operation is being interrupted on read()? Well, anyway, we do\n            // what libfuse does and retry in this case.\n            continue;\n          case EAGAIN:\n            // No data to read.  Try again later.\n            return observer.whenBecomesReadable().then([this]() { return readLoop(); });\n          case ENODEV:\n            // Unmounted.\n            return kj::READY_NOW;\n          default:\n            KJ_FAIL_SYSCALL(\"read(/dev/fuse)\", error);\n        }\n        KJ_UNREACHABLE;\n      }\n\n      // OK, we got some bytes.\n      auto bufferPtr = kj::arrayPtr(buffer, bytesRead);\n\n      while (bufferPtr.size() > 0) {\n        struct fuse_in_header header;\n        KJ_ASSERT(bufferPtr.size() >= sizeof(header), \"Incomplete FUSE header from kernel?\");\n        memcpy(&header, bufferPtr.begin(), sizeof(header));\n        KJ_ASSERT(bufferPtr.size() >= header.len, \"Incomplete FUSE message from kernel?\");\n        if (!dispatch(header, bufferPtr.slice(sizeof(header), header.len))) {\n          // Got FUSE_DESTROY.\n          return kj::READY_NOW;\n        }\n        bufferPtr = bufferPtr.slice(header.len, bufferPtr.size());\n      }\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bufferPtr.slice",
          "args": [
            "header.len",
            "bufferPtr.size()"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufferPtr.size",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispatch",
          "args": [
            "header",
            "bufferPtr.slice(sizeof(header), header.len)"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "dispatch",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "391-758",
          "snippet": "bool dispatch(struct fuse_in_header& header, kj::ArrayPtr<const kj::byte> body) {\n    auto nodeIter = nodeMap.find(header.nodeid);\n    KJ_REQUIRE(header.nodeid == 0 || nodeIter != nodeMap.end(),\n        \"Kernel asked for unknown node ID.\", header.nodeid);\n\n    switch (header.opcode) {\n      case FUSE_INIT: {\n        auto initBody = consumeStruct<struct fuse_init_in>(body);\n        KJ_REQUIRE(initBody.major == 7);\n        KJ_REQUIRE(initBody.minor >= 20);\n\n        auto reply = allocResponse<struct fuse_init_out>();\n        reply->body.major = 7;\n        reply->body.minor = 20;\n        reply->body.max_readahead = 65536;\n        reply->body.max_write = 65536;\n\n#ifdef FUSE_COMPAT_22_INIT_OUT_SIZE\n        // Compatibility with pre-2.15 kernels.\n        reply->bodySize = FUSE_COMPAT_22_INIT_OUT_SIZE;\n#endif\n\n        sendReply(header.unique, kj::mv(reply));\n        break;\n      }\n\n      case FUSE_DESTROY:\n        return false;\n\n      case FUSE_FORGET: {\n        auto requestBody = consumeStruct<struct fuse_forget_in>(body);\n        if ((nodeIter->second.refcount -= requestBody.nlookup) == 0) {\n          nodeMap.erase(nodeIter);\n        }\n        break;\n      }\n\n      case FUSE_BATCH_FORGET: {\n        auto requestBody = consumeStruct<struct fuse_batch_forget_in>(body);\n\n        for (uint i = 0; i < requestBody.count; i++) {\n          auto item = consumeStruct<struct fuse_forget_one>(body);\n          auto iter2 = nodeMap.find(item.nodeid);\n          KJ_REQUIRE(iter2 != nodeMap.end());\n          if ((iter2->second.refcount -= item.nlookup) == 0) {\n            nodeMap.erase(iter2);\n          }\n        }\n        break;\n      }\n\n      case FUSE_LOOKUP: {\n        auto name = consumeString(body);\n        auto requestId = header.unique;\n        uint64_t parentId = header.nodeid;\n        kj::String ownName = kj::heapString(name);\n\n        performReplyTask(requestId, EIO,\n            [this, parentId, nodeIter, KJ_MVCAP(ownName)]() mutable -> kj::Own<ResponseBase> {\n          auto maybeLookupResult = nodeIter->second.node->lookup(ownName.slice(0));\n          KJ_IF_MAYBE(lookupResult, maybeLookupResult) {\n            auto result = lookupResult->node->getAttributes();\n            auto attributes = result.attributes;\n\n            auto reply = allocResponse<struct fuse_entry_out>();\n\n            uint64_t inode = attributes.inodeNumber;\n            auto insertResult = childMap.insert(std::make_pair(\n                ChildKey { parentId, ownName }, ChildInfo()));\n\n            // Make sure the StringPtr in the key points at the String in the value.\n            if (insertResult.second) {\n              // This is a newly-inserted entry.\n              insertResult.first->second.name = kj::mv(ownName);\n            } else {\n              // Existing entry. Check consistency.\n              KJ_ASSERT(insertResult.first->second.name.begin() ==\n                        insertResult.first->first.name.begin());\n            }\n\n            if (insertResult.second || insertResult.first->second.inode != inode) {\n              // Either we've never looked up this child before, or the inode number has changed\n              // since we looked it up so we assume it has been replaced by a new node.\n              //\n              // TODO(someday): It would be better to detect when a node has been replaced by\n              //   comparing the capabilities, though this requires \"join\" support (level 4 RPC).\n              reply->body.nodeid = nodeIdCounter++;\n              insertResult.first->second.nodeId = reply->body.nodeid;\n              insertResult.first->second.inode = inode;\n            } else {\n              // This appears to be exactly the same child we returned previously. Use the same\n              // node ID.\n              reply->body.nodeid = insertResult.first->second.nodeId;\n            }\n\n            reply->body.generation = 0;\n            reply->newObject = ObjToInsert(reply->body.nodeid, kj::mv(lookupResult->node));\n\n            translateAttrs(attributes, &reply->body.attr);\n            if (options.cacheForever) {\n              reply->body.entry_valid = 365 * kj::DAYS / kj::SECONDS;\n              reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n            } else {\n              splitTime(lookupResult->ttl,\n                  &reply->body.entry_valid, &reply->body.entry_valid_nsec);\n              splitTime(result.ttl,\n                  &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n            }\n            return kj::mv(reply);\n          } else {\n            auto reply = kj::heap<ResponseBase>();\n            reply->header.error = -ENOENT;  // Has to be negative. Just because.\n            return kj::mv(reply);\n          }\n        });\n        break;\n      }\n\n      case FUSE_GETATTR: {\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto response = nodeIter->second.node->getAttributes();\n\n          auto reply = allocResponse<struct fuse_attr_out>();\n          if (options.cacheForever) {\n            reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n          } else {\n            splitTime(response.ttl, &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n          }\n          translateAttrs(response.attributes, &reply->body.attr);\n          return kj::mv(reply);\n        });\n        break;\n      }\n\n      case FUSE_READLINK:\n        // No input.\n        performReplyTask(header.unique, EINVAL, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto link = nodeIter->second.node->readlink();\n          auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(link.begin()), link.size());\n          return allocResponse<void>(kj::mv(link), bytes);\n        });\n        break;\n\n      case FUSE_OPEN: {\n        auto request = consumeStruct<struct fuse_open_in>(body);\n\n        if ((request.flags & O_ACCMODE) != O_RDONLY) {\n          sendError(header.unique, EROFS);\n          break;\n        }\n\n        // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n        //   perhaps we ought to assume this should always succeed and thus pipeline it?\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto response = nodeIter->second.node->openAsFile();\n          KJ_IF_MAYBE(file, response) {\n            auto reply = allocResponse<struct fuse_open_out>();\n            reply->body.fh = handleCounter++;\n            reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*file));\n\n            // TODO(someday):  Fill in open_flags, especially \"nonseekable\"?  See FOPEN_* in fuse.h.\n            if (options.cacheForever) reply->body.open_flags |= FOPEN_KEEP_CACHE;\n            return kj::mv(reply);\n          } else {\n            KJ_FAIL_REQUIRE(\"not a file\");\n          }\n        });\n        break;\n      }\n\n      case FUSE_READ: {\n        auto request = consumeStruct<struct fuse_read_in>(body);\n\n        auto iter2 = fileMap.find(request.fh);\n        KJ_REQUIRE(iter2 != fileMap.end(), \"Kernel requested invalid file handle?\");\n\n        performReplyTask(header.unique, EIO,\n            [this, KJ_MVCAP(request), iter2]() -> kj::Own<ResponseBase> {\n          auto bytes = iter2->second.cap->read(request.offset, request.size);\n          kj::ArrayPtr<kj::byte> slice = bytes.asPtr();\n          return allocResponse<void>(kj::mv(bytes), slice);\n        });\n        break;\n      }\n\n      case FUSE_RELEASE: {\n        // TODO(someday): When we support writes, we'll need to flush them here and possibly return\n        //   an error.\n        auto request = consumeStruct<struct fuse_release_in>(body);\n        KJ_REQUIRE(fileMap.erase(request.fh) == 1, \"Kernel released invalid file handle?\");\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n      }\n\n      case FUSE_OPENDIR: {\n        auto request = consumeStruct<struct fuse_open_in>(body);\n\n        if ((request.flags & O_ACCMODE) != O_RDONLY) {\n          sendError(header.unique, EROFS);\n          break;\n        }\n\n        // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n        //   perhaps we ought to assume this should always succeed and thus pipeline it?\n        performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n          auto maybeDirectory = nodeIter->second.node->openAsDirectory();\n          KJ_IF_MAYBE(directory, maybeDirectory) {\n            auto reply = allocResponse<struct fuse_open_out>();\n            reply->body.fh = handleCounter++;\n            reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*directory));\n            return kj::mv(reply);\n          } else {\n            KJ_FAIL_REQUIRE(\"not a directory\");\n          }\n        });\n        break;\n      }\n\n      case FUSE_READDIR: {\n        auto request = consumeStruct<struct fuse_read_in>(body);\n\n        auto iter2 = directoryMap.find(request.fh);\n        KJ_REQUIRE(iter2 != directoryMap.end(), \"Kernel requested invalid directory handle?\");\n\n        // Annoyingly, request.size is actually a size, in bytes. How many entries fit into that\n        // size is dependent on the entry names as well as the size of fuse_dirent. It would be\n        // annoying for implementations to have to compute this, so instead we make an estimate\n        // based on the assumption that the average file name is between 8 and 16 characters.  If\n        // file names turn out to be shorter, this may mean we produce a short read, but that\n        // appears to be OK -- the kernel will only assume EOF if the result is completely empty.\n        // If file names turn out to be longer, we may end up truncating the resulting list and\n        // then re-requesting it.  Someday we could implement some sort of streaming here to fix\n        // this, but that will be pretty ugly and it probably doesn't actually matter that much.\n\n        auto requestedSize = request.size;\n        auto requestedOffset = request.offset;\n\n        performReplyTask(header.unique, EIO,\n            [this, requestedSize, requestedOffset, iter2]() -> kj::Own<ResponseBase> {\n          auto entries = iter2->second.cap->read(\n              requestedOffset,\n              requestedSize / (sizeof(struct fuse_dirent) + 16));\n\n          size_t totalBytes = 0;\n          for (auto& entry: entries) {\n            // Carefully check whether we'll go over the requested size if we add this entry.  If\n            // so, break now.\n            size_t next = totalBytes + FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + entry.name.size());\n            if (next > requestedSize) {\n              break;\n            }\n            totalBytes = next;\n          }\n\n          auto bytes = kj::heapArray<kj::byte>(totalBytes);\n          kj::byte* pos = bytes.begin();\n          memset(pos, 0, bytes.size());\n\n          for (auto& entry: entries) {\n            auto& dirent = *reinterpret_cast<struct fuse_dirent*>(pos);\n            auto& name = entry.name;\n\n            dirent.ino = entry.inodeNumber;\n            dirent.off = entry.nextOffset;\n            dirent.namelen = name.size();\n            dirent.type = DT_UNKNOWN;\n            switch (entry.type) {\n              case fuse::Node::Type::UNKNOWN:                                 break;\n              case fuse::Node::Type::BLOCK_DEVICE:     dirent.type = DT_BLK ; break;\n              case fuse::Node::Type::CHARACTER_DEVICE: dirent.type = DT_CHR ; break;\n              case fuse::Node::Type::DIRECTORY:        dirent.type = DT_DIR ; break;\n              case fuse::Node::Type::FIFO:             dirent.type = DT_FIFO; break;\n              case fuse::Node::Type::SYMLINK:          dirent.type = DT_LNK ; break;\n              case fuse::Node::Type::REGULAR:          dirent.type = DT_REG ; break;\n              case fuse::Node::Type::SOCKET:           dirent.type = DT_SOCK; break;\n            }\n\n            memcpy(dirent.name, name.begin(), name.size());\n            pos += FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + name.size());\n\n            // Check if we truncated the list.\n            if (pos == bytes.end()) {\n              break;\n            }\n          }\n\n          KJ_ASSERT(pos == bytes.end());\n\n          auto bytesPtr = bytes.asPtr();  // Don't inline; param construction order is undefined.\n          return allocResponse<void>(kj::mv(bytes), bytesPtr);\n        });\n        break;\n      }\n\n      case FUSE_RELEASEDIR: {\n        // Presumably since directories aren't writable there's no possibility of close() errors.\n        auto request = consumeStruct<struct fuse_release_in>(body);\n        KJ_REQUIRE(directoryMap.erase(request.fh) == 1,\n                   \"Kernel released invalid directory handle?\");\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n      }\n\n      case FUSE_ACCESS: {\n        // If the node exists then F_OK and R_OK are implied. W_OK\n        auto request = consumeStruct<struct fuse_access_in>(body);\n\n        auto mask = request.mask;\n\n        if (request.mask & ~(R_OK | X_OK | F_OK)) {\n          // Some bit other than read/execute is being checked (presumably, W_OK). This is a\n          // read-only filesystem.\n          sendError(header.unique, EROFS);\n        } else if (request.mask != 0) {\n          // Need to check permissions.\n          performReplyTask(header.unique, EACCES,\n              [this, nodeIter, mask]() -> kj::Own<ResponseBase> {\n            auto result = nodeIter->second.node->getAttributes();\n            auto attributes = result.attributes;\n            // TODO(someday):  Account for uid/gid?  Currently irrelevant.\n            if (mask & R_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IROTH);\n            }\n            if (mask & X_OK) {\n              KJ_REQUIRE(attributes.permissions & S_IXOTH);\n            }\n\n            return allocEmptyResponse();\n          });\n        } else {\n          sendReply(header.unique, allocEmptyResponse());\n        }\n\n        break;\n      }\n\n      case FUSE_INTERRUPT: {\n        // We deal with tasks sequentially, so whatever task this call was intended to interrupt\n        // has in fact already completed. Therefore there's nothing for us to do.\n        break;\n      }\n\n      case FUSE_FLUSH:\n        // This seems to be called on close() even for files opened read-only.\n        sendReply(header.unique, allocEmptyResponse());\n        break;\n\n        // TODO(someday): Missing read-only syscalls: statfs, getxaddr, listxaddr, locking,\n        //     readdirplus (we currently set protocol version to pre-readdirplus to avoid it)\n        // TODO(someday): Write calls.\n\n      case FUSE_STATFS:\n      case FUSE_GETXATTR:\n      case FUSE_LISTXATTR:\n      case FUSE_GETLK:\n      case FUSE_SETLK:\n      case FUSE_SETLKW:\n      case CUSE_INIT:\n        sendError(header.unique, ENOSYS);\n\n      default:\n        // All other opcodes involve writes.\n        sendError(header.unique, EROFS);\n        break;\n    }\n\n    return true;\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  bool dispatch(struct fuse_in_header& header, kj::ArrayPtr<const kj::byte> body) {\n      auto nodeIter = nodeMap.find(header.nodeid);\n      KJ_REQUIRE(header.nodeid == 0 || nodeIter != nodeMap.end(),\n          \"Kernel asked for unknown node ID.\", header.nodeid);\n  \n      switch (header.opcode) {\n        case FUSE_INIT: {\n          auto initBody = consumeStruct<struct fuse_init_in>(body);\n          KJ_REQUIRE(initBody.major == 7);\n          KJ_REQUIRE(initBody.minor >= 20);\n  \n          auto reply = allocResponse<struct fuse_init_out>();\n          reply->body.major = 7;\n          reply->body.minor = 20;\n          reply->body.max_readahead = 65536;\n          reply->body.max_write = 65536;\n  \n  #ifdef FUSE_COMPAT_22_INIT_OUT_SIZE\n          // Compatibility with pre-2.15 kernels.\n          reply->bodySize = FUSE_COMPAT_22_INIT_OUT_SIZE;\n  #endif\n  \n          sendReply(header.unique, kj::mv(reply));\n          break;\n        }\n  \n        case FUSE_DESTROY:\n          return false;\n  \n        case FUSE_FORGET: {\n          auto requestBody = consumeStruct<struct fuse_forget_in>(body);\n          if ((nodeIter->second.refcount -= requestBody.nlookup) == 0) {\n            nodeMap.erase(nodeIter);\n          }\n          break;\n        }\n  \n        case FUSE_BATCH_FORGET: {\n          auto requestBody = consumeStruct<struct fuse_batch_forget_in>(body);\n  \n          for (uint i = 0; i < requestBody.count; i++) {\n            auto item = consumeStruct<struct fuse_forget_one>(body);\n            auto iter2 = nodeMap.find(item.nodeid);\n            KJ_REQUIRE(iter2 != nodeMap.end());\n            if ((iter2->second.refcount -= item.nlookup) == 0) {\n              nodeMap.erase(iter2);\n            }\n          }\n          break;\n        }\n  \n        case FUSE_LOOKUP: {\n          auto name = consumeString(body);\n          auto requestId = header.unique;\n          uint64_t parentId = header.nodeid;\n          kj::String ownName = kj::heapString(name);\n  \n          performReplyTask(requestId, EIO,\n              [this, parentId, nodeIter, KJ_MVCAP(ownName)]() mutable -> kj::Own<ResponseBase> {\n            auto maybeLookupResult = nodeIter->second.node->lookup(ownName.slice(0));\n            KJ_IF_MAYBE(lookupResult, maybeLookupResult) {\n              auto result = lookupResult->node->getAttributes();\n              auto attributes = result.attributes;\n  \n              auto reply = allocResponse<struct fuse_entry_out>();\n  \n              uint64_t inode = attributes.inodeNumber;\n              auto insertResult = childMap.insert(std::make_pair(\n                  ChildKey { parentId, ownName }, ChildInfo()));\n  \n              // Make sure the StringPtr in the key points at the String in the value.\n              if (insertResult.second) {\n                // This is a newly-inserted entry.\n                insertResult.first->second.name = kj::mv(ownName);\n              } else {\n                // Existing entry. Check consistency.\n                KJ_ASSERT(insertResult.first->second.name.begin() ==\n                          insertResult.first->first.name.begin());\n              }\n  \n              if (insertResult.second || insertResult.first->second.inode != inode) {\n                // Either we've never looked up this child before, or the inode number has changed\n                // since we looked it up so we assume it has been replaced by a new node.\n                //\n                // TODO(someday): It would be better to detect when a node has been replaced by\n                //   comparing the capabilities, though this requires \"join\" support (level 4 RPC).\n                reply->body.nodeid = nodeIdCounter++;\n                insertResult.first->second.nodeId = reply->body.nodeid;\n                insertResult.first->second.inode = inode;\n              } else {\n                // This appears to be exactly the same child we returned previously. Use the same\n                // node ID.\n                reply->body.nodeid = insertResult.first->second.nodeId;\n              }\n  \n              reply->body.generation = 0;\n              reply->newObject = ObjToInsert(reply->body.nodeid, kj::mv(lookupResult->node));\n  \n              translateAttrs(attributes, &reply->body.attr);\n              if (options.cacheForever) {\n                reply->body.entry_valid = 365 * kj::DAYS / kj::SECONDS;\n                reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n              } else {\n                splitTime(lookupResult->ttl,\n                    &reply->body.entry_valid, &reply->body.entry_valid_nsec);\n                splitTime(result.ttl,\n                    &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n              }\n              return kj::mv(reply);\n            } else {\n              auto reply = kj::heap<ResponseBase>();\n              reply->header.error = -ENOENT;  // Has to be negative. Just because.\n              return kj::mv(reply);\n            }\n          });\n          break;\n        }\n  \n        case FUSE_GETATTR: {\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto response = nodeIter->second.node->getAttributes();\n  \n            auto reply = allocResponse<struct fuse_attr_out>();\n            if (options.cacheForever) {\n              reply->body.attr_valid = 365 * kj::DAYS / kj::SECONDS;\n            } else {\n              splitTime(response.ttl, &reply->body.attr_valid, &reply->body.attr_valid_nsec);\n            }\n            translateAttrs(response.attributes, &reply->body.attr);\n            return kj::mv(reply);\n          });\n          break;\n        }\n  \n        case FUSE_READLINK:\n          // No input.\n          performReplyTask(header.unique, EINVAL, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto link = nodeIter->second.node->readlink();\n            auto bytes = kj::arrayPtr(reinterpret_cast<const kj::byte*>(link.begin()), link.size());\n            return allocResponse<void>(kj::mv(link), bytes);\n          });\n          break;\n  \n        case FUSE_OPEN: {\n          auto request = consumeStruct<struct fuse_open_in>(body);\n  \n          if ((request.flags & O_ACCMODE) != O_RDONLY) {\n            sendError(header.unique, EROFS);\n            break;\n          }\n  \n          // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n          //   perhaps we ought to assume this should always succeed and thus pipeline it?\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto response = nodeIter->second.node->openAsFile();\n            KJ_IF_MAYBE(file, response) {\n              auto reply = allocResponse<struct fuse_open_out>();\n              reply->body.fh = handleCounter++;\n              reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*file));\n  \n              // TODO(someday):  Fill in open_flags, especially \"nonseekable\"?  See FOPEN_* in fuse.h.\n              if (options.cacheForever) reply->body.open_flags |= FOPEN_KEEP_CACHE;\n              return kj::mv(reply);\n            } else {\n              KJ_FAIL_REQUIRE(\"not a file\");\n            }\n          });\n          break;\n        }\n  \n        case FUSE_READ: {\n          auto request = consumeStruct<struct fuse_read_in>(body);\n  \n          auto iter2 = fileMap.find(request.fh);\n          KJ_REQUIRE(iter2 != fileMap.end(), \"Kernel requested invalid file handle?\");\n  \n          performReplyTask(header.unique, EIO,\n              [this, KJ_MVCAP(request), iter2]() -> kj::Own<ResponseBase> {\n            auto bytes = iter2->second.cap->read(request.offset, request.size);\n            kj::ArrayPtr<kj::byte> slice = bytes.asPtr();\n            return allocResponse<void>(kj::mv(bytes), slice);\n          });\n          break;\n        }\n  \n        case FUSE_RELEASE: {\n          // TODO(someday): When we support writes, we'll need to flush them here and possibly return\n          //   an error.\n          auto request = consumeStruct<struct fuse_release_in>(body);\n          KJ_REQUIRE(fileMap.erase(request.fh) == 1, \"Kernel released invalid file handle?\");\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n        }\n  \n        case FUSE_OPENDIR: {\n          auto request = consumeStruct<struct fuse_open_in>(body);\n  \n          if ((request.flags & O_ACCMODE) != O_RDONLY) {\n            sendError(header.unique, EROFS);\n            break;\n          }\n  \n          // TODO(perf): Can we assume the kernel will check permissions before open()? If so,\n          //   perhaps we ought to assume this should always succeed and thus pipeline it?\n          performReplyTask(header.unique, EIO, [this, nodeIter]() -> kj::Own<ResponseBase> {\n            auto maybeDirectory = nodeIter->second.node->openAsDirectory();\n            KJ_IF_MAYBE(directory, maybeDirectory) {\n              auto reply = allocResponse<struct fuse_open_out>();\n              reply->body.fh = handleCounter++;\n              reply->newObject = ObjToInsert(reply->body.fh, kj::mv(*directory));\n              return kj::mv(reply);\n            } else {\n              KJ_FAIL_REQUIRE(\"not a directory\");\n            }\n          });\n          break;\n        }\n  \n        case FUSE_READDIR: {\n          auto request = consumeStruct<struct fuse_read_in>(body);\n  \n          auto iter2 = directoryMap.find(request.fh);\n          KJ_REQUIRE(iter2 != directoryMap.end(), \"Kernel requested invalid directory handle?\");\n  \n          // Annoyingly, request.size is actually a size, in bytes. How many entries fit into that\n          // size is dependent on the entry names as well as the size of fuse_dirent. It would be\n          // annoying for implementations to have to compute this, so instead we make an estimate\n          // based on the assumption that the average file name is between 8 and 16 characters.  If\n          // file names turn out to be shorter, this may mean we produce a short read, but that\n          // appears to be OK -- the kernel will only assume EOF if the result is completely empty.\n          // If file names turn out to be longer, we may end up truncating the resulting list and\n          // then re-requesting it.  Someday we could implement some sort of streaming here to fix\n          // this, but that will be pretty ugly and it probably doesn't actually matter that much.\n  \n          auto requestedSize = request.size;\n          auto requestedOffset = request.offset;\n  \n          performReplyTask(header.unique, EIO,\n              [this, requestedSize, requestedOffset, iter2]() -> kj::Own<ResponseBase> {\n            auto entries = iter2->second.cap->read(\n                requestedOffset,\n                requestedSize / (sizeof(struct fuse_dirent) + 16));\n  \n            size_t totalBytes = 0;\n            for (auto& entry: entries) {\n              // Carefully check whether we'll go over the requested size if we add this entry.  If\n              // so, break now.\n              size_t next = totalBytes + FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + entry.name.size());\n              if (next > requestedSize) {\n                break;\n              }\n              totalBytes = next;\n            }\n  \n            auto bytes = kj::heapArray<kj::byte>(totalBytes);\n            kj::byte* pos = bytes.begin();\n            memset(pos, 0, bytes.size());\n  \n            for (auto& entry: entries) {\n              auto& dirent = *reinterpret_cast<struct fuse_dirent*>(pos);\n              auto& name = entry.name;\n  \n              dirent.ino = entry.inodeNumber;\n              dirent.off = entry.nextOffset;\n              dirent.namelen = name.size();\n              dirent.type = DT_UNKNOWN;\n              switch (entry.type) {\n                case fuse::Node::Type::UNKNOWN:                                 break;\n                case fuse::Node::Type::BLOCK_DEVICE:     dirent.type = DT_BLK ; break;\n                case fuse::Node::Type::CHARACTER_DEVICE: dirent.type = DT_CHR ; break;\n                case fuse::Node::Type::DIRECTORY:        dirent.type = DT_DIR ; break;\n                case fuse::Node::Type::FIFO:             dirent.type = DT_FIFO; break;\n                case fuse::Node::Type::SYMLINK:          dirent.type = DT_LNK ; break;\n                case fuse::Node::Type::REGULAR:          dirent.type = DT_REG ; break;\n                case fuse::Node::Type::SOCKET:           dirent.type = DT_SOCK; break;\n              }\n  \n              memcpy(dirent.name, name.begin(), name.size());\n              pos += FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + name.size());\n  \n              // Check if we truncated the list.\n              if (pos == bytes.end()) {\n                break;\n              }\n            }\n  \n            KJ_ASSERT(pos == bytes.end());\n  \n            auto bytesPtr = bytes.asPtr();  // Don't inline; param construction order is undefined.\n            return allocResponse<void>(kj::mv(bytes), bytesPtr);\n          });\n          break;\n        }\n  \n        case FUSE_RELEASEDIR: {\n          // Presumably since directories aren't writable there's no possibility of close() errors.\n          auto request = consumeStruct<struct fuse_release_in>(body);\n          KJ_REQUIRE(directoryMap.erase(request.fh) == 1,\n                     \"Kernel released invalid directory handle?\");\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n        }\n  \n        case FUSE_ACCESS: {\n          // If the node exists then F_OK and R_OK are implied. W_OK\n          auto request = consumeStruct<struct fuse_access_in>(body);\n  \n          auto mask = request.mask;\n  \n          if (request.mask & ~(R_OK | X_OK | F_OK)) {\n            // Some bit other than read/execute is being checked (presumably, W_OK). This is a\n            // read-only filesystem.\n            sendError(header.unique, EROFS);\n          } else if (request.mask != 0) {\n            // Need to check permissions.\n            performReplyTask(header.unique, EACCES,\n                [this, nodeIter, mask]() -> kj::Own<ResponseBase> {\n              auto result = nodeIter->second.node->getAttributes();\n              auto attributes = result.attributes;\n              // TODO(someday):  Account for uid/gid?  Currently irrelevant.\n              if (mask & R_OK) {\n                KJ_REQUIRE(attributes.permissions & S_IROTH);\n              }\n              if (mask & X_OK) {\n                KJ_REQUIRE(attributes.permissions & S_IXOTH);\n              }\n  \n              return allocEmptyResponse();\n            });\n          } else {\n            sendReply(header.unique, allocEmptyResponse());\n          }\n  \n          break;\n        }\n  \n        case FUSE_INTERRUPT: {\n          // We deal with tasks sequentially, so whatever task this call was intended to interrupt\n          // has in fact already completed. Therefore there's nothing for us to do.\n          break;\n        }\n  \n        case FUSE_FLUSH:\n          // This seems to be called on close() even for files opened read-only.\n          sendReply(header.unique, allocEmptyResponse());\n          break;\n  \n          // TODO(someday): Missing read-only syscalls: statfs, getxaddr, listxaddr, locking,\n          //     readdirplus (we currently set protocol version to pre-readdirplus to avoid it)\n          // TODO(someday): Write calls.\n  \n        case FUSE_STATFS:\n        case FUSE_GETXATTR:\n        case FUSE_LISTXATTR:\n        case FUSE_GETLK:\n        case FUSE_SETLK:\n        case FUSE_SETLKW:\n        case CUSE_INIT:\n          sendError(header.unique, ENOSYS);\n  \n        default:\n          // All other opcodes involve writes.\n          sendError(header.unique, EROFS);\n          break;\n      }\n  \n      return true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bufferPtr.slice",
          "args": [
            "sizeof(header)",
            "header.len"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "bufferPtr.size() >= header.len",
            "\"Incomplete FUSE message from kernel?\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&header",
            "bufferPtr.begin()",
            "sizeof(header)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufferPtr.begin",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "bufferPtr.size() >= sizeof(header)",
            "\"Incomplete FUSE header from kernel?\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "bytesRead"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"read(/dev/fuse)\"",
            "error"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[this]() { return readLoop(); }"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readLoop",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "readLoop",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "347-389",
          "snippet": "kj::Promise<void> readLoop() {\n    for (;;) {\n      ssize_t bytesRead = read(fuseFd, buffer, sizeof(buffer));\n\n      if (bytesRead < 0) {\n        int error = errno;\n        switch (errno) {\n          case EINTR:\n            continue;\n          case ENOENT:\n            // libfuse simply retries on ENOENT. Comment says that ENOENT means \"the operation\n            // was interrupted\", but I can't tell what that's supposed to mean. It makes sense\n            // for write() but what operation is being interrupted on read()? Well, anyway, we do\n            // what libfuse does and retry in this case.\n            continue;\n          case EAGAIN:\n            // No data to read.  Try again later.\n            return observer.whenBecomesReadable().then([this]() { return readLoop(); });\n          case ENODEV:\n            // Unmounted.\n            return kj::READY_NOW;\n          default:\n            KJ_FAIL_SYSCALL(\"read(/dev/fuse)\", error);\n        }\n        KJ_UNREACHABLE;\n      }\n\n      // OK, we got some bytes.\n      auto bufferPtr = kj::arrayPtr(buffer, bytesRead);\n\n      while (bufferPtr.size() > 0) {\n        struct fuse_in_header header;\n        KJ_ASSERT(bufferPtr.size() >= sizeof(header), \"Incomplete FUSE header from kernel?\");\n        memcpy(&header, bufferPtr.begin(), sizeof(header));\n        KJ_ASSERT(bufferPtr.size() >= header.len, \"Incomplete FUSE message from kernel?\");\n        if (!dispatch(header, bufferPtr.slice(sizeof(header), header.len))) {\n          // Got FUSE_DESTROY.\n          return kj::READY_NOW;\n        }\n        bufferPtr = bufferPtr.slice(header.len, bufferPtr.size());\n      }\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fuseFd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Promise<void> readLoop() {\n      for (;;) {\n        ssize_t bytesRead = read(fuseFd, buffer, sizeof(buffer));\n  \n        if (bytesRead < 0) {\n          int error = errno;\n          switch (errno) {\n            case EINTR:\n              continue;\n            case ENOENT:\n              // libfuse simply retries on ENOENT. Comment says that ENOENT means \"the operation\n              // was interrupted\", but I can't tell what that's supposed to mean. It makes sense\n              // for write() but what operation is being interrupted on read()? Well, anyway, we do\n              // what libfuse does and retry in this case.\n              continue;\n            case EAGAIN:\n              // No data to read.  Try again later.\n              return observer.whenBecomesReadable().then([this]() { return readLoop(); });\n            case ENODEV:\n              // Unmounted.\n              return kj::READY_NOW;\n            default:\n              KJ_FAIL_SYSCALL(\"read(/dev/fuse)\", error);\n          }\n          KJ_UNREACHABLE;\n        }\n  \n        // OK, we got some bytes.\n        auto bufferPtr = kj::arrayPtr(buffer, bytesRead);\n  \n        while (bufferPtr.size() > 0) {\n          struct fuse_in_header header;\n          KJ_ASSERT(bufferPtr.size() >= sizeof(header), \"Incomplete FUSE header from kernel?\");\n          memcpy(&header, bufferPtr.begin(), sizeof(header));\n          KJ_ASSERT(bufferPtr.size() >= header.len, \"Incomplete FUSE message from kernel?\");\n          if (!dispatch(header, bufferPtr.slice(sizeof(header), header.len))) {\n            // Got FUSE_DESTROY.\n            return kj::READY_NOW;\n          }\n          bufferPtr = bufferPtr.slice(header.len, bufferPtr.size());\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "writeResponse",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "301-342",
    "snippet": "void writeResponse(kj::Own<ResponseBase>&& response) {\n    size_t size = response->size();\n    response->header.len = size;\n\n  retry:\n    ssize_t n = response->writeSelf(fuseFd);\n\n    if (n < 0) {\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          goto retry;\n        case EAGAIN:\n          KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n        case ENOENT:\n          // According to the libfuse code, this means \"the operation was interrupted\". It's\n          // unclear to me if this is officially part of the protocol or if libfuse is just not\n          // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n          // case, it seems safe to move on here (without updating the cap maps).\n          break;\n        default:\n          KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n      }\n    } else {\n      KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n\n      // Message accepted. Make sure any new capability is added to the appropriate table.\n      KJ_IF_MAYBE(newObj, response->newObject) {\n        if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n          auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n              NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n          ++insertResult.first->second.refcount;\n        } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n          fileMap.insert(std::make_pair(newObj->id,\n              FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n        } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n          directoryMap.insert(std::make_pair(newObj->id,\n              DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n        }\n      }\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "directoryMap.insert",
          "args": [
            "std::make_pair(newObj->id,\n              DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() })"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "newObj->id",
            "DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::Directory>>",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::Directory>>",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.is<kj::Own<fuse::Directory>>",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileMap.insert",
          "args": [
            "std::make_pair(newObj->id,\n              FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() })"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "newObj->id",
            "FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::File>>",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::File>>",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.is<kj::Own<fuse::File>>",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.insert",
          "args": [
            "std::make_pair(newObj->id,\n              NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 })"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "newObj->id",
            "NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::Node>>",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.get<kj::Own<fuse::Node>>",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newObj->obj.is<kj::Own<fuse::Node>>",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "newObj",
            "response->newObject"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n == size",
            "\"write() to FUSE device didn't accept entire command?\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"write(/dev/fuse)\"",
            "error"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response->writeSelf",
          "args": [
            "fuseFd"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "writeSelf",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "235-243",
          "snippet": "virtual ssize_t writeSelf(int fd) override {\n      struct iovec parts[2];\n      parts[0].iov_base = &this->header;\n      parts[0].iov_len = sizeof(this->header);\n      parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n      parts[1].iov_len = content.size();\n\n      return writev(fd, parts, 2);\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual ssize_t writeSelf(int fd) override {\n        struct iovec parts[2];\n        parts[0].iov_base = &this->header;\n        parts[0].iov_len = sizeof(this->header);\n        parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n        parts[1].iov_len = content.size();\n  \n        return writev(fd, parts, 2);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response->size",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void writeResponse(kj::Own<ResponseBase>&& response) {\n      size_t size = response->size();\n      response->header.len = size;\n  \n    retry:\n      ssize_t n = response->writeSelf(fuseFd);\n  \n      if (n < 0) {\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            goto retry;\n          case EAGAIN:\n            KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n          case ENOENT:\n            // According to the libfuse code, this means \"the operation was interrupted\". It's\n            // unclear to me if this is officially part of the protocol or if libfuse is just not\n            // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n            // case, it seems safe to move on here (without updating the cap maps).\n            break;\n          default:\n            KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n        }\n      } else {\n        KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n  \n        // Message accepted. Make sure any new capability is added to the appropriate table.\n        KJ_IF_MAYBE(newObj, response->newObject) {\n          if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n            auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n                NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n            ++insertResult.first->second.refcount;\n          } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n            fileMap.insert(std::make_pair(newObj->id,\n                FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n          } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n            directoryMap.insert(std::make_pair(newObj->id,\n                DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n          }\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "sendError",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "294-299",
    "snippet": "void sendError(uint64_t requestId, int error) {\n    auto response = kj::heap<ResponseBase>();\n    response->header.error = -error;  // Has to be negative. Just because.\n    response->header.unique = requestId;\n    writeResponse(kj::mv(response));\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeResponse",
          "args": [
            "kj::mv(response)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "writeResponse",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "301-342",
          "snippet": "void writeResponse(kj::Own<ResponseBase>&& response) {\n    size_t size = response->size();\n    response->header.len = size;\n\n  retry:\n    ssize_t n = response->writeSelf(fuseFd);\n\n    if (n < 0) {\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          goto retry;\n        case EAGAIN:\n          KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n        case ENOENT:\n          // According to the libfuse code, this means \"the operation was interrupted\". It's\n          // unclear to me if this is officially part of the protocol or if libfuse is just not\n          // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n          // case, it seems safe to move on here (without updating the cap maps).\n          break;\n        default:\n          KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n      }\n    } else {\n      KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n\n      // Message accepted. Make sure any new capability is added to the appropriate table.\n      KJ_IF_MAYBE(newObj, response->newObject) {\n        if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n          auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n              NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n          ++insertResult.first->second.refcount;\n        } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n          fileMap.insert(std::make_pair(newObj->id,\n              FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n        } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n          directoryMap.insert(std::make_pair(newObj->id,\n              DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n        }\n      }\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void writeResponse(kj::Own<ResponseBase>&& response) {\n      size_t size = response->size();\n      response->header.len = size;\n  \n    retry:\n      ssize_t n = response->writeSelf(fuseFd);\n  \n      if (n < 0) {\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            goto retry;\n          case EAGAIN:\n            KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n          case ENOENT:\n            // According to the libfuse code, this means \"the operation was interrupted\". It's\n            // unclear to me if this is officially part of the protocol or if libfuse is just not\n            // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n            // case, it seems safe to move on here (without updating the cap maps).\n            break;\n          default:\n            KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n        }\n      } else {\n        KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n  \n        // Message accepted. Make sure any new capability is added to the appropriate table.\n        KJ_IF_MAYBE(newObj, response->newObject) {\n          if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n            auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n                NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n            ++insertResult.first->second.refcount;\n          } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n            fileMap.insert(std::make_pair(newObj->id,\n                FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n          } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n            directoryMap.insert(std::make_pair(newObj->id,\n                DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n          }\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<ResponseBase>",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void sendError(uint64_t requestId, int error) {\n      auto response = kj::heap<ResponseBase>();\n      response->header.error = -error;  // Has to be negative. Just because.\n      response->header.unique = requestId;\n      writeResponse(kj::mv(response));\n    }\n}"
  },
  {
    "function_name": "sendReply",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "289-292",
    "snippet": "void sendReply(uint64_t requestId, kj::Own<ResponseBase>&& response) {\n    response->header.unique = requestId;\n    writeResponse(kj::mv(response));\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeResponse",
          "args": [
            "kj::mv(response)"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "writeResponse",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "301-342",
          "snippet": "void writeResponse(kj::Own<ResponseBase>&& response) {\n    size_t size = response->size();\n    response->header.len = size;\n\n  retry:\n    ssize_t n = response->writeSelf(fuseFd);\n\n    if (n < 0) {\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          goto retry;\n        case EAGAIN:\n          KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n        case ENOENT:\n          // According to the libfuse code, this means \"the operation was interrupted\". It's\n          // unclear to me if this is officially part of the protocol or if libfuse is just not\n          // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n          // case, it seems safe to move on here (without updating the cap maps).\n          break;\n        default:\n          KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n      }\n    } else {\n      KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n\n      // Message accepted. Make sure any new capability is added to the appropriate table.\n      KJ_IF_MAYBE(newObj, response->newObject) {\n        if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n          auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n              NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n          ++insertResult.first->second.refcount;\n        } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n          fileMap.insert(std::make_pair(newObj->id,\n              FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n        } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n          directoryMap.insert(std::make_pair(newObj->id,\n              DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n        }\n      }\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void writeResponse(kj::Own<ResponseBase>&& response) {\n      size_t size = response->size();\n      response->header.len = size;\n  \n    retry:\n      ssize_t n = response->writeSelf(fuseFd);\n  \n      if (n < 0) {\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            goto retry;\n          case EAGAIN:\n            KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n          case ENOENT:\n            // According to the libfuse code, this means \"the operation was interrupted\". It's\n            // unclear to me if this is officially part of the protocol or if libfuse is just not\n            // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n            // case, it seems safe to move on here (without updating the cap maps).\n            break;\n          default:\n            KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n        }\n      } else {\n        KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n  \n        // Message accepted. Make sure any new capability is added to the appropriate table.\n        KJ_IF_MAYBE(newObj, response->newObject) {\n          if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n            auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n                NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n            ++insertResult.first->second.refcount;\n          } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n            fileMap.insert(std::make_pair(newObj->id,\n                FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n          } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n            directoryMap.insert(std::make_pair(newObj->id,\n                DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n          }\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void sendReply(uint64_t requestId, kj::Own<ResponseBase>&& response) {\n      response->header.unique = requestId;\n      writeResponse(kj::mv(response));\n    }\n}"
  },
  {
    "function_name": "performReplyTask",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "261-287",
    "snippet": "void performReplyTask(uint64_t requestId, int defaultError, Function&& task) {\n    kj::Maybe<kj::Own<ResponseBase>> maybeResponse;\n    auto exception = kj::runCatchingExceptions(\n        [&maybeResponse, requestId, KJ_MVCAP(task)]() mutable {\n      auto taskResponse = task(); // This is allowed to be an error response.\n      taskResponse->header.unique = requestId;\n      maybeResponse = kj::mv(taskResponse);\n    });\n\n    KJ_IF_MAYBE(e, exception) {\n      auto errorResponse = kj::heap<ResponseBase>();\n      errorResponse->header.error = -defaultError; // TODO(someday): Real error numbers.\n      errorResponse->header.unique = requestId;\n      maybeResponse = kj::mv(errorResponse);\n    }\n\n    KJ_IF_MAYBE (response, maybeResponse) {\n      auto writeException = kj::runCatchingExceptions([KJ_MVCAP(response), this] () {\n        writeResponse(kj::mv(*response));\n      });\n\n      KJ_IF_MAYBE(e, writeException) {\n        // We only get here if the write failed. Abort.\n        abortReadLoop->reject(kj::mv(*e));\n      }\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abortReadLoop->reject",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[KJ_MVCAP(response)",
            "this] (){\n        writeResponse(kj::mv(*response));\n      }"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeResponse",
          "args": [
            "kj::mv(*response)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "writeResponse",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "301-342",
          "snippet": "void writeResponse(kj::Own<ResponseBase>&& response) {\n    size_t size = response->size();\n    response->header.len = size;\n\n  retry:\n    ssize_t n = response->writeSelf(fuseFd);\n\n    if (n < 0) {\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          goto retry;\n        case EAGAIN:\n          KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n        case ENOENT:\n          // According to the libfuse code, this means \"the operation was interrupted\". It's\n          // unclear to me if this is officially part of the protocol or if libfuse is just not\n          // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n          // case, it seems safe to move on here (without updating the cap maps).\n          break;\n        default:\n          KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n      }\n    } else {\n      KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n\n      // Message accepted. Make sure any new capability is added to the appropriate table.\n      KJ_IF_MAYBE(newObj, response->newObject) {\n        if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n          auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n              NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n          ++insertResult.first->second.refcount;\n        } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n          fileMap.insert(std::make_pair(newObj->id,\n              FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n        } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n          directoryMap.insert(std::make_pair(newObj->id,\n              DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n        }\n      }\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void writeResponse(kj::Own<ResponseBase>&& response) {\n      size_t size = response->size();\n      response->header.len = size;\n  \n    retry:\n      ssize_t n = response->writeSelf(fuseFd);\n  \n      if (n < 0) {\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            goto retry;\n          case EAGAIN:\n            KJ_FAIL_ASSERT(\"write(/dev/fuse) returned EAGAIN; I thought this wasn't possible.\");\n          case ENOENT:\n            // According to the libfuse code, this means \"the operation was interrupted\". It's\n            // unclear to me if this is officially part of the protocol or if libfuse is just not\n            // doing the proper bookkeeping and is double-replying to interrupted requests. In any\n            // case, it seems safe to move on here (without updating the cap maps).\n            break;\n          default:\n            KJ_FAIL_SYSCALL(\"write(/dev/fuse)\", error);\n        }\n      } else {\n        KJ_ASSERT(n == size, \"write() to FUSE device didn't accept entire command?\");\n  \n        // Message accepted. Make sure any new capability is added to the appropriate table.\n        KJ_IF_MAYBE(newObj, response->newObject) {\n          if (newObj->obj.is<kj::Own<fuse::Node>>()) {\n            auto insertResult = nodeMap.insert(std::make_pair(newObj->id,\n                NodeMapEntry { newObj->obj.get<kj::Own<fuse::Node>>()->addRef(), 0 }));\n            ++insertResult.first->second.refcount;\n          } else if (newObj->obj.is<kj::Own<fuse::File>>()) {\n            fileMap.insert(std::make_pair(newObj->id,\n                FileMapEntry { newObj->obj.get<kj::Own<fuse::File>>()->addRef() }));\n          } else if (newObj->obj.is<kj::Own<fuse::Directory>>()) {\n            directoryMap.insert(std::make_pair(newObj->id,\n                DirectoryMapEntry { newObj->obj.get<kj::Own<fuse::Directory>>()->addRef() }));\n          }\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*response"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "]",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "errorResponse"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<ResponseBase>",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&maybeResponse, requestId, KJ_MVCAP(task)]() mutable {\n      auto taskResponse = task(); // This is allowed to be an error response.\n      taskResponse->header.unique = requestId;\n      maybeResponse = kj::mv(taskResponse);\n    }"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "taskResponse"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  void performReplyTask(uint64_t requestId, int defaultError, Function&& task) {\n      kj::Maybe<kj::Own<ResponseBase>> maybeResponse;\n      auto exception = kj::runCatchingExceptions(\n          [&maybeResponse, requestId, KJ_MVCAP(task)]() mutable {\n        auto taskResponse = task(); // This is allowed to be an error response.\n        taskResponse->header.unique = requestId;\n        maybeResponse = kj::mv(taskResponse);\n      });\n  \n      KJ_IF_MAYBE(e, exception) {\n        auto errorResponse = kj::heap<ResponseBase>();\n        errorResponse->header.error = -defaultError; // TODO(someday): Real error numbers.\n        errorResponse->header.unique = requestId;\n        maybeResponse = kj::mv(errorResponse);\n      }\n  \n      KJ_IF_MAYBE (response, maybeResponse) {\n        auto writeException = kj::runCatchingExceptions([KJ_MVCAP(response), this] () {\n          writeResponse(kj::mv(*response));\n        });\n  \n        KJ_IF_MAYBE(e, writeException) {\n          // We only get here if the write failed. Abort.\n          abortReadLoop->reject(kj::mv(*e));\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "allocResponse",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "256-258",
    "snippet": "kj::Own<ResponseBase> allocResponse(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content) {\n    return kj::heap<ResponseWithContent<T, ContentOwner>>(kj::mv(owner), content);\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<ResponseWithContent<T, ContentOwner>>",
          "args": [
            "kj::mv(owner)",
            "content"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "owner"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Own<ResponseBase> allocResponse(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content) {\n      return kj::heap<ResponseWithContent<T, ContentOwner>>(kj::mv(owner), content);\n    }\n}"
  },
  {
    "function_name": "allocEmptyResponse",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "251-253",
    "snippet": "kj::Own<ResponseBase> allocEmptyResponse() {\n    return kj::heap<ResponseBase>();\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<ResponseBase>",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Own<ResponseBase> allocEmptyResponse() {\n      return kj::heap<ResponseBase>();\n    }\n}"
  },
  {
    "function_name": "allocResponse",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "247-249",
    "snippet": "kj::Own<Response<T>> allocResponse() {\n    return kj::heap<Response<T>>();\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Response<T>>",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Own<Response<T>> allocResponse() {\n      return kj::heap<Response<T>>();\n    }\n}"
  },
  {
    "function_name": "writeSelf",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "235-243",
    "snippet": "virtual ssize_t writeSelf(int fd) override {\n      struct iovec parts[2];\n      parts[0].iov_base = &this->header;\n      parts[0].iov_len = sizeof(this->header);\n      parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n      parts[1].iov_len = content.size();\n\n      return writev(fd, parts, 2);\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "fd",
            "parts",
            "2"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<kj::byte*>",
          "args": [
            "content.begin()"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual ssize_t writeSelf(int fd) override {\n        struct iovec parts[2];\n        parts[0].iov_base = &this->header;\n        parts[0].iov_len = sizeof(this->header);\n        parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n        parts[1].iov_len = content.size();\n  \n        return writev(fd, parts, 2);\n      }\n}"
  },
  {
    "function_name": "size",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "231-233",
    "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
  },
  {
    "function_name": "ResponseWithContent",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "228-229",
    "snippet": "inline explicit ResponseWithContent(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content)\n        : owner(kj::mv(owner)), content(content) {}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "owner"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  inline explicit ResponseWithContent(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content)\n          : owner(kj::mv(owner)), content(content) {}\n}"
  },
  {
    "function_name": "writeSelf",
    "container": "FuseDriver::ResponseWithContent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "210-220",
    "snippet": "virtual ssize_t writeSelf(int fd) override {\n      KJ_ASSERT(kj::implicitCast<void*>(&this->header + 1) == kj::implicitCast<void*>(&this->body));\n\n      struct iovec parts[2];\n      parts[0].iov_base = &this->header;\n      parts[0].iov_len = sizeof(this->header) + sizeof(this->body);\n      parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n      parts[1].iov_len = content.size();\n\n      return writev(fd, parts, 2);\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "fd",
            "parts",
            "2"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<kj::byte*>",
          "args": [
            "content.begin()"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "kj::implicitCast<void*>(&this->header + 1) == kj::implicitCast<void*>(&this->body)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<void*>",
          "args": [
            "&this->body"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<void*>",
          "args": [
            "&this->header + 1"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseWithContent {\n    virtual ssize_t writeSelf(int fd) override {\n          KJ_ASSERT(kj::implicitCast<void*>(&this->header + 1) == kj::implicitCast<void*>(&this->body));\n    \n          struct iovec parts[2];\n          parts[0].iov_base = &this->header;\n          parts[0].iov_len = sizeof(this->header) + sizeof(this->body);\n          parts[1].iov_base = const_cast<kj::byte*>(content.begin());\n          parts[1].iov_len = content.size();\n    \n          return writev(fd, parts, 2);\n        }\n  }\n}"
  },
  {
    "function_name": "size",
    "container": "FuseDriver::ResponseWithContent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "206-208",
    "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + sizeof(this->body) + content.size();\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "231-233",
          "snippet": "virtual size_t size() override {\n      return sizeof(this->header) + content.size();\n    }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  virtual size_t size() override {\n        return sizeof(this->header) + content.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseWithContent {\n    virtual size_t size() override {\n          return sizeof(this->header) + sizeof(this->body) + content.size();\n        }\n  }\n}"
  },
  {
    "function_name": "ResponseWithContent",
    "container": "FuseDriver::ResponseWithContent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "203-204",
    "snippet": "inline explicit ResponseWithContent(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content)\n        : owner(kj::mv(owner)), content(content) {}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "owner"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseWithContent {\n    inline explicit ResponseWithContent(ContentOwner&& owner, kj::ArrayPtr<const kj::byte> content)\n            : owner(kj::mv(owner)), content(content) {}\n  }\n}"
  },
  {
    "function_name": "writeSelf",
    "container": "FuseDriver::Response",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "192-195",
    "snippet": "virtual ssize_t writeSelf(int fd) override {\n      KJ_ASSERT(kj::implicitCast<void*>(&header + 1) == kj::implicitCast<void*>(&body));\n      return write(fd, &header, sizeof(header) + bodySize);\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "&header",
            "sizeof(header) + bodySize"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "kj::implicitCast<void*>(&header + 1) == kj::implicitCast<void*>(&body)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<void*>",
          "args": [
            "&body"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<void*>",
          "args": [
            "&header + 1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  Response {\n    virtual ssize_t writeSelf(int fd) override {\n          KJ_ASSERT(kj::implicitCast<void*>(&header + 1) == kj::implicitCast<void*>(&body));\n          return write(fd, &header, sizeof(header) + bodySize);\n        }\n  }\n}"
  },
  {
    "function_name": "size",
    "container": "FuseDriver::Response",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "188-190",
    "snippet": "virtual size_t size() override {\n      return sizeof(header) + bodySize;\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  Response {\n    virtual size_t size() override {\n          return sizeof(header) + bodySize;\n        }\n  }\n}"
  },
  {
    "function_name": "Response",
    "container": "FuseDriver::Response",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "184-186",
    "snippet": "inline Response(): bodySize(sizeof(body)) {\n      memset(&body, 0, sizeof(body));\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&body",
            "0",
            "sizeof(body)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  Response {\n    inline Response(): bodySize(sizeof(body)) {\n          memset(&body, 0, sizeof(body));\n        }\n  }\n}"
  },
  {
    "function_name": "writeSelf",
    "container": "FuseDriver::ResponseBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "176-176",
    "snippet": "virtual ssize_t writeSelf(int fd) { return write(fd, &header, sizeof(header)); }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "&header",
            "sizeof(header)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseBase {\n    virtual ssize_t writeSelf(int fd) { return write(fd, &header, sizeof(header)); }\n  }\n}"
  },
  {
    "function_name": "size",
    "container": "FuseDriver::ResponseBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "175-175",
    "snippet": "virtual size_t size() { return sizeof(header); }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseBase {\n    virtual size_t size() { return sizeof(header); }\n  }\n}"
  },
  {
    "function_name": "ResponseBase",
    "container": "FuseDriver::ResponseBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "172-172",
    "snippet": "inline ResponseBase() { memset(&header, 0, sizeof(header)); }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&header",
            "0",
            "sizeof(header)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ResponseBase {\n    inline ResponseBase() { memset(&header, 0, sizeof(header)); }\n  }\n}"
  },
  {
    "function_name": "ObjToInsert",
    "container": "FuseDriver::ObjToInsert",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "153-155",
    "snippet": "ObjToInsert(uint64_t id, kj::Own<fuse::Directory>&& directory): id(id) {\n      obj.init<kj::Own<fuse::Directory>>(kj::mv(directory));\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.init<kj::Own<fuse::Directory>>",
          "args": [
            "kj::mv(directory)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "directory"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ObjToInsert {\n    ObjToInsert(uint64_t id, kj::Own<fuse::Directory>&& directory): id(id) {\n          obj.init<kj::Own<fuse::Directory>>(kj::mv(directory));\n        }\n  }\n}"
  },
  {
    "function_name": "ObjToInsert",
    "container": "FuseDriver::ObjToInsert",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "149-151",
    "snippet": "ObjToInsert(uint64_t id, kj::Own<fuse::File>&& file): id(id) {\n      obj.init<kj::Own<fuse::File>>(kj::mv(file));\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.init<kj::Own<fuse::File>>",
          "args": [
            "kj::mv(file)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "file"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ObjToInsert {\n    ObjToInsert(uint64_t id, kj::Own<fuse::File>&& file): id(id) {\n          obj.init<kj::Own<fuse::File>>(kj::mv(file));\n        }\n  }\n}"
  },
  {
    "function_name": "ObjToInsert",
    "container": "FuseDriver::ObjToInsert",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "145-147",
    "snippet": "ObjToInsert(uint64_t id, kj::Own<fuse::Node>&& node): id(id) {\n      obj.init<kj::Own<fuse::Node>>(kj::mv(node));\n    }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.init<kj::Own<fuse::Node>>",
          "args": [
            "kj::mv(node)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  ObjToInsert {\n    ObjToInsert(uint64_t id, kj::Own<fuse::Node>&& node): id(id) {\n          obj.init<kj::Own<fuse::Node>>(kj::mv(node));\n        }\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "58-64",
    "snippet": "kj::Promise<void> run() {\n    auto paf = kj::newPromiseAndFulfiller<void>();\n    abortReadLoop = kj::mv(paf.fulfiller);\n\n    // Wait for readLoop() to report disconnect, but fail early if aborted.\n    return readLoop().exclusiveJoin(kj::mv(paf.promise));\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readLoop",
          "args": [
            "kj::mv(paf.promise)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readLoop",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "readLoop",
          "container": "FuseDriver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
          "lines": "347-389",
          "snippet": "kj::Promise<void> readLoop() {\n    for (;;) {\n      ssize_t bytesRead = read(fuseFd, buffer, sizeof(buffer));\n\n      if (bytesRead < 0) {\n        int error = errno;\n        switch (errno) {\n          case EINTR:\n            continue;\n          case ENOENT:\n            // libfuse simply retries on ENOENT. Comment says that ENOENT means \"the operation\n            // was interrupted\", but I can't tell what that's supposed to mean. It makes sense\n            // for write() but what operation is being interrupted on read()? Well, anyway, we do\n            // what libfuse does and retry in this case.\n            continue;\n          case EAGAIN:\n            // No data to read.  Try again later.\n            return observer.whenBecomesReadable().then([this]() { return readLoop(); });\n          case ENODEV:\n            // Unmounted.\n            return kj::READY_NOW;\n          default:\n            KJ_FAIL_SYSCALL(\"read(/dev/fuse)\", error);\n        }\n        KJ_UNREACHABLE;\n      }\n\n      // OK, we got some bytes.\n      auto bufferPtr = kj::arrayPtr(buffer, bytesRead);\n\n      while (bufferPtr.size() > 0) {\n        struct fuse_in_header header;\n        KJ_ASSERT(bufferPtr.size() >= sizeof(header), \"Incomplete FUSE header from kernel?\");\n        memcpy(&header, bufferPtr.begin(), sizeof(header));\n        KJ_ASSERT(bufferPtr.size() >= header.len, \"Incomplete FUSE message from kernel?\");\n        if (!dispatch(header, bufferPtr.slice(sizeof(header), header.len))) {\n          // Got FUSE_DESTROY.\n          return kj::READY_NOW;\n        }\n        bufferPtr = bufferPtr.slice(header.len, bufferPtr.size());\n      }\n    }\n  }",
          "includes": [
            "#include <sys/socket.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <kj/time.h>",
            "#include <kj/io.h>",
            "#include <sys/uio.h>",
            "#include <kj/async-unix.h>",
            "#include <unistd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unordered_map>",
            "#include <kj/one-of.h>",
            "#include <kj/debug.h>",
            "#include <linux/fuse.h>",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"fuse.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Promise<void> readLoop() {\n      for (;;) {\n        ssize_t bytesRead = read(fuseFd, buffer, sizeof(buffer));\n  \n        if (bytesRead < 0) {\n          int error = errno;\n          switch (errno) {\n            case EINTR:\n              continue;\n            case ENOENT:\n              // libfuse simply retries on ENOENT. Comment says that ENOENT means \"the operation\n              // was interrupted\", but I can't tell what that's supposed to mean. It makes sense\n              // for write() but what operation is being interrupted on read()? Well, anyway, we do\n              // what libfuse does and retry in this case.\n              continue;\n            case EAGAIN:\n              // No data to read.  Try again later.\n              return observer.whenBecomesReadable().then([this]() { return readLoop(); });\n            case ENODEV:\n              // Unmounted.\n              return kj::READY_NOW;\n            default:\n              KJ_FAIL_SYSCALL(\"read(/dev/fuse)\", error);\n          }\n          KJ_UNREACHABLE;\n        }\n  \n        // OK, we got some bytes.\n        auto bufferPtr = kj::arrayPtr(buffer, bytesRead);\n  \n        while (bufferPtr.size() > 0) {\n          struct fuse_in_header header;\n          KJ_ASSERT(bufferPtr.size() >= sizeof(header), \"Incomplete FUSE header from kernel?\");\n          memcpy(&header, bufferPtr.begin(), sizeof(header));\n          KJ_ASSERT(bufferPtr.size() >= header.len, \"Incomplete FUSE message from kernel?\");\n          if (!dispatch(header, bufferPtr.slice(sizeof(header), header.len))) {\n            // Got FUSE_DESTROY.\n            return kj::READY_NOW;\n          }\n          bufferPtr = bufferPtr.slice(header.len, bufferPtr.size());\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  kj::Promise<void> run() {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      abortReadLoop = kj::mv(paf.fulfiller);\n  \n      // Wait for readLoop() to report disconnect, but fail early if aborted.\n      return readLoop().exclusiveJoin(kj::mv(paf.promise));\n    }\n}"
  },
  {
    "function_name": "FuseDriver",
    "container": "FuseDriver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/fuse.c++",
    "lines": "45-56",
    "snippet": "FuseDriver(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node>&& root,\n             FuseOptions options)\n      : observer(eventPort, fuseFd, kj::UnixEventPort::FdObserver::OBSERVE_READ),\n        fuseFd(fuseFd), options(options) {\n    nodeMap.insert(std::make_pair(FUSE_ROOT_ID, NodeMapEntry { kj::mv(root), 1 }));\n\n    int flags;\n    KJ_SYSCALL(flags = fcntl(fuseFd, F_GETFL));\n    if ((flags & O_NONBLOCK) == 0) {\n      KJ_SYSCALL(fcntl(fuseFd, F_SETFL, flags | O_NONBLOCK));\n    }\n  }",
    "includes": [
      "#include <sys/socket.h>",
      "#include <time.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <kj/time.h>",
      "#include <kj/io.h>",
      "#include <sys/uio.h>",
      "#include <kj/async-unix.h>",
      "#include <unistd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <unordered_map>",
      "#include <kj/one-of.h>",
      "#include <kj/debug.h>",
      "#include <linux/fuse.h>",
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"fuse.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(fuseFd, F_SETFL, flags | O_NONBLOCK)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fuseFd",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "flags = fcntl(fuseFd, F_GETFL)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fuseFd",
            "F_GETFL"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeMap.insert",
          "args": [
            "std::make_pair(FUSE_ROOT_ID, NodeMapEntry { kj::mv(root), 1 })"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "FUSE_ROOT_ID",
            "NodeMapEntry { kj::mv(root), 1 }"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "root"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <kj/time.h>\n#include <kj/io.h>\n#include <sys/uio.h>\n#include <kj/async-unix.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unordered_map>\n#include <kj/one-of.h>\n#include <kj/debug.h>\n#include <linux/fuse.h>\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"fuse.h\"\n\nFuseDriver {\n  FuseDriver(kj::UnixEventPort& eventPort, int fuseFd, kj::Own<fuse::Node>&& root,\n               FuseOptions options)\n        : observer(eventPort, fuseFd, kj::UnixEventPort::FdObserver::OBSERVE_READ),\n          fuseFd(fuseFd), options(options) {\n      nodeMap.insert(std::make_pair(FUSE_ROOT_ID, NodeMapEntry { kj::mv(root), 1 }));\n  \n      int flags;\n      KJ_SYSCALL(flags = fcntl(fuseFd, F_GETFL));\n      if ((flags & O_NONBLOCK) == 0) {\n        KJ_SYSCALL(fcntl(fuseFd, F_SETFL, flags | O_NONBLOCK));\n      }\n    }\n}"
  }
]