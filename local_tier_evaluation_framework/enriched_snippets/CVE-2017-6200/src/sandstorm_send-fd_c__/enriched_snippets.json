[
  {
    "function_name": "receiveFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
    "lines": "61-118",
    "snippet": "kj::AutoCloseFd receiveFd(int sockFd,\n    kj::Function<void(kj::ArrayPtr<const kj::byte>)> dataCallback) {\n  // Receive the fuse FD from the socket.  recvmsg() is complicated...  :/\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  // Make sure we have space to receive a byte so that recvmsg() doesn't simply return\n  // immediately.\n  struct iovec iov;\n  memset(&iov, 0, sizeof(iov));\n  kj::byte buffer[1024];\n  iov.iov_base = &buffer;\n  iov.iov_len = sizeof(buffer);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  // Allocate space to receive a cmsg.\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_SPACE(sizeof(int))];\n  };\n  msg.msg_control = &cmsg;\n\n  // Wait for the message.\n  for (;;) {\n    msg.msg_controllen = sizeof(cmsgSpace);\n\n    ssize_t n;\n    KJ_SYSCALL(n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC));\n    KJ_ASSERT(n > 0, \"premature EOF while waiting for FD\");\n\n    for (size_t i: kj::range<size_t>(0, n)) {\n      if (buffer[i] == 0) {\n        // Yay, here's our zero byte.\n        if (i > 0) {\n          dataCallback(kj::arrayPtr(buffer, i));\n        }\n        if (n > i + 1) {\n          dataCallback(kj::arrayPtr(buffer + i + 1, n - i - 1));\n        }\n\n        KJ_ASSERT(msg.msg_controllen >= sizeof(cmsg), \"expected fd on socket\");\n\n        // We expect an SCM_RIGHTS message with a single FD.\n        KJ_ASSERT(cmsg.cmsg_level == SOL_SOCKET);\n        KJ_ASSERT(cmsg.cmsg_type == SCM_RIGHTS);\n        KJ_ASSERT(cmsg.cmsg_len == CMSG_LEN(sizeof(int)));\n\n        return kj::AutoCloseFd(*reinterpret_cast<int*>(CMSG_DATA(&cmsg)));\n      }\n    }\n\n    // No zero bytes; all data.\n    dataCallback(kj::arrayPtr(buffer, n));\n\n    KJ_ASSERT(msg.msg_controllen == 0, \"expected zero byte with fd\");\n  }\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <kj/debug.h>",
      "#include \"send-fd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "msg.msg_controllen == 0",
            "\"expected zero byte with fd\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataCallback",
          "args": [
            "kj::arrayPtr(buffer, n)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "n"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "*reinterpret_cast<int*>(CMSG_DATA(&cmsg))"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<int*>",
          "args": [
            "CMSG_DATA(&cmsg)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "&cmsg"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "cmsg.cmsg_len == CMSG_LEN(sizeof(int))"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(int)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "cmsg.cmsg_type == SCM_RIGHTS"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "cmsg.cmsg_level == SOL_SOCKET"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "msg.msg_controllen >= sizeof(cmsg)",
            "\"expected fd on socket\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataCallback",
          "args": [
            "kj::arrayPtr(buffer + i + 1, n - i - 1)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer + i + 1",
            "n - i - 1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataCallback",
          "args": [
            "kj::arrayPtr(buffer, i)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "i"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::range<size_t>",
          "args": [
            "0",
            "n"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n > 0",
            "\"premature EOF while waiting for FD\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "sockFd",
            "&msg",
            "MSG_CMSG_CLOEXEC"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(int)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iov",
            "0",
            "sizeof(iov)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include <kj/debug.h>\n#include \"send-fd.h\"\n\nkj::AutoCloseFd receiveFd(int sockFd,\n    kj::Function<void(kj::ArrayPtr<const kj::byte>)> dataCallback) {\n  // Receive the fuse FD from the socket.  recvmsg() is complicated...  :/\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  // Make sure we have space to receive a byte so that recvmsg() doesn't simply return\n  // immediately.\n  struct iovec iov;\n  memset(&iov, 0, sizeof(iov));\n  kj::byte buffer[1024];\n  iov.iov_base = &buffer;\n  iov.iov_len = sizeof(buffer);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  // Allocate space to receive a cmsg.\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_SPACE(sizeof(int))];\n  };\n  msg.msg_control = &cmsg;\n\n  // Wait for the message.\n  for (;;) {\n    msg.msg_controllen = sizeof(cmsgSpace);\n\n    ssize_t n;\n    KJ_SYSCALL(n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC));\n    KJ_ASSERT(n > 0, \"premature EOF while waiting for FD\");\n\n    for (size_t i: kj::range<size_t>(0, n)) {\n      if (buffer[i] == 0) {\n        // Yay, here's our zero byte.\n        if (i > 0) {\n          dataCallback(kj::arrayPtr(buffer, i));\n        }\n        if (n > i + 1) {\n          dataCallback(kj::arrayPtr(buffer + i + 1, n - i - 1));\n        }\n\n        KJ_ASSERT(msg.msg_controllen >= sizeof(cmsg), \"expected fd on socket\");\n\n        // We expect an SCM_RIGHTS message with a single FD.\n        KJ_ASSERT(cmsg.cmsg_level == SOL_SOCKET);\n        KJ_ASSERT(cmsg.cmsg_type == SCM_RIGHTS);\n        KJ_ASSERT(cmsg.cmsg_len == CMSG_LEN(sizeof(int)));\n\n        return kj::AutoCloseFd(*reinterpret_cast<int*>(CMSG_DATA(&cmsg)));\n      }\n    }\n\n    // No zero bytes; all data.\n    dataCallback(kj::arrayPtr(buffer, n));\n\n    KJ_ASSERT(msg.msg_controllen == 0, \"expected zero byte with fd\");\n  }\n}"
  },
  {
    "function_name": "receiveFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
    "lines": "55-59",
    "snippet": "kj::AutoCloseFd receiveFd(int sockFd) {\n  return receiveFd(sockFd, [](kj::ArrayPtr<const kj::byte>) {\n    KJ_FAIL_REQUIRE(\"Got unexpected data on unix socket while waiting for a file descriptor.\");\n  });\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <kj/debug.h>",
      "#include \"send-fd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "receiveFd",
          "args": [
            "sockFd",
            "[](kj::ArrayPtr<const kj::byte>) {\n    KJ_FAIL_REQUIRE(\"Got unexpected data on unix socket while waiting for a file descriptor.\");\n  }"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "receiveFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
          "lines": "61-118",
          "snippet": "kj::AutoCloseFd receiveFd(int sockFd,\n    kj::Function<void(kj::ArrayPtr<const kj::byte>)> dataCallback) {\n  // Receive the fuse FD from the socket.  recvmsg() is complicated...  :/\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  // Make sure we have space to receive a byte so that recvmsg() doesn't simply return\n  // immediately.\n  struct iovec iov;\n  memset(&iov, 0, sizeof(iov));\n  kj::byte buffer[1024];\n  iov.iov_base = &buffer;\n  iov.iov_len = sizeof(buffer);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  // Allocate space to receive a cmsg.\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_SPACE(sizeof(int))];\n  };\n  msg.msg_control = &cmsg;\n\n  // Wait for the message.\n  for (;;) {\n    msg.msg_controllen = sizeof(cmsgSpace);\n\n    ssize_t n;\n    KJ_SYSCALL(n = recvmsg(sockFd, &msg, MSG_CMSG_CLOEXEC));\n    KJ_ASSERT(n > 0, \"premature EOF while waiting for FD\");\n\n    for (size_t i: kj::range<size_t>(0, n)) {\n      if (buffer[i] == 0) {\n        // Yay, here's our zero byte.\n        if (i > 0) {\n          dataCallback(kj::arrayPtr(buffer, i));\n        }\n        if (n > i + 1) {\n          dataCallback(kj::arrayPtr(buffer + i + 1, n - i - 1));\n        }\n\n        KJ_ASSERT(msg.msg_controllen >= sizeof(cmsg), \"expected fd on socket\");\n\n        // We expect an SCM_RIGHTS message with a single FD.\n        KJ_ASSERT(cmsg.cmsg_level == SOL_SOCKET);\n        KJ_ASSERT(cmsg.cmsg_type == SCM_RIGHTS);\n        KJ_ASSERT(cmsg.cmsg_len == CMSG_LEN(sizeof(int)));\n\n        return kj::AutoCloseFd(*reinterpret_cast<int*>(CMSG_DATA(&cmsg)));\n      }\n    }\n\n    // No zero bytes; all data.\n    dataCallback(kj::arrayPtr(buffer, n));\n\n    KJ_ASSERT(msg.msg_controllen == 0, \"expected zero byte with fd\");\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Got unexpected data on unix socket while waiting for a file descriptor.\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include <kj/debug.h>\n#include \"send-fd.h\"\n\nkj::AutoCloseFd receiveFd(int sockFd) {\n  return receiveFd(sockFd, [](kj::ArrayPtr<const kj::byte>) {\n    KJ_FAIL_REQUIRE(\"Got unexpected data on unix socket while waiting for a file descriptor.\");\n  });\n}"
  },
  {
    "function_name": "sendFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/send-fd.c++",
    "lines": "24-53",
    "snippet": "void sendFd(int sendOn, int fdToSend) {\n  // Sends the fd over the given socket. A NUL byte is also sent, because at least one byte\n  // must be written along with the FD.\n\n  struct msghdr msg;\n  struct iovec iov;\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_LEN(sizeof(int))];\n  };\n  memset(&msg, 0, sizeof(msg));\n  memset(&iov, 0, sizeof(iov));\n  memset(cmsgSpace, 0, sizeof(cmsgSpace));\n\n  char c = 0;\n  iov.iov_base = &c;\n  iov.iov_len = 1;\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  msg.msg_control = &cmsg;\n  msg.msg_controllen = sizeof(cmsgSpace);\n\n  cmsg.cmsg_len = sizeof(cmsgSpace);\n  cmsg.cmsg_level = SOL_SOCKET;\n  cmsg.cmsg_type = SCM_RIGHTS;\n  *reinterpret_cast<int*>(CMSG_DATA(&cmsg)) = fdToSend;\n\n  KJ_SYSCALL(sendmsg(sendOn, &msg, 0));\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <kj/debug.h>",
      "#include \"send-fd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sendmsg(sendOn, &msg, 0)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "sendOn",
            "&msg",
            "0"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<int*>",
          "args": [
            "CMSG_DATA(&cmsg)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "&cmsg"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmsgSpace",
            "0",
            "sizeof(cmsgSpace)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iov",
            "0",
            "sizeof(iov)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(int)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include <kj/debug.h>\n#include \"send-fd.h\"\n\nvoid sendFd(int sendOn, int fdToSend) {\n  // Sends the fd over the given socket. A NUL byte is also sent, because at least one byte\n  // must be written along with the FD.\n\n  struct msghdr msg;\n  struct iovec iov;\n  union {\n    struct cmsghdr cmsg;\n    char cmsgSpace[CMSG_LEN(sizeof(int))];\n  };\n  memset(&msg, 0, sizeof(msg));\n  memset(&iov, 0, sizeof(iov));\n  memset(cmsgSpace, 0, sizeof(cmsgSpace));\n\n  char c = 0;\n  iov.iov_base = &c;\n  iov.iov_len = 1;\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  msg.msg_control = &cmsg;\n  msg.msg_controllen = sizeof(cmsgSpace);\n\n  cmsg.cmsg_len = sizeof(cmsgSpace);\n  cmsg.cmsg_level = SOL_SOCKET;\n  cmsg.cmsg_type = SCM_RIGHTS;\n  *reinterpret_cast<int*>(CMSG_DATA(&cmsg)) = fdToSend;\n\n  KJ_SYSCALL(sendmsg(sendOn, &msg, 0));\n}"
  }
]