[
  {
    "function_name": "getGrainStorageUsage",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "676-680",
    "snippet": "kj::Promise<void> BackendImpl::getGrainStorageUsage(GetGrainStorageUsageContext context) {\n  context.getResults(capnp::MessageSize { 4, 0 }).setSize(recursivelyCountSize(\n      kj::str(\"/var/sandstorm/grains/\", validateId(context.getParams().getGrainId()))));\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "recursivelyCountSize(\n      kj::str(\"/var/sandstorm/grains/\", validateId(context.getParams().getGrainId())))"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyCountSize",
          "args": [
            "kj::str(\"/var/sandstorm/grains/\", validateId(context.getParams().getGrainId()))"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCountSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "652-674",
          "snippet": "static uint64_t recursivelyCountSize(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n\n  // Count blocks, not length, because what we care about is allocated space.\n  uint64_t total = stats.st_blocks * 512;\n\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      total += recursivelyCountSize(kj::str(path, '/', file));\n    }\n  } else if (stats.st_nlink != 0) {\n    // Don't overcount hard links. (Note that st_nlink can in fact be zero in cases where we are\n    // racing with directory modifications, so we check for that to avoid divide-by-zero crashes.)\n    total /= stats.st_nlink;\n  }\n\n  return total;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic uint64_t recursivelyCountSize(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n\n  // Count blocks, not length, because what we care about is allocated space.\n  uint64_t total = stats.st_blocks * 512;\n\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      total += recursivelyCountSize(kj::str(path, '/', file));\n    }\n  } else if (stats.st_nlink != 0) {\n    // Don't overcount hard links. (Note that st_nlink can in fact be zero in cases where we are\n    // racing with directory modifications, so we check for that to avoid divide-by-zero crashes.)\n    total /= stats.st_nlink;\n  }\n\n  return total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/grains/\"",
            "validateId(context.getParams().getGrainId())"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "context.getParams().getGrainId()"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize { 4, 0 }"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::getGrainStorageUsage(GetGrainStorageUsageContext context) {\n    context.getResults(capnp::MessageSize { 4, 0 }).setSize(recursivelyCountSize(\n        kj::str(\"/var/sandstorm/grains/\", validateId(context.getParams().getGrainId()))));\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "recursivelyCountSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "652-674",
    "snippet": "static uint64_t recursivelyCountSize(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n\n  // Count blocks, not length, because what we care about is allocated space.\n  uint64_t total = stats.st_blocks * 512;\n\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      total += recursivelyCountSize(kj::str(path, '/', file));\n    }\n  } else if (stats.st_nlink != 0) {\n    // Don't overcount hard links. (Note that st_nlink can in fact be zero in cases where we are\n    // racing with directory modifications, so we check for that to avoid divide-by-zero crashes.)\n    total /= stats.st_nlink;\n  }\n\n  return total;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recursivelyCountSize",
          "args": [
            "kj::str(path, '/', file)"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCountSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "652-674",
          "snippet": "static uint64_t recursivelyCountSize(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n\n  // Count blocks, not length, because what we care about is allocated space.\n  uint64_t total = stats.st_blocks * 512;\n\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      total += recursivelyCountSize(kj::str(path, '/', file));\n    }\n  } else if (stats.st_nlink != 0) {\n    // Don't overcount hard links. (Note that st_nlink can in fact be zero in cases where we are\n    // racing with directory modifications, so we check for that to avoid divide-by-zero crashes.)\n    total /= stats.st_nlink;\n  }\n\n  return total;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "'/'",
            "file"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listDirectory",
          "args": [
            "path"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "292-297",
          "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(path.cStr(), &stats)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!path.endsWith(\"/\")",
            "\"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic uint64_t recursivelyCountSize(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively traverse directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n\n  // Count blocks, not length, because what we care about is allocated space.\n  uint64_t total = stats.st_blocks * 512;\n\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      total += recursivelyCountSize(kj::str(path, '/', file));\n    }\n  } else if (stats.st_nlink != 0) {\n    // Don't overcount hard links. (Note that st_nlink can in fact be zero in cases where we are\n    // racing with directory modifications, so we check for that to avoid divide-by-zero crashes.)\n    total /= stats.st_nlink;\n  }\n\n  return total;\n}"
  },
  {
    "function_name": "deleteBackup",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "637-648",
    "snippet": "kj::Promise<void> BackendImpl::deleteBackup(DeleteBackupContext context) {\n  auto path = kj::str(\"/var/sandstorm/backups/\", context.getParams().getBackupId());\n  while (unlink(path.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      break;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"unlink\", error, path);\n    }\n  }\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"unlink\"",
            "error",
            "path"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path.cStr()"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/backups/\"",
            "context.getParams().getBackupId()"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::deleteBackup(DeleteBackupContext context) {\n    auto path = kj::str(\"/var/sandstorm/backups/\", context.getParams().getBackupId());\n    while (unlink(path.cStr()) < 0) {\n      int error = errno;\n      if (error == ENOENT) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"unlink\", error, path);\n      }\n    }\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "downloadBackup",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "618-635",
    "snippet": "kj::Promise<void> BackendImpl::downloadBackup(DownloadBackupContext context) {\n  auto params = context.getParams();\n  auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n  auto stream = params.getStream();\n  context.releaseParams();\n\n  auto fd = raiiOpen(path, O_RDONLY | O_CLOEXEC);\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  auto expectReq = stream.expectSizeRequest();\n  expectReq.setSize(stats.st_size);\n  auto expectPromise = expectReq.send();\n\n  auto file = kj::heap<kj::FdInputStream>(kj::mv(fd));\n\n  auto promise = pump(*file, kj::mv(stream));\n  return promise.attach(kj::mv(file), kj::mv(expectPromise));\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(file)",
            "kj::mv(expectPromise)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "expectPromise"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "file"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "*file",
            "kj::mv(stream)"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "246-251",
          "snippet": "void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n    byte buffer[4096];\n    while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n      out.write(buffer, n);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<kj::FdInputStream>",
          "args": [
            "kj::mv(fd)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fd"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectReq.send",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectReq.setSize",
          "args": [
            "stats.st_size"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.expectSizeRequest",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(fd, &stats)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stats"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "path",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getStream",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/backups/\"",
            "params.getBackupId()"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getBackupId",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::downloadBackup(DownloadBackupContext context) {\n    auto params = context.getParams();\n    auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n    auto stream = params.getStream();\n    context.releaseParams();\n  \n    auto fd = raiiOpen(path, O_RDONLY | O_CLOEXEC);\n    struct stat stats;\n    KJ_SYSCALL(fstat(fd, &stats));\n    auto expectReq = stream.expectSizeRequest();\n    expectReq.setSize(stats.st_size);\n    auto expectPromise = expectReq.send();\n  \n    auto file = kj::heap<kj::FdInputStream>(kj::mv(fd));\n  \n    auto promise = pump(*file, kj::mv(stream));\n    return promise.attach(kj::mv(file), kj::mv(expectPromise));\n  }\n}"
  },
  {
    "function_name": "uploadBackup",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "607-616",
    "snippet": "kj::Promise<void> BackendImpl::uploadBackup(UploadBackupContext context) {\n  auto path = kj::str(\"/var/sandstorm/backups/\", context.getParams().getBackupId());\n  context.releaseParams();\n\n  recursivelyCreateParent(path);\n\n  context.getResults(capnp::MessageSize { 4, 1 }).setStream(\n      kj::heap<FileUploadStream>(kj::mv(path)));\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<FileUploadStream>(kj::mv(path))"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<FileUploadStream>",
          "args": [
            "kj::mv(path)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize { 4, 1 }"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyCreateParent",
          "args": [
            "path"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCreateParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "331-350",
          "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/backups/\"",
            "context.getParams().getBackupId()"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::uploadBackup(UploadBackupContext context) {\n    auto path = kj::str(\"/var/sandstorm/backups/\", context.getParams().getBackupId());\n    context.releaseParams();\n  \n    recursivelyCreateParent(path);\n  \n    context.getResults(capnp::MessageSize { 4, 1 }).setStream(\n        kj::heap<FileUploadStream>(kj::mv(path)));\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "dirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "598-603",
    "snippet": "static kj::String dirname(kj::StringPtr path) {\n    KJ_IF_MAYBE(pos, path.findLast('/')) {\n      return kj::heapString(path.slice(0, *pos));\n    } else {\n      return kj::heapString(\".\");\n    }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return kj::heapString",
          "args": [
            "\".\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path.slice(0, *pos)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "0",
            "*pos"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "pos",
            "path.findLast('/')"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.findLast",
          "args": [
            "'/'"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::String dirname(kj::StringPtr path) {\n    KJ_IF_MAYBE(pos, path.findLast('/')) {\n      return kj::heapString(path.slice(0, *pos));\n    } else {\n      return kj::heapString(\".\");\n    }"
  },
  {
    "function_name": "expectSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "587-590",
    "snippet": "kj::Promise<void> expectSize(ExpectSizeContext context) override {\n    // don't care\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> expectSize(ExpectSizeContext context) override {\n    // don't care\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "580-585",
    "snippet": "kj::Promise<void> done(DoneContext context) override {\n    KJ_SYSCALL(fsync(fd));\n    KJ_SYSCALL(rename(tmpPath.cStr(), finalPath.cStr()));\n    isDone = true;\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "rename(tmpPath.cStr(), finalPath.cStr())"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tmpPath.cStr()",
            "finalPath.cStr()"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalPath.cStr",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpPath.cStr",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fsync(fd)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "fd"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> done(DoneContext context) override {\n    KJ_SYSCALL(fsync(fd));\n    KJ_SYSCALL(rename(tmpPath.cStr(), finalPath.cStr()));\n    isDone = true;\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "574-578",
    "snippet": "kj::Promise<void> write(WriteContext context) override {\n    auto data = context.getParams().getData();\n    kj::FdOutputStream(fd.get()).write(data.begin(), data.size());\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "data.begin()",
            "data.size()"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "fd.get()"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd.get",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> write(WriteContext context) override {\n    auto data = context.getParams().getData();\n    kj::FdOutputStream(fd.get()).write(data.begin(), data.size());\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "FileUploadStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "561-564",
    "snippet": "FileUploadStream(kj::String finalPath)\n      : tmpPath(kj::str(finalPath, \".uploading\")),\n        finalPath(kj::mv(finalPath)),\n        fd(raiiOpen(tmpPath, O_WRONLY | O_CREAT | O_EXCL)) {}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "tmpPath",
            "O_WRONLY | O_CREAT | O_EXCL"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "finalPath"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "finalPath",
            "\".uploading\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nFileUploadStream(kj::String finalPath)\n      : tmpPath(kj::str(finalPath, \".uploading\")),\n        finalPath(kj::mv(finalPath)),\n        fd(raiiOpen(tmpPath, O_WRONLY | O_CREAT | O_EXCL)) {}"
  },
  {
    "function_name": "restoreGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "516-557",
    "snippet": "kj::Promise<void> BackendImpl::restoreGrain(RestoreGrainContext context) {\n  auto params = context.getParams();\n\n  auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n  auto grainDir = kj::str(\"/var/sandstorm/grains/\", params.getGrainId());\n\n  // Similar to the supervisor, the \"backup\" command sets up its own sandbox, and for that to work\n  // we need to pass along root privileges to it.\n  kj::Vector<kj::StringPtr> argv;\n  kj::String ownUid;\n  argv.add(\"backup\");\n  KJ_IF_MAYBE(u, sandboxUid) {\n    argv.add(\"--uid\");\n    ownUid = kj::str(*u);\n    argv.add(ownUid);\n  }\n  argv.add(\"-r\");\n  argv.add(path);\n  argv.add(grainDir);\n\n  KJ_SYSCALL(mkdir(grainDir.cStr(), 0777));\n  Subprocess::Options processOptions(argv.asPtr());\n  if (sandboxUid != nullptr) processOptions.uid = uid_t(0);\n  processOptions.executable = \"/proc/self/exe\";\n  auto outPipe = Pipe::make();\n  processOptions.stdout = outPipe.writeEnd;\n  Subprocess process(kj::mv(processOptions));\n  outPipe.writeEnd = nullptr;\n\n  context.releaseParams();\n\n  auto input = kj::mv(outPipe.readEnd);\n  auto asyncInput = ioProvider.wrapInputFd(input, kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n\n  auto promise = capnp::readMessage(*asyncInput);\n  return promise.attach(kj::mv(input), kj::mv(asyncInput), kj::mv(process))\n      .then([context](kj::Own<capnp::MessageReader>&& message) mutable {\n    auto metadata = message->getRoot<GrainInfo>();\n    context.getResults(capnp::MessageSize { metadata.totalSize().wordCount + 4, 0 })\n        .setInfo(metadata);\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "[context](kj::Own<capnp::MessageReader>&& message) mutable {\n    auto metadata = message->getRoot<GrainInfo>();\n    context.getResults(capnp::MessageSize { metadata.totalSize().wordCount + 4, 0 })\n        .setInfo(metadata);\n  }"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "metadata"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize { metadata.totalSize().wordCount + 4, 0 }"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.totalSize",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getRoot<GrainInfo>",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(input)",
            "kj::mv(asyncInput)",
            "kj::mv(process)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "process"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "asyncInput"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "input"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::readMessage",
          "args": [
            "*asyncInput"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioProvider.wrapInputFd",
          "args": [
            "input",
            "kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "outPipe.readEnd"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_t",
          "args": [
            "0"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.asPtr",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(grainDir.cStr(), 0777)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "grainDir.cStr()",
            "0777"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainDir.cStr",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "grainDir"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "path"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "\"-r\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "ownUid"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "*u"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "\"--uid\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "\"backup\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/grains/\"",
            "params.getGrainId()"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getGrainId",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "getGrainId",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "69-69",
          "snippet": "inline kj::StringPtr getGrainId() { return grainId; }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::StringPtr getGrainId() { return grainId; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/backups/\"",
            "params.getBackupId()"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getBackupId",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::restoreGrain(RestoreGrainContext context) {\n    auto params = context.getParams();\n  \n    auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n    auto grainDir = kj::str(\"/var/sandstorm/grains/\", params.getGrainId());\n  \n    // Similar to the supervisor, the \"backup\" command sets up its own sandbox, and for that to work\n    // we need to pass along root privileges to it.\n    kj::Vector<kj::StringPtr> argv;\n    kj::String ownUid;\n    argv.add(\"backup\");\n    KJ_IF_MAYBE(u, sandboxUid) {\n      argv.add(\"--uid\");\n      ownUid = kj::str(*u);\n      argv.add(ownUid);\n    }\n    argv.add(\"-r\");\n    argv.add(path);\n    argv.add(grainDir);\n  \n    KJ_SYSCALL(mkdir(grainDir.cStr(), 0777));\n    Subprocess::Options processOptions(argv.asPtr());\n    if (sandboxUid != nullptr) processOptions.uid = uid_t(0);\n    processOptions.executable = \"/proc/self/exe\";\n    auto outPipe = Pipe::make();\n    processOptions.stdout = outPipe.writeEnd;\n    Subprocess process(kj::mv(processOptions));\n    outPipe.writeEnd = nullptr;\n  \n    context.releaseParams();\n  \n    auto input = kj::mv(outPipe.readEnd);\n    auto asyncInput = ioProvider.wrapInputFd(input, kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n  \n    auto promise = capnp::readMessage(*asyncInput);\n    return promise.attach(kj::mv(input), kj::mv(asyncInput), kj::mv(process))\n        .then([context](kj::Own<capnp::MessageReader>&& message) mutable {\n      auto metadata = message->getRoot<GrainInfo>();\n      context.getResults(capnp::MessageSize { metadata.totalSize().wordCount + 4, 0 })\n          .setInfo(metadata);\n    });\n  }\n}"
  },
  {
    "function_name": "backupGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "471-514",
    "snippet": "kj::Promise<void> BackendImpl::backupGrain(BackupGrainContext context) {\n  auto params = context.getParams();\n\n  auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n  recursivelyCreateParent(path);\n  auto grainDir = kj::str(\"/var/sandstorm/grains/\", params.getGrainId());\n\n  // Similar to the supervisor, the \"backup\" command sets up its own sandbox, and for that to work\n  // we need to pass along root privileges to it.\n  kj::Vector<kj::StringPtr> argv;\n  kj::String ownUid;\n  argv.add(\"backup\");\n  KJ_IF_MAYBE(u, sandboxUid) {\n    argv.add(\"--uid\");\n    ownUid = kj::str(*u);\n    argv.add(ownUid);\n  }\n  argv.add(path);\n  argv.add(grainDir);\n\n  Subprocess::Options processOptions(argv.asPtr());\n  if (sandboxUid != nullptr) processOptions.uid = uid_t(0);\n  processOptions.executable = \"/proc/self/exe\";\n  auto inPipe = Pipe::make();\n  processOptions.stdin = inPipe.readEnd;\n  Subprocess process(kj::mv(processOptions));\n  inPipe.readEnd = nullptr;\n\n  auto metadata = params.getInfo();\n  auto metadataMsg = kj::heap<capnp::MallocMessageBuilder>(metadata.totalSize().wordCount + 4);\n  metadataMsg->setRoot(metadata);\n  context.releaseParams();\n  auto metadataStreamFd = kj::mv(inPipe.writeEnd);\n  auto output = ioProvider.wrapOutputFd(\n      metadataStreamFd, kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n  auto promise = capnp::writeMessage(*output, *metadataMsg);\n\n  return promise.attach(kj::mv(metadataMsg), kj::mv(metadataStreamFd), kj::mv(output))\n      .then([KJ_MVCAP(process)]() mutable {\n    // TODO(cleanup): We should probably use a SubprocessSet to wait asynchronously, but that\n    //   means we need to use SubprocessSet everywhere...\n    process.waitForSuccess();\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "[KJ_MVCAP(process)]() mutable {\n    // TODO(cleanup): We should probably use a SubprocessSet to wait asynchronously, but that\n    //   means we need to use SubprocessSet everywhere...\n    process.waitForSuccess();\n  }"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process.waitForSuccess",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "993-996",
          "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(metadataMsg)",
            "kj::mv(metadataStreamFd)",
            "kj::mv(output)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "output"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "metadataStreamFd"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "metadataMsg"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::writeMessage",
          "args": [
            "*output",
            "*metadataMsg"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioProvider.wrapOutputFd",
          "args": [
            "metadataStreamFd",
            "kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inPipe.writeEnd"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadataMsg->setRoot",
          "args": [
            "metadata"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "setRoot",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "66-69",
          "snippet": "bool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRoot(kj::StringPtr arg) {\n    root = arg;\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<capnp::MallocMessageBuilder>",
          "args": [
            "metadata.totalSize().wordCount + 4"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata.totalSize",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getInfo",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_t",
          "args": [
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.asPtr",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "grainDir"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "path"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "ownUid"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "*u"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "\"--uid\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "\"backup\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/grains/\"",
            "params.getGrainId()"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getGrainId",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "getGrainId",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "69-69",
          "snippet": "inline kj::StringPtr getGrainId() { return grainId; }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::StringPtr getGrainId() { return grainId; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursivelyCreateParent",
          "args": [
            "path"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCreateParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "331-350",
          "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/backups/\"",
            "params.getBackupId()"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getBackupId",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::backupGrain(BackupGrainContext context) {\n    auto params = context.getParams();\n  \n    auto path = kj::str(\"/var/sandstorm/backups/\", params.getBackupId());\n    recursivelyCreateParent(path);\n    auto grainDir = kj::str(\"/var/sandstorm/grains/\", params.getGrainId());\n  \n    // Similar to the supervisor, the \"backup\" command sets up its own sandbox, and for that to work\n    // we need to pass along root privileges to it.\n    kj::Vector<kj::StringPtr> argv;\n    kj::String ownUid;\n    argv.add(\"backup\");\n    KJ_IF_MAYBE(u, sandboxUid) {\n      argv.add(\"--uid\");\n      ownUid = kj::str(*u);\n      argv.add(ownUid);\n    }\n    argv.add(path);\n    argv.add(grainDir);\n  \n    Subprocess::Options processOptions(argv.asPtr());\n    if (sandboxUid != nullptr) processOptions.uid = uid_t(0);\n    processOptions.executable = \"/proc/self/exe\";\n    auto inPipe = Pipe::make();\n    processOptions.stdin = inPipe.readEnd;\n    Subprocess process(kj::mv(processOptions));\n    inPipe.readEnd = nullptr;\n  \n    auto metadata = params.getInfo();\n    auto metadataMsg = kj::heap<capnp::MallocMessageBuilder>(metadata.totalSize().wordCount + 4);\n    metadataMsg->setRoot(metadata);\n    context.releaseParams();\n    auto metadataStreamFd = kj::mv(inPipe.writeEnd);\n    auto output = ioProvider.wrapOutputFd(\n        metadataStreamFd, kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n    auto promise = capnp::writeMessage(*output, *metadataMsg);\n  \n    return promise.attach(kj::mv(metadataMsg), kj::mv(metadataStreamFd), kj::mv(output))\n        .then([KJ_MVCAP(process)]() mutable {\n      // TODO(cleanup): We should probably use a SubprocessSet to wait asynchronously, but that\n      //   means we need to use SubprocessSet everywhere...\n      process.waitForSuccess();\n    });\n  }\n}"
  },
  {
    "function_name": "deletePackage",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "461-467",
    "snippet": "kj::Promise<void> BackendImpl::deletePackage(DeletePackageContext context) {\n  auto path = kj::str(\"/var/sandstorm/apps/\", validateId(context.getParams().getPackageId()));\n  if (access(path.cStr(), F_OK) >= 0) {\n    tryRecursivelyDelete(path);\n  }\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tryRecursivelyDelete",
          "args": [
            "path"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "tryRecursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "32-49",
          "snippet": "static void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path.cStr()",
            "F_OK"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/apps/\"",
            "validateId(context.getParams().getPackageId())"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "context.getParams().getPackageId()"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::deletePackage(DeletePackageContext context) {\n    auto path = kj::str(\"/var/sandstorm/apps/\", validateId(context.getParams().getPackageId()));\n    if (access(path.cStr(), F_OK) >= 0) {\n      tryRecursivelyDelete(path);\n    }\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "tryGetPackage",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "437-459",
    "snippet": "kj::Promise<void> BackendImpl::tryGetPackage(TryGetPackageContext context) {\n  auto path = kj::str(\"/var/sandstorm/apps/\", validateId(context.getParams().getPackageId()));\n\n  KJ_IF_MAYBE(file, raiiOpenIfExists(kj::str(path, \"/sandstorm-manifest\"), O_RDONLY)) {\n    capnp::ReaderOptions manifestLimits;\n    manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n    capnp::StreamFdMessageReader reader(kj::mv(*file), manifestLimits);\n    auto manifest = reader.getRoot<spk::Manifest>();\n\n    kj::String appid = sandstorm::readAll(kj::str(path, \".appid\"));\n\n    capnp::MessageSize sizeHint = manifest.totalSize();\n    sizeHint.wordCount += 8 + appid.size() / sizeof(capnp::word);\n    auto results = context.getResults(sizeHint);\n    results.setAppId(trim(appid));\n    results.setManifest(manifest);\n    KJ_IF_MAYBE(fp, checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)) {\n      results.setAuthorPgpKeyFingerprint(*fp);\n    }\n  }\n\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.setAuthorPgpKeyFingerprint",
          "args": [
            "*fp"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fp",
            "checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkPgpSignature",
          "args": [
            "results.getAppId()",
            "manifest.getMetadata()",
            "sandboxUid"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "checkPgpSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "2449-2465",
          "snippet": "kj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "friend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);\n\nkj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "manifest.getMetadata",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.getAppId",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setManifest",
          "args": [
            "manifest"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setAppId",
          "args": [
            "trim(appid)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "appid"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "sizeHint"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appid.size",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "manifest.totalSize",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstorm::readAll",
          "args": [
            "kj::str(path, \".appid\")"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "383-385",
          "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "\".appid\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<spk::Manifest>",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*file"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpenIfExists",
          "args": [
            "kj::str(path, \"/sandstorm-manifest\")",
            "O_RDONLY"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "\"/sandstorm-manifest\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/apps/\"",
            "validateId(context.getParams().getPackageId())"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "context.getParams().getPackageId()"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::tryGetPackage(TryGetPackageContext context) {\n    auto path = kj::str(\"/var/sandstorm/apps/\", validateId(context.getParams().getPackageId()));\n  \n    KJ_IF_MAYBE(file, raiiOpenIfExists(kj::str(path, \"/sandstorm-manifest\"), O_RDONLY)) {\n      capnp::ReaderOptions manifestLimits;\n      manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n      capnp::StreamFdMessageReader reader(kj::mv(*file), manifestLimits);\n      auto manifest = reader.getRoot<spk::Manifest>();\n  \n      kj::String appid = sandstorm::readAll(kj::str(path, \".appid\"));\n  \n      capnp::MessageSize sizeHint = manifest.totalSize();\n      sizeHint.wordCount += 8 + appid.size() / sizeof(capnp::word);\n      auto results = context.getResults(sizeHint);\n      results.setAppId(trim(appid));\n      results.setManifest(manifest);\n      KJ_IF_MAYBE(fp, checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)) {\n        results.setAuthorPgpKeyFingerprint(*fp);\n      }\n    }\n  \n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "installPackage",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "432-435",
    "snippet": "kj::Promise<void> BackendImpl::installPackage(InstallPackageContext context)  {\n  context.getResults().setStream(kj::heap<PackageUploadStreamImpl>(*this));\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<PackageUploadStreamImpl>(*this)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<PackageUploadStreamImpl>",
          "args": [
            "*this"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::installPackage(InstallPackageContext context)  {\n    context.getResults().setStream(kj::heap<PackageUploadStreamImpl>(*this));\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "startProcess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "420-429",
    "snippet": "static Subprocess startProcess(\n      kj::AutoCloseFd input, kj::AutoCloseFd output, kj::StringPtr outdir,\n      kj::Maybe<uid_t> sandboxUid) {\n    Subprocess::Options options({\"spk\", \"unpack\", \"-\", outdir});\n    options.uid = sandboxUid;\n    options.executable = \"/proc/self/exe\";\n    options.stdin = input;\n    options.stdout = output;\n    return Subprocess(kj::mv(options));\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Subprocess",
          "args": [
            "kj::mv(options)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "notifyExited",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "374-383",
          "snippet": "void notifyExited(int status) {\n    // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n    // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n    // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n    //\n    // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n    //   async I/O.\n\n    pid = 0;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  void notifyExited(int status) {\n      // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n      // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n      // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n      //\n      // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n      //   async I/O.\n  \n      pid = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "options"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic Subprocess startProcess(\n      kj::AutoCloseFd input, kj::AutoCloseFd output, kj::StringPtr outdir,\n      kj::Maybe<uid_t> sandboxUid) {\n    Subprocess::Options options({\"spk\", \"unpack\", \"-\", outdir});\n    options.uid = sandboxUid;\n    options.executable = \"/proc/self/exe\";\n    options.stdin = input;\n    options.stdout = output;\n    return Subprocess(kj::mv(options));\n  }"
  },
  {
    "function_name": "tempDirname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "415-418",
    "snippet": "static kj::String tempDirname() {\n    static uint counter = 0;\n    return kj::str(\"/var/sandstorm/tmp/unpacking.\", time(nullptr), \".\", counter++);\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/tmp/unpacking.\"",
            "time(nullptr)",
            "\".\"",
            "counter++"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "nullptr"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::String tempDirname() {\n    static uint counter = 0;\n    return kj::str(\"/var/sandstorm/tmp/unpacking.\", time(nullptr), \".\", counter++);\n  }"
  },
  {
    "function_name": "saveAs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "364-402",
    "snippet": "kj::Promise<void> saveAs(SaveAsContext context) override {\n    KJ_REQUIRE(!saveCalled, \"saveAs() already called\");\n    saveCalled = true;\n    return readAll(*outputReadEnd).then([this,context](kj::String text) mutable {\n      unpackProcess.waitForSuccess();\n\n      auto packageId = validateId(context.getParams().getPackageId());\n      auto finalName = kj::str(\"/var/sandstorm/apps/\", packageId);\n      bool exists = access(finalName.cStr(), F_OK) >= 0;\n      if (!exists) {\n        // Write app ID file.\n        kj::FdOutputStream(\n            raiiOpen(kj::str(finalName, \".appid\"), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC))\n            .write(text.begin(), text.size());\n\n        // Move directory into place.\n        KJ_SYSCALL(rename(tmpdir.cStr(), finalName.cStr()));\n      }\n      KJ_ON_SCOPE_FAILURE(if (!exists) { tryRecursivelyDelete(finalName); });\n\n      capnp::ReaderOptions manifestLimits;\n      manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n      capnp::StreamFdMessageReader reader(raiiOpen(\n          kj::str(finalName, \"/sandstorm-manifest\"), O_RDONLY), manifestLimits);\n      auto manifest = reader.getRoot<spk::Manifest>();\n\n      capnp::MessageSize sizeHint = manifest.totalSize();\n      sizeHint.wordCount += 8 + text.size() / sizeof(capnp::word);\n      auto results = context.getResults(sizeHint);\n      results.setAppId(trim(text));\n      results.setManifest(manifest);\n      KJ_IF_MAYBE(fp, checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)) {\n        results.setAuthorPgpKeyFingerprint(*fp);\n      }\n    }, [this](kj::Exception&& e) {\n      kj::runCatchingExceptions([&]() { recursivelyDelete(tmpdir); });\n      kj::throwRecoverableException(kj::mv(e));\n    });\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "[this,context](kj::String text) mutable {\n      unpackProcess.waitForSuccess();\n\n      auto packageId = validateId(context.getParams().getPackageId());\n      auto finalName = kj::str(\"/var/sandstorm/apps/\", packageId);\n      bool exists = access(finalName.cStr(), F_OK) >= 0;\n      if (!exists) {\n        // Write app ID file.\n        kj::FdOutputStream(\n            raiiOpen(kj::str(finalName, \".appid\"), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC))\n            .write(text.begin(), text.size());\n\n        // Move directory into place.\n        KJ_SYSCALL(rename(tmpdir.cStr(), finalName.cStr()));\n      }\n      KJ_ON_SCOPE_FAILURE(if (!exists) { tryRecursivelyDelete(finalName); });\n\n      capnp::ReaderOptions manifestLimits;\n      manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n      capnp::StreamFdMessageReader reader(raiiOpen(\n          kj::str(finalName, \"/sandstorm-manifest\"), O_RDONLY), manifestLimits);\n      auto manifest = reader.getRoot<spk::Manifest>();\n\n      capnp::MessageSize sizeHint = manifest.totalSize();\n      sizeHint.wordCount += 8 + text.size() / sizeof(capnp::word);\n      auto results = context.getResults(sizeHint);\n      results.setAppId(trim(text));\n      results.setManifest(manifest);\n      KJ_IF_MAYBE(fp, checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)) {\n        results.setAuthorPgpKeyFingerprint(*fp);\n      }\n    }",
            "[this](kj::Exception&& e) {\n      kj::runCatchingExceptions([&]() { recursivelyDelete(tmpdir); });\n      kj::throwRecoverableException(kj::mv(e));\n    }"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "209-222",
          "snippet": "kj::Promise<kj::String> BackendImpl::readAll(kj::AsyncInputStream& input, kj::Vector<char> soFar) {\n  soFar.resize(soFar.size() + 4096);\n  return input.tryRead(soFar.end() - 4096, 4096, 4096)\n      .then([KJ_MVCAP(soFar),&input](size_t n) mutable -> kj::Promise<kj::String> {\n    if (n < 4096) {\n      // Must be EOF.\n      soFar.resize(soFar.size() - 4096 + n);\n      soFar.add('\\0');\n      return kj::String(soFar.releaseAsArray());\n    } else {\n      return readAll(input, kj::mv(soFar));\n    }\n  });\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<kj::String> BackendImpl::readAll(kj::AsyncInputStream& input, kj::Vector<char> soFar) {\n    soFar.resize(soFar.size() + 4096);\n    return input.tryRead(soFar.end() - 4096, 4096, 4096)\n        .then([KJ_MVCAP(soFar),&input](size_t n) mutable -> kj::Promise<kj::String> {\n      if (n < 4096) {\n        // Must be EOF.\n        soFar.resize(soFar.size() - 4096 + n);\n        soFar.add('\\0');\n        return kj::String(soFar.releaseAsArray());\n      } else {\n        return readAll(input, kj::mv(soFar));\n      }\n    });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "kj::mv(e)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() { recursivelyDelete(tmpdir); }"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyDelete",
          "args": [
            "tmpdir"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "299-313",
          "snippet": "void recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "results.setAuthorPgpKeyFingerprint",
          "args": [
            "*fp"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fp",
            "checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkPgpSignature",
          "args": [
            "results.getAppId()",
            "manifest.getMetadata()",
            "sandboxUid"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "checkPgpSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/spk.c++",
          "lines": "2449-2465",
          "snippet": "kj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include \"appid-replacements.h\"",
            "#include \"id-to-text.h\"",
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"union-fs.h\"",
            "#include \"fuse.h\"",
            "#include \"version.h\"",
            "#include <sodium/crypto_generichash_blake2b.h>",
            "#include <sandstorm/app-index/submit.capnp.h>",
            "#include <poll.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema-parser.h>",
            "#include <sys/xattr.h>",
            "#include <map>",
            "#include <set>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <sandstorm/appid-replacements.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <errno.h>",
            "#include <sys/mman.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sodium/crypto_hash_sha512.h>",
            "#include <sodium/crypto_hash_sha256.h>",
            "#include <sodium/crypto_sign.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"spk.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "friend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"appid-replacements.h\"\n#include \"id-to-text.h\"\n#include \"util.h\"\n#include \"send-fd.h\"\n#include \"union-fs.h\"\n#include \"fuse.h\"\n#include \"version.h\"\n#include <sodium/crypto_generichash_blake2b.h>\n#include <sandstorm/app-index/submit.capnp.h>\n#include <poll.h>\n#include <time.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema-parser.h>\n#include <sys/xattr.h>\n#include <map>\n#include <set>\n#include <dirent.h>\n#include <stdlib.h>\n#include <sandstorm/appid-replacements.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sodium/crypto_hash_sha512.h>\n#include <sodium/crypto_hash_sha256.h>\n#include <sodium/crypto_sign.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"spk.h\"\n\nfriend kj::Maybe<kj::String> checkPgpSignature(\n      kj::StringPtr appIdString, spk::Metadata::Reader metadata, kj::Maybe<uid_t> sandboxUid);\n\nkj::Maybe<kj::String> checkPgpSignature(kj::StringPtr appIdString, spk::Metadata::Reader metadata,\n                                        kj::Maybe<uid_t> sandboxUid) {\n  auto author = metadata.getAuthor();\n\n  if (author.hasPgpSignature()) {\n    KJ_REQUIRE(metadata.hasPgpKeyring(), \"package metadata contains PGP signature but no keyring\");\n\n    kj::Function<kj::String(kj::StringPtr problem)> error =\n        [](kj::StringPtr problem) -> kj::String {\n      KJ_FAIL_ASSERT(\"PGP signature verification problem\", problem);\n    };\n    return SpkTool::checkPgpSignature(appIdString,\n        author.getPgpSignature(), metadata.getPgpKeyring(), error, sandboxUid);\n  } else {\n    return nullptr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "manifest.getMetadata",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.getAppId",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setManifest",
          "args": [
            "manifest"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setAppId",
          "args": [
            "trim(text)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "text"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "sizeHint"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "manifest.totalSize",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<spk::Manifest>",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "kj::str(finalName, \"/sandstorm-manifest\")",
            "O_RDONLY"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "finalName",
            "\"/sandstorm-manifest\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "if (!exists){ tryRecursivelyDelete(finalName); }"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryRecursivelyDelete",
          "args": [
            "finalName"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "tryRecursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "32-49",
          "snippet": "static void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "!exists"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "save",
          "container": "WakelockSet::WrappedOngoingNotification",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1795-1799",
          "snippet": "kj::Promise<void> save(SaveContext context) override {\n      return wakelockSet.save(ongoingNotification).then([context] (auto args) mutable -> void {\n        context.getResults().setSturdyRef(args.getToken());\n      });\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "WakelockSet& wakelockSet;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\n\nWakelockSet {\n  WrappedOngoingNotification {\n    kj::Promise<void> save(SaveContext context) override {\n          return wakelockSet.save(ongoingNotification).then([context] (auto args) mutable -> void {\n            context.getResults().setSturdyRef(args.getToken());\n          });\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "rename(tmpdir.cStr(), finalName.cStr())"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tmpdir.cStr()",
            "finalName.cStr()"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalName.cStr",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpdir.cStr",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(kj::str(finalName, \".appid\"), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "kj::str(finalName, \".appid\")",
            "O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "finalName",
            "\".appid\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "finalName.cStr()",
            "F_OK"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalName.cStr",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/apps/\"",
            "packageId"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "context.getParams().getPackageId()"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpackProcess.waitForSuccess",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "993-996",
          "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "*outputReadEnd"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "383-385",
          "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!saveCalled",
            "\"saveAs() already called\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> saveAs(SaveAsContext context) override {\n    KJ_REQUIRE(!saveCalled, \"saveAs() already called\");\n    saveCalled = true;\n    return readAll(*outputReadEnd).then([this,context](kj::String text) mutable {\n      unpackProcess.waitForSuccess();\n\n      auto packageId = validateId(context.getParams().getPackageId());\n      auto finalName = kj::str(\"/var/sandstorm/apps/\", packageId);\n      bool exists = access(finalName.cStr(), F_OK) >= 0;\n      if (!exists) {\n        // Write app ID file.\n        kj::FdOutputStream(\n            raiiOpen(kj::str(finalName, \".appid\"), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC))\n            .write(text.begin(), text.size());\n\n        // Move directory into place.\n        KJ_SYSCALL(rename(tmpdir.cStr(), finalName.cStr()));\n      }\n      KJ_ON_SCOPE_FAILURE(if (!exists) { tryRecursivelyDelete(finalName); });\n\n      capnp::ReaderOptions manifestLimits;\n      manifestLimits.traversalLimitInWords = spk::Manifest::SIZE_LIMIT_IN_WORDS;\n      capnp::StreamFdMessageReader reader(raiiOpen(\n          kj::str(finalName, \"/sandstorm-manifest\"), O_RDONLY), manifestLimits);\n      auto manifest = reader.getRoot<spk::Manifest>();\n\n      capnp::MessageSize sizeHint = manifest.totalSize();\n      sizeHint.wordCount += 8 + text.size() / sizeof(capnp::word);\n      auto results = context.getResults(sizeHint);\n      results.setAppId(trim(text));\n      results.setManifest(manifest);\n      KJ_IF_MAYBE(fp, checkPgpSignature(results.getAppId(), manifest.getMetadata(), sandboxUid)) {\n        results.setAuthorPgpKeyFingerprint(*fp);\n      }\n    }, [this](kj::Exception&& e) {\n      kj::runCatchingExceptions([&]() { recursivelyDelete(tmpdir); });\n      kj::throwRecoverableException(kj::mv(e));\n    });\n  }"
  },
  {
    "function_name": "expectSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "359-362",
    "snippet": "kj::Promise<void> expectSize(ExpectSizeContext context) override {\n    // don't care\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> expectSize(ExpectSizeContext context) override {\n    // don't care\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "348-357",
    "snippet": "kj::Promise<void> done(DoneContext context) override {\n    auto forked = writeQueue.then([this,context]() mutable {\n      KJ_REQUIRE(inputWriteEnd != nullptr, \"called done() multiple times\");\n      inputWriteEnd = nullptr;\n      inputWriteFd = nullptr;\n    }).fork();\n\n    writeQueue = forked.addBranch();\n    return forked.addBranch();\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeQueue.then",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeQueue.then",
          "args": [
            "[this,context]() mutable {\n      KJ_REQUIRE(inputWriteEnd != nullptr, \"called done() multiple times\");\n      inputWriteEnd = nullptr;\n      inputWriteFd = nullptr;\n    }"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "inputWriteEnd != nullptr",
            "\"called done() multiple times\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> done(DoneContext context) override {\n    auto forked = writeQueue.then([this,context]() mutable {\n      KJ_REQUIRE(inputWriteEnd != nullptr, \"called done() multiple times\");\n      inputWriteEnd = nullptr;\n      inputWriteFd = nullptr;\n    }).fork();\n\n    writeQueue = forked.addBranch();\n    return forked.addBranch();\n  }"
  },
  {
    "function_name": "write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "337-346",
    "snippet": "kj::Promise<void> write(WriteContext context) override {\n    auto forked = writeQueue.then([this,context]() mutable {\n      auto data = context.getParams().getData();\n      return KJ_REQUIRE_NONNULL(inputWriteEnd, \"called write() after done()\")\n          ->write(data.begin(), data.size());\n    }).fork();\n\n    writeQueue = forked.addBranch();\n    return forked.addBranch();\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeQueue.then",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeQueue.then",
          "args": [
            "[this,context]() mutable {\n      auto data = context.getParams().getData();\n      return KJ_REQUIRE_NONNULL(inputWriteEnd, \"called write() after done()\")\n          ->write(data.begin(), data.size());\n    }"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [
            "data.begin()",
            "data.size()"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [
            "inputWriteEnd",
            "\"called write() after done()\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nkj::Promise<void> write(WriteContext context) override {\n    auto forked = writeQueue.then([this,context]() mutable {\n      auto data = context.getParams().getData();\n      return KJ_REQUIRE_NONNULL(inputWriteEnd, \"called write() after done()\")\n          ->write(data.begin(), data.size());\n    }).fork();\n\n    writeQueue = forked.addBranch();\n    return forked.addBranch();\n  }"
  },
  {
    "function_name": "PackageUploadStreamImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "318-329",
    "snippet": "PackageUploadStreamImpl(BackendImpl& backend, Pipe inPipe = Pipe::make(),\n                          Pipe outPipe = Pipe::make())\n      : sandboxUid(backend.sandboxUid),\n        inputWriteFd(kj::mv(inPipe.writeEnd)),\n        outputReadFd(kj::mv(outPipe.readEnd)),\n        inputWriteEnd(backend.ioProvider.wrapOutputFd(inputWriteFd,\n            kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC)),\n        outputReadEnd(backend.ioProvider.wrapInputFd(outputReadFd,\n            kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC)),\n        tmpdir(tempDirname()),\n        unpackProcess(startProcess(kj::mv(inPipe.readEnd), kj::mv(outPipe.writeEnd), tmpdir,\n                                   backend.sandboxUid)) {}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "startProcess",
          "args": [
            "kj::mv(inPipe.readEnd)",
            "kj::mv(outPipe.writeEnd)",
            "tmpdir",
            "backend.sandboxUid"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "startProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "420-429",
          "snippet": "static Subprocess startProcess(\n      kj::AutoCloseFd input, kj::AutoCloseFd output, kj::StringPtr outdir,\n      kj::Maybe<uid_t> sandboxUid) {\n    Subprocess::Options options({\"spk\", \"unpack\", \"-\", outdir});\n    options.uid = sandboxUid;\n    options.executable = \"/proc/self/exe\";\n    options.stdin = input;\n    options.stdout = output;\n    return Subprocess(kj::mv(options));\n  }",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic Subprocess startProcess(\n      kj::AutoCloseFd input, kj::AutoCloseFd output, kj::StringPtr outdir,\n      kj::Maybe<uid_t> sandboxUid) {\n    Subprocess::Options options({\"spk\", \"unpack\", \"-\", outdir});\n    options.uid = sandboxUid;\n    options.executable = \"/proc/self/exe\";\n    options.stdin = input;\n    options.stdout = output;\n    return Subprocess(kj::mv(options));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "outPipe.writeEnd"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inPipe.readEnd"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempDirname",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "tempDirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "415-418",
          "snippet": "static kj::String tempDirname() {\n    static uint counter = 0;\n    return kj::str(\"/var/sandstorm/tmp/unpacking.\", time(nullptr), \".\", counter++);\n  }",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::String tempDirname() {\n    static uint counter = 0;\n    return kj::str(\"/var/sandstorm/tmp/unpacking.\", time(nullptr), \".\", counter++);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "backend.ioProvider.wrapInputFd",
          "args": [
            "outputReadFd",
            "kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backend.ioProvider.wrapOutputFd",
          "args": [
            "inputWriteFd",
            "kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "outPipe.readEnd"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inPipe.writeEnd"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nPackageUploadStreamImpl(BackendImpl& backend, Pipe inPipe = Pipe::make(),\n                          Pipe outPipe = Pipe::make())\n      : sandboxUid(backend.sandboxUid),\n        inputWriteFd(kj::mv(inPipe.writeEnd)),\n        outputReadFd(kj::mv(outPipe.readEnd)),\n        inputWriteEnd(backend.ioProvider.wrapOutputFd(inputWriteFd,\n            kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC)),\n        outputReadEnd(backend.ioProvider.wrapInputFd(outputReadFd,\n            kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC)),\n        tmpdir(tempDirname()),\n        unpackProcess(startProcess(kj::mv(inPipe.readEnd), kj::mv(outPipe.writeEnd), tmpdir,\n                                   backend.sandboxUid)) {}"
  },
  {
    "function_name": "deleteUser",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "309-312",
    "snippet": "kj::Promise<void> BackendImpl::deleteUser(DeleteUserContext context) {\n  // Nothing to do: We store no per-user data in the back-end.\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::deleteUser(DeleteUserContext context) {\n    // Nothing to do: We store no per-user data in the back-end.\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "transferGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "304-307",
    "snippet": "kj::Promise<void> BackendImpl::transferGrain(TransferGrainContext context) {\n  // Nothing to do: Grains aren't stored by owner.\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::transferGrain(TransferGrainContext context) {\n    // Nothing to do: Grains aren't stored by owner.\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "deleteGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "278-302",
    "snippet": "kj::Promise<void> BackendImpl::deleteGrain(DeleteGrainContext context) {\n  auto grainId = validateId(context.getParams().getGrainId());\n  auto iter = supervisors.find(grainId);\n  kj::Promise<void> shutdownPromise = nullptr;\n  if (iter != supervisors.end()) {\n    shutdownPromise = iter->second.promise.addBranch()\n        .then([context](Supervisor::Client client) mutable {\n      return client.shutdownRequest().send().ignoreResult();\n    }).then([]() -> kj::Promise<void> {\n      return KJ_EXCEPTION(FAILED, \"expected shutdown() to throw disconnected exception\");\n    }, [](kj::Exception&& e) -> kj::Promise<void> {\n      if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n        return kj::READY_NOW;\n      } else {\n        return kj::mv(e);\n      }\n    });\n  } else {\n    shutdownPromise = kj::READY_NOW;\n  }\n\n  return shutdownPromise.then([grainId]() {\n    tryRecursivelyDelete(kj::str(\"/var/sandstorm/grains/\", grainId));\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownPromise.then",
          "args": [
            "[grainId]() {\n    tryRecursivelyDelete(kj::str(\"/var/sandstorm/grains/\", grainId));\n  }"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryRecursivelyDelete",
          "args": [
            "kj::str(\"/var/sandstorm/grains/\", grainId)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "tryRecursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "32-49",
          "snippet": "static void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/grains/\"",
            "grainId"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [
            "[]() -> kj::Promise<void> {\n      return KJ_EXCEPTION(FAILED, \"expected shutdown() to throw disconnected exception\");\n    }",
            "[](kj::Exception&& e) -> kj::Promise<void> {\n      if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n        return kj::READY_NOW;\n      } else {\n        return kj::mv(e);\n      }\n    }"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "FAILED",
            "\"expected shutdown() to throw disconnected exception\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [
            "[context](Supervisor::Client client) mutable {\n      return client.shutdownRequest().send().ignoreResult();\n    }"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.shutdownRequest",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.shutdownRequest",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.shutdownRequest",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.end",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.find",
          "args": [
            "grainId"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "context.getParams().getGrainId()"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::deleteGrain(DeleteGrainContext context) {\n    auto grainId = validateId(context.getParams().getGrainId());\n    auto iter = supervisors.find(grainId);\n    kj::Promise<void> shutdownPromise = nullptr;\n    if (iter != supervisors.end()) {\n      shutdownPromise = iter->second.promise.addBranch()\n          .then([context](Supervisor::Client client) mutable {\n        return client.shutdownRequest().send().ignoreResult();\n      }).then([]() -> kj::Promise<void> {\n        return KJ_EXCEPTION(FAILED, \"expected shutdown() to throw disconnected exception\");\n      }, [](kj::Exception&& e) -> kj::Promise<void> {\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          return kj::READY_NOW;\n        } else {\n          return kj::mv(e);\n        }\n      });\n    } else {\n      shutdownPromise = kj::READY_NOW;\n    }\n  \n    return shutdownPromise.then([grainId]() {\n      tryRecursivelyDelete(kj::str(\"/var/sandstorm/grains/\", grainId));\n    });\n  }\n}"
  },
  {
    "function_name": "getGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "248-273",
    "snippet": "kj::Promise<void> BackendImpl::getGrain(GetGrainContext context) {\n  auto grainId = context.getParams().getGrainId();\n  auto iter = supervisors.find(validateId(grainId));\n  if (iter != supervisors.end()) {\n    return iter->second.promise.addBranch()\n        .then([this,context,grainId](Supervisor::Client client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      return keepAliveReq.send()\n          .then([context,KJ_MVCAP(client)](auto&&) mutable -> kj::Promise<void> {\n        context.getResults().setSupervisor(kj::mv(client));\n        return kj::READY_NOW;\n      }, [](kj::Exception&& e) -> kj::Promise<void> {\n        if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n          KJ_LOG(ERROR, \"Exception when trying to keepAlive() a supervisor in getGrain().\", e);\n          return KJ_EXCEPTION(DISCONNECTED, \"grain is not running\");\n        } else {\n          return kj::mv(e);\n        }\n      });\n    });\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [
            "[this,context,grainId](Supervisor::Client client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      return keepAliveReq.send()\n          .then([context,KJ_MVCAP(client)](auto&&) mutable -> kj::Promise<void> {\n        context.getResults().setSupervisor(kj::mv(client));\n        return kj::READY_NOW;\n      }",
            "[](kj::Exception&& e) -> kj::Promise<void> {\n        if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n          KJ_LOG(ERROR, \"Exception when trying to keepAlive() a supervisor in getGrain().\", e);\n          return KJ_EXCEPTION(DISCONNECTED, \"grain is not running\");\n        } else {\n          return kj::mv(e);\n        }\n      }"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "DISCONNECTED",
            "\"grain is not running\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"Exception when trying to keepAlive() a supervisor in getGrain().\"",
            "e"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::mv(client)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "client"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keepAliveReq.send",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keepAliveReq.setCore",
          "args": [
            "coreReq.send().getCore()"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreReq.send",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreReq.send",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.keepAliveRequest",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreReq.setGrainId",
          "args": [
            "grainId"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "setGrainId",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "619-625",
          "snippet": "kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n  if (id == nullptr || id.findFirst('/') != nullptr) {\n    return \"Invalid grain id.\";\n  }\n  grainId = kj::heapString(id);\n  return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n    if (id == nullptr || id.findFirst('/') != nullptr) {\n      return \"Invalid grain id.\";\n    }\n    grainId = kj::heapString(id);\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "coreFactory.getSandstormCoreRequest",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.end",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.find",
          "args": [
            "validateId(grainId)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "grainId"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::getGrain(GetGrainContext context) {\n    auto grainId = context.getParams().getGrainId();\n    auto iter = supervisors.find(validateId(grainId));\n    if (iter != supervisors.end()) {\n      return iter->second.promise.addBranch()\n          .then([this,context,grainId](Supervisor::Client client) mutable {\n        // We should send a keepAlive() to make sure the supervisor is still up. We should also\n        // send a new SandstormCore capability in case the front-end has restarted.\n        auto coreReq = coreFactory.getSandstormCoreRequest();\n        coreReq.setGrainId(grainId);\n        auto keepAliveReq = client.keepAliveRequest();\n        keepAliveReq.setCore(coreReq.send().getCore());\n        return keepAliveReq.send()\n            .then([context,KJ_MVCAP(client)](auto&&) mutable -> kj::Promise<void> {\n          context.getResults().setSupervisor(kj::mv(client));\n          return kj::READY_NOW;\n        }, [](kj::Exception&& e) -> kj::Promise<void> {\n          if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n            KJ_LOG(ERROR, \"Exception when trying to keepAlive() a supervisor in getGrain().\", e);\n            return KJ_EXCEPTION(DISCONNECTED, \"grain is not running\");\n          } else {\n            return kj::mv(e);\n          }\n        });\n      });\n    }\n}"
  },
  {
    "function_name": "startGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "238-246",
    "snippet": "kj::Promise<void> BackendImpl::startGrain(StartGrainContext context) {\n  auto params = context.getParams();\n  return bootGrain(validateId(params.getGrainId()),\n                   validateId(params.getPackageId()), params.getCommand(),\n                   params.getIsNew(), params.getDevMode(), params.getMountProc(), false)\n      .then([context](Supervisor::Client client) mutable {\n    context.getResults().setSupervisor(kj::mv(client));\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bootGrain",
          "args": [
            "[context](Supervisor::Client client) mutable {\n    context.getResults().setSupervisor(kj::mv(client));\n  }"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::mv(client)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "client"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bootGrain",
          "args": [
            "validateId(params.getGrainId())",
            "validateId(params.getPackageId())",
            "params.getCommand()",
            "params.getIsNew()",
            "params.getDevMode()",
            "params.getMountProc()",
            "false"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "bootGrain",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "62-183",
          "snippet": "kj::Promise<Supervisor::Client> BackendImpl::bootGrain(\n    kj::StringPtr grainId, kj::StringPtr packageId,\n    spk::Manifest::Command::Reader command, bool isNew, bool devMode, bool mountProc,\n    bool isRetry) {\n  auto iter = supervisors.find(grainId);\n  if (iter != supervisors.end()) {\n    KJ_REQUIRE(!isNew, \"new grain matched existing grainId\");\n\n    // Supervisor for this grain is already running. Join that.\n    return iter->second.promise.addBranch()\n        .then([=](Supervisor::Client&& client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      auto promise = keepAliveReq.send();\n      return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n        // Success.\n        return kj::mv(client);\n      }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n        // Exception?\n        if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n          // to unregister itself. Give it an extra turn using evalLater() just in case, then\n          // re-run.\n          KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n          return kj::evalLater([=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          });\n        } else {\n          return kj::mv(exception);\n        }\n      });\n    });\n  }\n\n  // Grain is not currently running, so let's start it.\n  kj::Own<kj::AsyncInputStream> stdoutPipe;\n  kj::Vector<kj::String> argv;\n\n  argv.add(kj::heapString(\"supervisor\"));\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    argv.add(kj::heapString(\"--uid\"));\n    argv.add(kj::str(*u));\n  }\n\n  if (isNew) {\n    argv.add(kj::heapString(\"-n\"));\n  }\n\n  if (devMode) {\n    argv.add(kj::heapString(\"--dev\"));\n\n    if (mountProc) {\n      argv.add(kj::heapString(\"--proc\"));\n    }\n  }\n\n  for (auto env: command.getEnviron()) {\n    argv.add(kj::str(\"-e\", env.getKey(), \"=\", env.getValue()));\n  }\n\n  argv.add(kj::heapString(packageId));\n  argv.add(kj::heapString(grainId));\n\n  argv.add(kj::heapString(\"--\"));\n\n  if (command.hasDeprecatedExecutablePath()) {\n    argv.add(kj::heapString(command.getDeprecatedExecutablePath()));\n  }\n  for (auto arg: command.getArgv()) {\n    argv.add(kj::heapString(arg));\n  }\n\n  Subprocess::Options options(KJ_MAP(a, argv) -> const kj::StringPtr { return a; });\n  options.executable = \"/sandstorm\";\n\n  if (sandboxUid != nullptr) {\n    // Supervisor must run as root since user namespaces are not available.\n    options.uid = uid_t(0);\n  }\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe2(pipefds, O_CLOEXEC));\n  kj::AutoCloseFd stdoutOut(pipefds[1]);\n  stdoutPipe = ioProvider.wrapInputFd(pipefds[0],\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n  options.stdout = stdoutOut;\n  Subprocess process(kj::mv(options));\n\n  // Wait until supervisor prints something on stdout, indicating that it is ready.\n  static byte dummy[256];\n  auto promise = stdoutPipe->read(dummy, 1, sizeof(dummy));\n\n  // Meanwhile parse the socket address.\n  auto addressPromise =\n      network.parseAddress(kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\"));\n\n  // When both of those are done, connect to the address.\n  auto finalPromise = promise\n      .then([this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n    return kj::mv(addressPromise);\n  }).then([](kj::Own<kj::NetworkAddress>&& address) {\n    return address->connect();\n  }).then([this,KJ_MVCAP(stdoutPipe),KJ_MVCAP(process),grainId = kj::heapString(grainId)]\n          (kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    // Connected. Create the RunningGrain and fulfill promises.\n    auto ignorePromise = ignoreAll(*stdoutPipe);\n    tasks.add(ignorePromise.attach(kj::mv(stdoutPipe)));\n\n    auto coreRequest = coreFactory.getSandstormCoreRequest();\n    coreRequest.setGrainId(grainId);\n    auto core = coreRequest.send().getCore();\n    auto grain = kj::heap<RunningGrain>(*this, kj::mv(grainId), kj::mv(connection), kj::mv(core));\n    auto client = grain->getSupervisor();\n    tasks.add(grain->onDisconnect().attach(kj::mv(grain), kj::mv(process)));\n    return client;\n  }",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<Supervisor::Client> BackendImpl::bootGrain(\n      kj::StringPtr grainId, kj::StringPtr packageId,\n      spk::Manifest::Command::Reader command, bool isNew, bool devMode, bool mountProc,\n      bool isRetry) {\n    auto iter = supervisors.find(grainId);\n    if (iter != supervisors.end()) {\n      KJ_REQUIRE(!isNew, \"new grain matched existing grainId\");\n  \n      // Supervisor for this grain is already running. Join that.\n      return iter->second.promise.addBranch()\n          .then([=](Supervisor::Client&& client) mutable {\n        // We should send a keepAlive() to make sure the supervisor is still up. We should also\n        // send a new SandstormCore capability in case the front-end has restarted.\n        auto coreReq = coreFactory.getSandstormCoreRequest();\n        coreReq.setGrainId(grainId);\n        auto keepAliveReq = client.keepAliveRequest();\n        keepAliveReq.setCore(coreReq.send().getCore());\n        auto promise = keepAliveReq.send();\n        return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n          // Success.\n          return kj::mv(client);\n        }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n          // Exception?\n          if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n            // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n            // to unregister itself. Give it an extra turn using evalLater() just in case, then\n            // re-run.\n            KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n            return kj::evalLater([=]() mutable {\n              return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n            });\n          } else {\n            return kj::mv(exception);\n          }\n        });\n      });\n    }\n  \n    // Grain is not currently running, so let's start it.\n    kj::Own<kj::AsyncInputStream> stdoutPipe;\n    kj::Vector<kj::String> argv;\n  \n    argv.add(kj::heapString(\"supervisor\"));\n  \n    KJ_IF_MAYBE(u, sandboxUid) {\n      argv.add(kj::heapString(\"--uid\"));\n      argv.add(kj::str(*u));\n    }\n  \n    if (isNew) {\n      argv.add(kj::heapString(\"-n\"));\n    }\n  \n    if (devMode) {\n      argv.add(kj::heapString(\"--dev\"));\n  \n      if (mountProc) {\n        argv.add(kj::heapString(\"--proc\"));\n      }\n    }\n  \n    for (auto env: command.getEnviron()) {\n      argv.add(kj::str(\"-e\", env.getKey(), \"=\", env.getValue()));\n    }\n  \n    argv.add(kj::heapString(packageId));\n    argv.add(kj::heapString(grainId));\n  \n    argv.add(kj::heapString(\"--\"));\n  \n    if (command.hasDeprecatedExecutablePath()) {\n      argv.add(kj::heapString(command.getDeprecatedExecutablePath()));\n    }\n    for (auto arg: command.getArgv()) {\n      argv.add(kj::heapString(arg));\n    }\n  \n    Subprocess::Options options(KJ_MAP(a, argv) -> const kj::StringPtr { return a; });\n    options.executable = \"/sandstorm\";\n  \n    if (sandboxUid != nullptr) {\n      // Supervisor must run as root since user namespaces are not available.\n      options.uid = uid_t(0);\n    }\n  \n    int pipefds[2];\n    KJ_SYSCALL(pipe2(pipefds, O_CLOEXEC));\n    kj::AutoCloseFd stdoutOut(pipefds[1]);\n    stdoutPipe = ioProvider.wrapInputFd(pipefds[0],\n        kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n        kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n    options.stdout = stdoutOut;\n    Subprocess process(kj::mv(options));\n  \n    // Wait until supervisor prints something on stdout, indicating that it is ready.\n    static byte dummy[256];\n    auto promise = stdoutPipe->read(dummy, 1, sizeof(dummy));\n  \n    // Meanwhile parse the socket address.\n    auto addressPromise =\n        network.parseAddress(kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\"));\n  \n    // When both of those are done, connect to the address.\n    auto finalPromise = promise\n        .then([this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n      return kj::mv(addressPromise);\n    }).then([](kj::Own<kj::NetworkAddress>&& address) {\n      return address->connect();\n    }).then([this,KJ_MVCAP(stdoutPipe),KJ_MVCAP(process),grainId = kj::heapString(grainId)]\n            (kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      // Connected. Create the RunningGrain and fulfill promises.\n      auto ignorePromise = ignoreAll(*stdoutPipe);\n      tasks.add(ignorePromise.attach(kj::mv(stdoutPipe)));\n  \n      auto coreRequest = coreFactory.getSandstormCoreRequest();\n      coreRequest.setGrainId(grainId);\n      auto core = coreRequest.send().getCore();\n      auto grain = kj::heap<RunningGrain>(*this, kj::mv(grainId), kj::mv(connection), kj::mv(core));\n      auto client = grain->getSupervisor();\n      tasks.add(grain->onDisconnect().attach(kj::mv(grain), kj::mv(process)));\n      return client;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getMountProc",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getDevMode",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getIsNew",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "getIsNew",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.h",
          "lines": "57-57",
          "snippet": "inline bool getIsNew() { return isNew; }",
          "includes": [
            "#include <kj/io.h>",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <capnp/capability.h>",
            "#include <kj/async-io.h>",
            "#include <kj/vector.h>",
            "#include \"util.h\"",
            "#include \"abstract-main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/io.h>\n#include <sandstorm/supervisor.capnp.h>\n#include <capnp/capability.h>\n#include <kj/async-io.h>\n#include <kj/vector.h>\n#include \"util.h\"\n#include \"abstract-main.h\"\n\nSupervisorMain {\n  inline bool getIsNew() { return isNew; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getCommand",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateId",
          "args": [
            "params.getPackageId()"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "validateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "27-30",
          "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getPackageId",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getGrainId",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "getGrainId",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "69-69",
          "snippet": "inline kj::StringPtr getGrainId() { return grainId; }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::StringPtr getGrainId() { return grainId; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::startGrain(StartGrainContext context) {\n    auto params = context.getParams();\n    return bootGrain(validateId(params.getGrainId()),\n                     validateId(params.getPackageId()), params.getCommand(),\n                     params.getIsNew(), params.getDevMode(), params.getMountProc(), false)\n        .then([context](Supervisor::Client client) mutable {\n      context.getResults().setSupervisor(kj::mv(client));\n    });\n  }\n}"
  },
  {
    "function_name": "ping",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "234-236",
    "snippet": "kj::Promise<void> BackendImpl::ping(PingContext context) {\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::ping(PingContext context) {\n    return kj::READY_NOW;\n  }\n}"
  },
  {
    "function_name": "~RunningGrain",
    "container": "BackendImpl::RunningGrain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "230-232",
    "snippet": "BackendImpl::RunningGrain::~RunningGrain() noexcept(false) {\n  backend.supervisors.erase(grainId);\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend.supervisors.erase",
          "args": [
            "grainId"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  RunningGrain {\n    BackendImpl::RunningGrain::~RunningGrain() noexcept(false) {\n      backend.supervisors.erase(grainId);\n    }\n  }\n}"
  },
  {
    "function_name": "RunningGrain",
    "container": "BackendImpl::RunningGrain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "224-228",
    "snippet": "BackendImpl::RunningGrain::RunningGrain(\n    BackendImpl& backend, kj::String grainId, kj::Own<kj::AsyncIoStream> stream,\n    SandstormCore::Client&& core)\n    : backend(backend), grainId(kj::mv(grainId)),\n      stream(kj::mv(stream)), client(*this->stream, kj::mv(core)) {}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "core"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "grainId"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  RunningGrain {\n    BackendImpl::RunningGrain::RunningGrain(\n        BackendImpl& backend, kj::String grainId, kj::Own<kj::AsyncIoStream> stream,\n        SandstormCore::Client&& core)\n        : backend(backend), grainId(kj::mv(grainId)),\n          stream(kj::mv(stream)), client(*this->stream, kj::mv(core)) {}\n  }\n}"
  },
  {
    "function_name": "readAll",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "209-222",
    "snippet": "kj::Promise<kj::String> BackendImpl::readAll(kj::AsyncInputStream& input, kj::Vector<char> soFar) {\n  soFar.resize(soFar.size() + 4096);\n  return input.tryRead(soFar.end() - 4096, 4096, 4096)\n      .then([KJ_MVCAP(soFar),&input](size_t n) mutable -> kj::Promise<kj::String> {\n    if (n < 4096) {\n      // Must be EOF.\n      soFar.resize(soFar.size() - 4096 + n);\n      soFar.add('\\0');\n      return kj::String(soFar.releaseAsArray());\n    } else {\n      return readAll(input, kj::mv(soFar));\n    }\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "input",
            "kj::mv(soFar)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "209-222",
          "snippet": "kj::Promise<kj::String> BackendImpl::readAll(kj::AsyncInputStream& input, kj::Vector<char> soFar) {\n  soFar.resize(soFar.size() + 4096);\n  return input.tryRead(soFar.end() - 4096, 4096, 4096)\n      .then([KJ_MVCAP(soFar),&input](size_t n) mutable -> kj::Promise<kj::String> {\n    if (n < 4096) {\n      // Must be EOF.\n      soFar.resize(soFar.size() - 4096 + n);\n      soFar.add('\\0');\n      return kj::String(soFar.releaseAsArray());\n    } else {\n      return readAll(input, kj::mv(soFar));\n    }\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "soFar"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "soFar.releaseAsArray()"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soFar.releaseAsArray",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soFar.add",
          "args": [
            "'\\0'"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soFar.resize",
          "args": [
            "soFar.size() - 4096 + n"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soFar.size",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "[KJ_MVCAP(soFar)",
            "&input](size_t n"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "soFar.end() - 4096",
            "4096",
            "4096"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "soFar.end",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soFar.resize",
          "args": [
            "soFar.size() + 4096"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<kj::String> BackendImpl::readAll(kj::AsyncInputStream& input, kj::Vector<char> soFar) {\n    soFar.resize(soFar.size() + 4096);\n    return input.tryRead(soFar.end() - 4096, 4096, 4096)\n        .then([KJ_MVCAP(soFar),&input](size_t n) mutable -> kj::Promise<kj::String> {\n      if (n < 4096) {\n        // Must be EOF.\n        soFar.resize(soFar.size() - 4096 + n);\n        soFar.add('\\0');\n        return kj::String(soFar.releaseAsArray());\n      } else {\n        return readAll(input, kj::mv(soFar));\n      }\n    });\n  }\n}"
  },
  {
    "function_name": "ignoreAll",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "197-207",
    "snippet": "kj::Promise<void> BackendImpl::ignoreAll(kj::AsyncInputStream& input) {\n  static byte dummy[256];\n  return input.tryRead(dummy, sizeof(dummy), sizeof(dummy))\n      .then([&input](size_t n) -> kj::Promise<void> {\n    if (n < sizeof(dummy)) {\n      return kj::READY_NOW;\n    } else {\n      return ignoreAll(input);\n    }\n  });\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "[&input](size_t n) -> kj::Promise<void> {\n    if (n < sizeof(dummy)) {\n      return kj::READY_NOW;\n    } else {\n      return ignoreAll(input);\n    }\n  }"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignoreAll",
          "args": [
            "input"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ignoreAll",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "197-207",
          "snippet": "kj::Promise<void> BackendImpl::ignoreAll(kj::AsyncInputStream& input) {\n  static byte dummy[256];\n  return input.tryRead(dummy, sizeof(dummy), sizeof(dummy))\n      .then([&input](size_t n) -> kj::Promise<void> {\n    if (n < sizeof(dummy)) {\n      return kj::READY_NOW;\n    } else {\n      return ignoreAll(input);\n    }\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "dummy",
            "sizeof(dummy)",
            "sizeof(dummy)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::ignoreAll(kj::AsyncInputStream& input) {\n    static byte dummy[256];\n    return input.tryRead(dummy, sizeof(dummy), sizeof(dummy))\n        .then([&input](size_t n) -> kj::Promise<void> {\n      if (n < sizeof(dummy)) {\n        return kj::READY_NOW;\n      } else {\n        return ignoreAll(input);\n      }\n    });\n  }\n}"
  },
  {
    "function_name": "bootGrain",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "62-183",
    "snippet": "kj::Promise<Supervisor::Client> BackendImpl::bootGrain(\n    kj::StringPtr grainId, kj::StringPtr packageId,\n    spk::Manifest::Command::Reader command, bool isNew, bool devMode, bool mountProc,\n    bool isRetry) {\n  auto iter = supervisors.find(grainId);\n  if (iter != supervisors.end()) {\n    KJ_REQUIRE(!isNew, \"new grain matched existing grainId\");\n\n    // Supervisor for this grain is already running. Join that.\n    return iter->second.promise.addBranch()\n        .then([=](Supervisor::Client&& client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      auto promise = keepAliveReq.send();\n      return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n        // Success.\n        return kj::mv(client);\n      }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n        // Exception?\n        if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n          // to unregister itself. Give it an extra turn using evalLater() just in case, then\n          // re-run.\n          KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n          return kj::evalLater([=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          });\n        } else {\n          return kj::mv(exception);\n        }\n      });\n    });\n  }\n\n  // Grain is not currently running, so let's start it.\n  kj::Own<kj::AsyncInputStream> stdoutPipe;\n  kj::Vector<kj::String> argv;\n\n  argv.add(kj::heapString(\"supervisor\"));\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    argv.add(kj::heapString(\"--uid\"));\n    argv.add(kj::str(*u));\n  }\n\n  if (isNew) {\n    argv.add(kj::heapString(\"-n\"));\n  }\n\n  if (devMode) {\n    argv.add(kj::heapString(\"--dev\"));\n\n    if (mountProc) {\n      argv.add(kj::heapString(\"--proc\"));\n    }\n  }\n\n  for (auto env: command.getEnviron()) {\n    argv.add(kj::str(\"-e\", env.getKey(), \"=\", env.getValue()));\n  }\n\n  argv.add(kj::heapString(packageId));\n  argv.add(kj::heapString(grainId));\n\n  argv.add(kj::heapString(\"--\"));\n\n  if (command.hasDeprecatedExecutablePath()) {\n    argv.add(kj::heapString(command.getDeprecatedExecutablePath()));\n  }\n  for (auto arg: command.getArgv()) {\n    argv.add(kj::heapString(arg));\n  }\n\n  Subprocess::Options options(KJ_MAP(a, argv) -> const kj::StringPtr { return a; });\n  options.executable = \"/sandstorm\";\n\n  if (sandboxUid != nullptr) {\n    // Supervisor must run as root since user namespaces are not available.\n    options.uid = uid_t(0);\n  }\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe2(pipefds, O_CLOEXEC));\n  kj::AutoCloseFd stdoutOut(pipefds[1]);\n  stdoutPipe = ioProvider.wrapInputFd(pipefds[0],\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n  options.stdout = stdoutOut;\n  Subprocess process(kj::mv(options));\n\n  // Wait until supervisor prints something on stdout, indicating that it is ready.\n  static byte dummy[256];\n  auto promise = stdoutPipe->read(dummy, 1, sizeof(dummy));\n\n  // Meanwhile parse the socket address.\n  auto addressPromise =\n      network.parseAddress(kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\"));\n\n  // When both of those are done, connect to the address.\n  auto finalPromise = promise\n      .then([this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n    return kj::mv(addressPromise);\n  }).then([](kj::Own<kj::NetworkAddress>&& address) {\n    return address->connect();\n  }).then([this,KJ_MVCAP(stdoutPipe),KJ_MVCAP(process),grainId = kj::heapString(grainId)]\n          (kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    // Connected. Create the RunningGrain and fulfill promises.\n    auto ignorePromise = ignoreAll(*stdoutPipe);\n    tasks.add(ignorePromise.attach(kj::mv(stdoutPipe)));\n\n    auto coreRequest = coreFactory.getSandstormCoreRequest();\n    coreRequest.setGrainId(grainId);\n    auto core = coreRequest.send().getCore();\n    auto grain = kj::heap<RunningGrain>(*this, kj::mv(grainId), kj::mv(connection), kj::mv(core));\n    auto client = grain->getSupervisor();\n    tasks.add(grain->onDisconnect().attach(kj::mv(grain), kj::mv(process)));\n    return client;\n  }",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "grain->onDisconnect().attach(kj::mv(grain), kj::mv(process))"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grain->onDisconnect",
          "args": [
            "kj::mv(grain)",
            "kj::mv(process)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "process"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "grain"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grain->onDisconnect",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "70-70",
          "snippet": "inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "grain->getSupervisor",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "getSupervisor",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "72-74",
          "snippet": "inline Supervisor::Client getSupervisor() {\n      return client.bootstrap().castAs<Supervisor>();\n    }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline Supervisor::Client getSupervisor() {\n          return client.bootstrap().castAs<Supervisor>();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<RunningGrain>",
          "args": [
            "*this",
            "kj::mv(grainId)",
            "kj::mv(connection)",
            "kj::mv(core)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "core"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connection"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "grainId"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreRequest.send",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreRequest.send",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreRequest.setGrainId",
          "args": [
            "grainId"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "setGrainId",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "619-625",
          "snippet": "kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n  if (id == nullptr || id.findFirst('/') != nullptr) {\n    return \"Invalid grain id.\";\n  }\n  grainId = kj::heapString(id);\n  return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n    if (id == nullptr || id.findFirst('/') != nullptr) {\n      return \"Invalid grain id.\";\n    }\n    grainId = kj::heapString(id);\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "coreFactory.getSandstormCoreRequest",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "ignorePromise.attach(kj::mv(stdoutPipe))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignorePromise.attach",
          "args": [
            "kj::mv(stdoutPipe)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stdoutPipe"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignoreAll",
          "args": [
            "*stdoutPipe"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ignoreAll",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "197-207",
          "snippet": "kj::Promise<void> BackendImpl::ignoreAll(kj::AsyncInputStream& input) {\n  static byte dummy[256];\n  return input.tryRead(dummy, sizeof(dummy), sizeof(dummy))\n      .then([&input](size_t n) -> kj::Promise<void> {\n    if (n < sizeof(dummy)) {\n      return kj::READY_NOW;\n    } else {\n      return ignoreAll(input);\n    }\n  });\n}",
          "includes": [
            "#include <stdio.h>  // rename()",
            "#include <capnp/serialize-async.h>",
            "#include <capnp/serialize.h>",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include \"backend.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<void> BackendImpl::ignoreAll(kj::AsyncInputStream& input) {\n    static byte dummy[256];\n    return input.tryRead(dummy, sizeof(dummy), sizeof(dummy))\n        .then([&input](size_t n) -> kj::Promise<void> {\n      if (n < sizeof(dummy)) {\n        return kj::READY_NOW;\n      } else {\n        return ignoreAll(input);\n      }\n    });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "]",
          "args": [
            "kj::Own<kj::AsyncIoStream>&& connection"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "grainId"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise\n      .then",
          "args": [
            "[](kj::Own<kj::NetworkAddress>&& address) {\n    return address->connect();\n  }"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address->connect",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise\n      .then",
          "args": [
            "[this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n    return kj::mv(addressPromise);\n  }"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addressPromise"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"unix:/var/sandstorm/grains/\"",
            "grainId",
            "\"/socket\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdoutPipe->read",
          "args": [
            "dummy",
            "1",
            "sizeof(dummy)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioProvider.wrapInputFd",
          "args": [
            "pipefds[0]",
            "kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe2(pipefds, O_CLOEXEC)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "pipefds",
            "O_CLOEXEC"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_t",
          "args": [
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(arg)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "arg"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.getArgv",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(command.getDeprecatedExecutablePath())"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "command.getDeprecatedExecutablePath()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.getDeprecatedExecutablePath",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.hasDeprecatedExecutablePath",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"--\")"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"--\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(grainId)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "grainId"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(packageId)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "packageId"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::str(\"-e\", env.getKey(), \"=\", env.getValue())"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"-e\"",
            "env.getKey()",
            "\"=\"",
            "env.getValue()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env.getValue",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env.getKey",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command.getEnviron",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"--proc\")"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"--proc\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"--dev\")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"--dev\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"-n\")"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"-n\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::str(*u)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "*u"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"--uid\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"--uid\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv.add",
          "args": [
            "kj::heapString(\"supervisor\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"supervisor\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [
            "[=](Supervisor::Client&& client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      auto promise = keepAliveReq.send();\n      return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n        // Success.\n        return kj::mv(client);\n      }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n        // Exception?\n        if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n          // to unregister itself. Give it an extra turn using evalLater() just in case, then\n          // re-run.\n          KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n          return kj::evalLater([=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          });\n        } else {\n          return kj::mv(exception);\n        }\n      });\n    }"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n        // Success.\n        return kj::mv(client);\n      }",
            "[=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n        // Exception?\n        if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n          // to unregister itself. Give it an extra turn using evalLater() just in case, then\n          // re-run.\n          KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n          return kj::evalLater([=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          });\n        } else {\n          return kj::mv(exception);\n        }\n      }"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "[=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          }"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bootGrain",
          "args": [
            "grainId",
            "packageId",
            "command",
            "isNew",
            "devMode",
            "mountProc",
            "true"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "bootGrain",
          "container": "BackendImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
          "lines": "62-183",
          "snippet": "kj::Promise<Supervisor::Client> BackendImpl::bootGrain(\n    kj::StringPtr grainId, kj::StringPtr packageId,\n    spk::Manifest::Command::Reader command, bool isNew, bool devMode, bool mountProc,\n    bool isRetry) {\n  auto iter = supervisors.find(grainId);\n  if (iter != supervisors.end()) {\n    KJ_REQUIRE(!isNew, \"new grain matched existing grainId\");\n\n    // Supervisor for this grain is already running. Join that.\n    return iter->second.promise.addBranch()\n        .then([=](Supervisor::Client&& client) mutable {\n      // We should send a keepAlive() to make sure the supervisor is still up. We should also\n      // send a new SandstormCore capability in case the front-end has restarted.\n      auto coreReq = coreFactory.getSandstormCoreRequest();\n      coreReq.setGrainId(grainId);\n      auto keepAliveReq = client.keepAliveRequest();\n      keepAliveReq.setCore(coreReq.send().getCore());\n      auto promise = keepAliveReq.send();\n      return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n        // Success.\n        return kj::mv(client);\n      }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n        // Exception?\n        if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n          // to unregister itself. Give it an extra turn using evalLater() just in case, then\n          // re-run.\n          KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n          return kj::evalLater([=]() mutable {\n            return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n          });\n        } else {\n          return kj::mv(exception);\n        }\n      });\n    });\n  }\n\n  // Grain is not currently running, so let's start it.\n  kj::Own<kj::AsyncInputStream> stdoutPipe;\n  kj::Vector<kj::String> argv;\n\n  argv.add(kj::heapString(\"supervisor\"));\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    argv.add(kj::heapString(\"--uid\"));\n    argv.add(kj::str(*u));\n  }\n\n  if (isNew) {\n    argv.add(kj::heapString(\"-n\"));\n  }\n\n  if (devMode) {\n    argv.add(kj::heapString(\"--dev\"));\n\n    if (mountProc) {\n      argv.add(kj::heapString(\"--proc\"));\n    }\n  }\n\n  for (auto env: command.getEnviron()) {\n    argv.add(kj::str(\"-e\", env.getKey(), \"=\", env.getValue()));\n  }\n\n  argv.add(kj::heapString(packageId));\n  argv.add(kj::heapString(grainId));\n\n  argv.add(kj::heapString(\"--\"));\n\n  if (command.hasDeprecatedExecutablePath()) {\n    argv.add(kj::heapString(command.getDeprecatedExecutablePath()));\n  }\n  for (auto arg: command.getArgv()) {\n    argv.add(kj::heapString(arg));\n  }\n\n  Subprocess::Options options(KJ_MAP(a, argv) -> const kj::StringPtr { return a; });\n  options.executable = \"/sandstorm\";\n\n  if (sandboxUid != nullptr) {\n    // Supervisor must run as root since user namespaces are not available.\n    options.uid = uid_t(0);\n  }\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe2(pipefds, O_CLOEXEC));\n  kj::AutoCloseFd stdoutOut(pipefds[1]);\n  stdoutPipe = ioProvider.wrapInputFd(pipefds[0],\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n  options.stdout = stdoutOut;\n  Subprocess process(kj::mv(options));\n\n  // Wait until supervisor prints something on stdout, indicating that it is ready.\n  static byte dummy[256];\n  auto promise = stdoutPipe->read(dummy, 1, sizeof(dummy));\n\n  // Meanwhile parse the socket address.\n  auto addressPromise =\n      network.parseAddress(kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\"));\n\n  // When both of those are done, connect to the address.\n  auto finalPromise = promise\n      .then([this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n    return kj::mv(addressPromise);\n  }).then([](kj::Own<kj::NetworkAddress>&& address) {\n    return address->connect();\n  }).then([this,KJ_MVCAP(stdoutPipe),KJ_MVCAP(process),grainId = kj::heapString(grainId)]\n          (kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    // Connected. Create the RunningGrain and fulfill promises.\n    auto ignorePromise = ignoreAll(*stdoutPipe);\n    tasks.add(ignorePromise.attach(kj::mv(stdoutPipe)));\n\n    auto coreRequest = coreFactory.getSandstormCoreRequest();\n    coreRequest.setGrainId(grainId);\n    auto core = coreRequest.send().getCore();\n    auto grain = kj::heap<RunningGrain>(*this, kj::mv(grainId), kj::mv(connection), kj::mv(core));\n    auto client = grain->getSupervisor();\n    tasks.add(grain->onDisconnect().attach(kj::mv(grain), kj::mv(process)));\n    return client;\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "!isRetry",
            "\"retry supervisor startup logic failed\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getType",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "client"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keepAliveReq.send",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keepAliveReq.setCore",
          "args": [
            "coreReq.send().getCore()"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreReq.send",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreReq.send",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.keepAliveRequest",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coreFactory.getSandstormCoreRequest",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.promise.addBranch",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!isNew",
            "\"new grain matched existing grainId\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.end",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supervisors.find",
          "args": [
            "grainId"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  kj::Promise<Supervisor::Client> BackendImpl::bootGrain(\n      kj::StringPtr grainId, kj::StringPtr packageId,\n      spk::Manifest::Command::Reader command, bool isNew, bool devMode, bool mountProc,\n      bool isRetry) {\n    auto iter = supervisors.find(grainId);\n    if (iter != supervisors.end()) {\n      KJ_REQUIRE(!isNew, \"new grain matched existing grainId\");\n  \n      // Supervisor for this grain is already running. Join that.\n      return iter->second.promise.addBranch()\n          .then([=](Supervisor::Client&& client) mutable {\n        // We should send a keepAlive() to make sure the supervisor is still up. We should also\n        // send a new SandstormCore capability in case the front-end has restarted.\n        auto coreReq = coreFactory.getSandstormCoreRequest();\n        coreReq.setGrainId(grainId);\n        auto keepAliveReq = client.keepAliveRequest();\n        keepAliveReq.setCore(coreReq.send().getCore());\n        auto promise = keepAliveReq.send();\n        return promise.then([KJ_MVCAP(client)](auto) mutable -> kj::Promise<Supervisor::Client> {\n          // Success.\n          return kj::mv(client);\n        }, [=](kj::Exception&& exception) mutable -> kj::Promise<Supervisor::Client> {\n          // Exception?\n          if (exception.getType() == kj::Exception::Type::DISCONNECTED) {\n            // Oops, disconnected. onDisconnect() should have already fired causing the RunningGrain\n            // to unregister itself. Give it an extra turn using evalLater() just in case, then\n            // re-run.\n            KJ_ASSERT(!isRetry, \"retry supervisor startup logic failed\");\n            return kj::evalLater([=]() mutable {\n              return bootGrain(grainId, packageId, command, isNew, devMode, mountProc, true);\n            });\n          } else {\n            return kj::mv(exception);\n          }\n        });\n      });\n    }\n  \n    // Grain is not currently running, so let's start it.\n    kj::Own<kj::AsyncInputStream> stdoutPipe;\n    kj::Vector<kj::String> argv;\n  \n    argv.add(kj::heapString(\"supervisor\"));\n  \n    KJ_IF_MAYBE(u, sandboxUid) {\n      argv.add(kj::heapString(\"--uid\"));\n      argv.add(kj::str(*u));\n    }\n  \n    if (isNew) {\n      argv.add(kj::heapString(\"-n\"));\n    }\n  \n    if (devMode) {\n      argv.add(kj::heapString(\"--dev\"));\n  \n      if (mountProc) {\n        argv.add(kj::heapString(\"--proc\"));\n      }\n    }\n  \n    for (auto env: command.getEnviron()) {\n      argv.add(kj::str(\"-e\", env.getKey(), \"=\", env.getValue()));\n    }\n  \n    argv.add(kj::heapString(packageId));\n    argv.add(kj::heapString(grainId));\n  \n    argv.add(kj::heapString(\"--\"));\n  \n    if (command.hasDeprecatedExecutablePath()) {\n      argv.add(kj::heapString(command.getDeprecatedExecutablePath()));\n    }\n    for (auto arg: command.getArgv()) {\n      argv.add(kj::heapString(arg));\n    }\n  \n    Subprocess::Options options(KJ_MAP(a, argv) -> const kj::StringPtr { return a; });\n    options.executable = \"/sandstorm\";\n  \n    if (sandboxUid != nullptr) {\n      // Supervisor must run as root since user namespaces are not available.\n      options.uid = uid_t(0);\n    }\n  \n    int pipefds[2];\n    KJ_SYSCALL(pipe2(pipefds, O_CLOEXEC));\n    kj::AutoCloseFd stdoutOut(pipefds[1]);\n    stdoutPipe = ioProvider.wrapInputFd(pipefds[0],\n        kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP |\n        kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC);\n    options.stdout = stdoutOut;\n    Subprocess process(kj::mv(options));\n  \n    // Wait until supervisor prints something on stdout, indicating that it is ready.\n    static byte dummy[256];\n    auto promise = stdoutPipe->read(dummy, 1, sizeof(dummy));\n  \n    // Meanwhile parse the socket address.\n    auto addressPromise =\n        network.parseAddress(kj::str(\"unix:/var/sandstorm/grains/\", grainId, \"/socket\"));\n  \n    // When both of those are done, connect to the address.\n    auto finalPromise = promise\n        .then([this,KJ_MVCAP(addressPromise)](size_t n) mutable {\n      return kj::mv(addressPromise);\n    }).then([](kj::Own<kj::NetworkAddress>&& address) {\n      return address->connect();\n    }).then([this,KJ_MVCAP(stdoutPipe),KJ_MVCAP(process),grainId = kj::heapString(grainId)]\n            (kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      // Connected. Create the RunningGrain and fulfill promises.\n      auto ignorePromise = ignoreAll(*stdoutPipe);\n      tasks.add(ignorePromise.attach(kj::mv(stdoutPipe)));\n  \n      auto coreRequest = coreFactory.getSandstormCoreRequest();\n      coreRequest.setGrainId(grainId);\n      auto core = coreRequest.send().getCore();\n      auto grain = kj::heap<RunningGrain>(*this, kj::mv(grainId), kj::mv(connection), kj::mv(core));\n      auto client = grain->getSupervisor();\n      tasks.add(grain->onDisconnect().attach(kj::mv(grain), kj::mv(process)));\n      return client;\n    }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "56-58",
    "snippet": "void BackendImpl::taskFailed(kj::Exception&& exception) {\n  KJ_LOG(ERROR, exception);\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  void BackendImpl::taskFailed(kj::Exception&& exception) {\n    KJ_LOG(ERROR, exception);\n  }\n}"
  },
  {
    "function_name": "BackendImpl",
    "container": "BackendImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "51-54",
    "snippet": "BackendImpl::BackendImpl(kj::LowLevelAsyncIoProvider& ioProvider, kj::Network& network,\n  SandstormCoreFactory::Client&& sandstormCoreFactory, kj::Maybe<uid_t> sandboxUid)\n    : ioProvider(ioProvider), network(network), coreFactory(kj::mv(sandstormCoreFactory)),\n      sandboxUid(sandboxUid), tasks(*this) {}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sandstormCoreFactory"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nBackendImpl {\n  BackendImpl::BackendImpl(kj::LowLevelAsyncIoProvider& ioProvider, kj::Network& network,\n    SandstormCoreFactory::Client&& sandstormCoreFactory, kj::Maybe<uid_t> sandboxUid)\n      : ioProvider(ioProvider), network(network), coreFactory(kj::mv(sandstormCoreFactory)),\n        sandboxUid(sandboxUid), tasks(*this) {}\n}"
  },
  {
    "function_name": "tryRecursivelyDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "32-49",
    "snippet": "static void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recursivelyDelete",
          "args": [
            "tmpPath"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "299-313",
          "snippet": "void recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"rename(path, tmpPath)\"",
            "error",
            "path",
            "tmpPath"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "path.cStr()",
            "tmpPath.cStr()"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpPath.cStr",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/tmp/deleting.\"",
            "time(nullptr)",
            "\".\"",
            "counter++"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "nullptr"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!path.endsWith(\"/\")",
            "\"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic void tryRecursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  static uint counter = 0;\n  auto tmpPath = kj::str(\"/var/sandstorm/tmp/deleting.\", time(nullptr), \".\", counter++);\n\n  while (rename(path.cStr(), tmpPath.cStr()) < 0) {\n    int error = errno;\n    if (error == ENOENT) {\n      return;\n    } else if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"rename(path, tmpPath)\", error, path, tmpPath);\n    }\n  }\n\n  recursivelyDelete(tmpPath);\n}"
  },
  {
    "function_name": "validateId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.c++",
    "lines": "27-30",
    "snippet": "static kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}",
    "includes": [
      "#include <stdio.h>  // rename()",
      "#include <capnp/serialize-async.h>",
      "#include <capnp/serialize.h>",
      "#include \"spk.h\"",
      "#include \"util.h\"",
      "#include <kj/debug.h>",
      "#include \"backend.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr",
            "id"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id.findFirst",
          "args": [
            "'/'"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id.startsWith",
          "args": [
            "\".\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id.size",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>  // rename()\n#include <capnp/serialize-async.h>\n#include <capnp/serialize.h>\n#include \"spk.h\"\n#include \"util.h\"\n#include <kj/debug.h>\n#include \"backend.h\"\n\nstatic kj::StringPtr validateId(kj::StringPtr id) {\n  KJ_REQUIRE(id.size() >= 8 && !id.startsWith(\".\") && id.findFirst('/') == nullptr, id);\n  return id;\n}"
  }
]