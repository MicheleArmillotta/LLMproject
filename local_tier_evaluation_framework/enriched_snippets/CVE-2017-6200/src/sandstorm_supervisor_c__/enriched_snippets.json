[
  {
    "function_name": "runSupervisor",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2309-2407",
    "snippet": "[[noreturn]] void SupervisorMain::runSupervisor(int apiFd, kj::AutoCloseFd startEventFd) {\n  // We're currently in a somewhat dangerous state: our root directory is controlled\n  // by the app.  If glibc reads, say, /etc/nsswitch.conf, the grain could take control\n  // of the supervisor.  Fix this by chrooting to the supervisor directory.\n  // TODO(someday): chroot somewhere that's guaranteed to be empty instead, so that if the\n  //   supervisor storage is itself compromised it can't be used to execute arbitrary code in\n  //   the supervisor process.\n  KJ_SYSCALL(chroot(\".\"));\n\n  permanentlyDropSuperuser();\n  setupSeccomp();\n\n  // TODO(soon): Somehow make sure all grandchildren die if supervisor dies. Currently SIGKILL\n  //   on the supervisor won't give it a chance to kill the sandbox pid tree. Perhaps the\n  //   supervisor should actually be the app's root process? We'd have to more carefully handle\n  //   SIGCHLD in that case and also worry about signals sent from the app process.\n\n  kj::UnixEventPort::captureSignal(SIGCHLD);\n  auto ioContext = kj::setupAsyncIo();\n\n  // Detect child exit.\n  auto exitPromise = ioContext.unixEventPort.onSignal(SIGCHLD).then([this](siginfo_t info) {\n    KJ_ASSERT(childPid != 0);\n    int status;\n    KJ_SYSCALL(waitpid(childPid, &status, 0));\n    childPid = 0;\n    KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n    if (WIFSIGNALED(status)) {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n          \" (\", strsignal(WTERMSIG(status)), \").\"));\n    } else {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status)));\n    }\n  }).eagerlyEvaluate([this](kj::Exception&& e) {\n    context.exitError(kj::str(\n        \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e));\n  });\n\n  auto coreRedirector = kj::refcounted<CapRedirector>();\n  SandstormCore::Client coreCap = static_cast<capnp::Capability::Client>(\n    kj::addRef(*coreRedirector)).castAs<SandstormCore>();\n  SupervisorRealmGateway::Client gateway = kj::heap<SupervisorRealmGatewayImpl>(coreCap);\n\n  // Compute grain size and watch for changes.\n  DiskUsageWatcher diskWatcher(ioContext.unixEventPort, ioContext.provider->getTimer(), coreCap);\n  auto diskWatcherTask = diskWatcher.init();\n\n  // Set up the RPC connection to the app and export the supervisor interface.\n  auto appConnection = ioContext.lowLevelProvider->wrapSocketFd(apiFd,\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC |\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP);\n  capnp::TwoPartyVatNetwork appNetwork(*appConnection, capnp::rpc::twoparty::Side::SERVER);\n  WakelockSet wakelockSet(grainId, coreCap);\n  auto server = capnp::makeRpcServer(appNetwork, kj::heap<SandstormApiImpl>(wakelockSet, grainId,\n      coreCap), kj::mv(gateway));\n\n  // Limit outstanding calls from the app to 1MiW (8MiB) in order to prevent an errant or malicious\n  // app from consuming excessive RAM elsewhere in the system.\n  server.setFlowLimit(1u << 20);\n\n  // Get the app's UiView by restoring a null SturdyRef from it.\n  capnp::MallocMessageBuilder message;\n  auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n  hostId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n  MainView<>::Client app = server.bootstrap(hostId).castAs<MainView<>>();\n\n  // Set up the external RPC interface, re-exporting the UiView.\n  // TODO(someday):  If there are multiple front-ends, or the front-ends restart a lot, we'll\n  //   want to wrap the UiView and cache session objects.  Perhaps we could do this by making\n  //   them persistable, though it's unclear how that would work with SessionContext.\n  Supervisor::Client mainCap = kj::heap<SupervisorImpl>(\n      ioContext.unixEventPort, kj::mv(app), wakelockSet, kj::mv(startEventFd),\n      coreCap, kj::addRef(*coreRedirector));\n\n  auto acceptTask = systemConnector->run(ioContext, kj::mv(mainCap), kj::mv(coreRedirector));\n\n  // Wait for disconnect or accept loop failure or disk watch failure, then exit. Also rotate log\n  // every 512k (thus having at most 1MB of logs at a time).\n  acceptTask.exclusiveJoin(kj::mv(diskWatcherTask))\n            .exclusiveJoin(appNetwork.onDisconnect())\n            .exclusiveJoin(rotateLog(ioContext.provider->getTimer(),\n                                     STDERR_FILENO, \"log\", 512u << 10))\n            .wait(ioContext.waitScope);\n\n  // Only onDisconnect() would return normally (rather than throw), so the app must have\n  // disconnected (i.e. from the Cap'n Proto API socket).\n\n  // Hmm, app disconnected API socket. The app probably exited and we just haven't gotten the\n  // signal yet, so sleep for a moment to let it arrive, so that we can report the exit status.\n  // Otherwise kill.\n  ioContext.provider->getTimer().afterDelay(1 * kj::SECONDS)\n      .exclusiveJoin(kj::mv(exitPromise))\n      .wait(ioContext.waitScope);\n\n  SANDSTORM_LOG(\"App disconnected API socket but didn't actually exit; killing it.\");\n  killChildAndExit(1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;",
      "kj::Own<CapRedirector> coreRedirector;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "killChildAndExit",
          "args": [
            "1"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "killChildAndExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "474-480",
          "snippet": "[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"App disconnected API socket but didn't actually exit; killing it.\""
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "kj::mv(exitPromise)"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exitPromise"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "1 * kj::SECONDS"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptTask.exclusiveJoin",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptTask.exclusiveJoin",
          "args": [
            "rotateLog(ioContext.provider->getTimer(),\n                                     STDERR_FILENO, \"log\", 512u << 10)"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rotateLog",
          "args": [
            "ioContext.provider->getTimer()",
            "STDERR_FILENO",
            "\"log\"",
            "512u << 10"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "rotateLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "480-513",
          "snippet": "kj::Promise<void> rotateLog(kj::Timer& timer, int logFd, kj::StringPtr path, size_t threshold) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(logFd, &stats));\n  if (stats.st_size >= threshold) {\n    // TODO(someday): If .1 exists, we could move it to .2, which we could move to .3, etc. We could\n    //   also gzip older logs to save space. But does anyone actually care? Probably not? Note that\n    //   if this changes, the lseek() below probably needs to be replaced with something more\n    //   sophisticated.\n    auto out = raiiOpen(kj::str(path, \".1\"), O_WRONLY | O_CREAT | O_TRUNC);\n\n    // `logFd` might be write-only, so we reopen it for read.\n    auto in = raiiOpen(path, O_RDONLY);\n\n    // Only copy over the last `threshold` bytes of the log. We do this specifically to help deal\n    // with old grains that grew enormous logs before log rotation was introduced -- we'd like them\n    // to chop their logs down to size the first time they are opened. Note that this means \"log.1\"\n    // will tend to start mid-line, which is ugly, but it's probably not worth trying to avoid.\n    KJ_SYSCALL(lseek(in, stats.st_size - threshold, SEEK_SET));\n\n    // Transfer data using `sendfile()` to avoid unnecessary copies and context switches.\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = sendfile(out, in, nullptr, threshold));\n      if (n == 0) break;\n    }\n\n    // EOF. Quick, truncate before any other log data appears.\n    KJ_SYSCALL(ftruncate(logFd, 0));\n  }\n\n  return timer.afterDelay(5 * kj::MINUTES).then([=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  });\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Promise<void> rotateLog(kj::Timer& timer, int logFd, kj::StringPtr path, size_t threshold) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(logFd, &stats));\n  if (stats.st_size >= threshold) {\n    // TODO(someday): If .1 exists, we could move it to .2, which we could move to .3, etc. We could\n    //   also gzip older logs to save space. But does anyone actually care? Probably not? Note that\n    //   if this changes, the lseek() below probably needs to be replaced with something more\n    //   sophisticated.\n    auto out = raiiOpen(kj::str(path, \".1\"), O_WRONLY | O_CREAT | O_TRUNC);\n\n    // `logFd` might be write-only, so we reopen it for read.\n    auto in = raiiOpen(path, O_RDONLY);\n\n    // Only copy over the last `threshold` bytes of the log. We do this specifically to help deal\n    // with old grains that grew enormous logs before log rotation was introduced -- we'd like them\n    // to chop their logs down to size the first time they are opened. Note that this means \"log.1\"\n    // will tend to start mid-line, which is ugly, but it's probably not worth trying to avoid.\n    KJ_SYSCALL(lseek(in, stats.st_size - threshold, SEEK_SET));\n\n    // Transfer data using `sendfile()` to avoid unnecessary copies and context switches.\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = sendfile(out, in, nullptr, threshold));\n      if (n == 0) break;\n    }\n\n    // EOF. Quick, truncate before any other log data appears.\n    KJ_SYSCALL(ftruncate(logFd, 0));\n  }\n\n  return timer.afterDelay(5 * kj::MINUTES).then([=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  });\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptTask.exclusiveJoin",
          "args": [
            "appNetwork.onDisconnect()"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appNetwork.onDisconnect",
          "args": [],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "70-70",
          "snippet": "inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "acceptTask.exclusiveJoin",
          "args": [
            "kj::mv(diskWatcherTask)"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "diskWatcherTask"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systemConnector->run",
          "args": [
            "ioContext",
            "kj::mv(mainCap)",
            "kj::mv(coreRedirector)"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "SupervisorMain::DefaultSystemConnector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2288-2304",
          "snippet": "kj::Promise<void> SupervisorMain::DefaultSystemConnector::run(\n    kj::AsyncIoContext& ioContext, Supervisor::Client mainCap,\n    kj::Own<CapRedirector> coreRedirector) const {\n  auto listener = kj::heap<TwoPartyServerWithClientBootstrap>(\n      kj::mv(mainCap), kj::mv(coreRedirector));\n\n  unlink(\"socket\");  // Clear stale socket, if any.\n  return ioContext.provider->getNetwork().parseAddress(\"unix:socket\", 0).then(\n      [KJ_MVCAP(listener)](kj::Own<kj::NetworkAddress>&& addr) mutable {\n    auto serverPort = addr->listen();\n\n    // The front-end knows we're ready to accept connections when we write something to stdout.\n    KJ_SYSCALL(write(STDOUT_FILENO, \"Listening...\\n\", strlen(\"Listening...\\n\")));\n\n    auto promise = listener->listen(kj::mv(serverPort));\n    return promise.attach(kj::mv(listener));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<CapRedirector> coreRedirector;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Own<CapRedirector> coreRedirector;\n\nSupervisorMain {\n  DefaultSystemConnector {\n    kj::Promise<void> SupervisorMain::DefaultSystemConnector::run(\n        kj::AsyncIoContext& ioContext, Supervisor::Client mainCap,\n        kj::Own<CapRedirector> coreRedirector) const {\n      auto listener = kj::heap<TwoPartyServerWithClientBootstrap>(\n          kj::mv(mainCap), kj::mv(coreRedirector));\n    \n      unlink(\"socket\");  // Clear stale socket, if any.\n      return ioContext.provider->getNetwork().parseAddress(\"unix:socket\", 0).then(\n          [KJ_MVCAP(listener)](kj::Own<kj::NetworkAddress>&& addr) mutable {\n        auto serverPort = addr->listen();\n    \n        // The front-end knows we're ready to accept connections when we write something to stdout.\n        KJ_SYSCALL(write(STDOUT_FILENO, \"Listening...\\n\", strlen(\"Listening...\\n\")));\n    \n        auto promise = listener->listen(kj::mv(serverPort));\n        return promise.attach(kj::mv(listener));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "coreRedirector"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainCap"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<SupervisorImpl>",
          "args": [
            "ioContext.unixEventPort",
            "kj::mv(app)",
            "wakelockSet",
            "kj::mv(startEventFd)",
            "coreCap",
            "kj::addRef(*coreRedirector)"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*coreRedirector"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "startEventFd"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "app"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.bootstrap",
          "args": [],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.bootstrap",
          "args": [
            "hostId"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "capnp::rpc::twoparty::Side::CLIENT"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.initRoot<capnp::rpc::twoparty::VatId>",
          "args": [],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.setFlowLimit",
          "args": [
            "1u << 20"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::makeRpcServer",
          "args": [
            "appNetwork",
            "kj::heap<SandstormApiImpl>(wakelockSet, grainId,\n      coreCap)",
            "kj::mv(gateway)"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "gateway"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<SandstormApiImpl>",
          "args": [
            "wakelockSet",
            "grainId",
            "coreCap"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.lowLevelProvider->wrapSocketFd",
          "args": [
            "apiFd",
            "kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC |\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diskWatcher.init",
          "args": [],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "98-118",
          "snippet": "kj::Promise<void> init() {\n    // Start watching the current directory.\n\n    // Note: this function is also called to restart watching from scratch when the inotify event\n    //   queue overflows (hopefully rare).\n\n    int fd;\n    KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n    inotifyFd = kj::AutoCloseFd(fd);\n\n    // Note that because we create the FdObserver before creating any watches, we don't have\n    // to worry about the possibility that we missed an event between creation of the fd and\n    // creation of the FdObserver.\n    observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n        kj::UnixEventPort::FdObserver::OBSERVE_READ);\n\n    totalSize = 0;\n    watchMap.clear();\n    pendingWatches.add(nullptr);  // root directory\n    return readLoop();\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> init() {\n      // Start watching the current directory.\n  \n      // Note: this function is also called to restart watching from scratch when the inotify event\n      //   queue overflows (hopefully rare).\n  \n      int fd;\n      KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      inotifyFd = kj::AutoCloseFd(fd);\n  \n      // Note that because we create the FdObserver before creating any watches, we don't have\n      // to worry about the possibility that we missed an event between creation of the fd and\n      // creation of the FdObserver.\n      observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n          kj::UnixEventPort::FdObserver::OBSERVE_READ);\n  \n      totalSize = 0;\n      watchMap.clear();\n      pendingWatches.add(nullptr);  // root directory\n      return readLoop();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<SupervisorRealmGatewayImpl>",
          "args": [
            "coreCap"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<capnp::Capability::Client>",
          "args": [],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<capnp::Capability::Client>",
          "args": [
            "kj::addRef(*coreRedirector)"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*coreRedirector"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<CapRedirector>",
          "args": [],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.unixEventPort.onSignal",
          "args": [
            "[this](kj::Exception&& e) {\n    context.exitError(kj::str(\n        \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e));\n  }"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n        \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e)"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\"",
            "e"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.unixEventPort.onSignal",
          "args": [
            "[this](siginfo_t info) {\n    KJ_ASSERT(childPid != 0);\n    int status;\n    KJ_SYSCALL(waitpid(childPid, &status, 0));\n    childPid = 0;\n    KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n    if (WIFSIGNALED(status)) {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n          \" (\", strsignal(WTERMSIG(status)), \").\"));\n    } else {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status)));\n    }\n  }"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status))"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** SANDSTORM SUPERVISOR: App exited with status code: \"",
            "WEXITSTATUS(status)"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n          \" (\", strsignal(WTERMSIG(status)), \").\")"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"** SANDSTORM SUPERVISOR: App exited due to signal \"",
            "WTERMSIG(status)",
            "\" (\"",
            "strsignal(WTERMSIG(status))",
            "\").\""
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "WTERMSIG(status)"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "WIFEXITED(status) || WIFSIGNALED(status)"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitpid(childPid, &status, 0)"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "childPid",
            "&status",
            "0"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "childPid != 0"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.unixEventPort.onSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupSeccomp",
          "args": [],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "setupSeccomp",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1067-1210",
          "snippet": "void SupervisorMain::setupSeccomp() {\n  // Install a rudimentary seccomp blacklist.\n  // TODO(security): Change this to a whitelist.\n\n  scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n  if (ctx == nullptr)\n    KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n  KJ_DEFER(seccomp_release(ctx));\n\n#define CHECK_SECCOMP(call)                   \\\n  do {                                        \\\n    if (auto result = (call)) {               \\\n      KJ_FAIL_SYSCALL(#call, -result);        \\\n    }                                         \\\n  } while (0)\n\n  // Native code only for now, so there are no seccomp_arch_add calls.\n\n  // Redundant, but this is standard and harmless.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n\n  // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n  // should fail, but there's no need to kill the issuer.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n  // Disable some things that seem scary.\n  if (!devmode) {\n    // ptrace is scary\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n  } else {\n    // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n    // orig_ax using ptrace allows a complete seccomp bypass.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n  }\n\n  // Restrict the set of allowable network protocol families\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n\n  // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n  // of interesting information leaks.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n\n  // Despite existing at a 64-bit syscall, set_thread_area is only useful\n  // for 32-bit programs.  64-bit programs use arch_prctl instead.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n\n  // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n      SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n\n  // AIO is scary.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n\n  // Scary vm syscalls\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n\n  // Scary futex operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n\n  // Utterly terrifying profiling operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n\n  // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n  // that run in-kernel (albeit with a very limited instruction set).\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n      SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n\n  // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n  // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n  //   disable things until we've reviewed them?\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n\n  // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n\n  // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n\n  if (seccompDumpPfc) {\n    seccomp_export_pfc(ctx, 1);\n  }\n\n  CHECK_SECCOMP(seccomp_load(ctx));\n\n#pragma GCC diagnostic pop\n#undef CHECK_SECCOMP\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto result = kj::heapString(cResult);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nSupervisorMain {\n  void SupervisorMain::setupSeccomp() {\n    // Install a rudimentary seccomp blacklist.\n    // TODO(security): Change this to a whitelist.\n  \n    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n    if (ctx == nullptr)\n      KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n    KJ_DEFER(seccomp_release(ctx));\n  \n  #define CHECK_SECCOMP(call)                   \\\n    do {                                        \\\n      if (auto result = (call)) {               \\\n        KJ_FAIL_SYSCALL(#call, -result);        \\\n      }                                         \\\n    } while (0)\n  \n    // Native code only for now, so there are no seccomp_arch_add calls.\n  \n    // Redundant, but this is standard and harmless.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n  \n    // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n    // should fail, but there's no need to kill the issuer.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n  \n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n    // Disable some things that seem scary.\n    if (!devmode) {\n      // ptrace is scary\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n    } else {\n      // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n      // orig_ax using ptrace allows a complete seccomp bypass.\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n    }\n  \n    // Restrict the set of allowable network protocol families\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n  \n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n  \n    // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n    // of interesting information leaks.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n  \n    // Despite existing at a 64-bit syscall, set_thread_area is only useful\n    // for 32-bit programs.  64-bit programs use arch_prctl instead.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n  \n    // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n        SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n  \n    // AIO is scary.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n  \n    // Scary vm syscalls\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n  \n    // Scary futex operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n  \n    // Utterly terrifying profiling operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n  \n    // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n    // that run in-kernel (albeit with a very limited instruction set).\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n        SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n  \n    // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n    // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n    //   disable things until we've reviewed them?\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n  \n    // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n  \n    // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n  \n    if (seccompDumpPfc) {\n      seccomp_export_pfc(ctx, 1);\n    }\n  \n    CHECK_SECCOMP(seccomp_load(ctx));\n  \n  #pragma GCC diagnostic pop\n  #undef CHECK_SECCOMP\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "permanentlyDropSuperuser",
          "args": [],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "permanentlyDropSuperuser",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1508-1525",
          "snippet": "void SupervisorMain::permanentlyDropSuperuser() {\n  KJ_IF_MAYBE(ruid, sandboxUid) {\n    // setuid() to non-zero implicitly drops capabilities.\n    KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n  } else {\n    // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n    // object-capabilities, hence the quotes.)\n    //\n    // This unfortunately must be performed post-fork (in both parent and child), because the child\n    // needs to do one final unshare().\n\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::permanentlyDropSuperuser() {\n    KJ_IF_MAYBE(ruid, sandboxUid) {\n      // setuid() to non-zero implicitly drops capabilities.\n      KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n    } else {\n      // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n      // object-capabilities, hence the quotes.)\n      //\n      // This unfortunately must be performed post-fork (in both parent and child), because the child\n      // needs to do one final unshare().\n  \n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "chroot(\".\")"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "\".\""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\nkj::Own<CapRedirector> coreRedirector;\n\nSupervisorMain {\n  [[noreturn]] void SupervisorMain::runSupervisor(int apiFd, kj::AutoCloseFd startEventFd) {\n    // We're currently in a somewhat dangerous state: our root directory is controlled\n    // by the app.  If glibc reads, say, /etc/nsswitch.conf, the grain could take control\n    // of the supervisor.  Fix this by chrooting to the supervisor directory.\n    // TODO(someday): chroot somewhere that's guaranteed to be empty instead, so that if the\n    //   supervisor storage is itself compromised it can't be used to execute arbitrary code in\n    //   the supervisor process.\n    KJ_SYSCALL(chroot(\".\"));\n  \n    permanentlyDropSuperuser();\n    setupSeccomp();\n  \n    // TODO(soon): Somehow make sure all grandchildren die if supervisor dies. Currently SIGKILL\n    //   on the supervisor won't give it a chance to kill the sandbox pid tree. Perhaps the\n    //   supervisor should actually be the app's root process? We'd have to more carefully handle\n    //   SIGCHLD in that case and also worry about signals sent from the app process.\n  \n    kj::UnixEventPort::captureSignal(SIGCHLD);\n    auto ioContext = kj::setupAsyncIo();\n  \n    // Detect child exit.\n    auto exitPromise = ioContext.unixEventPort.onSignal(SIGCHLD).then([this](siginfo_t info) {\n      KJ_ASSERT(childPid != 0);\n      int status;\n      KJ_SYSCALL(waitpid(childPid, &status, 0));\n      childPid = 0;\n      KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n      if (WIFSIGNALED(status)) {\n        context.exitError(kj::str(\n            \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n            \" (\", strsignal(WTERMSIG(status)), \").\"));\n      } else {\n        context.exitError(kj::str(\n            \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status)));\n      }\n    }).eagerlyEvaluate([this](kj::Exception&& e) {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e));\n    });\n  \n    auto coreRedirector = kj::refcounted<CapRedirector>();\n    SandstormCore::Client coreCap = static_cast<capnp::Capability::Client>(\n      kj::addRef(*coreRedirector)).castAs<SandstormCore>();\n    SupervisorRealmGateway::Client gateway = kj::heap<SupervisorRealmGatewayImpl>(coreCap);\n  \n    // Compute grain size and watch for changes.\n    DiskUsageWatcher diskWatcher(ioContext.unixEventPort, ioContext.provider->getTimer(), coreCap);\n    auto diskWatcherTask = diskWatcher.init();\n  \n    // Set up the RPC connection to the app and export the supervisor interface.\n    auto appConnection = ioContext.lowLevelProvider->wrapSocketFd(apiFd,\n        kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC |\n        kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP);\n    capnp::TwoPartyVatNetwork appNetwork(*appConnection, capnp::rpc::twoparty::Side::SERVER);\n    WakelockSet wakelockSet(grainId, coreCap);\n    auto server = capnp::makeRpcServer(appNetwork, kj::heap<SandstormApiImpl>(wakelockSet, grainId,\n        coreCap), kj::mv(gateway));\n  \n    // Limit outstanding calls from the app to 1MiW (8MiB) in order to prevent an errant or malicious\n    // app from consuming excessive RAM elsewhere in the system.\n    server.setFlowLimit(1u << 20);\n  \n    // Get the app's UiView by restoring a null SturdyRef from it.\n    capnp::MallocMessageBuilder message;\n    auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n    hostId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n    MainView<>::Client app = server.bootstrap(hostId).castAs<MainView<>>();\n  \n    // Set up the external RPC interface, re-exporting the UiView.\n    // TODO(someday):  If there are multiple front-ends, or the front-ends restart a lot, we'll\n    //   want to wrap the UiView and cache session objects.  Perhaps we could do this by making\n    //   them persistable, though it's unclear how that would work with SessionContext.\n    Supervisor::Client mainCap = kj::heap<SupervisorImpl>(\n        ioContext.unixEventPort, kj::mv(app), wakelockSet, kj::mv(startEventFd),\n        coreCap, kj::addRef(*coreRedirector));\n  \n    auto acceptTask = systemConnector->run(ioContext, kj::mv(mainCap), kj::mv(coreRedirector));\n  \n    // Wait for disconnect or accept loop failure or disk watch failure, then exit. Also rotate log\n    // every 512k (thus having at most 1MB of logs at a time).\n    acceptTask.exclusiveJoin(kj::mv(diskWatcherTask))\n              .exclusiveJoin(appNetwork.onDisconnect())\n              .exclusiveJoin(rotateLog(ioContext.provider->getTimer(),\n                                       STDERR_FILENO, \"log\", 512u << 10))\n              .wait(ioContext.waitScope);\n  \n    // Only onDisconnect() would return normally (rather than throw), so the app must have\n    // disconnected (i.e. from the Cap'n Proto API socket).\n  \n    // Hmm, app disconnected API socket. The app probably exited and we just haven't gotten the\n    // signal yet, so sleep for a moment to let it arrive, so that we can report the exit status.\n    // Otherwise kill.\n    ioContext.provider->getTimer().afterDelay(1 * kj::SECONDS)\n        .exclusiveJoin(kj::mv(exitPromise))\n        .wait(ioContext.waitScope);\n  \n    SANDSTORM_LOG(\"App disconnected API socket but didn't actually exit; killing it.\");\n    killChildAndExit(1);\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "SupervisorMain::DefaultSystemConnector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2288-2304",
    "snippet": "kj::Promise<void> SupervisorMain::DefaultSystemConnector::run(\n    kj::AsyncIoContext& ioContext, Supervisor::Client mainCap,\n    kj::Own<CapRedirector> coreRedirector) const {\n  auto listener = kj::heap<TwoPartyServerWithClientBootstrap>(\n      kj::mv(mainCap), kj::mv(coreRedirector));\n\n  unlink(\"socket\");  // Clear stale socket, if any.\n  return ioContext.provider->getNetwork().parseAddress(\"unix:socket\", 0).then(\n      [KJ_MVCAP(listener)](kj::Own<kj::NetworkAddress>&& addr) mutable {\n    auto serverPort = addr->listen();\n\n    // The front-end knows we're ready to accept connections when we write something to stdout.\n    KJ_SYSCALL(write(STDOUT_FILENO, \"Listening...\\n\", strlen(\"Listening...\\n\")));\n\n    auto promise = listener->listen(kj::mv(serverPort));\n    return promise.attach(kj::mv(listener));\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<CapRedirector> coreRedirector;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(listener)"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listener->listen",
          "args": [
            "kj::mv(serverPort)"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "listen",
          "container": "TwoPartyServerWithClientBootstrap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1227-1247",
          "snippet": "kj::Promise<void> TwoPartyServerWithClientBootstrap::listen(\n  kj::Own<kj::ConnectionReceiver>&& listener) {\n  return listener->accept()\n      .then([this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    auto connectionState = kj::heap<AcceptedConnection>(bootstrapInterface, kj::mv(connection));\n\n    // Update the bootstrap redirector to point at the new connection's bootstrap.\n    capnp::MallocMessageBuilder message(8);\n    auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n    vatId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n    uint iteration = redirector->setTarget(connectionState->rpcSystem.bootstrap(vatId));\n\n    // Run the connection until disconnect.\n    auto promise = connectionState->network.onDisconnect();\n    tasks.add(promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    })));\n\n    return listen(kj::mv(listener));\n  }",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nTwoPartyServerWithClientBootstrap {\n  kj::Promise<void> TwoPartyServerWithClientBootstrap::listen(\n    kj::Own<kj::ConnectionReceiver>&& listener) {\n    return listener->accept()\n        .then([this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      auto connectionState = kj::heap<AcceptedConnection>(bootstrapInterface, kj::mv(connection));\n  \n      // Update the bootstrap redirector to point at the new connection's bootstrap.\n      capnp::MallocMessageBuilder message(8);\n      auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n      vatId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n      uint iteration = redirector->setTarget(connectionState->rpcSystem.bootstrap(vatId));\n  \n      // Run the connection until disconnect.\n      auto promise = connectionState->network.onDisconnect();\n      tasks.add(promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n        // Disconnect the redirector when the client disconnects.\n        redirector->setDisconnected(iteration);\n      })));\n  \n      return listen(kj::mv(listener));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "serverPort"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(STDOUT_FILENO, \"Listening...\\n\", strlen(\"Listening...\\n\"))"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDOUT_FILENO",
            "\"Listening...\\n\"",
            "strlen(\"Listening...\\n\")"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"Listening...\\n\""
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->listen",
          "args": [],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "[KJ_MVCAP(listener)](kj::Own<kj::NetworkAddress>&& addr"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"unix:socket\"",
            "0"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "\"socket\""
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TwoPartyServerWithClientBootstrap>",
          "args": [
            "kj::mv(mainCap)",
            "kj::mv(coreRedirector)"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "coreRedirector"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainCap"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Own<CapRedirector> coreRedirector;\n\nSupervisorMain {\n  DefaultSystemConnector {\n    kj::Promise<void> SupervisorMain::DefaultSystemConnector::run(\n        kj::AsyncIoContext& ioContext, Supervisor::Client mainCap,\n        kj::Own<CapRedirector> coreRedirector) const {\n      auto listener = kj::heap<TwoPartyServerWithClientBootstrap>(\n          kj::mv(mainCap), kj::mv(coreRedirector));\n    \n      unlink(\"socket\");  // Clear stale socket, if any.\n      return ioContext.provider->getNetwork().parseAddress(\"unix:socket\", 0).then(\n          [KJ_MVCAP(listener)](kj::Own<kj::NetworkAddress>&& addr) mutable {\n        auto serverPort = addr->listen();\n    \n        // The front-end knows we're ready to accept connections when we write something to stdout.\n        KJ_SYSCALL(write(STDOUT_FILENO, \"Listening...\\n\", strlen(\"Listening...\\n\")));\n    \n        auto promise = listener->listen(kj::mv(serverPort));\n        return promise.attach(kj::mv(listener));\n      }\n  }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2283-2285",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, \"connection failed\", exception);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"connection failed\"",
            "exception"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, \"connection failed\", exception);\n  }"
  },
  {
    "function_name": "makeInotifyFd",
    "container": "LogWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2269-2273",
    "snippet": "static kj::AutoCloseFd makeInotifyFd() {\n      int ifd;\n      KJ_SYSCALL(ifd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      return kj::AutoCloseFd(ifd);\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "ifd"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ifd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC)"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_init1",
          "args": [
            "IN_NONBLOCK | IN_CLOEXEC"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  static kj::AutoCloseFd makeInotifyFd() {\n        int ifd;\n        KJ_SYSCALL(ifd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n        return kj::AutoCloseFd(ifd);\n      }\n}"
  },
  {
    "function_name": "watchLoop",
    "container": "LogWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2218-2267",
    "snippet": "kj::Promise<void> watchLoop() {\n      // Exhaust all events from the inotify queue, because edge triggering.\n      // Luckily we don't actually have to interpret the events because we're only waiting on\n      // one type of event.\n      for (;;) {\n        byte buffer[sizeof(struct inotify_event) + NAME_MAX + 1];\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotify, buffer, sizeof(buffer)));\n        if (n < 0) break;\n        KJ_ASSERT(n > 0);\n      }\n\n      // Check for recent rotation.\n      struct stat stats;\n      KJ_SYSCALL(fstat(logFile, &stats));\n      if (lastOffset > stats.st_size) {\n        // Looks like log was rotated.\n        lastOffset = 0;\n        KJ_SYSCALL(lseek(logFile, 0, SEEK_SET));\n      }\n\n      // Read all unread data from logFile and send it to the stream.\n      // TODO(perf): Flow control? Currently we avoid asking for very much data at once.\n      for (;;) {\n        auto req = stream.writeRequest();\n        auto orphanage =\n            capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>(req);\n        auto orphan = orphanage.newOrphan<capnp::Data>(4096);\n        auto data = orphan.get();\n\n        size_t n = kj::FdInputStream(logFile.get())\n            .tryRead(data.begin(), data.size(), data.size());\n        bool done = n < data.size();\n        if (done) {\n          orphan.truncate(n);\n        }\n        req.adoptData(kj::mv(orphan));\n\n        tasks.add(req.send().ignoreResult());\n\n        if (done) break;\n      }\n\n      KJ_SYSCALL(lastOffset = lseek(logFile, 0, SEEK_CUR));\n\n      // OK, now wait for more.\n      return inotifyObserver.whenBecomesReadable().then([this]() {\n        return watchLoop();\n      });\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inotifyObserver.whenBecomesReadable",
          "args": [
            "[this]() {\n        return watchLoop();\n      }"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchLoop",
          "args": [],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "watchLoop",
          "container": "LogWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2218-2267",
          "snippet": "kj::Promise<void> watchLoop() {\n      // Exhaust all events from the inotify queue, because edge triggering.\n      // Luckily we don't actually have to interpret the events because we're only waiting on\n      // one type of event.\n      for (;;) {\n        byte buffer[sizeof(struct inotify_event) + NAME_MAX + 1];\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotify, buffer, sizeof(buffer)));\n        if (n < 0) break;\n        KJ_ASSERT(n > 0);\n      }\n\n      // Check for recent rotation.\n      struct stat stats;\n      KJ_SYSCALL(fstat(logFile, &stats));\n      if (lastOffset > stats.st_size) {\n        // Looks like log was rotated.\n        lastOffset = 0;\n        KJ_SYSCALL(lseek(logFile, 0, SEEK_SET));\n      }\n\n      // Read all unread data from logFile and send it to the stream.\n      // TODO(perf): Flow control? Currently we avoid asking for very much data at once.\n      for (;;) {\n        auto req = stream.writeRequest();\n        auto orphanage =\n            capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>(req);\n        auto orphan = orphanage.newOrphan<capnp::Data>(4096);\n        auto data = orphan.get();\n\n        size_t n = kj::FdInputStream(logFile.get())\n            .tryRead(data.begin(), data.size(), data.size());\n        bool done = n < data.size();\n        if (done) {\n          orphan.truncate(n);\n        }\n        req.adoptData(kj::mv(orphan));\n\n        tasks.add(req.send().ignoreResult());\n\n        if (done) break;\n      }\n\n      KJ_SYSCALL(lastOffset = lseek(logFile, 0, SEEK_CUR));\n\n      // OK, now wait for more.\n      return inotifyObserver.whenBecomesReadable().then([this]() {\n        return watchLoop();\n      });\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "inotifyObserver.whenBecomesReadable",
          "args": [],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lastOffset = lseek(logFile, 0, SEEK_CUR)"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "logFile",
            "0",
            "SEEK_CUR"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "req.send().ignoreResult()"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.adoptData",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.truncate",
          "args": [
            "n"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "data.begin()",
            "data.size()",
            "data.size()"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdInputStream",
          "args": [
            "logFile.get()"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logFile.get",
          "args": [],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.get",
          "args": [],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<capnp::Data>",
          "args": [
            "4096"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>",
          "args": [
            "req"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.writeRequest",
          "args": [],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lseek(logFile, 0, SEEK_SET)"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "logFile",
            "0",
            "SEEK_SET"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(logFile, &stats)"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "logFile",
            "&stats"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n > 0"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = read(inotify, buffer, sizeof(buffer))"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "inotify",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  kj::Promise<void> watchLoop() {\n        // Exhaust all events from the inotify queue, because edge triggering.\n        // Luckily we don't actually have to interpret the events because we're only waiting on\n        // one type of event.\n        for (;;) {\n          byte buffer[sizeof(struct inotify_event) + NAME_MAX + 1];\n          ssize_t n;\n          KJ_NONBLOCKING_SYSCALL(n = read(inotify, buffer, sizeof(buffer)));\n          if (n < 0) break;\n          KJ_ASSERT(n > 0);\n        }\n  \n        // Check for recent rotation.\n        struct stat stats;\n        KJ_SYSCALL(fstat(logFile, &stats));\n        if (lastOffset > stats.st_size) {\n          // Looks like log was rotated.\n          lastOffset = 0;\n          KJ_SYSCALL(lseek(logFile, 0, SEEK_SET));\n        }\n  \n        // Read all unread data from logFile and send it to the stream.\n        // TODO(perf): Flow control? Currently we avoid asking for very much data at once.\n        for (;;) {\n          auto req = stream.writeRequest();\n          auto orphanage =\n              capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>(req);\n          auto orphan = orphanage.newOrphan<capnp::Data>(4096);\n          auto data = orphan.get();\n  \n          size_t n = kj::FdInputStream(logFile.get())\n              .tryRead(data.begin(), data.size(), data.size());\n          bool done = n < data.size();\n          if (done) {\n            orphan.truncate(n);\n          }\n          req.adoptData(kj::mv(orphan));\n  \n          tasks.add(req.send().ignoreResult());\n  \n          if (done) break;\n        }\n  \n        KJ_SYSCALL(lastOffset = lseek(logFile, 0, SEEK_CUR));\n  \n        // OK, now wait for more.\n        return inotifyObserver.whenBecomesReadable().then([this]() {\n          return watchLoop();\n        });\n      }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "LogWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2214-2216",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, exception);\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  void taskFailed(kj::Exception&& exception) override {\n        KJ_LOG(ERROR, exception);\n      }\n}"
  },
  {
    "function_name": "addTask",
    "container": "LogWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2201-2204",
    "snippet": "void addTask(kj::Promise<void> task) {\n      // HACK for watchLog().\n      tasks.add(kj::mv(task));\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "kj::mv(task)"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "task"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  void addTask(kj::Promise<void> task) {\n        // HACK for watchLog().\n        tasks.add(kj::mv(task));\n      }\n}"
  },
  {
    "function_name": "LogWatcher",
    "container": "LogWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2190-2199",
    "snippet": "explicit LogWatcher(kj::UnixEventPort& eventPort, kj::StringPtr logPath,\n                        kj::AutoCloseFd logFileParam, ByteStream::Client stream)\n        : logFile(kj::mv(logFileParam)),\n          inotify(makeInotifyFd()),\n          inotifyObserver(eventPort, inotify, kj::UnixEventPort::FdObserver::OBSERVE_READ),\n          stream(kj::mv(stream)),\n          tasks(*this) {\n      KJ_SYSCALL(inotify_add_watch(inotify, logPath.cStr(), IN_MODIFY));\n      tasks.add(watchLoop());\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "watchLoop()"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchLoop",
          "args": [],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "watchLoop",
          "container": "LogWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2218-2267",
          "snippet": "kj::Promise<void> watchLoop() {\n      // Exhaust all events from the inotify queue, because edge triggering.\n      // Luckily we don't actually have to interpret the events because we're only waiting on\n      // one type of event.\n      for (;;) {\n        byte buffer[sizeof(struct inotify_event) + NAME_MAX + 1];\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotify, buffer, sizeof(buffer)));\n        if (n < 0) break;\n        KJ_ASSERT(n > 0);\n      }\n\n      // Check for recent rotation.\n      struct stat stats;\n      KJ_SYSCALL(fstat(logFile, &stats));\n      if (lastOffset > stats.st_size) {\n        // Looks like log was rotated.\n        lastOffset = 0;\n        KJ_SYSCALL(lseek(logFile, 0, SEEK_SET));\n      }\n\n      // Read all unread data from logFile and send it to the stream.\n      // TODO(perf): Flow control? Currently we avoid asking for very much data at once.\n      for (;;) {\n        auto req = stream.writeRequest();\n        auto orphanage =\n            capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>(req);\n        auto orphan = orphanage.newOrphan<capnp::Data>(4096);\n        auto data = orphan.get();\n\n        size_t n = kj::FdInputStream(logFile.get())\n            .tryRead(data.begin(), data.size(), data.size());\n        bool done = n < data.size();\n        if (done) {\n          orphan.truncate(n);\n        }\n        req.adoptData(kj::mv(orphan));\n\n        tasks.add(req.send().ignoreResult());\n\n        if (done) break;\n      }\n\n      KJ_SYSCALL(lastOffset = lseek(logFile, 0, SEEK_CUR));\n\n      // OK, now wait for more.\n      return inotifyObserver.whenBecomesReadable().then([this]() {\n        return watchLoop();\n      });\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  kj::Promise<void> watchLoop() {\n        // Exhaust all events from the inotify queue, because edge triggering.\n        // Luckily we don't actually have to interpret the events because we're only waiting on\n        // one type of event.\n        for (;;) {\n          byte buffer[sizeof(struct inotify_event) + NAME_MAX + 1];\n          ssize_t n;\n          KJ_NONBLOCKING_SYSCALL(n = read(inotify, buffer, sizeof(buffer)));\n          if (n < 0) break;\n          KJ_ASSERT(n > 0);\n        }\n  \n        // Check for recent rotation.\n        struct stat stats;\n        KJ_SYSCALL(fstat(logFile, &stats));\n        if (lastOffset > stats.st_size) {\n          // Looks like log was rotated.\n          lastOffset = 0;\n          KJ_SYSCALL(lseek(logFile, 0, SEEK_SET));\n        }\n  \n        // Read all unread data from logFile and send it to the stream.\n        // TODO(perf): Flow control? Currently we avoid asking for very much data at once.\n        for (;;) {\n          auto req = stream.writeRequest();\n          auto orphanage =\n              capnp::Orphanage::getForMessageContaining<ByteStream::WriteParams::Builder>(req);\n          auto orphan = orphanage.newOrphan<capnp::Data>(4096);\n          auto data = orphan.get();\n  \n          size_t n = kj::FdInputStream(logFile.get())\n              .tryRead(data.begin(), data.size(), data.size());\n          bool done = n < data.size();\n          if (done) {\n            orphan.truncate(n);\n          }\n          req.adoptData(kj::mv(orphan));\n  \n          tasks.add(req.send().ignoreResult());\n  \n          if (done) break;\n        }\n  \n        KJ_SYSCALL(lastOffset = lseek(logFile, 0, SEEK_CUR));\n  \n        // OK, now wait for more.\n        return inotifyObserver.whenBecomesReadable().then([this]() {\n          return watchLoop();\n        });\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "inotify_add_watch(inotify, logPath.cStr(), IN_MODIFY)"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_add_watch",
          "args": [
            "inotify",
            "logPath.cStr()",
            "IN_MODIFY"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPath.cStr",
          "args": [],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeInotifyFd",
          "args": [],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "makeInotifyFd",
          "container": "LogWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2269-2273",
          "snippet": "static kj::AutoCloseFd makeInotifyFd() {\n      int ifd;\n      KJ_SYSCALL(ifd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      return kj::AutoCloseFd(ifd);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  static kj::AutoCloseFd makeInotifyFd() {\n        int ifd;\n        KJ_SYSCALL(ifd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n        return kj::AutoCloseFd(ifd);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "logFileParam"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  explicit LogWatcher(kj::UnixEventPort& eventPort, kj::StringPtr logPath,\n                          kj::AutoCloseFd logFileParam, ByteStream::Client stream)\n          : logFile(kj::mv(logFileParam)),\n            inotify(makeInotifyFd()),\n            inotifyObserver(eventPort, inotify, kj::UnixEventPort::FdObserver::OBSERVE_READ),\n            stream(kj::mv(stream)),\n            tasks(*this) {\n        KJ_SYSCALL(inotify_add_watch(inotify, logPath.cStr(), IN_MODIFY));\n        tasks.add(watchLoop());\n      }\n}"
  },
  {
    "function_name": "ensureStarted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2177-2186",
    "snippet": "void ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::AutoCloseFd startAppEvent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n == sizeof(one)"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = write(startAppEvent, &one, sizeof(one))"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "startAppEvent",
            "&one",
            "sizeof(one)"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::AutoCloseFd startAppEvent;\n\nvoid ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }"
  },
  {
    "function_name": "getWwwFileHack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2121-2166",
    "snippet": "kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "Supervisor::WwwFileStatus::NOT_FOUND"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {4, 0}"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"not a regular file\""
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "Supervisor::WwwFileStatus::DIRECTORY"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {4, 0}"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "kj::mv(inStream)",
            "kj::mv(expectSizeTask)"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "246-251",
          "snippet": "void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n    byte buffer[4096];\n    while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n      out.write(buffer, n);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "expectSizeTask"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inStream"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<kj::FdInputStream>",
          "args": [
            "kj::mv(*fd)"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*fd"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setSize",
          "args": [
            "stats.st_size"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.expectSizeRequest",
          "args": [],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getStream",
          "args": [],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(*fd, &stats)"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "*fd",
            "&stats"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"sandbox/www/\"",
            "path"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "Supervisor::WwwFileStatus::NOT_FOUND"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {4, 0}"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part.size",
          "args": [],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parts.removeLast",
          "args": [],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.back",
          "args": [],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.back",
          "args": [],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "path",
            "'/'"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "splitFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "448-457",
          "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getPath",
          "args": [],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.allowCancellation",
          "args": [],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }"
  },
  {
    "function_name": "drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2109-2119",
    "snippet": "kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Supervisor can only drop wakelocks for now.\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockSet.drop",
          "args": [
            "objectId.getWakeLockNotification()"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2109-2119",
          "snippet": "kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getWakeLockNotification",
          "args": [],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.which",
          "args": [],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureStarted",
          "args": [],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "ensureStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2177-2186",
          "snippet": "void ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::AutoCloseFd startAppEvent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::AutoCloseFd startAppEvent;\n\nvoid ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\n\nkj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }"
  },
  {
    "function_name": "restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2085-2107",
    "snippet": "kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MainView<>::Client mainView;",
      "WakelockSet& wakelockSet;",
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown objectId type\""
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        }"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore)"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<SaveWrapper>",
          "args": [
            "args.getCap().template castAs<AppPersistent<>>()",
            "params.getRequirements()",
            "params.getParentToken()",
            "sandstormCore"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getParentToken",
          "args": [],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getRequirements",
          "args": [],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setObjectId",
          "args": [
            "objectId.getAppRef()"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.getAppRef",
          "args": [],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mainView.restoreRequest",
          "args": [],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "wakelockSet.restore(objectId.getWakeLockNotification())"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockSet.restore",
          "args": [
            "objectId.getWakeLockNotification()"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2085-2107",
          "snippet": "kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getWakeLockNotification",
          "args": [],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.which",
          "args": [],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getRef",
          "args": [],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureStarted",
          "args": [],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "ensureStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2177-2186",
          "snippet": "void ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::AutoCloseFd startAppEvent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::AutoCloseFd startAppEvent;\n\nvoid ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nMainView<>::Client mainView;\nWakelockSet& wakelockSet;\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }"
  },
  {
    "function_name": "watchLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2044-2083",
    "snippet": "kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::mv(watcher)"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "watcher"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize { 4, 1 }"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watcher->addTask",
          "args": [
            "kj::mv(*f)"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "addTask",
          "container": "LogWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2201-2204",
          "snippet": "void addTask(kj::Promise<void> task) {\n      // HACK for watchLog().\n      tasks.add(kj::mv(task));\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nLogWatcher {\n  void addTask(kj::Promise<void> task) {\n        // HACK for watchLog().\n        tasks.add(kj::mv(task));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*f"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<LogWatcher>",
          "args": [
            "eventPort",
            "\"log\"",
            "kj::mv(logFile)",
            "params.getStream()"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getStream",
          "args": [],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "logFile"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.read",
          "args": [
            "data.begin()",
            "backlog1"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SimpleDataFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/union-fs.c++",
          "lines": "529-533",
          "snippet": "kj::Array<uint8_t> read(uint64_t offset0, uint32_t size0) override {\n    auto offset = kj::min(data.size(), offset0);\n    auto size = kj::min(data.size() - offset, size0);\n    return kj::heapArray(data.slice(offset, offset + size));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"fuse.h\"",
            "#include <stdlib.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/serialize.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include \"union-fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fuse.h\"\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <set>\n#include <map>\n#include <capnp/serialize.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include \"union-fs.h\"\n\nSimpleDataFile {\n  kj::Array<uint8_t> read(uint64_t offset0, uint32_t size0) override {\n      auto offset = kj::min(data.size(), offset0);\n      auto size = kj::min(data.size() - offset, size0);\n      return kj::heapArray(data.slice(offset, offset + size));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.initData",
          "args": [
            "backlog1"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getStream",
          "args": [],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getStream",
          "args": [],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log1->get",
          "args": [],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lseek(*log1, stats1.st_size - backlog1, SEEK_SET)"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "*log1",
            "stats1.st_size - backlog1",
            "SEEK_SET"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "requestedBacklog1",
            "stats1.st_size"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(*log1, &stats1)"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "*log1",
            "&stats1"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "log1",
            "raiiOpenIfExists(\"log.1\", O_RDONLY)"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpenIfExists",
          "args": [
            "\"log.1\"",
            "O_RDONLY"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lseek(logFile, stats.st_size - backlog, SEEK_SET)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "logFile",
            "stats.st_size - backlog",
            "SEEK_SET"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "requestedBacklog",
            "stats.st_size"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getBacklogAmount",
          "args": [],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(logFile, &stats)"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "logFile",
            "&stats"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstorm::raiiOpen",
          "args": [
            "\"log\"",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2039-2042",
    "snippet": "kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "killChildAndExit",
          "args": [
            "0"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "killChildAndExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "474-480",
          "snippet": "[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain shutdown requested.\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }"
  },
  {
    "function_name": "syncStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2033-2037",
    "snippet": "kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "syncfs(fd)"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syncfs",
          "args": [
            "fd"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\".\"",
            "O_RDONLY | O_DIRECTORY"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "keepAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2022-2031",
    "snippet": "kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;",
      "kj::Own<CapRedirector> coreRedirector;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "coreRedirector->setTarget",
          "args": [
            "params.getCore()"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "setTarget",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1139-1149",
          "snippet": "uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n  KJ_REQUIRE(state.is<Passive>());\n\n  ++iteration;\n  target = newTarget;\n\n  // If the previous target was a promise target, fulfill it.\n  state.get<Passive>()->fulfill(kj::mv(newTarget));\n\n  return iteration;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n    KJ_REQUIRE(state.is<Passive>());\n  \n    ++iteration;\n    target = newTarget;\n  \n    // If the previous target was a promise target, fulfill it.\n    state.get<Passive>()->fulfill(kj::mv(newTarget));\n  \n    return iteration;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.getCore",
          "args": [],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.hasCore",
          "args": [],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\nkj::Own<CapRedirector> coreRedirector;\n\nkj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "getMainView",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2016-2020",
    "snippet": "kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MainView<>::Client mainView;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "mainView"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "capnp::MessageSize {4, 1}"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureStarted",
          "args": [],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ensureStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2177-2186",
          "snippet": "void ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::AutoCloseFd startAppEvent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::AutoCloseFd startAppEvent;\n\nvoid ensureStarted() {\n    // Ensure that the app has been started.\n    if (startAppEvent != nullptr) {\n      uint64_t one = 1;\n      ssize_t n;\n      KJ_SYSCALL(n = write(startAppEvent, &one, sizeof(one)));\n      KJ_ASSERT(n == sizeof(one));\n      startAppEvent = nullptr;\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nMainView<>::Client mainView;\n\nkj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "SupervisorImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "2009-2014",
    "snippet": "inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MainView<>::Client mainView;",
      "WakelockSet& wakelockSet;",
      "SandstormCore::Client sandstormCore;",
      "kj::Own<CapRedirector> coreRedirector;",
      "kj::AutoCloseFd startAppEvent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "startAppEvent"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "coreRedirector"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainView"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nMainView<>::Client mainView;\nWakelockSet& wakelockSet;\nSandstormCore::Client sandstormCore;\nkj::Own<CapRedirector> coreRedirector;\nkj::AutoCloseFd startAppEvent;\n\ninline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}"
  },
  {
    "function_name": "WakelockHandle",
    "container": "WakelockHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1988-1991",
    "snippet": "WakelockHandle(capnp::Data::Reader sturdyRef,\n                   SandstormApiImpl& api)\n      : sturdyRef(kj::heapArray(sturdyRef)), api(api) {\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "sturdyRef"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockHandle {\n  WakelockHandle(capnp::Data::Reader sturdyRef,\n                     SandstormApiImpl& api)\n        : sturdyRef(kj::heapArray(sturdyRef)), api(api) {\n      }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1982-1984",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }"
  },
  {
    "function_name": "dropHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1974-1980",
    "snippet": "void dropHandle(kj::ArrayPtr<byte> sturdyRef) {\n    auto req = sandstormCore.dropRequest();\n    req.setToken(sturdyRef);\n    // TODO(someday): Handle failures for drop? Currently, if the the frontend never drops the\n    // notification or calls cancel on it, then this handle will essentially leak.\n    tasks.add(req.send().ignoreResult());\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "req.send().ignoreResult()"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "sturdyRef"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.dropRequest",
          "args": [],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nvoid dropHandle(kj::ArrayPtr<byte> sturdyRef) {\n    auto req = sandstormCore.dropRequest();\n    req.setToken(sturdyRef);\n    // TODO(someday): Handle failures for drop? Currently, if the the frontend never drops the\n    // notification or calls cancel on it, then this handle will essentially leak.\n    tasks.add(req.send().ignoreResult());\n  }"
  },
  {
    "function_name": "getIdentityId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1963-1971",
    "snippet": "kj::Promise<void> getIdentityId(GetIdentityIdContext context) override {\n    auto params = context.getParams();\n    auto req = sandstormCore.getIdentityIdRequest(params.totalSize());\n    req.setIdentity(params.getIdentity());\n    context.releaseParams();\n    return req.send().then([context](auto args) mutable -> void {\n      context.getResults().setId(args.getId());\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto args) mutable -> void {\n      context.getResults().setId(args.getId());\n    }"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "args.getId()"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getId",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setIdentity",
          "args": [
            "params.getIdentity()"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getIdentity",
          "args": [],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.getIdentityIdRequest",
          "args": [
            "params.totalSize()"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.totalSize",
          "args": [],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> getIdentityId(GetIdentityIdContext context) override {\n    auto params = context.getParams();\n    auto req = sandstormCore.getIdentityIdRequest(params.totalSize());\n    req.setIdentity(params.getIdentity());\n    context.releaseParams();\n    return req.send().then([context](auto args) mutable -> void {\n      context.getResults().setId(args.getId());\n    });\n  }"
  },
  {
    "function_name": "backgroundActivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1955-1961",
    "snippet": "kj::Promise<void> backgroundActivity(BackgroundActivityContext context) override {\n    auto params = context.getParams();\n    auto req = sandstormCore.backgroundActivityRequest(params.totalSize());\n    req.setEvent(params.getEvent());\n    context.releaseParams();\n    return req.send().ignoreResult();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setEvent",
          "args": [
            "params.getEvent()"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getEvent",
          "args": [],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.backgroundActivityRequest",
          "args": [
            "params.totalSize()"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.totalSize",
          "args": [],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> backgroundActivity(BackgroundActivityContext context) override {\n    auto params = context.getParams();\n    auto req = sandstormCore.backgroundActivityRequest(params.totalSize());\n    req.setEvent(params.getEvent());\n    context.releaseParams();\n    return req.send().ignoreResult();\n  }"
  },
  {
    "function_name": "stayAwake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1904-1953",
    "snippet": "kj::Promise<void> stayAwake(StayAwakeContext context) override {\n    //   The supervisor maintains a map of \"wake locks\". Since wake locks\n    //   by their nature do not outlast the process, this map can be held in-memory. When\n    //   `stayAwake()` is called, the supervisor:\n    //   - Constructs a wrapper around `OngoingNotification` to be passed to the front-end. The\n    //     wrapper is persistent.\n    //   - Calls SandstormCore.getOwnerNotificationTarget().addOngoing(), passing along\n    //     this new wrapper object as well as the `displayInfo` provided from the app.\n    //   - On the handle returned by `addOngoing()`, immediately calls `save()` (with\n    //     sealFor = this grain; see `SystemPersistent`), storing the resulting `SturdyRef`\n    //     (actually, just an API token) into a wrapped handle.\n    //   - Constructs a wrapped handle object and returns it from `stayAwake()`.\n    //   - When that handle is destroyed, calls SandstormCore.drop() on the handle SturdyRef stored\n    //     and calls cancel on the original ongoing notification passed from the app.\n    //   - When SandstormCore calls the wrapper OngoingNotification's `cancel()` method, forwards\n    //     that call to the app.\n    //   - When SandstormCore drops the wrapper OngoingNotification (via `Supervisor.drop()`),\n    //     if it's the last reference, then disable backgrounding.\n    //\n    //   Meanwhile, until the point that SandstormCore calls cancel on the OngoingNotification, the\n    //   supervisor does not kill itself during its regular keep-alive check.\n    //\n    //   The main reason this is so complicated is that the front-end is supposed to be able to\n    //   restart independently of the app, but the `OngoingNotification` provided by the app is\n    //   not required to be persistent. The supervisor thus takes care of the complication of\n    //   dealing with persistence through front-end restarts.\n    auto params = context.getParams();\n\n    OngoingNotification::Client notification =\n      kj::heap<WakelockSet::WrappedOngoingNotification>(params.getNotification(), wakelockSet);\n\n    auto req = sandstormCore.getOwnerNotificationTargetRequest().send().getOwner()\n      .addOngoingRequest();\n    req.setDisplayInfo(params.getDisplayInfo());\n    req.setNotification(notification);\n\n    context.releaseParams();\n    // We actually don't need to catch errors here, since if an error occurs, the notification will\n    // be dropped and cleanup will happen automatically.\n    return req.send().then([this, context](auto args) mutable {\n      auto req = args.getHandle().template castAs<SystemPersistent>().saveRequest();\n      auto grainOwner = req.getSealFor().initGrain();\n      grainOwner.setGrainId(grainId);\n      grainOwner.getSaveLabel().setDefaultText(\"ongoing notification handle\");\n      return req.send().then([this, context](auto args) mutable -> void {\n        SANDSTORM_LOG(\"Grain has enabled backgrounding.\");\n        context.getResults().setHandle(kj::heap<WakelockHandle>(args.getSturdyRef(), *this));\n      });\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;",
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[this, context](auto args) mutable {\n      auto req = args.getHandle().template castAs<SystemPersistent>().saveRequest();\n      auto grainOwner = req.getSealFor().initGrain();\n      grainOwner.setGrainId(grainId);\n      grainOwner.getSaveLabel().setDefaultText(\"ongoing notification handle\");\n      return req.send().then([this, context](auto args) mutable -> void {\n        SANDSTORM_LOG(\"Grain has enabled backgrounding.\");\n        context.getResults().setHandle(kj::heap<WakelockHandle>(args.getSturdyRef(), *this));\n      });\n    }"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<WakelockHandle>(args.getSturdyRef(), *this)"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WakelockHandle>",
          "args": [
            "args.getSturdyRef()",
            "*this"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getSturdyRef",
          "args": [],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain has enabled backgrounding.\""
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainOwner.getSaveLabel",
          "args": [
            "\"ongoing notification handle\""
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainOwner.getSaveLabel",
          "args": [],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainOwner.setGrainId",
          "args": [
            "grainId"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "setGrainId",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "619-625",
          "snippet": "kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n  if (id == nullptr || id.findFirst('/') != nullptr) {\n    return \"Invalid grain id.\";\n  }\n  grainId = kj::heapString(id);\n  return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n    if (id == nullptr || id.findFirst('/') != nullptr) {\n      return \"Invalid grain id.\";\n    }\n    grainId = kj::heapString(id);\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "req.getSealFor",
          "args": [],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getSealFor",
          "args": [],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getHandle",
          "args": [],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getHandle",
          "args": [],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getHandle",
          "args": [],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setNotification",
          "args": [
            "notification"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setDisplayInfo",
          "args": [
            "params.getDisplayInfo()"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getDisplayInfo",
          "args": [],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.getOwnerNotificationTargetRequest",
          "args": [],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.getOwnerNotificationTargetRequest",
          "args": [],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.getOwnerNotificationTargetRequest",
          "args": [],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.getOwnerNotificationTargetRequest",
          "args": [],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WakelockSet::WrappedOngoingNotification>",
          "args": [
            "params.getNotification()",
            "wakelockSet"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getNotification",
          "args": [],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> stayAwake(StayAwakeContext context) override {\n    //   The supervisor maintains a map of \"wake locks\". Since wake locks\n    //   by their nature do not outlast the process, this map can be held in-memory. When\n    //   `stayAwake()` is called, the supervisor:\n    //   - Constructs a wrapper around `OngoingNotification` to be passed to the front-end. The\n    //     wrapper is persistent.\n    //   - Calls SandstormCore.getOwnerNotificationTarget().addOngoing(), passing along\n    //     this new wrapper object as well as the `displayInfo` provided from the app.\n    //   - On the handle returned by `addOngoing()`, immediately calls `save()` (with\n    //     sealFor = this grain; see `SystemPersistent`), storing the resulting `SturdyRef`\n    //     (actually, just an API token) into a wrapped handle.\n    //   - Constructs a wrapped handle object and returns it from `stayAwake()`.\n    //   - When that handle is destroyed, calls SandstormCore.drop() on the handle SturdyRef stored\n    //     and calls cancel on the original ongoing notification passed from the app.\n    //   - When SandstormCore calls the wrapper OngoingNotification's `cancel()` method, forwards\n    //     that call to the app.\n    //   - When SandstormCore drops the wrapper OngoingNotification (via `Supervisor.drop()`),\n    //     if it's the last reference, then disable backgrounding.\n    //\n    //   Meanwhile, until the point that SandstormCore calls cancel on the OngoingNotification, the\n    //   supervisor does not kill itself during its regular keep-alive check.\n    //\n    //   The main reason this is so complicated is that the front-end is supposed to be able to\n    //   restart independently of the app, but the `OngoingNotification` provided by the app is\n    //   not required to be persistent. The supervisor thus takes care of the complication of\n    //   dealing with persistence through front-end restarts.\n    auto params = context.getParams();\n\n    OngoingNotification::Client notification =\n      kj::heap<WakelockSet::WrappedOngoingNotification>(params.getNotification(), wakelockSet);\n\n    auto req = sandstormCore.getOwnerNotificationTargetRequest().send().getOwner()\n      .addOngoingRequest();\n    req.setDisplayInfo(params.getDisplayInfo());\n    req.setNotification(notification);\n\n    context.releaseParams();\n    // We actually don't need to catch errors here, since if an error occurs, the notification will\n    // be dropped and cleanup will happen automatically.\n    return req.send().then([this, context](auto args) mutable {\n      auto req = args.getHandle().template castAs<SystemPersistent>().saveRequest();\n      auto grainOwner = req.getSealFor().initGrain();\n      grainOwner.setGrainId(grainId);\n      grainOwner.getSaveLabel().setDefaultText(\"ongoing notification handle\");\n      return req.send().then([this, context](auto args) mutable -> void {\n        SANDSTORM_LOG(\"Grain has enabled backgrounding.\");\n        context.getResults().setHandle(kj::heap<WakelockHandle>(args.getSturdyRef(), *this));\n      });\n    });\n  }"
  },
  {
    "function_name": "drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1894-1898",
    "snippet": "kj::Promise<void> drop(DropContext context) override {\n    auto req = sandstormCore.dropRequest();\n    req.setToken(context.getParams().getToken());\n    return req.send().ignoreResult();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "context.getParams().getToken()"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.dropRequest",
          "args": [],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> drop(DropContext context) override {\n    auto req = sandstormCore.dropRequest();\n    req.setToken(context.getParams().getToken());\n    return req.send().ignoreResult();\n  }"
  },
  {
    "function_name": "restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1886-1892",
    "snippet": "kj::Promise<void> restore(RestoreContext context) override {\n    auto req = sandstormCore.restoreRequest();\n    req.setToken(context.getParams().getToken());\n    return req.send().then([context](auto args) mutable -> void {\n      context.getResults().setCap(args.getCap());\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto args) mutable -> void {\n      context.getResults().setCap(args.getCap());\n    }"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "args.getCap()"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setToken",
          "args": [
            "context.getParams().getToken()"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.restoreRequest",
          "args": [],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nkj::Promise<void> restore(RestoreContext context) override {\n    auto req = sandstormCore.restoreRequest();\n    req.setToken(context.getParams().getToken());\n    return req.send().then([context](auto args) mutable -> void {\n      context.getResults().setCap(args.getCap());\n    });\n  }"
  },
  {
    "function_name": "save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1874-1884",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    auto args = context.getParams();\n    KJ_REQUIRE(args.hasCap(), \"Cannot save a null capability.\");\n    auto req = args.getCap().template castAs<SystemPersistent>().saveRequest();\n    auto grainOwner = req.getSealFor().initGrain();\n    grainOwner.setGrainId(grainId);\n    grainOwner.setSaveLabel(args.getLabel());\n    return req.send().then([this, context](auto args) mutable -> void {\n      context.getResults().setToken(args.getSturdyRef());\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[this, context](auto args) mutable -> void {\n      context.getResults().setToken(args.getSturdyRef());\n    }"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "args.getSturdyRef()"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getSturdyRef",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainOwner.setSaveLabel",
          "args": [
            "args.getLabel()"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getLabel",
          "args": [],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grainOwner.setGrainId",
          "args": [
            "grainId"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "setGrainId",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "619-625",
          "snippet": "kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n  if (id == nullptr || id.findFirst('/') != nullptr) {\n    return \"Invalid grain id.\";\n  }\n  grainId = kj::heapString(id);\n  return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n    if (id == nullptr || id.findFirst('/') != nullptr) {\n      return \"Invalid grain id.\";\n    }\n    grainId = kj::heapString(id);\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "req.getSealFor",
          "args": [],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getSealFor",
          "args": [],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getCap",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "args.hasCap()",
            "\"Cannot save a null capability.\""
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.hasCap",
          "args": [],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> save(SaveContext context) override {\n    auto args = context.getParams();\n    KJ_REQUIRE(args.hasCap(), \"Cannot save a null capability.\");\n    auto req = args.getCap().template castAs<SystemPersistent>().saveRequest();\n    auto grainOwner = req.getSealFor().initGrain();\n    grainOwner.setGrainId(grainId);\n    grainOwner.setSaveLabel(args.getLabel());\n    return req.send().then([this, context](auto args) mutable -> void {\n      context.getResults().setToken(args.getSturdyRef());\n    });\n  }"
  },
  {
    "function_name": "SandstormApiImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1854-1856",
    "snippet": "SandstormApiImpl(WakelockSet& wakelockSet, kj::StringPtr grainId,\n                   SandstormCore::Client& sandstormCore)\n    : wakelockSet(wakelockSet), grainId(grainId), sandstormCore(sandstormCore), tasks(*this) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;",
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\nSandstormCore::Client sandstormCore;\n\nSandstormApiImpl(WakelockSet& wakelockSet, kj::StringPtr grainId,\n                   SandstormCore::Client& sandstormCore)\n    : wakelockSet(wakelockSet), grainId(grainId), sandstormCore(sandstormCore), tasks(*this) {}"
  },
  {
    "function_name": "taskFailed",
    "container": "WakelockSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1841-1843",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet {\n  void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, exception);\n    }\n}"
  },
  {
    "function_name": "restore",
    "container": "WakelockSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1832-1837",
    "snippet": "PersistentOngoingNotification::Client restore(uint32_t wakelockId) {\n    auto iter = wakelockMap.find(wakelockId);\n    KJ_REQUIRE(iter != wakelockMap.end(), \"Wakelock id not found\");\n    return kj::heap<WakelockSet::WrappedOngoingNotification>(iter->second.ongoingNotification,\n                                                             *this);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<WakelockSet::WrappedOngoingNotification>",
          "args": [
            "iter->second.ongoingNotification",
            "*this"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "iter != wakelockMap.end()",
            "\"Wakelock id not found\""
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockMap.end",
          "args": [],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockMap.find",
          "args": [
            "wakelockId"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet {\n  PersistentOngoingNotification::Client restore(uint32_t wakelockId) {\n      auto iter = wakelockMap.find(wakelockId);\n      KJ_REQUIRE(iter != wakelockMap.end(), \"Wakelock id not found\");\n      return kj::heap<WakelockSet::WrappedOngoingNotification>(iter->second.ongoingNotification,\n                                                               *this);\n    }\n}"
  },
  {
    "function_name": "drop",
    "container": "WakelockSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1822-1830",
    "snippet": "void drop(uint32_t wakelockId) {\n    auto iter = wakelockMap.find(wakelockId);\n    if (iter == wakelockMap.end()) {\n      KJ_LOG(WARNING, \"Tried to drop a wakelock that has already been deleted\");\n      return;\n    }\n    wakelockMap.erase(iter);\n    decrementWakelock();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decrementWakelock",
          "args": [],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "decrementWakelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1744-1751",
          "snippet": "static void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nstatic void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakelockMap.erase",
          "args": [
            "iter"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"Tried to drop a wakelock that has already been deleted\""
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockMap.end",
          "args": [],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockMap.find",
          "args": [
            "wakelockId"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet {\n  void drop(uint32_t wakelockId) {\n      auto iter = wakelockMap.find(wakelockId);\n      if (iter == wakelockMap.end()) {\n        KJ_LOG(WARNING, \"Tried to drop a wakelock that has already been deleted\");\n        return;\n      }\n      wakelockMap.erase(iter);\n      decrementWakelock();\n    }\n}"
  },
  {
    "function_name": "save",
    "container": "WakelockSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1811-1820",
    "snippet": "capnp::RemotePromise<sandstorm::SandstormCore::MakeTokenResults>\n  save(OngoingNotification::Client client) {\n    ++sandstorm::wakelockCount;\n    auto id = counter++;\n    wakelockMap.insert(std::make_pair(id, WakeLockInfo(client)));\n    auto req = sandstormCore.makeTokenRequest();\n    req.getRef().setWakeLockNotification(id);\n    req.getOwner().setFrontend();\n    return req.send();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getOwner",
          "args": [],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getOwner",
          "args": [],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getRef",
          "args": [
            "id"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getRef",
          "args": [],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.makeTokenRequest",
          "args": [],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakelockMap.insert",
          "args": [
            "std::make_pair(id, WakeLockInfo(client))"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "id",
            "WakeLockInfo(client)"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WakeLockInfo",
          "args": [
            "client"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "WakeLockInfo",
          "container": "WakeLockInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1757-1758",
          "snippet": "WakeLockInfo(OngoingNotification::Client& ongoingNotification)\n    : ongoingNotification(ongoingNotification) {}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakeLockInfo {\n  WakeLockInfo(OngoingNotification::Client& ongoingNotification)\n      : ongoingNotification(ongoingNotification) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nWakelockSet {\n  capnp::RemotePromise<sandstorm::SandstormCore::MakeTokenResults>\n    save(OngoingNotification::Client client) {\n      ++sandstorm::wakelockCount;\n      auto id = counter++;\n      wakelockMap.insert(std::make_pair(id, WakeLockInfo(client)));\n      auto req = sandstormCore.makeTokenRequest();\n      req.getRef().setWakeLockNotification(id);\n      req.getOwner().setFrontend();\n      return req.send();\n    }\n}"
  },
  {
    "function_name": "WakelockSet",
    "container": "WakelockSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1806-1807",
    "snippet": "WakelockSet(kj::StringPtr grainId, SandstormCore::Client& sandstormCore)\n    : grainId(grainId), sandstormCore(sandstormCore), tasks(*this), counter(1) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nWakelockSet {\n  WakelockSet(kj::StringPtr grainId, SandstormCore::Client& sandstormCore)\n      : grainId(grainId), sandstormCore(sandstormCore), tasks(*this), counter(1) {}\n}"
  },
  {
    "function_name": "save",
    "container": "WakelockSet::WrappedOngoingNotification",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1795-1799",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n      return wakelockSet.save(ongoingNotification).then([context] (auto args) mutable -> void {\n        context.getResults().setSturdyRef(args.getToken());\n      });\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakelockSet.save",
          "args": [
            "[context] (auto args) mutable -> void {\n        context.getResults().setSturdyRef(args.getToken());\n      }"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1874-1884",
          "snippet": "kj::Promise<void> save(SaveContext context) override {\n    auto args = context.getParams();\n    KJ_REQUIRE(args.hasCap(), \"Cannot save a null capability.\");\n    auto req = args.getCap().template castAs<SystemPersistent>().saveRequest();\n    auto grainOwner = req.getSealFor().initGrain();\n    grainOwner.setGrainId(grainId);\n    grainOwner.setSaveLabel(args.getLabel());\n    return req.send().then([this, context](auto args) mutable -> void {\n      context.getResults().setToken(args.getSturdyRef());\n    });\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nkj::Promise<void> save(SaveContext context) override {\n    auto args = context.getParams();\n    KJ_REQUIRE(args.hasCap(), \"Cannot save a null capability.\");\n    auto req = args.getCap().template castAs<SystemPersistent>().saveRequest();\n    auto grainOwner = req.getSealFor().initGrain();\n    grainOwner.setGrainId(grainId);\n    grainOwner.setSaveLabel(args.getLabel());\n    return req.send().then([this, context](auto args) mutable -> void {\n      context.getResults().setToken(args.getSturdyRef());\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "args.getToken()"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getToken",
          "args": [],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\n\nWakelockSet {\n  WrappedOngoingNotification {\n    kj::Promise<void> save(SaveContext context) override {\n          return wakelockSet.save(ongoingNotification).then([context] (auto args) mutable -> void {\n            context.getResults().setSturdyRef(args.getToken());\n          });\n        }\n  }\n}"
  },
  {
    "function_name": "cancel",
    "container": "WakelockSet::WrappedOngoingNotification",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1790-1793",
    "snippet": "kj::Promise<void> cancel(CancelContext context) override {\n      cancel();\n      return ongoingNotification.cancelRequest().send().ignoreResult();\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ongoingNotification.cancelRequest",
          "args": [],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ongoingNotification.cancelRequest",
          "args": [],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ongoingNotification.cancelRequest",
          "args": [],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel",
          "args": [],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "cancel",
          "container": "WakelockSet::WrappedOngoingNotification",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1783-1788",
          "snippet": "void cancel() {\n      if (!isCancelled) {\n        isCancelled = true;\n        decrementWakelock();\n      }\n    }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet {\n  WrappedOngoingNotification {\n    kj::Promise<void> cancel(CancelContext context) override {\n          cancel();\n          return ongoingNotification.cancelRequest().send().ignoreResult();\n        }\n  }\n}"
  },
  {
    "function_name": "cancel",
    "container": "WakelockSet::WrappedOngoingNotification",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1783-1788",
    "snippet": "void cancel() {\n      if (!isCancelled) {\n        isCancelled = true;\n        decrementWakelock();\n      }\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decrementWakelock",
          "args": [],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "decrementWakelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1744-1751",
          "snippet": "static void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nstatic void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet {\n  WrappedOngoingNotification {\n    void cancel() {\n          if (!isCancelled) {\n            isCancelled = true;\n            decrementWakelock();\n          }\n        }\n  }\n}"
  },
  {
    "function_name": "WrappedOngoingNotification",
    "container": "WakelockSet::WrappedOngoingNotification",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1768-1772",
    "snippet": "WrappedOngoingNotification(OngoingNotification::Client ongoingNotification,\n                               WakelockSet& wakelockSet)\n      : ongoingNotification(ongoingNotification), wakelockSet(wakelockSet), isCancelled(false) {\n      ++sandstorm::wakelockCount;\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WakelockSet& wakelockSet;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\n\nWakelockSet {\n  WrappedOngoingNotification {\n    WrappedOngoingNotification(OngoingNotification::Client ongoingNotification,\n                                   WakelockSet& wakelockSet)\n          : ongoingNotification(ongoingNotification), wakelockSet(wakelockSet), isCancelled(false) {\n          ++sandstorm::wakelockCount;\n        }\n  }\n}"
  },
  {
    "function_name": "WakeLockInfo",
    "container": "WakeLockInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1757-1758",
    "snippet": "WakeLockInfo(OngoingNotification::Client& ongoingNotification)\n    : ongoingNotification(ongoingNotification) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakeLockInfo {\n  WakeLockInfo(OngoingNotification::Client& ongoingNotification)\n      : ongoingNotification(ongoingNotification) {}\n}"
  },
  {
    "function_name": "decrementWakelock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1744-1751",
    "snippet": "static void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain's backgrounding has been disabled; staying up for now.\""
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nstatic void decrementWakelock() {\n  --sandstorm::wakelockCount;\n  if (sandstorm::wakelockCount == 0) {\n    SANDSTORM_LOG(\"Grain's backgrounding has been disabled; staying up for now.\");\n    // Stay alive for one more keepAlive tick after disabling backgrounding.\n    sandstorm::keepAlive = true;\n  }\n}"
  },
  {
    "function_name": "export_",
    "container": "SupervisorRealmGatewayImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1736-1739",
    "snippet": "kj::Promise<void> export_(ExportContext context) override {\n    KJ_FAIL_REQUIRE(\"Cannot directly call save() on capabilities outside the grain. \"\n      \"Use SandstormApi.save() instead.\");\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Cannot directly call save() on capabilities outside the grain. \"\n      \"Use SandstormApi.save() instead.\""
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorRealmGatewayImpl {\n  kj::Promise<void> export_(ExportContext context) override {\n      KJ_FAIL_REQUIRE(\"Cannot directly call save() on capabilities outside the grain. \"\n        \"Use SandstormApi.save() instead.\");\n    }\n}"
  },
  {
    "function_name": "import",
    "container": "SupervisorRealmGatewayImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1722-1734",
    "snippet": "kj::Promise<void> import(ImportContext context) override {\n    auto cap = context.getParams().getCap().castAs<AppPersistent<>>();\n    auto owner = context.getParams().getParams().getSealFor();\n    return cap.saveRequest().send().then([this, owner, context](auto response) mutable {\n      auto req = sandstormCore.makeTokenRequest();\n      req.getRef().setAppRef(response.getObjectId());\n      req.setOwner(owner);\n      // TODO(someday): Set requirements. This will require membranes to work properly.\n      return req.send().then([context](auto response) mutable -> void {\n        context.getResults().setSturdyRef(response.getToken());\n      });\n     });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [
            "[this, owner, context](auto response) mutable {\n      auto req = sandstormCore.makeTokenRequest();\n      req.getRef().setAppRef(response.getObjectId());\n      req.setOwner(owner);\n      // TODO(someday): Set requirements. This will require membranes to work properly.\n      return req.send().then([context](auto response) mutable -> void {\n        context.getResults().setSturdyRef(response.getToken());\n      });\n     }"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto response) mutable -> void {\n        context.getResults().setSturdyRef(response.getToken());\n      }"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "response.getToken()"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getToken",
          "args": [],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setOwner",
          "args": [
            "owner"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getRef",
          "args": [
            "response.getObjectId()"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getObjectId",
          "args": [],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.getRef",
          "args": [],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.makeTokenRequest",
          "args": [],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nSupervisorRealmGatewayImpl {\n  kj::Promise<void> import(ImportContext context) override {\n      auto cap = context.getParams().getCap().castAs<AppPersistent<>>();\n      auto owner = context.getParams().getParams().getSealFor();\n      return cap.saveRequest().send().then([this, owner, context](auto response) mutable {\n        auto req = sandstormCore.makeTokenRequest();\n        req.getRef().setAppRef(response.getObjectId());\n        req.setOwner(owner);\n        // TODO(someday): Set requirements. This will require membranes to work properly.\n        return req.send().then([context](auto response) mutable -> void {\n          context.getResults().setSturdyRef(response.getToken());\n        });\n       });\n    }\n}"
  },
  {
    "function_name": "SupervisorRealmGatewayImpl",
    "container": "SupervisorRealmGatewayImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1719-1720",
    "snippet": "explicit SupervisorRealmGatewayImpl(SandstormCore::Client& sandstormCore)\n    : sandstormCore(sandstormCore) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nSupervisorRealmGatewayImpl {\n  explicit SupervisorRealmGatewayImpl(SandstormCore::Client& sandstormCore)\n      : sandstormCore(sandstormCore) {}\n}"
  },
  {
    "function_name": "addRequirements",
    "container": "SaveWrapper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1702-1704",
    "snippet": "kj::Promise<void> addRequirements(AddRequirementsContext context) override {\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSaveWrapper {\n  kj::Promise<void> addRequirements(AddRequirementsContext context) override {\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "save",
    "container": "SaveWrapper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1691-1700",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    auto owner = context.getParams().getSealFor();\n    auto req = sandstormCore.makeChildTokenRequest();\n    req.setParent(parentToken);\n    req.setOwner(owner);\n    req.setRequirements(requirements);\n    return req.send().then([context](auto args) mutable -> void {\n      context.getResults().setSturdyRef(args.getToken());\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto args) mutable -> void {\n      context.getResults().setSturdyRef(args.getToken());\n    }"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "args.getToken()"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args.getToken",
          "args": [],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setRequirements",
          "args": [
            "requirements"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setOwner",
          "args": [
            "owner"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setParent",
          "args": [
            "parentToken"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandstormCore.makeChildTokenRequest",
          "args": [],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nSaveWrapper {\n  kj::Promise<void> save(SaveContext context) override {\n      auto owner = context.getParams().getSealFor();\n      auto req = sandstormCore.makeChildTokenRequest();\n      req.setParent(parentToken);\n      req.setOwner(owner);\n      req.setRequirements(requirements);\n      return req.send().then([context](auto args) mutable -> void {\n        context.getResults().setSturdyRef(args.getToken());\n      });\n    }\n}"
  },
  {
    "function_name": "dispatchCall",
    "container": "SaveWrapper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1675-1689",
    "snippet": "kj::Promise<void> dispatchCall(\n      uint64_t interfaceId, uint16_t methodId,\n      capnp::CallContext<capnp::AnyPointer, capnp::AnyPointer> context) override {\n    if (interfaceId == capnp::typeId<capnp::Persistent<>>()) {\n      return capnp::Persistent< capnp::Data,\n        sandstorm::ApiTokenOwner>::Server::dispatchCallInternal(methodId, context);\n    } else if (interfaceId == capnp::typeId<SystemPersistent>()) {\n      return SystemPersistent::Server::dispatchCallInternal(methodId, context);\n    }\n\n    capnp::AnyPointer::Reader params = context.getParams();\n    auto req = cap.typelessRequest(interfaceId, methodId, params.targetSize());\n    req.set(params);\n    return context.tailCall(kj::mv(req));\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.tailCall",
          "args": [
            "kj::mv(req)"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "req"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.set",
          "args": [
            "params"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.typelessRequest",
          "args": [
            "interfaceId",
            "methodId",
            "params.targetSize()"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.targetSize",
          "args": [],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SystemPersistent::Server::dispatchCallInternal",
          "args": [
            "methodId",
            "context"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<SystemPersistent>",
          "args": [],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Persistent< capnp::Data,\n        sandstorm::ApiTokenOwner>::Server::dispatchCallInternal",
          "args": [
            "methodId",
            "context"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<capnp::Persistent<>>",
          "args": [],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSaveWrapper {\n  kj::Promise<void> dispatchCall(\n        uint64_t interfaceId, uint16_t methodId,\n        capnp::CallContext<capnp::AnyPointer, capnp::AnyPointer> context) override {\n      if (interfaceId == capnp::typeId<capnp::Persistent<>>()) {\n        return capnp::Persistent< capnp::Data,\n          sandstorm::ApiTokenOwner>::Server::dispatchCallInternal(methodId, context);\n      } else if (interfaceId == capnp::typeId<SystemPersistent>()) {\n        return SystemPersistent::Server::dispatchCallInternal(methodId, context);\n      }\n  \n      capnp::AnyPointer::Reader params = context.getParams();\n      auto req = cap.typelessRequest(interfaceId, methodId, params.targetSize());\n      req.set(params);\n      return context.tailCall(kj::mv(req));\n    }\n}"
  },
  {
    "function_name": "SaveWrapper",
    "container": "SaveWrapper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1667-1673",
    "snippet": "SaveWrapper(AppPersistent<>::Client&& cap, capnp::List<MembraneRequirement>::Reader _requirements,\n              capnp::Data::Reader parentToken, SandstormCore::Client sandstormCore)\n      : cap(kj::mv(cap)), parentToken(kj::heapArray<const byte>(parentToken)),\n        sandstormCore(kj::mv(sandstormCore)) {\n    builder.setRoot(kj::mv(_requirements));\n    requirements = builder.getRoot<capnp::List<MembraneRequirement>>().asReader();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SandstormCore::Client sandstormCore;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getRoot<capnp::List<MembraneRequirement>>",
          "args": [],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getRoot<capnp::List<MembraneRequirement>>",
          "args": [],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setRoot",
          "args": [
            "kj::mv(_requirements)"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "setRoot",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "66-69",
          "snippet": "bool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRoot(kj::StringPtr arg) {\n    root = arg;\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "_requirements"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sandstormCore"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<const byte>",
          "args": [
            "parentToken"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSandstormCore::Client sandstormCore;\n\nSaveWrapper {\n  SaveWrapper(AppPersistent<>::Client&& cap, capnp::List<MembraneRequirement>::Reader _requirements,\n                capnp::Data::Reader parentToken, SandstormCore::Client sandstormCore)\n        : cap(kj::mv(cap)), parentToken(kj::heapArray<const byte>(parentToken)),\n          sandstormCore(kj::mv(sandstormCore)) {\n      builder.setRoot(kj::mv(_requirements));\n      requirements = builder.getRoot<capnp::List<MembraneRequirement>>().asReader();\n    }\n}"
  },
  {
    "function_name": "runChild",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1607-1661",
    "snippet": "[[noreturn]] void SupervisorMain::runChild(int apiFd, kj::AutoCloseFd startEventFd) {\n  // We are the child.\n\n  enterSandbox();\n\n  // Wait until we get the signal to start. (It's important to do this after entering the sandbox\n  // so that the parent process has permission to send SIGKILL to the child even in\n  // privileged-mode.)\n  uint64_t dummy;\n  KJ_SYSCALL(read(startEventFd, &dummy, sizeof(dummy)));\n\n  // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n  // code likes to ignore e.g. SIGPIPE.)\n  // TODO(cleanup):  Is there a better way to do this?\n  for (uint i = 0; i < NSIG; i++) {\n    signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n  }\n\n  // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n  sigset_t sigmask;\n  sigemptyset(&sigmask);\n  KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n\n  // Make sure the API socket is on FD 3.\n  if (apiFd == 3) {\n    // Socket end already has correct fd.  Unset CLOEXEC.\n    KJ_SYSCALL(fcntl(apiFd, F_SETFD, 0));\n  } else {\n    // dup socket to correct fd.\n    KJ_SYSCALL(dup2(apiFd, 3));\n    KJ_SYSCALL(close(apiFd));\n  }\n\n  // Redirect stdout to stderr, so that our own stdout serves one purpose:  to notify the parent\n  // process when we're ready to accept connections.  We previously directed stderr to a log file.\n  KJ_SYSCALL(dup2(STDERR_FILENO, STDOUT_FILENO));\n\n  char* argv[command.size() + 1];\n  for (uint i: kj::indices(command)) {\n    argv[i] = const_cast<char*>(command[i].cStr());\n  }\n  argv[command.size()] = nullptr;\n\n  char* env[environment.size() + 1];\n  for (uint i: kj::indices(environment)) {\n    env[i] = const_cast<char*>(environment[i].cStr());\n  }\n  env[environment.size()] = nullptr;\n\n  char** argvp = argv;  // work-around Clang not liking lambda + vararray\n  char** envp = env;    // same\n\n  KJ_SYSCALL(execve(argvp[0], argvp, envp), argvp[0]);\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execve(argvp[0], argvp, envp)",
            "argvp[0]"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "argvp[0]",
            "argvp",
            "envp"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "environment.size",
          "args": [],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "environment[i].cStr()"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "environment[i].cStr",
          "args": [],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "environment"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "command[i].cStr()"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command[i].cStr",
          "args": [],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "command"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(STDERR_FILENO, STDOUT_FILENO)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDERR_FILENO",
            "STDOUT_FILENO"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(apiFd)"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "apiFd"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(apiFd, 3)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "apiFd",
            "3"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(apiFd, F_SETFD, 0)"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "apiFd",
            "F_SETFD",
            "0"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &sigmask, nullptr)"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigmask",
            "nullptr"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sigmask"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "i",
            "SIG_DFL"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "read(startEventFd, &dummy, sizeof(dummy))"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "startEventFd",
            "&dummy",
            "sizeof(dummy)"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "enterSandbox",
          "args": [],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "enterSandbox",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1534-1550",
          "snippet": "void SupervisorMain::enterSandbox() {\n  // Fully enter the sandbox.  Called only by the child process.\n  KJ_SYSCALL(chdir(\"/\"));\n\n  // Unshare the network, creating a new loopback interface.\n  unshareNetwork();\n\n  // Mount proc if --proc was passed.\n  maybeFinishMountingProc();\n\n  // Now actually drop all credentials.\n  permanentlyDropSuperuser();\n\n  // Use seccomp to disable dangerous syscalls. We do this last so that we can disable things\n  // that we just used above, like unshare() or setuid().\n  setupSeccomp();\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::enterSandbox() {\n    // Fully enter the sandbox.  Called only by the child process.\n    KJ_SYSCALL(chdir(\"/\"));\n  \n    // Unshare the network, creating a new loopback interface.\n    unshareNetwork();\n  \n    // Mount proc if --proc was passed.\n    maybeFinishMountingProc();\n  \n    // Now actually drop all credentials.\n    permanentlyDropSuperuser();\n  \n    // Use seccomp to disable dangerous syscalls. We do this last so that we can disable things\n    // that we just used above, like unshare() or setuid().\n    setupSeccomp();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  [[noreturn]] void SupervisorMain::runChild(int apiFd, kj::AutoCloseFd startEventFd) {\n    // We are the child.\n  \n    enterSandbox();\n  \n    // Wait until we get the signal to start. (It's important to do this after entering the sandbox\n    // so that the parent process has permission to send SIGKILL to the child even in\n    // privileged-mode.)\n    uint64_t dummy;\n    KJ_SYSCALL(read(startEventFd, &dummy, sizeof(dummy)));\n  \n    // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n    // code likes to ignore e.g. SIGPIPE.)\n    // TODO(cleanup):  Is there a better way to do this?\n    for (uint i = 0; i < NSIG; i++) {\n      signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n    }\n  \n    // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n    sigset_t sigmask;\n    sigemptyset(&sigmask);\n    KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n  \n    // Make sure the API socket is on FD 3.\n    if (apiFd == 3) {\n      // Socket end already has correct fd.  Unset CLOEXEC.\n      KJ_SYSCALL(fcntl(apiFd, F_SETFD, 0));\n    } else {\n      // dup socket to correct fd.\n      KJ_SYSCALL(dup2(apiFd, 3));\n      KJ_SYSCALL(close(apiFd));\n    }\n  \n    // Redirect stdout to stderr, so that our own stdout serves one purpose:  to notify the parent\n    // process when we're ready to accept connections.  We previously directed stderr to a log file.\n    KJ_SYSCALL(dup2(STDERR_FILENO, STDOUT_FILENO));\n  \n    char* argv[command.size() + 1];\n    for (uint i: kj::indices(command)) {\n      argv[i] = const_cast<char*>(command[i].cStr());\n    }\n    argv[command.size()] = nullptr;\n  \n    char* env[environment.size() + 1];\n    for (uint i: kj::indices(environment)) {\n      env[i] = const_cast<char*>(environment[i].cStr());\n    }\n    env[environment.size()] = nullptr;\n  \n    char** argvp = argv;  // work-around Clang not liking lambda + vararray\n    char** envp = env;    // same\n  \n    KJ_SYSCALL(execve(argvp[0], argvp, envp), argvp[0]);\n    KJ_UNREACHABLE;\n  }\n}"
  },
  {
    "function_name": "checkIfAlreadyRunning",
    "container": "SupervisorMain::DefaultSystemConnector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1554-1603",
    "snippet": "void SupervisorMain::DefaultSystemConnector::checkIfAlreadyRunning() const {\n  // Attempt to connect to any existing supervisor and call keepAlive().  If successful, we\n  // don't want to start a new instance; we should use the existing instance.\n\n  // TODO(soon):  There's a race condition if two supervisors are started up in rapid succession.\n  //   We could maybe avoid that with some filesystem locking.  It's currently unlikely to happen\n  //   in practice because it would require sending a request to the shell server to open the\n  //   grain, then restarting the shell server, then opening the grain again, all before the\n  //   first supervisor finished starting.  Or, I suppose, running two shell servers and trying\n  //   to open the same grain in both at once.\n\n  auto ioContext = kj::setupAsyncIo();\n\n  // Connect to the client.\n  auto addr = ioContext.provider->getNetwork().parseAddress(\"unix:socket\")\n      .wait(ioContext.waitScope);\n  kj::Own<kj::AsyncIoStream> connection;\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    connection = addr->connect().wait(ioContext.waitScope);\n  })) {\n    // Failed to connect.  Assume socket is stale.\n    return;\n  }\n\n  // Set up RPC.\n  capnp::TwoPartyVatNetwork vatNetwork(*connection, capnp::rpc::twoparty::Side::CLIENT);\n  auto client = capnp::makeRpcClient(vatNetwork);\n\n  // Restore the default capability (the Supervisor interface).\n  capnp::MallocMessageBuilder message;\n  auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n  hostId.setSide(capnp::rpc::twoparty::Side::SERVER);\n  Supervisor::Client cap = client.bootstrap(hostId).castAs<Supervisor>();\n\n  // Call keepAlive().\n  auto promise = cap.keepAliveRequest().send();\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    promise.wait(ioContext.waitScope);\n  })) {\n    // Failed to keep-alive.  Supervisor must have died just as we were connecting to it.  Go\n    // ahead and start a new one.\n    return;\n  }\n\n  // We successfully connected and keepalived the existing supervisor, so we can exit.  The\n  // caller is expecting us to write to stdout when the stocket is ready, so do that anyway.\n  KJ_SYSCALL(write(STDOUT_FILENO, \"Already running...\\n\", strlen(\"Already running...\\n\")));\n  _exit(0);\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(STDOUT_FILENO, \"Already running...\\n\", strlen(\"Already running...\\n\"))"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDOUT_FILENO",
            "\"Already running...\\n\"",
            "strlen(\"Already running...\\n\")"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"Already running...\\n\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n    promise.wait(ioContext.waitScope);\n  })"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    promise.wait(ioContext.waitScope);\n  }"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.keepAliveRequest",
          "args": [],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.keepAliveRequest",
          "args": [],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bootstrap",
          "args": [],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bootstrap",
          "args": [
            "hostId"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "capnp::rpc::twoparty::Side::SERVER"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.initRoot<capnp::rpc::twoparty::VatId>",
          "args": [],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::makeRpcClient",
          "args": [
            "vatNetwork"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    connection = addr->connect().wait(ioContext.waitScope);\n  }"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->connect",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->connect",
          "args": [],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"unix:socket\""
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nSupervisorMain {\n  DefaultSystemConnector {\n    void SupervisorMain::DefaultSystemConnector::checkIfAlreadyRunning() const {\n      // Attempt to connect to any existing supervisor and call keepAlive().  If successful, we\n      // don't want to start a new instance; we should use the existing instance.\n    \n      // TODO(soon):  There's a race condition if two supervisors are started up in rapid succession.\n      //   We could maybe avoid that with some filesystem locking.  It's currently unlikely to happen\n      //   in practice because it would require sending a request to the shell server to open the\n      //   grain, then restarting the shell server, then opening the grain again, all before the\n      //   first supervisor finished starting.  Or, I suppose, running two shell servers and trying\n      //   to open the same grain in both at once.\n    \n      auto ioContext = kj::setupAsyncIo();\n    \n      // Connect to the client.\n      auto addr = ioContext.provider->getNetwork().parseAddress(\"unix:socket\")\n          .wait(ioContext.waitScope);\n      kj::Own<kj::AsyncIoStream> connection;\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        connection = addr->connect().wait(ioContext.waitScope);\n      })) {\n        // Failed to connect.  Assume socket is stale.\n        return;\n      }\n    \n      // Set up RPC.\n      capnp::TwoPartyVatNetwork vatNetwork(*connection, capnp::rpc::twoparty::Side::CLIENT);\n      auto client = capnp::makeRpcClient(vatNetwork);\n    \n      // Restore the default capability (the Supervisor interface).\n      capnp::MallocMessageBuilder message;\n      auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n      hostId.setSide(capnp::rpc::twoparty::Side::SERVER);\n      Supervisor::Client cap = client.bootstrap(hostId).castAs<Supervisor>();\n    \n      // Call keepAlive().\n      auto promise = cap.keepAliveRequest().send();\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        promise.wait(ioContext.waitScope);\n      })) {\n        // Failed to keep-alive.  Supervisor must have died just as we were connecting to it.  Go\n        // ahead and start a new one.\n        return;\n      }\n    \n      // We successfully connected and keepalived the existing supervisor, so we can exit.  The\n      // caller is expecting us to write to stdout when the stocket is ready, so do that anyway.\n      KJ_SYSCALL(write(STDOUT_FILENO, \"Already running...\\n\", strlen(\"Already running...\\n\")));\n      _exit(0);\n      KJ_UNREACHABLE;\n    }\n  }\n}"
  },
  {
    "function_name": "enterSandbox",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1534-1550",
    "snippet": "void SupervisorMain::enterSandbox() {\n  // Fully enter the sandbox.  Called only by the child process.\n  KJ_SYSCALL(chdir(\"/\"));\n\n  // Unshare the network, creating a new loopback interface.\n  unshareNetwork();\n\n  // Mount proc if --proc was passed.\n  maybeFinishMountingProc();\n\n  // Now actually drop all credentials.\n  permanentlyDropSuperuser();\n\n  // Use seccomp to disable dangerous syscalls. We do this last so that we can disable things\n  // that we just used above, like unshare() or setuid().\n  setupSeccomp();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setupSeccomp",
          "args": [],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "setupSeccomp",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1067-1210",
          "snippet": "void SupervisorMain::setupSeccomp() {\n  // Install a rudimentary seccomp blacklist.\n  // TODO(security): Change this to a whitelist.\n\n  scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n  if (ctx == nullptr)\n    KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n  KJ_DEFER(seccomp_release(ctx));\n\n#define CHECK_SECCOMP(call)                   \\\n  do {                                        \\\n    if (auto result = (call)) {               \\\n      KJ_FAIL_SYSCALL(#call, -result);        \\\n    }                                         \\\n  } while (0)\n\n  // Native code only for now, so there are no seccomp_arch_add calls.\n\n  // Redundant, but this is standard and harmless.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n\n  // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n  // should fail, but there's no need to kill the issuer.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n  // Disable some things that seem scary.\n  if (!devmode) {\n    // ptrace is scary\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n  } else {\n    // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n    // orig_ax using ptrace allows a complete seccomp bypass.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n  }\n\n  // Restrict the set of allowable network protocol families\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n\n  // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n  // of interesting information leaks.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n\n  // Despite existing at a 64-bit syscall, set_thread_area is only useful\n  // for 32-bit programs.  64-bit programs use arch_prctl instead.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n\n  // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n      SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n\n  // AIO is scary.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n\n  // Scary vm syscalls\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n\n  // Scary futex operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n\n  // Utterly terrifying profiling operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n\n  // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n  // that run in-kernel (albeit with a very limited instruction set).\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n      SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n\n  // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n  // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n  //   disable things until we've reviewed them?\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n\n  // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n\n  // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n\n  if (seccompDumpPfc) {\n    seccomp_export_pfc(ctx, 1);\n  }\n\n  CHECK_SECCOMP(seccomp_load(ctx));\n\n#pragma GCC diagnostic pop\n#undef CHECK_SECCOMP\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto result = kj::heapString(cResult);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nSupervisorMain {\n  void SupervisorMain::setupSeccomp() {\n    // Install a rudimentary seccomp blacklist.\n    // TODO(security): Change this to a whitelist.\n  \n    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n    if (ctx == nullptr)\n      KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n    KJ_DEFER(seccomp_release(ctx));\n  \n  #define CHECK_SECCOMP(call)                   \\\n    do {                                        \\\n      if (auto result = (call)) {               \\\n        KJ_FAIL_SYSCALL(#call, -result);        \\\n      }                                         \\\n    } while (0)\n  \n    // Native code only for now, so there are no seccomp_arch_add calls.\n  \n    // Redundant, but this is standard and harmless.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n  \n    // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n    // should fail, but there's no need to kill the issuer.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n  \n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n    // Disable some things that seem scary.\n    if (!devmode) {\n      // ptrace is scary\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n    } else {\n      // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n      // orig_ax using ptrace allows a complete seccomp bypass.\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n    }\n  \n    // Restrict the set of allowable network protocol families\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n  \n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n  \n    // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n    // of interesting information leaks.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n  \n    // Despite existing at a 64-bit syscall, set_thread_area is only useful\n    // for 32-bit programs.  64-bit programs use arch_prctl instead.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n  \n    // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n        SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n  \n    // AIO is scary.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n  \n    // Scary vm syscalls\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n  \n    // Scary futex operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n  \n    // Utterly terrifying profiling operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n  \n    // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n    // that run in-kernel (albeit with a very limited instruction set).\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n        SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n  \n    // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n    // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n    //   disable things until we've reviewed them?\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n  \n    // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n  \n    // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n  \n    if (seccompDumpPfc) {\n      seccomp_export_pfc(ctx, 1);\n    }\n  \n    CHECK_SECCOMP(seccomp_load(ctx));\n  \n  #pragma GCC diagnostic pop\n  #undef CHECK_SECCOMP\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "permanentlyDropSuperuser",
          "args": [],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "permanentlyDropSuperuser",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1508-1525",
          "snippet": "void SupervisorMain::permanentlyDropSuperuser() {\n  KJ_IF_MAYBE(ruid, sandboxUid) {\n    // setuid() to non-zero implicitly drops capabilities.\n    KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n  } else {\n    // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n    // object-capabilities, hence the quotes.)\n    //\n    // This unfortunately must be performed post-fork (in both parent and child), because the child\n    // needs to do one final unshare().\n\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::permanentlyDropSuperuser() {\n    KJ_IF_MAYBE(ruid, sandboxUid) {\n      // setuid() to non-zero implicitly drops capabilities.\n      KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n    } else {\n      // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n      // object-capabilities, hence the quotes.)\n      //\n      // This unfortunately must be performed post-fork (in both parent and child), because the child\n      // needs to do one final unshare().\n  \n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybeFinishMountingProc",
          "args": [],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "maybeFinishMountingProc",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1487-1506",
          "snippet": "void SupervisorMain::maybeFinishMountingProc() {\n  // Mount proc if it was requested.  Note that this must take place after fork() to get the\n  // correct pid namespace.  We must keep a copy of proc mounted at all times; otherwise we\n  // lose the privilege of mounting proc.\n\n  if (mountProc) {\n    auto oldProc = raiiOpen(\"proc\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\n    // This puts the new proc onto the namespace root, which is mostly inaccessible.\n    KJ_SYSCALL(mount(\"proc\", \"/\", nullptr, MS_MOVE, nullptr));\n\n    // Now mount the new proc in the right place.\n    KJ_SYSCALL(mount(\"proc\", \"proc\", \"proc\", MS_NOSUID | MS_NODEV | MS_NOEXEC, nullptr));\n\n    // And get rid of the old one.\n    KJ_SYSCALL(fchdir(oldProc));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/\"));\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::maybeFinishMountingProc() {\n    // Mount proc if it was requested.  Note that this must take place after fork() to get the\n    // correct pid namespace.  We must keep a copy of proc mounted at all times; otherwise we\n    // lose the privilege of mounting proc.\n  \n    if (mountProc) {\n      auto oldProc = raiiOpen(\"proc\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  \n      // This puts the new proc onto the namespace root, which is mostly inaccessible.\n      KJ_SYSCALL(mount(\"proc\", \"/\", nullptr, MS_MOVE, nullptr));\n  \n      // Now mount the new proc in the right place.\n      KJ_SYSCALL(mount(\"proc\", \"proc\", \"proc\", MS_NOSUID | MS_NODEV | MS_NOEXEC, nullptr));\n  \n      // And get rid of the old one.\n      KJ_SYSCALL(fchdir(oldProc));\n      KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n      KJ_SYSCALL(chdir(\"/\"));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshareNetwork",
          "args": [],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "unshareNetwork",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1212-1460",
          "snippet": "void SupervisorMain::unshareNetwork() {\n  // Unshare the network and set up a new loopback device.\n\n  // Enter new network namespace.\n  KJ_SYSCALL(unshare(CLONE_NEWNET));\n\n  // Create a socket for our ioctls.\n  int fd;\n  KJ_SYSCALL(fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP));\n  KJ_DEFER(close(fd));\n\n  // Bring up the loopback device.\n  {\n    // Set the address of \"lo\".\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    strcpy(ifr.ifr_ifrn.ifrn_name, \"lo\");\n    struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n    addr->sin_family = AF_INET;\n    addr->sin_addr.s_addr = htonl(0x7F000001);  // 127.0.0.1\n    KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n\n    // Set flags to enable \"lo\".\n    memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n    ifr.ifr_ifru.ifru_flags = IFF_LOOPBACK | IFF_UP | IFF_RUNNING;\n    KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n  }\n\n  // Check if iptables module is available, skip the rest if not.\n  if (!isIpTablesAvailable) {\n    // TODO(soon): Put a runtime warning here, so that people can notice if this code won't work.\n    return;\n  }\n\n  // Create a fake network interface \"dummy0\" of type \"dummy\". We need this only so that we can\n  // route packets to it which we can in turn filter with iptables.\n  {\n    int netlink;\n    KJ_SYSCALL(netlink = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE));\n    KJ_DEFER(close(netlink));\n\n    socklen_t bufsize = 32768;\n    KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize)));\n    bufsize = 1048576;\n    KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize)));\n\n    StructyMessage message(4);\n\n    auto header = message.add<struct nlmsghdr>();\n\n    header->nlmsg_type = RTM_NEWLINK;\n    header->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL;\n\n    message.add<struct ifinfomsg>();  // leave zero'd\n\n    auto ifnameAttr = message.add<struct rtattr>();\n    ifnameAttr->rta_len = sizeof(struct rtattr) + sizeof(\"dummy0\");\n    ifnameAttr->rta_type = IFLA_IFNAME;\n    message.addString(\"dummy0\");\n\n    auto portAttr = message.add<struct rtattr>();\n    portAttr->rta_type = IFLA_LINKINFO;\n\n    // We're cargo-culting a bit here. IFLA_LINKINFO is not documented but it looks kind of\n    // like an rtattr. For some reason the string value is not NUL-terminated, though.\n    auto typeAttr = message.add<struct rtattr>();\n    typeAttr->rta_type = IFLA_INFO_KIND;  // Looks like it might be the right constant?\n    typeAttr->rta_len = sizeof(struct rtattr) + strlen(\"dummy\");\n    message.addBytes(\"dummy\", strlen(\"dummy\"));\n\n    portAttr->rta_len = offsetBetween(portAttr, message.end());\n\n    header->nlmsg_len = offsetBetween(header, message.end());\n\n    struct msghdr socketMsg;\n    memset(&socketMsg, 0, sizeof(socketMsg));\n\n    struct sockaddr_nl netlinkAddr;\n    memset(&netlinkAddr, 0, sizeof(netlinkAddr));\n    netlinkAddr.nl_family = AF_NETLINK;\n    socketMsg.msg_name = &netlinkAddr;\n    socketMsg.msg_namelen = sizeof(netlinkAddr);\n\n    struct iovec iov;\n    iov.iov_base = message.begin();\n    iov.iov_len = message.size();\n    socketMsg.msg_iov = &iov;\n    socketMsg.msg_iovlen = 1;\n\n    KJ_SYSCALL(sendmsg(netlink, &socketMsg, 0));\n\n    struct {\n      struct nlmsghdr header;\n      struct nlmsgerr error;\n      char buffer[512];\n    } result;\n    iov.iov_base = &result;\n    iov.iov_len = sizeof(result);\n\n    KJ_SYSCALL(recvmsg(netlink, &socketMsg, 0));\n\n    KJ_ASSERT(result.header.nlmsg_type == NLMSG_ERROR);\n    KJ_ASSERT(result.header.nlmsg_seq == 0);\n    if (result.error.error != 0) {\n      KJ_FAIL_SYSCALL(\"netlink(ip link add dummy0 type dummy)\", -result.error.error);\n    }\n  }\n\n  // Bring up dummy0.\n  {\n    // Set the address of \"dummy0\".\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    strcpy(ifr.ifr_ifrn.ifrn_name, \"dummy0\");\n    struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n    addr->sin_family = AF_INET;\n    addr->sin_addr.s_addr = htonl(0xc0a8fa02);  // 192.168.250.2\n    KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n\n    // Set flags to enable \"dummy0\".\n    memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n    ifr.ifr_ifru.ifru_flags = IFF_UP | IFF_RUNNING;\n    KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n  }\n\n  // Route external addresses through the \"dummy0\" interface, so that our iptables trick works.\n  {\n    struct rtentry route;\n    memset(&route, 0, sizeof(route));\n    route.rt_flags = RTF_UP | RTF_GATEWAY;\n    route.rt_dst.sa_family = AF_INET;\n    route.rt_gateway.sa_family = AF_INET;\n    reinterpret_cast<struct sockaddr_in*>(&route.rt_gateway)->sin_addr.s_addr =\n        htonl(0xc0a8fa01);  // 192.168.250.1; any address in 192.168.250.x would work here\n\n    KJ_SYSCALL(ioctl(fd, SIOCADDRT, &route));\n  }\n\n  // Set up iptables to redirect all non-local traffic to 127.0.0.1:23136.\n  //\n  // This should be equivalent-ish to:\n  //   iptables -t nat -A OUTPUT -p tcp -j DNAT --to 127.0.0.1:23136\n  //   iptables -t nat -A OUTPUT -p udp -j DNAT --to 127.0.0.1:23136\n  {\n    // Get the existing iptables info, needed in order to properly fill out the update request.\n    struct ipt_getinfo info;\n    memset(&info, 0, sizeof(info));\n    strcpy(info.name, \"nat\");\n    socklen_t optsize = sizeof(info);\n    KJ_SYSCALL(getsockopt(fd, IPPROTO_IP, IPT_SO_GET_INFO, &info, &optsize));\n\n    // Linux kernel interfaces like to be designed as a packed list of structs of varying types,\n    // kind of like SBE but uglier. Ugh.\n    StructyMessage message;\n\n    // Create a replace message.\n    auto replace = message.add<struct ipt_replace>();\n    strcpy(replace->name, \"nat\");\n    replace->valid_hooks = info.valid_hooks;\n\n    // The kernel insists that we give it a place to write out the counters on the existing\n    // table entries. Of course, they should all be zero, and we don't care either way. But we\n    // have to give it space.\n    struct xt_counters oldCounters[info.num_entries];\n    memset(oldCounters, 0, sizeof(oldCounters));\n    replace->num_counters = info.num_entries;\n    replace->counters = oldCounters;\n\n    // Create an entry which accepts all packets destined for 127.0.0.0/8.\n    ++replace->num_entries;\n    auto acceptLocal = message.add<struct ipt_entry>();\n    acceptLocal->ip.dst.s_addr = htonl(0x7F000000);   // ip   127.0.0.0\n    acceptLocal->ip.dmsk.s_addr = htonl(0xFF000000);  // mask 255.0.0.0\n    auto acceptLocalTarget = message.add<struct ipt_entry_target>();\n    *message.add<int>() = -1 - NF_ACCEPT;\n    acceptLocalTarget->u.target_size = offsetBetween(acceptLocalTarget, message.end());\n    acceptLocal->target_offset = offsetBetween(acceptLocal, acceptLocalTarget);\n    acceptLocal->next_offset = offsetBetween(acceptLocal, message.end());\n\n    // Create an entry which forwards all TCP packets to a local port.\n    ++replace->num_entries;\n    auto dnatTcp = message.add<struct ipt_entry>();\n    dnatTcp->ip.proto = IPPROTO_TCP;\n    auto dnatTcpTarget = message.add<struct ipt_entry_target>();\n    auto dnatTcpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n    dnatTcpRange->rangesize = 1;\n    dnatTcpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n    dnatTcpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatTcpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatTcpRange->range[0].min.tcp.port = htons(23136);\n    dnatTcpRange->range[0].max.tcp.port = htons(23136);\n    dnatTcpTarget->u.user.target_size = offsetBetween(dnatTcpTarget, message.end());\n    strcpy(dnatTcpTarget->u.user.name, \"DNAT\");\n    dnatTcp->target_offset = offsetBetween(dnatTcp, dnatTcpTarget);\n    dnatTcp->next_offset = offsetBetween(dnatTcp, message.end());\n\n    // Create an entry which forwards all UDP packets to a local port.\n    ++replace->num_entries;\n    auto dnatUdp = message.add<struct ipt_entry>();\n    dnatUdp->ip.proto = IPPROTO_UDP;\n    auto dnatUdpTarget = message.add<struct ipt_entry_target>();\n    auto dnatUdpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n    dnatUdpRange->rangesize = 1;\n    dnatUdpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n    dnatUdpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatUdpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatUdpRange->range[0].min.udp.port = htons(23136);\n    dnatUdpRange->range[0].max.udp.port = htons(23136);\n    dnatUdpTarget->u.user.target_size = offsetBetween(dnatUdpTarget, message.end());\n    strcpy(dnatUdpTarget->u.user.name, \"DNAT\");\n    dnatUdp->target_offset = offsetBetween(dnatUdp, dnatUdpTarget);\n    dnatUdp->next_offset = offsetBetween(dnatUdp, message.end());\n\n    // Create an entry which accepts everything.\n    ++replace->num_entries;\n    auto acceptAll = message.add<struct ipt_entry>();\n    auto acceptAllTarget = message.add<struct ipt_entry_target>();\n    *message.add<int>() = -1 - NF_ACCEPT;\n    acceptAllTarget->u.target_size = offsetBetween(acceptAllTarget, message.end());\n    acceptAll->target_offset = offsetBetween(acceptAll, acceptAllTarget);\n    acceptAll->next_offset = offsetBetween(acceptAll, message.end());\n\n    // Cap it off with an error entry.\n    ++replace->num_entries;\n    auto error = message.add<struct ipt_entry>();\n    auto errorTarget = message.add<struct xt_error_target>();\n    errorTarget->target.u.user.target_size = offsetBetween(errorTarget, message.end());\n    strcpy(errorTarget->target.u.user.name, \"ERROR\");\n    strcpy(errorTarget->errorname, \"ERROR\");\n    error->target_offset = offsetBetween(error, errorTarget);\n    error->next_offset = offsetBetween(error, message.end());\n\n    replace->hook_entry[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptLocal);\n    replace->hook_entry[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n\n    replace->underflow[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n\n    replace->size = offsetBetween(replace->entries, message.end());\n\n    KJ_SYSCALL(setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, message.begin(), message.size()));\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto result = kj::heapString(cResult);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nSupervisorMain {\n  void SupervisorMain::unshareNetwork() {\n    // Unshare the network and set up a new loopback device.\n  \n    // Enter new network namespace.\n    KJ_SYSCALL(unshare(CLONE_NEWNET));\n  \n    // Create a socket for our ioctls.\n    int fd;\n    KJ_SYSCALL(fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP));\n    KJ_DEFER(close(fd));\n  \n    // Bring up the loopback device.\n    {\n      // Set the address of \"lo\".\n      struct ifreq ifr;\n      memset(&ifr, 0, sizeof(ifr));\n      strcpy(ifr.ifr_ifrn.ifrn_name, \"lo\");\n      struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n      addr->sin_family = AF_INET;\n      addr->sin_addr.s_addr = htonl(0x7F000001);  // 127.0.0.1\n      KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n  \n      // Set flags to enable \"lo\".\n      memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n      ifr.ifr_ifru.ifru_flags = IFF_LOOPBACK | IFF_UP | IFF_RUNNING;\n      KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n    }\n  \n    // Check if iptables module is available, skip the rest if not.\n    if (!isIpTablesAvailable) {\n      // TODO(soon): Put a runtime warning here, so that people can notice if this code won't work.\n      return;\n    }\n  \n    // Create a fake network interface \"dummy0\" of type \"dummy\". We need this only so that we can\n    // route packets to it which we can in turn filter with iptables.\n    {\n      int netlink;\n      KJ_SYSCALL(netlink = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE));\n      KJ_DEFER(close(netlink));\n  \n      socklen_t bufsize = 32768;\n      KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize)));\n      bufsize = 1048576;\n      KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize)));\n  \n      StructyMessage message(4);\n  \n      auto header = message.add<struct nlmsghdr>();\n  \n      header->nlmsg_type = RTM_NEWLINK;\n      header->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL;\n  \n      message.add<struct ifinfomsg>();  // leave zero'd\n  \n      auto ifnameAttr = message.add<struct rtattr>();\n      ifnameAttr->rta_len = sizeof(struct rtattr) + sizeof(\"dummy0\");\n      ifnameAttr->rta_type = IFLA_IFNAME;\n      message.addString(\"dummy0\");\n  \n      auto portAttr = message.add<struct rtattr>();\n      portAttr->rta_type = IFLA_LINKINFO;\n  \n      // We're cargo-culting a bit here. IFLA_LINKINFO is not documented but it looks kind of\n      // like an rtattr. For some reason the string value is not NUL-terminated, though.\n      auto typeAttr = message.add<struct rtattr>();\n      typeAttr->rta_type = IFLA_INFO_KIND;  // Looks like it might be the right constant?\n      typeAttr->rta_len = sizeof(struct rtattr) + strlen(\"dummy\");\n      message.addBytes(\"dummy\", strlen(\"dummy\"));\n  \n      portAttr->rta_len = offsetBetween(portAttr, message.end());\n  \n      header->nlmsg_len = offsetBetween(header, message.end());\n  \n      struct msghdr socketMsg;\n      memset(&socketMsg, 0, sizeof(socketMsg));\n  \n      struct sockaddr_nl netlinkAddr;\n      memset(&netlinkAddr, 0, sizeof(netlinkAddr));\n      netlinkAddr.nl_family = AF_NETLINK;\n      socketMsg.msg_name = &netlinkAddr;\n      socketMsg.msg_namelen = sizeof(netlinkAddr);\n  \n      struct iovec iov;\n      iov.iov_base = message.begin();\n      iov.iov_len = message.size();\n      socketMsg.msg_iov = &iov;\n      socketMsg.msg_iovlen = 1;\n  \n      KJ_SYSCALL(sendmsg(netlink, &socketMsg, 0));\n  \n      struct {\n        struct nlmsghdr header;\n        struct nlmsgerr error;\n        char buffer[512];\n      } result;\n      iov.iov_base = &result;\n      iov.iov_len = sizeof(result);\n  \n      KJ_SYSCALL(recvmsg(netlink, &socketMsg, 0));\n  \n      KJ_ASSERT(result.header.nlmsg_type == NLMSG_ERROR);\n      KJ_ASSERT(result.header.nlmsg_seq == 0);\n      if (result.error.error != 0) {\n        KJ_FAIL_SYSCALL(\"netlink(ip link add dummy0 type dummy)\", -result.error.error);\n      }\n    }\n  \n    // Bring up dummy0.\n    {\n      // Set the address of \"dummy0\".\n      struct ifreq ifr;\n      memset(&ifr, 0, sizeof(ifr));\n      strcpy(ifr.ifr_ifrn.ifrn_name, \"dummy0\");\n      struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n      addr->sin_family = AF_INET;\n      addr->sin_addr.s_addr = htonl(0xc0a8fa02);  // 192.168.250.2\n      KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n  \n      // Set flags to enable \"dummy0\".\n      memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n      ifr.ifr_ifru.ifru_flags = IFF_UP | IFF_RUNNING;\n      KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n    }\n  \n    // Route external addresses through the \"dummy0\" interface, so that our iptables trick works.\n    {\n      struct rtentry route;\n      memset(&route, 0, sizeof(route));\n      route.rt_flags = RTF_UP | RTF_GATEWAY;\n      route.rt_dst.sa_family = AF_INET;\n      route.rt_gateway.sa_family = AF_INET;\n      reinterpret_cast<struct sockaddr_in*>(&route.rt_gateway)->sin_addr.s_addr =\n          htonl(0xc0a8fa01);  // 192.168.250.1; any address in 192.168.250.x would work here\n  \n      KJ_SYSCALL(ioctl(fd, SIOCADDRT, &route));\n    }\n  \n    // Set up iptables to redirect all non-local traffic to 127.0.0.1:23136.\n    //\n    // This should be equivalent-ish to:\n    //   iptables -t nat -A OUTPUT -p tcp -j DNAT --to 127.0.0.1:23136\n    //   iptables -t nat -A OUTPUT -p udp -j DNAT --to 127.0.0.1:23136\n    {\n      // Get the existing iptables info, needed in order to properly fill out the update request.\n      struct ipt_getinfo info;\n      memset(&info, 0, sizeof(info));\n      strcpy(info.name, \"nat\");\n      socklen_t optsize = sizeof(info);\n      KJ_SYSCALL(getsockopt(fd, IPPROTO_IP, IPT_SO_GET_INFO, &info, &optsize));\n  \n      // Linux kernel interfaces like to be designed as a packed list of structs of varying types,\n      // kind of like SBE but uglier. Ugh.\n      StructyMessage message;\n  \n      // Create a replace message.\n      auto replace = message.add<struct ipt_replace>();\n      strcpy(replace->name, \"nat\");\n      replace->valid_hooks = info.valid_hooks;\n  \n      // The kernel insists that we give it a place to write out the counters on the existing\n      // table entries. Of course, they should all be zero, and we don't care either way. But we\n      // have to give it space.\n      struct xt_counters oldCounters[info.num_entries];\n      memset(oldCounters, 0, sizeof(oldCounters));\n      replace->num_counters = info.num_entries;\n      replace->counters = oldCounters;\n  \n      // Create an entry which accepts all packets destined for 127.0.0.0/8.\n      ++replace->num_entries;\n      auto acceptLocal = message.add<struct ipt_entry>();\n      acceptLocal->ip.dst.s_addr = htonl(0x7F000000);   // ip   127.0.0.0\n      acceptLocal->ip.dmsk.s_addr = htonl(0xFF000000);  // mask 255.0.0.0\n      auto acceptLocalTarget = message.add<struct ipt_entry_target>();\n      *message.add<int>() = -1 - NF_ACCEPT;\n      acceptLocalTarget->u.target_size = offsetBetween(acceptLocalTarget, message.end());\n      acceptLocal->target_offset = offsetBetween(acceptLocal, acceptLocalTarget);\n      acceptLocal->next_offset = offsetBetween(acceptLocal, message.end());\n  \n      // Create an entry which forwards all TCP packets to a local port.\n      ++replace->num_entries;\n      auto dnatTcp = message.add<struct ipt_entry>();\n      dnatTcp->ip.proto = IPPROTO_TCP;\n      auto dnatTcpTarget = message.add<struct ipt_entry_target>();\n      auto dnatTcpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n      dnatTcpRange->rangesize = 1;\n      dnatTcpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n      dnatTcpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatTcpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatTcpRange->range[0].min.tcp.port = htons(23136);\n      dnatTcpRange->range[0].max.tcp.port = htons(23136);\n      dnatTcpTarget->u.user.target_size = offsetBetween(dnatTcpTarget, message.end());\n      strcpy(dnatTcpTarget->u.user.name, \"DNAT\");\n      dnatTcp->target_offset = offsetBetween(dnatTcp, dnatTcpTarget);\n      dnatTcp->next_offset = offsetBetween(dnatTcp, message.end());\n  \n      // Create an entry which forwards all UDP packets to a local port.\n      ++replace->num_entries;\n      auto dnatUdp = message.add<struct ipt_entry>();\n      dnatUdp->ip.proto = IPPROTO_UDP;\n      auto dnatUdpTarget = message.add<struct ipt_entry_target>();\n      auto dnatUdpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n      dnatUdpRange->rangesize = 1;\n      dnatUdpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n      dnatUdpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatUdpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatUdpRange->range[0].min.udp.port = htons(23136);\n      dnatUdpRange->range[0].max.udp.port = htons(23136);\n      dnatUdpTarget->u.user.target_size = offsetBetween(dnatUdpTarget, message.end());\n      strcpy(dnatUdpTarget->u.user.name, \"DNAT\");\n      dnatUdp->target_offset = offsetBetween(dnatUdp, dnatUdpTarget);\n      dnatUdp->next_offset = offsetBetween(dnatUdp, message.end());\n  \n      // Create an entry which accepts everything.\n      ++replace->num_entries;\n      auto acceptAll = message.add<struct ipt_entry>();\n      auto acceptAllTarget = message.add<struct ipt_entry_target>();\n      *message.add<int>() = -1 - NF_ACCEPT;\n      acceptAllTarget->u.target_size = offsetBetween(acceptAllTarget, message.end());\n      acceptAll->target_offset = offsetBetween(acceptAll, acceptAllTarget);\n      acceptAll->next_offset = offsetBetween(acceptAll, message.end());\n  \n      // Cap it off with an error entry.\n      ++replace->num_entries;\n      auto error = message.add<struct ipt_entry>();\n      auto errorTarget = message.add<struct xt_error_target>();\n      errorTarget->target.u.user.target_size = offsetBetween(errorTarget, message.end());\n      strcpy(errorTarget->target.u.user.name, \"ERROR\");\n      strcpy(errorTarget->errorname, \"ERROR\");\n      error->target_offset = offsetBetween(error, errorTarget);\n      error->next_offset = offsetBetween(error, message.end());\n  \n      replace->hook_entry[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptLocal);\n      replace->hook_entry[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n  \n      replace->underflow[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n  \n      replace->size = offsetBetween(replace->entries, message.end());\n  \n      KJ_SYSCALL(setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, message.begin(), message.size()));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "chdir(\"/\")"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::enterSandbox() {\n    // Fully enter the sandbox.  Called only by the child process.\n    KJ_SYSCALL(chdir(\"/\"));\n  \n    // Unshare the network, creating a new loopback interface.\n    unshareNetwork();\n  \n    // Mount proc if --proc was passed.\n    maybeFinishMountingProc();\n  \n    // Now actually drop all credentials.\n    permanentlyDropSuperuser();\n  \n    // Use seccomp to disable dangerous syscalls. We do this last so that we can disable things\n    // that we just used above, like unshare() or setuid().\n    setupSeccomp();\n  }\n}"
  },
  {
    "function_name": "permanentlyDropSuperuser",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1508-1525",
    "snippet": "void SupervisorMain::permanentlyDropSuperuser() {\n  KJ_IF_MAYBE(ruid, sandboxUid) {\n    // setuid() to non-zero implicitly drops capabilities.\n    KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n  } else {\n    // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n    // object-capabilities, hence the quotes.)\n    //\n    // This unfortunately must be performed post-fork (in both parent and child), because the child\n    // needs to do one final unshare().\n\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "capset(&hdr, data)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capset",
          "args": [
            "&hdr",
            "data"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "sizeof(data)"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setresuid(*ruid, *ruid, *ruid)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "*ruid",
            "*ruid",
            "*ruid"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::permanentlyDropSuperuser() {\n    KJ_IF_MAYBE(ruid, sandboxUid) {\n      // setuid() to non-zero implicitly drops capabilities.\n      KJ_SYSCALL(setresuid(*ruid, *ruid, *ruid));\n    } else {\n      // Drop all Linux \"capabilities\".  (These are Linux/POSIX \"capabilities\", which are not true\n      // object-capabilities, hence the quotes.)\n      //\n      // This unfortunately must be performed post-fork (in both parent and child), because the child\n      // needs to do one final unshare().\n  \n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n    }\n}"
  },
  {
    "function_name": "maybeFinishMountingProc",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1487-1506",
    "snippet": "void SupervisorMain::maybeFinishMountingProc() {\n  // Mount proc if it was requested.  Note that this must take place after fork() to get the\n  // correct pid namespace.  We must keep a copy of proc mounted at all times; otherwise we\n  // lose the privilege of mounting proc.\n\n  if (mountProc) {\n    auto oldProc = raiiOpen(\"proc\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\n    // This puts the new proc onto the namespace root, which is mostly inaccessible.\n    KJ_SYSCALL(mount(\"proc\", \"/\", nullptr, MS_MOVE, nullptr));\n\n    // Now mount the new proc in the right place.\n    KJ_SYSCALL(mount(\"proc\", \"proc\", \"proc\", MS_NOSUID | MS_NODEV | MS_NOEXEC, nullptr));\n\n    // And get rid of the old one.\n    KJ_SYSCALL(fchdir(oldProc));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/\"));\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "chdir(\"/\")"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "umount2(\".\", MNT_DETACH)"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\".\"",
            "MNT_DETACH"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fchdir(oldProc)"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "oldProc"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"proc\", \"proc\", \"proc\", MS_NOSUID | MS_NODEV | MS_NOEXEC, nullptr)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "\"proc\"",
            "\"proc\"",
            "MS_NOSUID | MS_NODEV | MS_NOEXEC",
            "nullptr"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"proc\", \"/\", nullptr, MS_MOVE, nullptr)"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "\"/\"",
            "nullptr",
            "MS_MOVE",
            "nullptr"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"proc\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::maybeFinishMountingProc() {\n    // Mount proc if it was requested.  Note that this must take place after fork() to get the\n    // correct pid namespace.  We must keep a copy of proc mounted at all times; otherwise we\n    // lose the privilege of mounting proc.\n  \n    if (mountProc) {\n      auto oldProc = raiiOpen(\"proc\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  \n      // This puts the new proc onto the namespace root, which is mostly inaccessible.\n      KJ_SYSCALL(mount(\"proc\", \"/\", nullptr, MS_MOVE, nullptr));\n  \n      // Now mount the new proc in the right place.\n      KJ_SYSCALL(mount(\"proc\", \"proc\", \"proc\", MS_NOSUID | MS_NODEV | MS_NOEXEC, nullptr));\n  \n      // And get rid of the old one.\n      KJ_SYSCALL(fchdir(oldProc));\n      KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n      KJ_SYSCALL(chdir(\"/\"));\n    }\n  }\n}"
  },
  {
    "function_name": "checkIfIpTablesLoaded",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1462-1482",
    "snippet": "bool SupervisorMain::checkIfIpTablesLoaded() {\n  // Detect if the iptables kernel module is available. Must be called before entering the\n  // sandbox since this requires /proc.\n  //\n  // TODO(soon): This check is wrong because iptables could be compiled directly into the kernel\n  //   rather than as a module. Indeed, /proc/modules is reported to be sometimes absent in the\n  //   wild, perhaps when the kernel is compiled without module support. For now we'll assume\n  //   iptables is unavailable in that case.\n\n  KJ_IF_MAYBE(procModules, raiiOpenIfExists(\"/proc/modules\", O_RDONLY)) {\n    kj::FdInputStream rawIn(kj::mv(*procModules));\n    kj::BufferedInputStreamWrapper bufferedIn(rawIn);\n\n    for (;;) {\n      KJ_IF_MAYBE(line, readLine(bufferedIn)) {\n        if (line->startsWith(\"ip_tables \")) return true;\n      } else {\n        break;\n      }\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "line->startsWith",
          "args": [
            "\"ip_tables \""
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*procModules"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "procModules",
            "raiiOpenIfExists(\"/proc/modules\", O_RDONLY)"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpenIfExists",
          "args": [
            "\"/proc/modules\"",
            "O_RDONLY"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  bool SupervisorMain::checkIfIpTablesLoaded() {\n    // Detect if the iptables kernel module is available. Must be called before entering the\n    // sandbox since this requires /proc.\n    //\n    // TODO(soon): This check is wrong because iptables could be compiled directly into the kernel\n    //   rather than as a module. Indeed, /proc/modules is reported to be sometimes absent in the\n    //   wild, perhaps when the kernel is compiled without module support. For now we'll assume\n    //   iptables is unavailable in that case.\n  \n    KJ_IF_MAYBE(procModules, raiiOpenIfExists(\"/proc/modules\", O_RDONLY)) {\n      kj::FdInputStream rawIn(kj::mv(*procModules));\n      kj::BufferedInputStreamWrapper bufferedIn(rawIn);\n  \n      for (;;) {\n        KJ_IF_MAYBE(line, readLine(bufferedIn)) {\n          if (line->startsWith(\"ip_tables \")) return true;\n        } else {\n          break;\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "unshareNetwork",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1212-1460",
    "snippet": "void SupervisorMain::unshareNetwork() {\n  // Unshare the network and set up a new loopback device.\n\n  // Enter new network namespace.\n  KJ_SYSCALL(unshare(CLONE_NEWNET));\n\n  // Create a socket for our ioctls.\n  int fd;\n  KJ_SYSCALL(fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP));\n  KJ_DEFER(close(fd));\n\n  // Bring up the loopback device.\n  {\n    // Set the address of \"lo\".\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    strcpy(ifr.ifr_ifrn.ifrn_name, \"lo\");\n    struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n    addr->sin_family = AF_INET;\n    addr->sin_addr.s_addr = htonl(0x7F000001);  // 127.0.0.1\n    KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n\n    // Set flags to enable \"lo\".\n    memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n    ifr.ifr_ifru.ifru_flags = IFF_LOOPBACK | IFF_UP | IFF_RUNNING;\n    KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n  }\n\n  // Check if iptables module is available, skip the rest if not.\n  if (!isIpTablesAvailable) {\n    // TODO(soon): Put a runtime warning here, so that people can notice if this code won't work.\n    return;\n  }\n\n  // Create a fake network interface \"dummy0\" of type \"dummy\". We need this only so that we can\n  // route packets to it which we can in turn filter with iptables.\n  {\n    int netlink;\n    KJ_SYSCALL(netlink = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE));\n    KJ_DEFER(close(netlink));\n\n    socklen_t bufsize = 32768;\n    KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize)));\n    bufsize = 1048576;\n    KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize)));\n\n    StructyMessage message(4);\n\n    auto header = message.add<struct nlmsghdr>();\n\n    header->nlmsg_type = RTM_NEWLINK;\n    header->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL;\n\n    message.add<struct ifinfomsg>();  // leave zero'd\n\n    auto ifnameAttr = message.add<struct rtattr>();\n    ifnameAttr->rta_len = sizeof(struct rtattr) + sizeof(\"dummy0\");\n    ifnameAttr->rta_type = IFLA_IFNAME;\n    message.addString(\"dummy0\");\n\n    auto portAttr = message.add<struct rtattr>();\n    portAttr->rta_type = IFLA_LINKINFO;\n\n    // We're cargo-culting a bit here. IFLA_LINKINFO is not documented but it looks kind of\n    // like an rtattr. For some reason the string value is not NUL-terminated, though.\n    auto typeAttr = message.add<struct rtattr>();\n    typeAttr->rta_type = IFLA_INFO_KIND;  // Looks like it might be the right constant?\n    typeAttr->rta_len = sizeof(struct rtattr) + strlen(\"dummy\");\n    message.addBytes(\"dummy\", strlen(\"dummy\"));\n\n    portAttr->rta_len = offsetBetween(portAttr, message.end());\n\n    header->nlmsg_len = offsetBetween(header, message.end());\n\n    struct msghdr socketMsg;\n    memset(&socketMsg, 0, sizeof(socketMsg));\n\n    struct sockaddr_nl netlinkAddr;\n    memset(&netlinkAddr, 0, sizeof(netlinkAddr));\n    netlinkAddr.nl_family = AF_NETLINK;\n    socketMsg.msg_name = &netlinkAddr;\n    socketMsg.msg_namelen = sizeof(netlinkAddr);\n\n    struct iovec iov;\n    iov.iov_base = message.begin();\n    iov.iov_len = message.size();\n    socketMsg.msg_iov = &iov;\n    socketMsg.msg_iovlen = 1;\n\n    KJ_SYSCALL(sendmsg(netlink, &socketMsg, 0));\n\n    struct {\n      struct nlmsghdr header;\n      struct nlmsgerr error;\n      char buffer[512];\n    } result;\n    iov.iov_base = &result;\n    iov.iov_len = sizeof(result);\n\n    KJ_SYSCALL(recvmsg(netlink, &socketMsg, 0));\n\n    KJ_ASSERT(result.header.nlmsg_type == NLMSG_ERROR);\n    KJ_ASSERT(result.header.nlmsg_seq == 0);\n    if (result.error.error != 0) {\n      KJ_FAIL_SYSCALL(\"netlink(ip link add dummy0 type dummy)\", -result.error.error);\n    }\n  }\n\n  // Bring up dummy0.\n  {\n    // Set the address of \"dummy0\".\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    strcpy(ifr.ifr_ifrn.ifrn_name, \"dummy0\");\n    struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n    addr->sin_family = AF_INET;\n    addr->sin_addr.s_addr = htonl(0xc0a8fa02);  // 192.168.250.2\n    KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n\n    // Set flags to enable \"dummy0\".\n    memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n    ifr.ifr_ifru.ifru_flags = IFF_UP | IFF_RUNNING;\n    KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n  }\n\n  // Route external addresses through the \"dummy0\" interface, so that our iptables trick works.\n  {\n    struct rtentry route;\n    memset(&route, 0, sizeof(route));\n    route.rt_flags = RTF_UP | RTF_GATEWAY;\n    route.rt_dst.sa_family = AF_INET;\n    route.rt_gateway.sa_family = AF_INET;\n    reinterpret_cast<struct sockaddr_in*>(&route.rt_gateway)->sin_addr.s_addr =\n        htonl(0xc0a8fa01);  // 192.168.250.1; any address in 192.168.250.x would work here\n\n    KJ_SYSCALL(ioctl(fd, SIOCADDRT, &route));\n  }\n\n  // Set up iptables to redirect all non-local traffic to 127.0.0.1:23136.\n  //\n  // This should be equivalent-ish to:\n  //   iptables -t nat -A OUTPUT -p tcp -j DNAT --to 127.0.0.1:23136\n  //   iptables -t nat -A OUTPUT -p udp -j DNAT --to 127.0.0.1:23136\n  {\n    // Get the existing iptables info, needed in order to properly fill out the update request.\n    struct ipt_getinfo info;\n    memset(&info, 0, sizeof(info));\n    strcpy(info.name, \"nat\");\n    socklen_t optsize = sizeof(info);\n    KJ_SYSCALL(getsockopt(fd, IPPROTO_IP, IPT_SO_GET_INFO, &info, &optsize));\n\n    // Linux kernel interfaces like to be designed as a packed list of structs of varying types,\n    // kind of like SBE but uglier. Ugh.\n    StructyMessage message;\n\n    // Create a replace message.\n    auto replace = message.add<struct ipt_replace>();\n    strcpy(replace->name, \"nat\");\n    replace->valid_hooks = info.valid_hooks;\n\n    // The kernel insists that we give it a place to write out the counters on the existing\n    // table entries. Of course, they should all be zero, and we don't care either way. But we\n    // have to give it space.\n    struct xt_counters oldCounters[info.num_entries];\n    memset(oldCounters, 0, sizeof(oldCounters));\n    replace->num_counters = info.num_entries;\n    replace->counters = oldCounters;\n\n    // Create an entry which accepts all packets destined for 127.0.0.0/8.\n    ++replace->num_entries;\n    auto acceptLocal = message.add<struct ipt_entry>();\n    acceptLocal->ip.dst.s_addr = htonl(0x7F000000);   // ip   127.0.0.0\n    acceptLocal->ip.dmsk.s_addr = htonl(0xFF000000);  // mask 255.0.0.0\n    auto acceptLocalTarget = message.add<struct ipt_entry_target>();\n    *message.add<int>() = -1 - NF_ACCEPT;\n    acceptLocalTarget->u.target_size = offsetBetween(acceptLocalTarget, message.end());\n    acceptLocal->target_offset = offsetBetween(acceptLocal, acceptLocalTarget);\n    acceptLocal->next_offset = offsetBetween(acceptLocal, message.end());\n\n    // Create an entry which forwards all TCP packets to a local port.\n    ++replace->num_entries;\n    auto dnatTcp = message.add<struct ipt_entry>();\n    dnatTcp->ip.proto = IPPROTO_TCP;\n    auto dnatTcpTarget = message.add<struct ipt_entry_target>();\n    auto dnatTcpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n    dnatTcpRange->rangesize = 1;\n    dnatTcpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n    dnatTcpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatTcpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatTcpRange->range[0].min.tcp.port = htons(23136);\n    dnatTcpRange->range[0].max.tcp.port = htons(23136);\n    dnatTcpTarget->u.user.target_size = offsetBetween(dnatTcpTarget, message.end());\n    strcpy(dnatTcpTarget->u.user.name, \"DNAT\");\n    dnatTcp->target_offset = offsetBetween(dnatTcp, dnatTcpTarget);\n    dnatTcp->next_offset = offsetBetween(dnatTcp, message.end());\n\n    // Create an entry which forwards all UDP packets to a local port.\n    ++replace->num_entries;\n    auto dnatUdp = message.add<struct ipt_entry>();\n    dnatUdp->ip.proto = IPPROTO_UDP;\n    auto dnatUdpTarget = message.add<struct ipt_entry_target>();\n    auto dnatUdpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n    dnatUdpRange->rangesize = 1;\n    dnatUdpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n    dnatUdpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatUdpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n    dnatUdpRange->range[0].min.udp.port = htons(23136);\n    dnatUdpRange->range[0].max.udp.port = htons(23136);\n    dnatUdpTarget->u.user.target_size = offsetBetween(dnatUdpTarget, message.end());\n    strcpy(dnatUdpTarget->u.user.name, \"DNAT\");\n    dnatUdp->target_offset = offsetBetween(dnatUdp, dnatUdpTarget);\n    dnatUdp->next_offset = offsetBetween(dnatUdp, message.end());\n\n    // Create an entry which accepts everything.\n    ++replace->num_entries;\n    auto acceptAll = message.add<struct ipt_entry>();\n    auto acceptAllTarget = message.add<struct ipt_entry_target>();\n    *message.add<int>() = -1 - NF_ACCEPT;\n    acceptAllTarget->u.target_size = offsetBetween(acceptAllTarget, message.end());\n    acceptAll->target_offset = offsetBetween(acceptAll, acceptAllTarget);\n    acceptAll->next_offset = offsetBetween(acceptAll, message.end());\n\n    // Cap it off with an error entry.\n    ++replace->num_entries;\n    auto error = message.add<struct ipt_entry>();\n    auto errorTarget = message.add<struct xt_error_target>();\n    errorTarget->target.u.user.target_size = offsetBetween(errorTarget, message.end());\n    strcpy(errorTarget->target.u.user.name, \"ERROR\");\n    strcpy(errorTarget->errorname, \"ERROR\");\n    error->target_offset = offsetBetween(error, errorTarget);\n    error->next_offset = offsetBetween(error, message.end());\n\n    replace->hook_entry[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n    replace->hook_entry[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptLocal);\n    replace->hook_entry[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n\n    replace->underflow[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptAll);\n    replace->underflow[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n\n    replace->size = offsetBetween(replace->entries, message.end());\n\n    KJ_SYSCALL(setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, message.begin(), message.size()));\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto result = kj::heapString(cResult);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, message.begin(), message.size())"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "IPPROTO_IP",
            "IPT_SO_SET_REPLACE",
            "message.begin()",
            "message.size()"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.size",
          "args": [],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.begin",
          "args": [],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetBetween",
          "args": [
            "replace->entries",
            "message.end()"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "offsetBetween",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "147-149",
          "snippet": "inline size_t offsetBetween(void* start, void* end) {\n  return reinterpret_cast<char*>(end) - reinterpret_cast<char*>(start);\n}",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\ninline size_t offsetBetween(void* start, void* end) {\n  return reinterpret_cast<char*>(end) - reinterpret_cast<char*>(start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "errorTarget->errorname",
            "\"ERROR\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "errorTarget->target.u.user.name",
            "\"ERROR\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct xt_error_target>",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry>",
          "args": [],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<int>",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry_target>",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry>",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dnatUdpTarget->u.user.name",
            "\"DNAT\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "23136"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "23136"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct nf_nat_ipv4_multi_range_compat>",
          "args": [],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry_target>",
          "args": [],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry>",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dnatTcpTarget->u.user.name",
            "\"DNAT\""
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "23136"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "23136"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct nf_nat_ipv4_multi_range_compat>",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry_target>",
          "args": [],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry>",
          "args": [],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<int>",
          "args": [],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry_target>",
          "args": [],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0xFF000000"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000000"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_entry>",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oldCounters",
            "0",
            "sizeof(oldCounters)"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "replace->name",
            "\"nat\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ipt_replace>",
          "args": [],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "getsockopt(fd, IPPROTO_IP, IPT_SO_GET_INFO, &info, &optsize)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "fd",
            "IPPROTO_IP",
            "IPT_SO_GET_INFO",
            "&info",
            "&optsize"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "info.name",
            "\"nat\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ioctl(fd, SIOCADDRT, &route)"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCADDRT",
            "&route"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0xc0a8fa01"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct sockaddr_in*>",
          "args": [
            "&route.rt_gateway"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&route",
            "0",
            "sizeof(route)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ioctl(fd, SIOCSIFFLAGS, &ifr)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr.ifr_ifru",
            "0",
            "sizeof(ifr.ifr_ifru)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ioctl(fd, SIOCSIFADDR, &ifr)"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCSIFADDR",
            "&ifr"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0xc0a8fa02"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct sockaddr_in*>",
          "args": [
            "&ifr.ifr_ifru.ifru_addr"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ifr.ifr_ifrn.ifrn_name",
            "\"dummy0\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"netlink(ip link add dummy0 type dummy)\"",
            "-result.error.error"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "result.header.nlmsg_seq == 0"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "result.header.nlmsg_type == NLMSG_ERROR"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "recvmsg(netlink, &socketMsg, 0)"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "netlink",
            "&socketMsg",
            "0"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sendmsg(netlink, &socketMsg, 0)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "netlink",
            "&socketMsg",
            "0"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.begin",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&netlinkAddr",
            "0",
            "sizeof(netlinkAddr)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&socketMsg",
            "0",
            "sizeof(socketMsg)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.end",
          "args": [],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.addBytes",
          "args": [
            "\"dummy\"",
            "strlen(\"dummy\")"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "addBytes",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "132-135",
          "snippet": "void addBytes(const void* data, size_t size) {\n    memcpy(pos, data, size);\n    pos += (size + (alignment - 1)) & ~(alignment - 1);\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  void addBytes(const void* data, size_t size) {\n      memcpy(pos, data, size);\n      pos += (size + (alignment - 1)) & ~(alignment - 1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"dummy\""
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"dummy\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct rtattr>",
          "args": [],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct rtattr>",
          "args": [],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.addString",
          "args": [
            "\"dummy0\""
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "addString",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "129-131",
          "snippet": "void addString(const char* data) {\n    addBytes(data, strlen(data));\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  void addString(const char* data) {\n      addBytes(data, strlen(data));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.add<struct rtattr>",
          "args": [],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct ifinfomsg>",
          "args": [],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.add<struct nlmsghdr>",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(netlink, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize))"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "netlink",
            "SOL_SOCKET",
            "SO_RCVBUF",
            "&bufsize",
            "sizeof(bufsize)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(netlink, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize))"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "netlink",
            "SOL_SOCKET",
            "SO_SNDBUF",
            "&bufsize",
            "sizeof(bufsize)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "close(netlink)"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "netlink"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "netlink = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_NETLINK",
            "SOCK_RAW",
            "NETLINK_ROUTE"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ioctl(fd, SIOCSIFFLAGS, &ifr)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr.ifr_ifru",
            "0",
            "sizeof(ifr.ifr_ifru)"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ioctl(fd, SIOCSIFADDR, &ifr)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCSIFADDR",
            "&ifr"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct sockaddr_in*>",
          "args": [
            "&ifr.ifr_ifru.ifru_addr"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ifr.ifr_ifrn.ifrn_name",
            "\"lo\""
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "close(fd)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "IPPROTO_IP"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unshare(CLONE_NEWNET)"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNET"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nSupervisorMain {\n  void SupervisorMain::unshareNetwork() {\n    // Unshare the network and set up a new loopback device.\n  \n    // Enter new network namespace.\n    KJ_SYSCALL(unshare(CLONE_NEWNET));\n  \n    // Create a socket for our ioctls.\n    int fd;\n    KJ_SYSCALL(fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP));\n    KJ_DEFER(close(fd));\n  \n    // Bring up the loopback device.\n    {\n      // Set the address of \"lo\".\n      struct ifreq ifr;\n      memset(&ifr, 0, sizeof(ifr));\n      strcpy(ifr.ifr_ifrn.ifrn_name, \"lo\");\n      struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n      addr->sin_family = AF_INET;\n      addr->sin_addr.s_addr = htonl(0x7F000001);  // 127.0.0.1\n      KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n  \n      // Set flags to enable \"lo\".\n      memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n      ifr.ifr_ifru.ifru_flags = IFF_LOOPBACK | IFF_UP | IFF_RUNNING;\n      KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n    }\n  \n    // Check if iptables module is available, skip the rest if not.\n    if (!isIpTablesAvailable) {\n      // TODO(soon): Put a runtime warning here, so that people can notice if this code won't work.\n      return;\n    }\n  \n    // Create a fake network interface \"dummy0\" of type \"dummy\". We need this only so that we can\n    // route packets to it which we can in turn filter with iptables.\n    {\n      int netlink;\n      KJ_SYSCALL(netlink = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE));\n      KJ_DEFER(close(netlink));\n  \n      socklen_t bufsize = 32768;\n      KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize)));\n      bufsize = 1048576;\n      KJ_SYSCALL(setsockopt(netlink, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize)));\n  \n      StructyMessage message(4);\n  \n      auto header = message.add<struct nlmsghdr>();\n  \n      header->nlmsg_type = RTM_NEWLINK;\n      header->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL;\n  \n      message.add<struct ifinfomsg>();  // leave zero'd\n  \n      auto ifnameAttr = message.add<struct rtattr>();\n      ifnameAttr->rta_len = sizeof(struct rtattr) + sizeof(\"dummy0\");\n      ifnameAttr->rta_type = IFLA_IFNAME;\n      message.addString(\"dummy0\");\n  \n      auto portAttr = message.add<struct rtattr>();\n      portAttr->rta_type = IFLA_LINKINFO;\n  \n      // We're cargo-culting a bit here. IFLA_LINKINFO is not documented but it looks kind of\n      // like an rtattr. For some reason the string value is not NUL-terminated, though.\n      auto typeAttr = message.add<struct rtattr>();\n      typeAttr->rta_type = IFLA_INFO_KIND;  // Looks like it might be the right constant?\n      typeAttr->rta_len = sizeof(struct rtattr) + strlen(\"dummy\");\n      message.addBytes(\"dummy\", strlen(\"dummy\"));\n  \n      portAttr->rta_len = offsetBetween(portAttr, message.end());\n  \n      header->nlmsg_len = offsetBetween(header, message.end());\n  \n      struct msghdr socketMsg;\n      memset(&socketMsg, 0, sizeof(socketMsg));\n  \n      struct sockaddr_nl netlinkAddr;\n      memset(&netlinkAddr, 0, sizeof(netlinkAddr));\n      netlinkAddr.nl_family = AF_NETLINK;\n      socketMsg.msg_name = &netlinkAddr;\n      socketMsg.msg_namelen = sizeof(netlinkAddr);\n  \n      struct iovec iov;\n      iov.iov_base = message.begin();\n      iov.iov_len = message.size();\n      socketMsg.msg_iov = &iov;\n      socketMsg.msg_iovlen = 1;\n  \n      KJ_SYSCALL(sendmsg(netlink, &socketMsg, 0));\n  \n      struct {\n        struct nlmsghdr header;\n        struct nlmsgerr error;\n        char buffer[512];\n      } result;\n      iov.iov_base = &result;\n      iov.iov_len = sizeof(result);\n  \n      KJ_SYSCALL(recvmsg(netlink, &socketMsg, 0));\n  \n      KJ_ASSERT(result.header.nlmsg_type == NLMSG_ERROR);\n      KJ_ASSERT(result.header.nlmsg_seq == 0);\n      if (result.error.error != 0) {\n        KJ_FAIL_SYSCALL(\"netlink(ip link add dummy0 type dummy)\", -result.error.error);\n      }\n    }\n  \n    // Bring up dummy0.\n    {\n      // Set the address of \"dummy0\".\n      struct ifreq ifr;\n      memset(&ifr, 0, sizeof(ifr));\n      strcpy(ifr.ifr_ifrn.ifrn_name, \"dummy0\");\n      struct sockaddr_in* addr = reinterpret_cast<struct sockaddr_in*>(&ifr.ifr_ifru.ifru_addr);\n      addr->sin_family = AF_INET;\n      addr->sin_addr.s_addr = htonl(0xc0a8fa02);  // 192.168.250.2\n      KJ_SYSCALL(ioctl(fd, SIOCSIFADDR, &ifr));\n  \n      // Set flags to enable \"dummy0\".\n      memset(&ifr.ifr_ifru, 0, sizeof(ifr.ifr_ifru));\n      ifr.ifr_ifru.ifru_flags = IFF_UP | IFF_RUNNING;\n      KJ_SYSCALL(ioctl(fd, SIOCSIFFLAGS, &ifr));\n    }\n  \n    // Route external addresses through the \"dummy0\" interface, so that our iptables trick works.\n    {\n      struct rtentry route;\n      memset(&route, 0, sizeof(route));\n      route.rt_flags = RTF_UP | RTF_GATEWAY;\n      route.rt_dst.sa_family = AF_INET;\n      route.rt_gateway.sa_family = AF_INET;\n      reinterpret_cast<struct sockaddr_in*>(&route.rt_gateway)->sin_addr.s_addr =\n          htonl(0xc0a8fa01);  // 192.168.250.1; any address in 192.168.250.x would work here\n  \n      KJ_SYSCALL(ioctl(fd, SIOCADDRT, &route));\n    }\n  \n    // Set up iptables to redirect all non-local traffic to 127.0.0.1:23136.\n    //\n    // This should be equivalent-ish to:\n    //   iptables -t nat -A OUTPUT -p tcp -j DNAT --to 127.0.0.1:23136\n    //   iptables -t nat -A OUTPUT -p udp -j DNAT --to 127.0.0.1:23136\n    {\n      // Get the existing iptables info, needed in order to properly fill out the update request.\n      struct ipt_getinfo info;\n      memset(&info, 0, sizeof(info));\n      strcpy(info.name, \"nat\");\n      socklen_t optsize = sizeof(info);\n      KJ_SYSCALL(getsockopt(fd, IPPROTO_IP, IPT_SO_GET_INFO, &info, &optsize));\n  \n      // Linux kernel interfaces like to be designed as a packed list of structs of varying types,\n      // kind of like SBE but uglier. Ugh.\n      StructyMessage message;\n  \n      // Create a replace message.\n      auto replace = message.add<struct ipt_replace>();\n      strcpy(replace->name, \"nat\");\n      replace->valid_hooks = info.valid_hooks;\n  \n      // The kernel insists that we give it a place to write out the counters on the existing\n      // table entries. Of course, they should all be zero, and we don't care either way. But we\n      // have to give it space.\n      struct xt_counters oldCounters[info.num_entries];\n      memset(oldCounters, 0, sizeof(oldCounters));\n      replace->num_counters = info.num_entries;\n      replace->counters = oldCounters;\n  \n      // Create an entry which accepts all packets destined for 127.0.0.0/8.\n      ++replace->num_entries;\n      auto acceptLocal = message.add<struct ipt_entry>();\n      acceptLocal->ip.dst.s_addr = htonl(0x7F000000);   // ip   127.0.0.0\n      acceptLocal->ip.dmsk.s_addr = htonl(0xFF000000);  // mask 255.0.0.0\n      auto acceptLocalTarget = message.add<struct ipt_entry_target>();\n      *message.add<int>() = -1 - NF_ACCEPT;\n      acceptLocalTarget->u.target_size = offsetBetween(acceptLocalTarget, message.end());\n      acceptLocal->target_offset = offsetBetween(acceptLocal, acceptLocalTarget);\n      acceptLocal->next_offset = offsetBetween(acceptLocal, message.end());\n  \n      // Create an entry which forwards all TCP packets to a local port.\n      ++replace->num_entries;\n      auto dnatTcp = message.add<struct ipt_entry>();\n      dnatTcp->ip.proto = IPPROTO_TCP;\n      auto dnatTcpTarget = message.add<struct ipt_entry_target>();\n      auto dnatTcpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n      dnatTcpRange->rangesize = 1;\n      dnatTcpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n      dnatTcpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatTcpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatTcpRange->range[0].min.tcp.port = htons(23136);\n      dnatTcpRange->range[0].max.tcp.port = htons(23136);\n      dnatTcpTarget->u.user.target_size = offsetBetween(dnatTcpTarget, message.end());\n      strcpy(dnatTcpTarget->u.user.name, \"DNAT\");\n      dnatTcp->target_offset = offsetBetween(dnatTcp, dnatTcpTarget);\n      dnatTcp->next_offset = offsetBetween(dnatTcp, message.end());\n  \n      // Create an entry which forwards all UDP packets to a local port.\n      ++replace->num_entries;\n      auto dnatUdp = message.add<struct ipt_entry>();\n      dnatUdp->ip.proto = IPPROTO_UDP;\n      auto dnatUdpTarget = message.add<struct ipt_entry_target>();\n      auto dnatUdpRange = message.add<struct nf_nat_ipv4_multi_range_compat>();\n      dnatUdpRange->rangesize = 1;\n      dnatUdpRange->range[0].flags = NF_NAT_RANGE_PROTO_SPECIFIED | NF_NAT_RANGE_MAP_IPS;\n      dnatUdpRange->range[0].min_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatUdpRange->range[0].max_ip = htonl(0x7F000001);  // 127.0.0.1\n      dnatUdpRange->range[0].min.udp.port = htons(23136);\n      dnatUdpRange->range[0].max.udp.port = htons(23136);\n      dnatUdpTarget->u.user.target_size = offsetBetween(dnatUdpTarget, message.end());\n      strcpy(dnatUdpTarget->u.user.name, \"DNAT\");\n      dnatUdp->target_offset = offsetBetween(dnatUdp, dnatUdpTarget);\n      dnatUdp->next_offset = offsetBetween(dnatUdp, message.end());\n  \n      // Create an entry which accepts everything.\n      ++replace->num_entries;\n      auto acceptAll = message.add<struct ipt_entry>();\n      auto acceptAllTarget = message.add<struct ipt_entry_target>();\n      *message.add<int>() = -1 - NF_ACCEPT;\n      acceptAllTarget->u.target_size = offsetBetween(acceptAllTarget, message.end());\n      acceptAll->target_offset = offsetBetween(acceptAll, acceptAllTarget);\n      acceptAll->next_offset = offsetBetween(acceptAll, message.end());\n  \n      // Cap it off with an error entry.\n      ++replace->num_entries;\n      auto error = message.add<struct ipt_entry>();\n      auto errorTarget = message.add<struct xt_error_target>();\n      errorTarget->target.u.user.target_size = offsetBetween(errorTarget, message.end());\n      strcpy(errorTarget->target.u.user.name, \"ERROR\");\n      strcpy(errorTarget->errorname, \"ERROR\");\n      error->target_offset = offsetBetween(error, errorTarget);\n      error->next_offset = offsetBetween(error, message.end());\n  \n      replace->hook_entry[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n      replace->hook_entry[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptLocal);\n      replace->hook_entry[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n  \n      replace->underflow[NF_INET_PRE_ROUTING] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_LOCAL_IN] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_FORWARD] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_LOCAL_OUT] = offsetBetween(replace->entries, acceptAll);\n      replace->underflow[NF_INET_POST_ROUTING] = offsetBetween(replace->entries, acceptAll);\n  \n      replace->size = offsetBetween(replace->entries, message.end());\n  \n      KJ_SYSCALL(setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, message.begin(), message.size()));\n    }\n  }\n}"
  },
  {
    "function_name": "setupSeccomp",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1067-1210",
    "snippet": "void SupervisorMain::setupSeccomp() {\n  // Install a rudimentary seccomp blacklist.\n  // TODO(security): Change this to a whitelist.\n\n  scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n  if (ctx == nullptr)\n    KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n  KJ_DEFER(seccomp_release(ctx));\n\n#define CHECK_SECCOMP(call)                   \\\n  do {                                        \\\n    if (auto result = (call)) {               \\\n      KJ_FAIL_SYSCALL(#call, -result);        \\\n    }                                         \\\n  } while (0)\n\n  // Native code only for now, so there are no seccomp_arch_add calls.\n\n  // Redundant, but this is standard and harmless.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n\n  // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n  // should fail, but there's no need to kill the issuer.\n  CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n  // Disable some things that seem scary.\n  if (!devmode) {\n    // ptrace is scary\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n  } else {\n    // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n    // orig_ax using ptrace allows a complete seccomp bypass.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n  }\n\n  // Restrict the set of allowable network protocol families\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n\n  // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n  // of interesting information leaks.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n\n  // Despite existing at a 64-bit syscall, set_thread_area is only useful\n  // for 32-bit programs.  64-bit programs use arch_prctl instead.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n\n  // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n      SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n\n  // AIO is scary.\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n\n  // Scary vm syscalls\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n\n  // Scary futex operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n\n  // Utterly terrifying profiling operations\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n\n  // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n  // that run in-kernel (albeit with a very limited instruction set).\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n      SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n\n  // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n  // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n  //   disable things until we've reviewed them?\n  CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n\n  // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n\n  // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n\n  if (seccompDumpPfc) {\n    seccomp_export_pfc(ctx, 1);\n  }\n\n  CHECK_SECCOMP(seccomp_load(ctx));\n\n#pragma GCC diagnostic pop\n#undef CHECK_SECCOMP\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto result = kj::heapString(cResult);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_load(ctx)"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_load",
          "args": [
            "ctx"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_export_pfc",
          "args": [
            "ctx",
            "1"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(userfaultfd)",
            "0"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "userfaultfd"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(bpf)",
            "0"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "bpf"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(seccomp)",
            "0"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "seccomp"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n      SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP))"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EINVAL)",
            "SCMP_SYS(prctl)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "PR_SET_SECCOMP"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "prctl"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EINVAL"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(perf_event_open)",
            "0"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "perf_event_open"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(get_robust_list)",
            "0"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "get_robust_list"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(set_robust_list)",
            "0"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "set_robust_list"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(vmsplice)",
            "0"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "vmsplice"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0)"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(move_pages)",
            "0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "move_pages"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0)"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(migrate_pages)",
            "0"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "migrate_pages"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(set_mempolicy)",
            "0"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "set_mempolicy"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0)"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(get_mempolicy)",
            "0"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "get_mempolicy"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(mbind)",
            "0"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "mbind"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(remap_file_pages)",
            "0"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "remap_file_pages"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0)"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(io_cancel)",
            "0"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "io_cancel"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(io_submit)",
            "0"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "io_submit"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(io_getevents)",
            "0"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "io_getevents"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(io_destroy)",
            "0"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "io_destroy"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(io_setup)",
            "0"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "io_setup"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n      SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(clone)",
            "1",
            "SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_MASKED_EQ",
            "CLONE_NEWUSER",
            "CLONE_NEWUSER"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "clone"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(quotactl)",
            "0"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "quotactl"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(pivot_root)",
            "0"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "pivot_root"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0)"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(mount)",
            "0"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "mount"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(unshare)",
            "0"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "unshare"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0)"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(set_thread_area)",
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "set_thread_area"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0)"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(modify_ldt)",
            "0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "modify_ldt"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0)"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(acct)",
            "0"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "acct"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0)"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(personality)",
            "0"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "personality"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(uselib)",
            "0"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "uselib"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0)"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(syslog)",
            "0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "syslog"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(keyctl)",
            "0"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "keyctl"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(request_key)",
            "0"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "request_key"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(add_key)",
            "0"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "add_key"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_KEY))"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_KEY)"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_KEY"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_SECURITY))"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_SECURITY"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI))"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_NETBEUI"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_DECnet))"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_DECnet)"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_DECnet"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ROSE))"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_ROSE)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_ROSE"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_X25))"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_X25)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_X25"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC))"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_ATMPVC"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE))"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_BRIDGE"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_NETROM))"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_NETROM)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_NETROM"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK))"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_APPLETALK"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_IPX))"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_IPX)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_IPX"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_EQ, AF_AX25))"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, AF_AX25)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "AF_AX25"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n     SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1))"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EAFNOSUPPORT)",
            "SCMP_SYS(socket)",
            "1",
            "SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_GE",
            "AF_NETLINK + 1"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "socket"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EAFNOSUPPORT"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET))"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(ptrace)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "PTRACE_SETREGSET"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "ptrace"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS))"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(ptrace)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "PTRACE_SETFPREGS"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "ptrace"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS))"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(ptrace)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "PTRACE_SETREGS"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "ptrace"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n      SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER))"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(ptrace)",
            "1",
            "SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_A0",
          "args": [
            "SCMP_CMP_EQ",
            "PTRACE_POKEUSER"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "ptrace"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(EPERM)",
            "SCMP_SYS(ptrace)",
            "0"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "ptrace"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "EPERM"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS))"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "ctx",
            "SCMP_FLTATR_ACT_BADARCH",
            "SCMP_ACT_ERRNO(ENOSYS)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_SECCOMP",
          "args": [
            "seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_attr_set",
          "args": [
            "ctx",
            "SCMP_FLTATR_CTL_NNP",
            "1"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "seccomp_release(ctx)"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "ctx"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"seccomp_init\"",
            "0"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_ALLOW"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nSupervisorMain {\n  void SupervisorMain::setupSeccomp() {\n    // Install a rudimentary seccomp blacklist.\n    // TODO(security): Change this to a whitelist.\n  \n    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n    if (ctx == nullptr)\n      KJ_FAIL_SYSCALL(\"seccomp_init\", 0);  // No real error code\n    KJ_DEFER(seccomp_release(ctx));\n  \n  #define CHECK_SECCOMP(call)                   \\\n    do {                                        \\\n      if (auto result = (call)) {               \\\n        KJ_FAIL_SYSCALL(#call, -result);        \\\n      }                                         \\\n    } while (0)\n  \n    // Native code only for now, so there are no seccomp_arch_add calls.\n  \n    // Redundant, but this is standard and harmless.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 1));\n  \n    // It's easy to inadvertently issue an x32 syscall (e.g. syscall(-1)).  Such syscalls\n    // should fail, but there's no need to kill the issuer.\n    CHECK_SECCOMP(seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ERRNO(ENOSYS)));\n  \n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"  // SCMP_* macros produce these\n    // Disable some things that seem scary.\n    if (!devmode) {\n      // ptrace is scary\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 0));\n    } else {\n      // Try to be somewhat safe with ptrace in dev mode.  Note that the ability to modify\n      // orig_ax using ptrace allows a complete seccomp bypass.\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_POKEUSER)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETFPREGS)));\n      CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(ptrace), 1,\n        SCMP_A0(SCMP_CMP_EQ, PTRACE_SETREGSET)));\n    }\n  \n    // Restrict the set of allowable network protocol families\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_GE, AF_NETLINK + 1)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_AX25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_IPX)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_APPLETALK)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETROM)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_BRIDGE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ATMPVC)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_X25)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_ROSE)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_DECnet)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_NETBEUI)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_SECURITY)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EAFNOSUPPORT), SCMP_SYS(socket), 1,\n       SCMP_A0(SCMP_CMP_EQ, AF_KEY)));\n  \n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(add_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(request_key), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(keyctl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(syslog), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(uselib), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(personality), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(acct), 0));\n  \n    // 16-bit code is unnecessary in the sandbox, and modify_ldt is a historic source\n    // of interesting information leaks.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(modify_ldt), 0));\n  \n    // Despite existing at a 64-bit syscall, set_thread_area is only useful\n    // for 32-bit programs.  64-bit programs use arch_prctl instead.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_thread_area), 0));\n  \n    // Disable namespaces. Nested sandboxing could be useful but the attack surface is large.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(unshare), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mount), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(pivot_root), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(quotactl), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n        SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n  \n    // AIO is scary.\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_setup), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_destroy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_getevents), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_submit), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(io_cancel), 0));\n  \n    // Scary vm syscalls\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(remap_file_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(mbind), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_mempolicy), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(migrate_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(move_pages), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(vmsplice), 0));\n  \n    // Scary futex operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(set_robust_list), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(get_robust_list), 0));\n  \n    // Utterly terrifying profiling operations\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(perf_event_open), 0));\n  \n    // Don't let apps specify their own seccomp filters, since seccomp filters are literally programs\n    // that run in-kernel (albeit with a very limited instruction set).\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(prctl), 1,\n        SCMP_A0(SCMP_CMP_EQ, PR_SET_SECCOMP)));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(seccomp), 0));\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(bpf), 0));\n  \n    // New syscalls that don't seem useful to Sandstorm apps therefore we will disallow them.\n    // TODO(cleanup): Can we somehow specify \"disallow all calls greater than N\" to preemptively\n    //   disable things until we've reviewed them?\n    CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS), SCMP_SYS(userfaultfd), 0));\n  \n    // TOOD(someday): See if we can get away with turning off mincore, madvise, sysinfo etc.\n  \n    // TODO(someday): Turn off POSIX message queues and other such esoteric features.\n  \n    if (seccompDumpPfc) {\n      seccomp_export_pfc(ctx, 1);\n    }\n  \n    CHECK_SECCOMP(seccomp_load(ctx));\n  \n  #pragma GCC diagnostic pop\n  #undef CHECK_SECCOMP\n  }\n}"
  },
  {
    "function_name": "setupStdio",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "1043-1065",
    "snippet": "void SupervisorMain::setupStdio() {\n  // Make sure stdin is /dev/null and set stderr to go to a log file.\n\n  if (!keepStdio) {\n    // We want to replace stdin with /dev/null because even if there is no input on stdin, it\n    // could inadvertently be an FD with other powers.  For example, it might be a TTY, in which\n    // case you could write to it or otherwise mess with the terminal.\n    int devNull;\n    KJ_SYSCALL(devNull = open(\"/dev/null\", O_RDONLY | O_CLOEXEC));\n    KJ_SYSCALL(dup2(devNull, STDIN_FILENO));\n    KJ_SYSCALL(close(devNull));\n\n    // We direct stderr to a log file for debugging purposes.\n    // TODO(soon):  Rotate logs.\n    int log;\n    KJ_SYSCALL(log = open(\"log\", O_WRONLY | O_APPEND | O_CLOEXEC));\n    KJ_SYSCALL(dup2(log, STDERR_FILENO));\n    KJ_SYSCALL(close(log));\n  }\n\n  // We will later make stdout a copy of stderr specifically for the sandboxed process.  In the\n  // supervisor, stdout is how we tell our parent that we're ready to receive connections.\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(log)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "log"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(log, STDERR_FILENO)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "log",
            "STDERR_FILENO"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "log = open(\"log\", O_WRONLY | O_APPEND | O_CLOEXEC)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"log\"",
            "O_WRONLY | O_APPEND | O_CLOEXEC"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(devNull)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "devNull"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(devNull, STDIN_FILENO)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devNull",
            "STDIN_FILENO"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "devNull = open(\"/dev/null\", O_RDONLY | O_CLOEXEC)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setupStdio() {\n    // Make sure stdin is /dev/null and set stderr to go to a log file.\n  \n    if (!keepStdio) {\n      // We want to replace stdin with /dev/null because even if there is no input on stdin, it\n      // could inadvertently be an FD with other powers.  For example, it might be a TTY, in which\n      // case you could write to it or otherwise mess with the terminal.\n      int devNull;\n      KJ_SYSCALL(devNull = open(\"/dev/null\", O_RDONLY | O_CLOEXEC));\n      KJ_SYSCALL(dup2(devNull, STDIN_FILENO));\n      KJ_SYSCALL(close(devNull));\n  \n      // We direct stderr to a log file for debugging purposes.\n      // TODO(soon):  Rotate logs.\n      int log;\n      KJ_SYSCALL(log = open(\"log\", O_WRONLY | O_APPEND | O_CLOEXEC));\n      KJ_SYSCALL(dup2(log, STDERR_FILENO));\n      KJ_SYSCALL(close(log));\n    }\n  \n    // We will later make stdout a copy of stderr specifically for the sandboxed process.  In the\n    // supervisor, stdout is how we tell our parent that we're ready to receive connections.\n  }\n}"
  },
  {
    "function_name": "setupFilesystem",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "956-1041",
    "snippet": "void SupervisorMain::setupFilesystem() {\n  // The root of our mount namespace will be the app package itself.  We optionally create\n  // tmp, dev, and var.  tmp is an ordinary tmpfs.  dev is a read-only tmpfs that contains\n  // a few safe device nodes.  var is the 'var/sandbox' directory inside the grain.\n  //\n  // Now for the tricky part: the supervisor needs to be able to see a little bit more.\n  // In particular, it needs to be able to see the entire directory designated for the grain,\n  // whereas the app only sees the \"sandbox\" subdirectory. We arrange for the the supervisor's\n  // special directory to be \".\", even though it's not mounted anywhere.\n\n  // Set up the supervisor's directory. We immediately detach it from the mount tree, only\n  // keeping a file descriptor, which we can later access via fchdir(). This prevents the\n  // supervisor dir from being accessible to the app.\n  bind(varPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_NOEXEC);\n  auto supervisorDir = raiiOpen(\"/tmp/sandstorm-grain\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  KJ_SYSCALL(umount2(\"/tmp/sandstorm-grain\", MNT_DETACH));\n\n  // Bind the app package to \"sandbox\", which will be the grain's root directory.\n  bind(pkgPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_RDONLY);\n\n  // Change to that directory.\n  KJ_SYSCALL(chdir(\"/tmp/sandstorm-grain\"));\n\n  // Optionally bind var, tmp, dev if the app requests it by having the corresponding directories\n  // in the package.\n  if (access(\"tmp\", F_OK) == 0) {\n    // Create a new tmpfs for this run.  We don't use a shared one or just /tmp for two reasons:\n    // 1) tmpfs has no quota control, so a shared instance could be DoS'd by any one grain, or\n    //    just used to effectively allocate more RAM than the grain is allowed.\n    // 2) When we exit, the mount namespace disappears and the tmpfs is thus automatically\n    //    unmounted.  No need for careful cleanup, and no need to implement a risky recursive\n    //    delete.\n    KJ_SYSCALL(mount(\"sandstorm-tmp\", \"tmp\", \"tmpfs\", MS_NOSUID,\n                     \"size=16m,nr_inodes=4k,mode=770\"));\n  }\n  if (access(\"dev\", F_OK) == 0) {\n    KJ_SYSCALL(mount(\"sandstorm-dev\", \"dev\", \"tmpfs\",\n                     MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n                     \"size=1m,nr_inodes=16,mode=755\"));\n    makeCharDeviceNode(\"null\", \"null\", 1, 3);\n    makeCharDeviceNode(\"zero\", \"zero\", 1, 5);\n    makeCharDeviceNode(\"random\", \"urandom\", 1, 9);\n    makeCharDeviceNode(\"urandom\", \"urandom\", 1, 9);\n    KJ_SYSCALL(mount(\"dev\", \"dev\", nullptr,\n                     MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY,\n                     nullptr));\n  }\n  if (access(\"var\", F_OK) == 0) {\n    bind(kj::str(varPath, \"/sandbox\"), \"var\", MS_NODEV);\n  }\n  if (access(\"proc/cpuinfo\", F_OK) == 0) {\n    // Map in the real cpuinfo.\n    bind(\"/proc/cpuinfo\", \"proc/cpuinfo\", MS_NOSUID | MS_NOEXEC | MS_NODEV);\n  }\n\n  // Grab a reference to the old root directory.\n  auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\n  // Keep /proc around if requested.\n  if (mountProc) {\n    if (access(\"proc\", F_OK) == 0) {\n      // Mount it to retain permission to mount it.  This mount will be associated with the\n      // wrong pid namespce.  We'll fix it after forking.  We have to bind it: we can't mount\n      // a new copy because we don't have the appropriate permission on the active pid ns.\n      KJ_SYSCALL(mount(\"/proc\", \"proc\", nullptr, MS_BIND | MS_REC, nullptr));\n    } else {\n      mountProc = false;\n    }\n  }\n\n\n  // OK, everything is bound, so we can pivot_root.\n  KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp/sandstorm-grain\", \"/tmp/sandstorm-grain\"));\n\n  // We're now in a very strange state: our root directory is the grain directory,\n  // but the old root is mounted on top of the grain directory.  As far as I can tell,\n  // there is no simple way to unmount the old root, since \"/\" and \"/.\" both refer to the\n  // grain directory.  Fortunately, we kept a reference to the old root.\n  KJ_SYSCALL(fchdir(oldRootDir));\n  KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n  KJ_SYSCALL(fchdir(supervisorDir));\n\n  // Now \".\" is the grain's storage directory and \"/\" is the sandbox directory, i.e.\n  // \"/\" == \"./sandbox\". Yes, this means the root directory is _below_ the current directory.\n  // Crazy.\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fchdir(supervisorDir)"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "supervisorDir"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "umount2(\".\", MNT_DETACH)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\".\"",
            "MNT_DETACH"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fchdir(oldRootDir)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "oldRootDir"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "syscall(SYS_pivot_root, \"/tmp/sandstorm-grain\", \"/tmp/sandstorm-grain\")"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_pivot_root",
            "\"/tmp/sandstorm-grain\"",
            "\"/tmp/sandstorm-grain\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"/proc\", \"proc\", nullptr, MS_BIND | MS_REC, nullptr)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/proc\"",
            "\"proc\"",
            "nullptr",
            "MS_BIND | MS_REC",
            "nullptr"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"proc\"",
            "F_OK"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "\"/proc/cpuinfo\"",
            "\"proc/cpuinfo\"",
            "MS_NOSUID | MS_NOEXEC | MS_NODEV"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "708-716",
          "snippet": "void SupervisorMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REMOUNT | MS_NOSUID | flags, nullptr),\n      src, dst);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n    // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n    // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n    // them.\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND, nullptr), src, dst);\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                     MS_BIND | MS_REMOUNT | MS_NOSUID | flags, nullptr),\n        src, dst);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"proc/cpuinfo\"",
            "F_OK"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "varPath",
            "\"/sandbox\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"var\"",
            "F_OK"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"dev\", \"dev\", nullptr,\n                     MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY,\n                     nullptr)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"dev\"",
            "\"dev\"",
            "nullptr",
            "MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY",
            "nullptr"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeCharDeviceNode",
          "args": [
            "\"urandom\"",
            "\"urandom\"",
            "1",
            "9"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "makeCharDeviceNode",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "946-954",
          "snippet": "void SupervisorMain::makeCharDeviceNode(\n    const char *name, const char* realName, int major, int minor) {\n  // Creating a real device node with mknod won't work on any current kernel, and we're\n  // currently stuck with the filesystem being nodev, so even if mknod were to work, the\n  // resulting device node wouldn't function.\n  auto dst = kj::str(\"dev/\", name);\n  KJ_SYSCALL(mknod(dst.cStr(), S_IFREG | 0666, 0));\n  KJ_SYSCALL(mount(kj::str(\"/dev/\", realName).cStr(), dst.cStr(), nullptr, MS_BIND, nullptr));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::makeCharDeviceNode(\n      const char *name, const char* realName, int major, int minor) {\n    // Creating a real device node with mknod won't work on any current kernel, and we're\n    // currently stuck with the filesystem being nodev, so even if mknod were to work, the\n    // resulting device node wouldn't function.\n    auto dst = kj::str(\"dev/\", name);\n    KJ_SYSCALL(mknod(dst.cStr(), S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(kj::str(\"/dev/\", realName).cStr(), dst.cStr(), nullptr, MS_BIND, nullptr));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"sandstorm-dev\", \"dev\", \"tmpfs\",\n                     MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n                     \"size=1m,nr_inodes=16,mode=755\")"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"sandstorm-dev\"",
            "\"dev\"",
            "\"tmpfs\"",
            "MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV",
            "\"size=1m,nr_inodes=16,mode=755\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"dev\"",
            "F_OK"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"sandstorm-tmp\", \"tmp\", \"tmpfs\", MS_NOSUID,\n                     \"size=16m,nr_inodes=4k,mode=770\")"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"sandstorm-tmp\"",
            "\"tmp\"",
            "\"tmpfs\"",
            "MS_NOSUID",
            "\"size=16m,nr_inodes=4k,mode=770\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"tmp\"",
            "F_OK"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "chdir(\"/tmp/sandstorm-grain\")"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/tmp/sandstorm-grain\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "umount2(\"/tmp/sandstorm-grain\", MNT_DETACH)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"/tmp/sandstorm-grain\"",
            "MNT_DETACH"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/tmp/sandstorm-grain\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setupFilesystem() {\n    // The root of our mount namespace will be the app package itself.  We optionally create\n    // tmp, dev, and var.  tmp is an ordinary tmpfs.  dev is a read-only tmpfs that contains\n    // a few safe device nodes.  var is the 'var/sandbox' directory inside the grain.\n    //\n    // Now for the tricky part: the supervisor needs to be able to see a little bit more.\n    // In particular, it needs to be able to see the entire directory designated for the grain,\n    // whereas the app only sees the \"sandbox\" subdirectory. We arrange for the the supervisor's\n    // special directory to be \".\", even though it's not mounted anywhere.\n  \n    // Set up the supervisor's directory. We immediately detach it from the mount tree, only\n    // keeping a file descriptor, which we can later access via fchdir(). This prevents the\n    // supervisor dir from being accessible to the app.\n    bind(varPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_NOEXEC);\n    auto supervisorDir = raiiOpen(\"/tmp/sandstorm-grain\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(umount2(\"/tmp/sandstorm-grain\", MNT_DETACH));\n  \n    // Bind the app package to \"sandbox\", which will be the grain's root directory.\n    bind(pkgPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_RDONLY);\n  \n    // Change to that directory.\n    KJ_SYSCALL(chdir(\"/tmp/sandstorm-grain\"));\n  \n    // Optionally bind var, tmp, dev if the app requests it by having the corresponding directories\n    // in the package.\n    if (access(\"tmp\", F_OK) == 0) {\n      // Create a new tmpfs for this run.  We don't use a shared one or just /tmp for two reasons:\n      // 1) tmpfs has no quota control, so a shared instance could be DoS'd by any one grain, or\n      //    just used to effectively allocate more RAM than the grain is allowed.\n      // 2) When we exit, the mount namespace disappears and the tmpfs is thus automatically\n      //    unmounted.  No need for careful cleanup, and no need to implement a risky recursive\n      //    delete.\n      KJ_SYSCALL(mount(\"sandstorm-tmp\", \"tmp\", \"tmpfs\", MS_NOSUID,\n                       \"size=16m,nr_inodes=4k,mode=770\"));\n    }\n    if (access(\"dev\", F_OK) == 0) {\n      KJ_SYSCALL(mount(\"sandstorm-dev\", \"dev\", \"tmpfs\",\n                       MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n                       \"size=1m,nr_inodes=16,mode=755\"));\n      makeCharDeviceNode(\"null\", \"null\", 1, 3);\n      makeCharDeviceNode(\"zero\", \"zero\", 1, 5);\n      makeCharDeviceNode(\"random\", \"urandom\", 1, 9);\n      makeCharDeviceNode(\"urandom\", \"urandom\", 1, 9);\n      KJ_SYSCALL(mount(\"dev\", \"dev\", nullptr,\n                       MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY,\n                       nullptr));\n    }\n    if (access(\"var\", F_OK) == 0) {\n      bind(kj::str(varPath, \"/sandbox\"), \"var\", MS_NODEV);\n    }\n    if (access(\"proc/cpuinfo\", F_OK) == 0) {\n      // Map in the real cpuinfo.\n      bind(\"/proc/cpuinfo\", \"proc/cpuinfo\", MS_NOSUID | MS_NOEXEC | MS_NODEV);\n    }\n  \n    // Grab a reference to the old root directory.\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  \n    // Keep /proc around if requested.\n    if (mountProc) {\n      if (access(\"proc\", F_OK) == 0) {\n        // Mount it to retain permission to mount it.  This mount will be associated with the\n        // wrong pid namespce.  We'll fix it after forking.  We have to bind it: we can't mount\n        // a new copy because we don't have the appropriate permission on the active pid ns.\n        KJ_SYSCALL(mount(\"/proc\", \"proc\", nullptr, MS_BIND | MS_REC, nullptr));\n      } else {\n        mountProc = false;\n      }\n    }\n  \n  \n    // OK, everything is bound, so we can pivot_root.\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp/sandstorm-grain\", \"/tmp/sandstorm-grain\"));\n  \n    // We're now in a very strange state: our root directory is the grain directory,\n    // but the old root is mounted on top of the grain directory.  As far as I can tell,\n    // there is no simple way to unmount the old root, since \"/\" and \"/.\" both refer to the\n    // grain directory.  Fortunately, we kept a reference to the old root.\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(fchdir(supervisorDir));\n  \n    // Now \".\" is the grain's storage directory and \"/\" is the sandbox directory, i.e.\n    // \"/\" == \"./sandbox\". Yes, this means the root directory is _below_ the current directory.\n    // Crazy.\n  }\n}"
  },
  {
    "function_name": "makeCharDeviceNode",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "946-954",
    "snippet": "void SupervisorMain::makeCharDeviceNode(\n    const char *name, const char* realName, int major, int minor) {\n  // Creating a real device node with mknod won't work on any current kernel, and we're\n  // currently stuck with the filesystem being nodev, so even if mknod were to work, the\n  // resulting device node wouldn't function.\n  auto dst = kj::str(\"dev/\", name);\n  KJ_SYSCALL(mknod(dst.cStr(), S_IFREG | 0666, 0));\n  KJ_SYSCALL(mount(kj::str(\"/dev/\", realName).cStr(), dst.cStr(), nullptr, MS_BIND, nullptr));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(kj::str(\"/dev/\", realName).cStr(), dst.cStr(), nullptr, MS_BIND, nullptr)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "kj::str(\"/dev/\", realName).cStr()",
            "dst.cStr()",
            "nullptr",
            "MS_BIND",
            "nullptr"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/dev/\"",
            "realName"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mknod(dst.cStr(), S_IFREG | 0666, 0)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "dst.cStr()",
            "S_IFREG | 0666",
            "0"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"dev/\"",
            "name"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::makeCharDeviceNode(\n      const char *name, const char* realName, int major, int minor) {\n    // Creating a real device node with mknod won't work on any current kernel, and we're\n    // currently stuck with the filesystem being nodev, so even if mknod were to work, the\n    // resulting device node wouldn't function.\n    auto dst = kj::str(\"dev/\", name);\n    KJ_SYSCALL(mknod(dst.cStr(), S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(kj::str(\"/dev/\", realName).cStr(), dst.cStr(), nullptr, MS_BIND, nullptr));\n  }\n}"
  },
  {
    "function_name": "unshareOuter",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "894-944",
    "snippet": "void SupervisorMain::unshareOuter() {\n  if (sandboxUid == nullptr) {\n    // Use user namespaces.\n    pid_t uid = getuid(), gid = getgid();\n\n    // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n    // little odd in that it doesn't actually affect this process, but affects later children\n    // created by it.\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n\n    // Map ourselves as 1000:1000, since it costs nothing to mask the uid and gid.\n    uid_t fakeUid = 1000;\n    gid_t fakeGid = 1000;\n\n    if (devmode) {\n      // \"Randomize\" the UID and GID in dev mode. This catches app bugs where the app expects the\n      // UID or GID to be always 1000, which is not true of servers that use the privileged sandbox\n      // rather than the userns sandbox. (The \"randomization\" algorithm here is only meant to\n      // appear random to a human. The funny-looking numbers are just arbitrary primes chosen\n      // without much thought.)\n      time_t now = time(nullptr);\n      fakeUid = now * 4721 % 2000 + 1;\n      fakeGid = now * 2791 % 2000 + 1;\n    }\n\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(fakeUid, \" \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(fakeGid, \" \", gid, \" 1\\n\"));\n  } else {\n    // Use root privileges instead of user namespaces.\n\n    // We need to raise our privileges to call unshare(), and to perform other setup that occurs\n    // after unshare().\n    KJ_SYSCALL(seteuid(0));\n\n    // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n    // little odd in that it doesn't actually affect this process, but affects later children\n    // created by it.\n    KJ_SYSCALL(unshare(CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Set a dummy host / domain so the grain can't see the real one.  (unshare(CLONE_NEWUTS) means\n  // these settings only affect this process and its children.)\n  KJ_SYSCALL(sethostname(\"sandbox\", 7));\n  KJ_SYSCALL(setdomainname(\"sandbox\", 7));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setdomainname(\"sandbox\", 7)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdomainname",
          "args": [
            "\"sandbox\"",
            "7"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sethostname(\"sandbox\", 7)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sethostname",
          "args": [
            "\"sandbox\"",
            "7"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"none\"",
            "\"/\"",
            "nullptr",
            "MS_REC | MS_PRIVATE",
            "nullptr"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unshare(CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID)"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "seteuid(0)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seteuid",
          "args": [
            "0"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeUserNSMap",
          "args": [
            "\"gid\"",
            "kj::str(fakeGid, \" \", gid, \" 1\\n\")"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "writeUserNSMap",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "889-892",
          "snippet": "void SupervisorMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n    kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n        .write(contents.begin(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "fakeGid",
            "\" \"",
            "gid",
            "\" 1\\n\""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "fakeUid",
            "\" \"",
            "uid",
            "\" 1\\n\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeSetgroupsIfPresent",
          "args": [
            "\"deny\\n\""
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "writeSetgroupsIfPresent",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "883-887",
          "snippet": "void SupervisorMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::writeSetgroupsIfPresent(const char *contents) {\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n      kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "nullptr"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID)"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::unshareOuter() {\n    if (sandboxUid == nullptr) {\n      // Use user namespaces.\n      pid_t uid = getuid(), gid = getgid();\n  \n      // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n      // little odd in that it doesn't actually affect this process, but affects later children\n      // created by it.\n      KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n  \n      // Map ourselves as 1000:1000, since it costs nothing to mask the uid and gid.\n      uid_t fakeUid = 1000;\n      gid_t fakeGid = 1000;\n  \n      if (devmode) {\n        // \"Randomize\" the UID and GID in dev mode. This catches app bugs where the app expects the\n        // UID or GID to be always 1000, which is not true of servers that use the privileged sandbox\n        // rather than the userns sandbox. (The \"randomization\" algorithm here is only meant to\n        // appear random to a human. The funny-looking numbers are just arbitrary primes chosen\n        // without much thought.)\n        time_t now = time(nullptr);\n        fakeUid = now * 4721 % 2000 + 1;\n        fakeGid = now * 2791 % 2000 + 1;\n      }\n  \n      writeSetgroupsIfPresent(\"deny\\n\");\n      writeUserNSMap(\"uid\", kj::str(fakeUid, \" \", uid, \" 1\\n\"));\n      writeUserNSMap(\"gid\", kj::str(fakeGid, \" \", gid, \" 1\\n\"));\n    } else {\n      // Use root privileges instead of user namespaces.\n  \n      // We need to raise our privileges to call unshare(), and to perform other setup that occurs\n      // after unshare().\n      KJ_SYSCALL(seteuid(0));\n  \n      // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n      // little odd in that it doesn't actually affect this process, but affects later children\n      // created by it.\n      KJ_SYSCALL(unshare(CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n    }\n  \n    // To really unshare the mount namespace, we also have to make sure all mounts are private.\n    // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n    // are undocumented.  :(\n    KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n  \n    // Set a dummy host / domain so the grain can't see the real one.  (unshare(CLONE_NEWUTS) means\n    // these settings only affect this process and its children.)\n    KJ_SYSCALL(sethostname(\"sandbox\", 7));\n    KJ_SYSCALL(setdomainname(\"sandbox\", 7));\n  }\n}"
  },
  {
    "function_name": "writeUserNSMap",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "889-892",
    "snippet": "void SupervisorMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "contents.begin()",
            "contents.size()"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.size",
          "args": [],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.begin",
          "args": [],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "kj::str(\"/proc/self/\", type, \"_map\").cStr()",
            "O_WRONLY | O_CLOEXEC"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/proc/self/\"",
            "type",
            "\"_map\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n    kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n        .write(contents.begin(), contents.size());\n  }\n}"
  },
  {
    "function_name": "writeSetgroupsIfPresent",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "883-887",
    "snippet": "void SupervisorMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "contents",
            "strlen(contents)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "contents"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "kj::mv(*fd)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*fd"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fd",
            "raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpenIfExists",
          "args": [
            "\"/proc/self/setgroups\"",
            "O_WRONLY | O_CLOEXEC"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::writeSetgroupsIfPresent(const char *contents) {\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n      kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n    }\n  }\n}"
  },
  {
    "function_name": "checkPaths",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "832-881",
    "snippet": "void SupervisorMain::checkPaths() {\n  // Create or verify the pkg, var, and tmp directories.\n\n  // Let us be explicit about permissions for now.\n  umask(0);\n\n  // Set default paths if flags weren't provided.\n  if (pkgPath == nullptr) pkgPath = kj::str(\"/var/sandstorm/apps/\", appName);\n  if (varPath == nullptr) varPath = kj::str(\"/var/sandstorm/grains/\", grainId);\n\n  // Check that package exists.\n  KJ_SYSCALL(access(pkgPath.cStr(), R_OK | X_OK), pkgPath);\n\n  // Create / verify existence of the var directory.  Do this as the target user.\n  if (isNew) {\n    if (mkdir(varPath.cStr(), 0770) != 0) {\n      int error = errno;\n      if (errno == EEXIST) {\n        context.exitError(kj::str(\"Grain already exists: \", grainId));\n      } else {\n        KJ_FAIL_SYSCALL(\"mkdir(varPath.cStr(), 0770)\", error, varPath);\n      }\n    }\n    KJ_SYSCALL(mkdir(kj::str(varPath, \"/sandbox\").cStr(), 0770), varPath);\n  } else {\n    if (access(varPath.cStr(), R_OK | W_OK | X_OK) != 0) {\n      int error = errno;\n      if (error == ENOENT) {\n        context.exitError(kj::str(\"No such grain: \", grainId));\n      } else {\n        KJ_FAIL_SYSCALL(\"access(varPath.cStr(), R_OK | W_OK | X_OK)\", error, varPath);\n      }\n    }\n  }\n\n  // Create the temp directory if it doesn't exist.  We only need one tmpdir because we're just\n  // going to bind it to a private mount anyway.\n  if (mkdir(kj::str(\"/tmp/sandstorm-grain\").cStr(), 0770) < 0) {\n    int error = errno;\n    if (error != EEXIST) {\n      KJ_FAIL_SYSCALL(\"mkdir(\\\"/tmp/sandstorm-grain\\\")\", error);\n    }\n  }\n\n  // Create the log file while we're still non-superuser.\n  int logfd;\n  KJ_SYSCALL(logfd = open(kj::str(varPath, \"/log\").cStr(),\n      O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0600));\n  KJ_SYSCALL(close(logfd));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(logfd)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "logfd"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "logfd = open(kj::str(varPath, \"/log\").cStr(),\n      O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0600)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "kj::str(varPath, \"/log\").cStr()",
            "O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT",
            "0600"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "varPath",
            "\"/log\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mkdir(\\\"/tmp/sandstorm-grain\\\")\"",
            "error"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "kj::str(\"/tmp/sandstorm-grain\").cStr()",
            "0770"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/tmp/sandstorm-grain\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"access(varPath.cStr(), R_OK | W_OK | X_OK)\"",
            "error",
            "varPath"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"No such grain: \", grainId)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"No such grain: \"",
            "grainId"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "varPath.cStr()",
            "R_OK | W_OK | X_OK"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varPath.cStr",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(kj::str(varPath, \"/sandbox\").cStr(), 0770)",
            "varPath"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "kj::str(varPath, \"/sandbox\").cStr()",
            "0770"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "varPath",
            "\"/sandbox\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mkdir(varPath.cStr(), 0770)\"",
            "error",
            "varPath"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.exitError",
          "args": [
            "kj::str(\"Grain already exists: \", grainId)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Grain already exists: \"",
            "grainId"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "varPath.cStr()",
            "0770"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varPath.cStr",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "access(pkgPath.cStr(), R_OK | X_OK)",
            "pkgPath"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "pkgPath.cStr()",
            "R_OK | X_OK"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pkgPath.cStr",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/grains/\"",
            "grainId"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/var/sandstorm/apps/\"",
            "appName"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::checkPaths() {\n    // Create or verify the pkg, var, and tmp directories.\n  \n    // Let us be explicit about permissions for now.\n    umask(0);\n  \n    // Set default paths if flags weren't provided.\n    if (pkgPath == nullptr) pkgPath = kj::str(\"/var/sandstorm/apps/\", appName);\n    if (varPath == nullptr) varPath = kj::str(\"/var/sandstorm/grains/\", grainId);\n  \n    // Check that package exists.\n    KJ_SYSCALL(access(pkgPath.cStr(), R_OK | X_OK), pkgPath);\n  \n    // Create / verify existence of the var directory.  Do this as the target user.\n    if (isNew) {\n      if (mkdir(varPath.cStr(), 0770) != 0) {\n        int error = errno;\n        if (errno == EEXIST) {\n          context.exitError(kj::str(\"Grain already exists: \", grainId));\n        } else {\n          KJ_FAIL_SYSCALL(\"mkdir(varPath.cStr(), 0770)\", error, varPath);\n        }\n      }\n      KJ_SYSCALL(mkdir(kj::str(varPath, \"/sandbox\").cStr(), 0770), varPath);\n    } else {\n      if (access(varPath.cStr(), R_OK | W_OK | X_OK) != 0) {\n        int error = errno;\n        if (error == ENOENT) {\n          context.exitError(kj::str(\"No such grain: \", grainId));\n        } else {\n          KJ_FAIL_SYSCALL(\"access(varPath.cStr(), R_OK | W_OK | X_OK)\", error, varPath);\n        }\n      }\n    }\n  \n    // Create the temp directory if it doesn't exist.  We only need one tmpdir because we're just\n    // going to bind it to a private mount anyway.\n    if (mkdir(kj::str(\"/tmp/sandstorm-grain\").cStr(), 0770) < 0) {\n      int error = errno;\n      if (error != EEXIST) {\n        KJ_FAIL_SYSCALL(\"mkdir(\\\"/tmp/sandstorm-grain\\\")\", error);\n      }\n    }\n  \n    // Create the log file while we're still non-superuser.\n    int logfd;\n    KJ_SYSCALL(logfd = open(kj::str(varPath, \"/log\").cStr(),\n        O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0600));\n    KJ_SYSCALL(close(logfd));\n  }\n}"
  },
  {
    "function_name": "setResourceLimits",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "824-830",
    "snippet": "void SupervisorMain::setResourceLimits() {\n  struct rlimit limit;\n  memset(&limit, 0, sizeof(limit));\n  limit.rlim_cur = 1024;\n  limit.rlim_max = 4096;\n  KJ_SYSCALL(setrlimit(RLIMIT_NOFILE, &limit));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setrlimit(RLIMIT_NOFILE, &limit)"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_NOFILE",
            "&limit"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&limit",
            "0",
            "sizeof(limit)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setResourceLimits() {\n    struct rlimit limit;\n    memset(&limit, 0, sizeof(limit));\n    limit.rlim_cur = 1024;\n    limit.rlim_max = 4096;\n    KJ_SYSCALL(setrlimit(RLIMIT_NOFILE, &limit));\n  }\n}"
  },
  {
    "function_name": "closeFds",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "769-822",
    "snippet": "void SupervisorMain::closeFds() {\n  // Close all unexpected file descriptors (i.e. other than stdin/stdout/stderr).  This is a\n  // safety measure incase we were launched by a badly-written parent program which forgot to\n  // set CLOEXEC on its private file descriptors.  We don't want the sandboxed process to\n  // accidentally get access to those.\n\n  // We detect open file descriptors by reading from /proc.\n  //\n  // We need to defer closing each FD until after the scan completes, because:\n  // 1) We probably shouldn't change the directory contents while listing.\n  // 2) opendir() itself opens an FD.  Closing it would disrupt the scan.\n  kj::Vector<int> fds;\n\n  {\n    DIR* dir = opendir(\"/proc/self/fd\");\n    if (dir == nullptr) {\n      KJ_FAIL_SYSCALL(\"opendir(/proc/self/fd)\", errno);\n    }\n    KJ_DEFER(KJ_SYSCALL(closedir(dir)) { break; });\n\n    for (;;) {\n      struct dirent entry;\n      struct dirent* eptr = nullptr;\n      int error = readdir_r(dir, &entry, &eptr);\n      if (error != 0) {\n        KJ_FAIL_SYSCALL(\"readdir_r(/proc/self/fd)\", error);\n      }\n      if (eptr == nullptr) {\n        // End of directory.\n        break;\n      }\n\n      if (eptr->d_name[0] != '.') {\n        char* end;\n        int fd = strtoul(eptr->d_name, &end, 10);\n        KJ_ASSERT(*end == '\\0' && end > eptr->d_name,\n                  \"File in /proc/self/fd had non-numeric name?\", eptr->d_name);\n        if (fd > STDERR_FILENO) {\n          fds.add(fd);\n        }\n      }\n    }\n  }\n\n  int saveFd = systemConnector->getSaveFd().orDefault(0);\n\n  for (int fd: fds) {\n    if (fd != saveFd) {\n      // Ignore close errors -- we don't care, as long as the file is closed.  (Also, one close()\n      // will always return EBADF because it's the directory FD closed in closedir().)\n      close(fd);\n    }\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systemConnector->getSaveFd",
          "args": [
            "0"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systemConnector->getSaveFd",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "getSaveFd",
          "container": "SupervisorMain::DefaultSystemConnector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.h",
          "lines": "133-133",
          "snippet": "kj::Maybe<int> getSaveFd() const override { return nullptr; }",
          "includes": [
            "#include <kj/io.h>",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <capnp/capability.h>",
            "#include <kj/async-io.h>",
            "#include <kj/vector.h>",
            "#include \"util.h\"",
            "#include \"abstract-main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/io.h>\n#include <sandstorm/supervisor.capnp.h>\n#include <capnp/capability.h>\n#include <kj/async-io.h>\n#include <kj/vector.h>\n#include \"util.h\"\n#include \"abstract-main.h\"\n\nSupervisorMain {\n  DefaultSystemConnector {\n    kj::Maybe<int> getSaveFd() const override { return nullptr; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fds.add",
          "args": [
            "fd"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "*end == '\\0' && end > eptr->d_name",
            "\"File in /proc/self/fd had non-numeric name?\"",
            "eptr->d_name"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "eptr->d_name",
            "&end",
            "10"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"readdir_r(/proc/self/fd)\"",
            "error"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir_r",
          "args": [
            "dir",
            "&entry",
            "&eptr"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"opendir(/proc/self/fd)\"",
            "errno"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc/self/fd\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::closeFds() {\n    // Close all unexpected file descriptors (i.e. other than stdin/stdout/stderr).  This is a\n    // safety measure incase we were launched by a badly-written parent program which forgot to\n    // set CLOEXEC on its private file descriptors.  We don't want the sandboxed process to\n    // accidentally get access to those.\n  \n    // We detect open file descriptors by reading from /proc.\n    //\n    // We need to defer closing each FD until after the scan completes, because:\n    // 1) We probably shouldn't change the directory contents while listing.\n    // 2) opendir() itself opens an FD.  Closing it would disrupt the scan.\n    kj::Vector<int> fds;\n  \n    {\n      DIR* dir = opendir(\"/proc/self/fd\");\n      if (dir == nullptr) {\n        KJ_FAIL_SYSCALL(\"opendir(/proc/self/fd)\", errno);\n      }\n      KJ_DEFER(KJ_SYSCALL(closedir(dir)) { break; });\n  \n      for (;;) {\n        struct dirent entry;\n        struct dirent* eptr = nullptr;\n        int error = readdir_r(dir, &entry, &eptr);\n        if (error != 0) {\n          KJ_FAIL_SYSCALL(\"readdir_r(/proc/self/fd)\", error);\n        }\n        if (eptr == nullptr) {\n          // End of directory.\n          break;\n        }\n  \n        if (eptr->d_name[0] != '.') {\n          char* end;\n          int fd = strtoul(eptr->d_name, &end, 10);\n          KJ_ASSERT(*end == '\\0' && end > eptr->d_name,\n                    \"File in /proc/self/fd had non-numeric name?\", eptr->d_name);\n          if (fd > STDERR_FILENO) {\n            fds.add(fd);\n          }\n        }\n      }\n    }\n  \n    int saveFd = systemConnector->getSaveFd().orDefault(0);\n  \n    for (int fd: fds) {\n      if (fd != saveFd) {\n        // Ignore close errors -- we don't care, as long as the file is closed.  (Also, one close()\n        // will always return EBADF because it's the directory FD closed in closedir().)\n        close(fd);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "setupSupervisor",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "754-767",
    "snippet": "void SupervisorMain::setupSupervisor() {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary.  Sandboxed apps should not need that.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  closeFds();\n  setResourceLimits();\n  checkPaths();\n  unshareOuter();\n  setupFilesystem();\n  setupStdio();\n\n  // Note:  permanentlyDropSuperuser() is performed post-fork; see comment in function def.\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [
      "#define PR_SET_NO_NEW_PRIVS 38"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setupStdio",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "setupStdio",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1043-1065",
          "snippet": "void SupervisorMain::setupStdio() {\n  // Make sure stdin is /dev/null and set stderr to go to a log file.\n\n  if (!keepStdio) {\n    // We want to replace stdin with /dev/null because even if there is no input on stdin, it\n    // could inadvertently be an FD with other powers.  For example, it might be a TTY, in which\n    // case you could write to it or otherwise mess with the terminal.\n    int devNull;\n    KJ_SYSCALL(devNull = open(\"/dev/null\", O_RDONLY | O_CLOEXEC));\n    KJ_SYSCALL(dup2(devNull, STDIN_FILENO));\n    KJ_SYSCALL(close(devNull));\n\n    // We direct stderr to a log file for debugging purposes.\n    // TODO(soon):  Rotate logs.\n    int log;\n    KJ_SYSCALL(log = open(\"log\", O_WRONLY | O_APPEND | O_CLOEXEC));\n    KJ_SYSCALL(dup2(log, STDERR_FILENO));\n    KJ_SYSCALL(close(log));\n  }\n\n  // We will later make stdout a copy of stderr specifically for the sandboxed process.  In the\n  // supervisor, stdout is how we tell our parent that we're ready to receive connections.\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setupStdio() {\n    // Make sure stdin is /dev/null and set stderr to go to a log file.\n  \n    if (!keepStdio) {\n      // We want to replace stdin with /dev/null because even if there is no input on stdin, it\n      // could inadvertently be an FD with other powers.  For example, it might be a TTY, in which\n      // case you could write to it or otherwise mess with the terminal.\n      int devNull;\n      KJ_SYSCALL(devNull = open(\"/dev/null\", O_RDONLY | O_CLOEXEC));\n      KJ_SYSCALL(dup2(devNull, STDIN_FILENO));\n      KJ_SYSCALL(close(devNull));\n  \n      // We direct stderr to a log file for debugging purposes.\n      // TODO(soon):  Rotate logs.\n      int log;\n      KJ_SYSCALL(log = open(\"log\", O_WRONLY | O_APPEND | O_CLOEXEC));\n      KJ_SYSCALL(dup2(log, STDERR_FILENO));\n      KJ_SYSCALL(close(log));\n    }\n  \n    // We will later make stdout a copy of stderr specifically for the sandboxed process.  In the\n    // supervisor, stdout is how we tell our parent that we're ready to receive connections.\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setupFilesystem",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "setupFilesystem",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "956-1041",
          "snippet": "void SupervisorMain::setupFilesystem() {\n  // The root of our mount namespace will be the app package itself.  We optionally create\n  // tmp, dev, and var.  tmp is an ordinary tmpfs.  dev is a read-only tmpfs that contains\n  // a few safe device nodes.  var is the 'var/sandbox' directory inside the grain.\n  //\n  // Now for the tricky part: the supervisor needs to be able to see a little bit more.\n  // In particular, it needs to be able to see the entire directory designated for the grain,\n  // whereas the app only sees the \"sandbox\" subdirectory. We arrange for the the supervisor's\n  // special directory to be \".\", even though it's not mounted anywhere.\n\n  // Set up the supervisor's directory. We immediately detach it from the mount tree, only\n  // keeping a file descriptor, which we can later access via fchdir(). This prevents the\n  // supervisor dir from being accessible to the app.\n  bind(varPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_NOEXEC);\n  auto supervisorDir = raiiOpen(\"/tmp/sandstorm-grain\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  KJ_SYSCALL(umount2(\"/tmp/sandstorm-grain\", MNT_DETACH));\n\n  // Bind the app package to \"sandbox\", which will be the grain's root directory.\n  bind(pkgPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_RDONLY);\n\n  // Change to that directory.\n  KJ_SYSCALL(chdir(\"/tmp/sandstorm-grain\"));\n\n  // Optionally bind var, tmp, dev if the app requests it by having the corresponding directories\n  // in the package.\n  if (access(\"tmp\", F_OK) == 0) {\n    // Create a new tmpfs for this run.  We don't use a shared one or just /tmp for two reasons:\n    // 1) tmpfs has no quota control, so a shared instance could be DoS'd by any one grain, or\n    //    just used to effectively allocate more RAM than the grain is allowed.\n    // 2) When we exit, the mount namespace disappears and the tmpfs is thus automatically\n    //    unmounted.  No need for careful cleanup, and no need to implement a risky recursive\n    //    delete.\n    KJ_SYSCALL(mount(\"sandstorm-tmp\", \"tmp\", \"tmpfs\", MS_NOSUID,\n                     \"size=16m,nr_inodes=4k,mode=770\"));\n  }\n  if (access(\"dev\", F_OK) == 0) {\n    KJ_SYSCALL(mount(\"sandstorm-dev\", \"dev\", \"tmpfs\",\n                     MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n                     \"size=1m,nr_inodes=16,mode=755\"));\n    makeCharDeviceNode(\"null\", \"null\", 1, 3);\n    makeCharDeviceNode(\"zero\", \"zero\", 1, 5);\n    makeCharDeviceNode(\"random\", \"urandom\", 1, 9);\n    makeCharDeviceNode(\"urandom\", \"urandom\", 1, 9);\n    KJ_SYSCALL(mount(\"dev\", \"dev\", nullptr,\n                     MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY,\n                     nullptr));\n  }\n  if (access(\"var\", F_OK) == 0) {\n    bind(kj::str(varPath, \"/sandbox\"), \"var\", MS_NODEV);\n  }\n  if (access(\"proc/cpuinfo\", F_OK) == 0) {\n    // Map in the real cpuinfo.\n    bind(\"/proc/cpuinfo\", \"proc/cpuinfo\", MS_NOSUID | MS_NOEXEC | MS_NODEV);\n  }\n\n  // Grab a reference to the old root directory.\n  auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\n  // Keep /proc around if requested.\n  if (mountProc) {\n    if (access(\"proc\", F_OK) == 0) {\n      // Mount it to retain permission to mount it.  This mount will be associated with the\n      // wrong pid namespce.  We'll fix it after forking.  We have to bind it: we can't mount\n      // a new copy because we don't have the appropriate permission on the active pid ns.\n      KJ_SYSCALL(mount(\"/proc\", \"proc\", nullptr, MS_BIND | MS_REC, nullptr));\n    } else {\n      mountProc = false;\n    }\n  }\n\n\n  // OK, everything is bound, so we can pivot_root.\n  KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp/sandstorm-grain\", \"/tmp/sandstorm-grain\"));\n\n  // We're now in a very strange state: our root directory is the grain directory,\n  // but the old root is mounted on top of the grain directory.  As far as I can tell,\n  // there is no simple way to unmount the old root, since \"/\" and \"/.\" both refer to the\n  // grain directory.  Fortunately, we kept a reference to the old root.\n  KJ_SYSCALL(fchdir(oldRootDir));\n  KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n  KJ_SYSCALL(fchdir(supervisorDir));\n\n  // Now \".\" is the grain's storage directory and \"/\" is the sandbox directory, i.e.\n  // \"/\" == \"./sandbox\". Yes, this means the root directory is _below_ the current directory.\n  // Crazy.\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setupFilesystem() {\n    // The root of our mount namespace will be the app package itself.  We optionally create\n    // tmp, dev, and var.  tmp is an ordinary tmpfs.  dev is a read-only tmpfs that contains\n    // a few safe device nodes.  var is the 'var/sandbox' directory inside the grain.\n    //\n    // Now for the tricky part: the supervisor needs to be able to see a little bit more.\n    // In particular, it needs to be able to see the entire directory designated for the grain,\n    // whereas the app only sees the \"sandbox\" subdirectory. We arrange for the the supervisor's\n    // special directory to be \".\", even though it's not mounted anywhere.\n  \n    // Set up the supervisor's directory. We immediately detach it from the mount tree, only\n    // keeping a file descriptor, which we can later access via fchdir(). This prevents the\n    // supervisor dir from being accessible to the app.\n    bind(varPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_NOEXEC);\n    auto supervisorDir = raiiOpen(\"/tmp/sandstorm-grain\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(umount2(\"/tmp/sandstorm-grain\", MNT_DETACH));\n  \n    // Bind the app package to \"sandbox\", which will be the grain's root directory.\n    bind(pkgPath, \"/tmp/sandstorm-grain\", MS_NODEV | MS_RDONLY);\n  \n    // Change to that directory.\n    KJ_SYSCALL(chdir(\"/tmp/sandstorm-grain\"));\n  \n    // Optionally bind var, tmp, dev if the app requests it by having the corresponding directories\n    // in the package.\n    if (access(\"tmp\", F_OK) == 0) {\n      // Create a new tmpfs for this run.  We don't use a shared one or just /tmp for two reasons:\n      // 1) tmpfs has no quota control, so a shared instance could be DoS'd by any one grain, or\n      //    just used to effectively allocate more RAM than the grain is allowed.\n      // 2) When we exit, the mount namespace disappears and the tmpfs is thus automatically\n      //    unmounted.  No need for careful cleanup, and no need to implement a risky recursive\n      //    delete.\n      KJ_SYSCALL(mount(\"sandstorm-tmp\", \"tmp\", \"tmpfs\", MS_NOSUID,\n                       \"size=16m,nr_inodes=4k,mode=770\"));\n    }\n    if (access(\"dev\", F_OK) == 0) {\n      KJ_SYSCALL(mount(\"sandstorm-dev\", \"dev\", \"tmpfs\",\n                       MS_NOATIME | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n                       \"size=1m,nr_inodes=16,mode=755\"));\n      makeCharDeviceNode(\"null\", \"null\", 1, 3);\n      makeCharDeviceNode(\"zero\", \"zero\", 1, 5);\n      makeCharDeviceNode(\"random\", \"urandom\", 1, 9);\n      makeCharDeviceNode(\"urandom\", \"urandom\", 1, 9);\n      KJ_SYSCALL(mount(\"dev\", \"dev\", nullptr,\n                       MS_REMOUNT | MS_BIND | MS_NOEXEC | MS_NOSUID | MS_NODEV | MS_RDONLY,\n                       nullptr));\n    }\n    if (access(\"var\", F_OK) == 0) {\n      bind(kj::str(varPath, \"/sandbox\"), \"var\", MS_NODEV);\n    }\n    if (access(\"proc/cpuinfo\", F_OK) == 0) {\n      // Map in the real cpuinfo.\n      bind(\"/proc/cpuinfo\", \"proc/cpuinfo\", MS_NOSUID | MS_NOEXEC | MS_NODEV);\n    }\n  \n    // Grab a reference to the old root directory.\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n  \n    // Keep /proc around if requested.\n    if (mountProc) {\n      if (access(\"proc\", F_OK) == 0) {\n        // Mount it to retain permission to mount it.  This mount will be associated with the\n        // wrong pid namespce.  We'll fix it after forking.  We have to bind it: we can't mount\n        // a new copy because we don't have the appropriate permission on the active pid ns.\n        KJ_SYSCALL(mount(\"/proc\", \"proc\", nullptr, MS_BIND | MS_REC, nullptr));\n      } else {\n        mountProc = false;\n      }\n    }\n  \n  \n    // OK, everything is bound, so we can pivot_root.\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp/sandstorm-grain\", \"/tmp/sandstorm-grain\"));\n  \n    // We're now in a very strange state: our root directory is the grain directory,\n    // but the old root is mounted on top of the grain directory.  As far as I can tell,\n    // there is no simple way to unmount the old root, since \"/\" and \"/.\" both refer to the\n    // grain directory.  Fortunately, we kept a reference to the old root.\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(fchdir(supervisorDir));\n  \n    // Now \".\" is the grain's storage directory and \"/\" is the sandbox directory, i.e.\n    // \"/\" == \"./sandbox\". Yes, this means the root directory is _below_ the current directory.\n    // Crazy.\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshareOuter",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "unshareOuter",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "894-944",
          "snippet": "void SupervisorMain::unshareOuter() {\n  if (sandboxUid == nullptr) {\n    // Use user namespaces.\n    pid_t uid = getuid(), gid = getgid();\n\n    // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n    // little odd in that it doesn't actually affect this process, but affects later children\n    // created by it.\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n\n    // Map ourselves as 1000:1000, since it costs nothing to mask the uid and gid.\n    uid_t fakeUid = 1000;\n    gid_t fakeGid = 1000;\n\n    if (devmode) {\n      // \"Randomize\" the UID and GID in dev mode. This catches app bugs where the app expects the\n      // UID or GID to be always 1000, which is not true of servers that use the privileged sandbox\n      // rather than the userns sandbox. (The \"randomization\" algorithm here is only meant to\n      // appear random to a human. The funny-looking numbers are just arbitrary primes chosen\n      // without much thought.)\n      time_t now = time(nullptr);\n      fakeUid = now * 4721 % 2000 + 1;\n      fakeGid = now * 2791 % 2000 + 1;\n    }\n\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(fakeUid, \" \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(fakeGid, \" \", gid, \" 1\\n\"));\n  } else {\n    // Use root privileges instead of user namespaces.\n\n    // We need to raise our privileges to call unshare(), and to perform other setup that occurs\n    // after unshare().\n    KJ_SYSCALL(seteuid(0));\n\n    // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n    // little odd in that it doesn't actually affect this process, but affects later children\n    // created by it.\n    KJ_SYSCALL(unshare(CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Set a dummy host / domain so the grain can't see the real one.  (unshare(CLONE_NEWUTS) means\n  // these settings only affect this process and its children.)\n  KJ_SYSCALL(sethostname(\"sandbox\", 7));\n  KJ_SYSCALL(setdomainname(\"sandbox\", 7));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::unshareOuter() {\n    if (sandboxUid == nullptr) {\n      // Use user namespaces.\n      pid_t uid = getuid(), gid = getgid();\n  \n      // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n      // little odd in that it doesn't actually affect this process, but affects later children\n      // created by it.\n      KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n  \n      // Map ourselves as 1000:1000, since it costs nothing to mask the uid and gid.\n      uid_t fakeUid = 1000;\n      gid_t fakeGid = 1000;\n  \n      if (devmode) {\n        // \"Randomize\" the UID and GID in dev mode. This catches app bugs where the app expects the\n        // UID or GID to be always 1000, which is not true of servers that use the privileged sandbox\n        // rather than the userns sandbox. (The \"randomization\" algorithm here is only meant to\n        // appear random to a human. The funny-looking numbers are just arbitrary primes chosen\n        // without much thought.)\n        time_t now = time(nullptr);\n        fakeUid = now * 4721 % 2000 + 1;\n        fakeGid = now * 2791 % 2000 + 1;\n      }\n  \n      writeSetgroupsIfPresent(\"deny\\n\");\n      writeUserNSMap(\"uid\", kj::str(fakeUid, \" \", uid, \" 1\\n\"));\n      writeUserNSMap(\"gid\", kj::str(fakeGid, \" \", gid, \" 1\\n\"));\n    } else {\n      // Use root privileges instead of user namespaces.\n  \n      // We need to raise our privileges to call unshare(), and to perform other setup that occurs\n      // after unshare().\n      KJ_SYSCALL(seteuid(0));\n  \n      // Unshare all of the namespaces except network.  Note that unsharing the pid namespace is a\n      // little odd in that it doesn't actually affect this process, but affects later children\n      // created by it.\n      KJ_SYSCALL(unshare(CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWUTS | CLONE_NEWPID));\n    }\n  \n    // To really unshare the mount namespace, we also have to make sure all mounts are private.\n    // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n    // are undocumented.  :(\n    KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n  \n    // Set a dummy host / domain so the grain can't see the real one.  (unshare(CLONE_NEWUTS) means\n    // these settings only affect this process and its children.)\n    KJ_SYSCALL(sethostname(\"sandbox\", 7));\n    KJ_SYSCALL(setdomainname(\"sandbox\", 7));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkPaths",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "checkPaths",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "832-881",
          "snippet": "void SupervisorMain::checkPaths() {\n  // Create or verify the pkg, var, and tmp directories.\n\n  // Let us be explicit about permissions for now.\n  umask(0);\n\n  // Set default paths if flags weren't provided.\n  if (pkgPath == nullptr) pkgPath = kj::str(\"/var/sandstorm/apps/\", appName);\n  if (varPath == nullptr) varPath = kj::str(\"/var/sandstorm/grains/\", grainId);\n\n  // Check that package exists.\n  KJ_SYSCALL(access(pkgPath.cStr(), R_OK | X_OK), pkgPath);\n\n  // Create / verify existence of the var directory.  Do this as the target user.\n  if (isNew) {\n    if (mkdir(varPath.cStr(), 0770) != 0) {\n      int error = errno;\n      if (errno == EEXIST) {\n        context.exitError(kj::str(\"Grain already exists: \", grainId));\n      } else {\n        KJ_FAIL_SYSCALL(\"mkdir(varPath.cStr(), 0770)\", error, varPath);\n      }\n    }\n    KJ_SYSCALL(mkdir(kj::str(varPath, \"/sandbox\").cStr(), 0770), varPath);\n  } else {\n    if (access(varPath.cStr(), R_OK | W_OK | X_OK) != 0) {\n      int error = errno;\n      if (error == ENOENT) {\n        context.exitError(kj::str(\"No such grain: \", grainId));\n      } else {\n        KJ_FAIL_SYSCALL(\"access(varPath.cStr(), R_OK | W_OK | X_OK)\", error, varPath);\n      }\n    }\n  }\n\n  // Create the temp directory if it doesn't exist.  We only need one tmpdir because we're just\n  // going to bind it to a private mount anyway.\n  if (mkdir(kj::str(\"/tmp/sandstorm-grain\").cStr(), 0770) < 0) {\n    int error = errno;\n    if (error != EEXIST) {\n      KJ_FAIL_SYSCALL(\"mkdir(\\\"/tmp/sandstorm-grain\\\")\", error);\n    }\n  }\n\n  // Create the log file while we're still non-superuser.\n  int logfd;\n  KJ_SYSCALL(logfd = open(kj::str(varPath, \"/log\").cStr(),\n      O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0600));\n  KJ_SYSCALL(close(logfd));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::checkPaths() {\n    // Create or verify the pkg, var, and tmp directories.\n  \n    // Let us be explicit about permissions for now.\n    umask(0);\n  \n    // Set default paths if flags weren't provided.\n    if (pkgPath == nullptr) pkgPath = kj::str(\"/var/sandstorm/apps/\", appName);\n    if (varPath == nullptr) varPath = kj::str(\"/var/sandstorm/grains/\", grainId);\n  \n    // Check that package exists.\n    KJ_SYSCALL(access(pkgPath.cStr(), R_OK | X_OK), pkgPath);\n  \n    // Create / verify existence of the var directory.  Do this as the target user.\n    if (isNew) {\n      if (mkdir(varPath.cStr(), 0770) != 0) {\n        int error = errno;\n        if (errno == EEXIST) {\n          context.exitError(kj::str(\"Grain already exists: \", grainId));\n        } else {\n          KJ_FAIL_SYSCALL(\"mkdir(varPath.cStr(), 0770)\", error, varPath);\n        }\n      }\n      KJ_SYSCALL(mkdir(kj::str(varPath, \"/sandbox\").cStr(), 0770), varPath);\n    } else {\n      if (access(varPath.cStr(), R_OK | W_OK | X_OK) != 0) {\n        int error = errno;\n        if (error == ENOENT) {\n          context.exitError(kj::str(\"No such grain: \", grainId));\n        } else {\n          KJ_FAIL_SYSCALL(\"access(varPath.cStr(), R_OK | W_OK | X_OK)\", error, varPath);\n        }\n      }\n    }\n  \n    // Create the temp directory if it doesn't exist.  We only need one tmpdir because we're just\n    // going to bind it to a private mount anyway.\n    if (mkdir(kj::str(\"/tmp/sandstorm-grain\").cStr(), 0770) < 0) {\n      int error = errno;\n      if (error != EEXIST) {\n        KJ_FAIL_SYSCALL(\"mkdir(\\\"/tmp/sandstorm-grain\\\")\", error);\n      }\n    }\n  \n    // Create the log file while we're still non-superuser.\n    int logfd;\n    KJ_SYSCALL(logfd = open(kj::str(varPath, \"/log\").cStr(),\n        O_WRONLY | O_APPEND | O_CLOEXEC | O_CREAT, 0600));\n    KJ_SYSCALL(close(logfd));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setResourceLimits",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "setResourceLimits",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "824-830",
          "snippet": "void SupervisorMain::setResourceLimits() {\n  struct rlimit limit;\n  memset(&limit, 0, sizeof(limit));\n  limit.rlim_cur = 1024;\n  limit.rlim_max = 4096;\n  KJ_SYSCALL(setrlimit(RLIMIT_NOFILE, &limit));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setResourceLimits() {\n    struct rlimit limit;\n    memset(&limit, 0, sizeof(limit));\n    limit.rlim_cur = 1024;\n    limit.rlim_max = 4096;\n    KJ_SYSCALL(setrlimit(RLIMIT_NOFILE, &limit));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closeFds",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "closeFds",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "769-822",
          "snippet": "void SupervisorMain::closeFds() {\n  // Close all unexpected file descriptors (i.e. other than stdin/stdout/stderr).  This is a\n  // safety measure incase we were launched by a badly-written parent program which forgot to\n  // set CLOEXEC on its private file descriptors.  We don't want the sandboxed process to\n  // accidentally get access to those.\n\n  // We detect open file descriptors by reading from /proc.\n  //\n  // We need to defer closing each FD until after the scan completes, because:\n  // 1) We probably shouldn't change the directory contents while listing.\n  // 2) opendir() itself opens an FD.  Closing it would disrupt the scan.\n  kj::Vector<int> fds;\n\n  {\n    DIR* dir = opendir(\"/proc/self/fd\");\n    if (dir == nullptr) {\n      KJ_FAIL_SYSCALL(\"opendir(/proc/self/fd)\", errno);\n    }\n    KJ_DEFER(KJ_SYSCALL(closedir(dir)) { break; });\n\n    for (;;) {\n      struct dirent entry;\n      struct dirent* eptr = nullptr;\n      int error = readdir_r(dir, &entry, &eptr);\n      if (error != 0) {\n        KJ_FAIL_SYSCALL(\"readdir_r(/proc/self/fd)\", error);\n      }\n      if (eptr == nullptr) {\n        // End of directory.\n        break;\n      }\n\n      if (eptr->d_name[0] != '.') {\n        char* end;\n        int fd = strtoul(eptr->d_name, &end, 10);\n        KJ_ASSERT(*end == '\\0' && end > eptr->d_name,\n                  \"File in /proc/self/fd had non-numeric name?\", eptr->d_name);\n        if (fd > STDERR_FILENO) {\n          fds.add(fd);\n        }\n      }\n    }\n  }\n\n  int saveFd = systemConnector->getSaveFd().orDefault(0);\n\n  for (int fd: fds) {\n    if (fd != saveFd) {\n      // Ignore close errors -- we don't care, as long as the file is closed.  (Also, one close()\n      // will always return EBADF because it's the directory FD closed in closedir().)\n      close(fd);\n    }\n  }\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::closeFds() {\n    // Close all unexpected file descriptors (i.e. other than stdin/stdout/stderr).  This is a\n    // safety measure incase we were launched by a badly-written parent program which forgot to\n    // set CLOEXEC on its private file descriptors.  We don't want the sandboxed process to\n    // accidentally get access to those.\n  \n    // We detect open file descriptors by reading from /proc.\n    //\n    // We need to defer closing each FD until after the scan completes, because:\n    // 1) We probably shouldn't change the directory contents while listing.\n    // 2) opendir() itself opens an FD.  Closing it would disrupt the scan.\n    kj::Vector<int> fds;\n  \n    {\n      DIR* dir = opendir(\"/proc/self/fd\");\n      if (dir == nullptr) {\n        KJ_FAIL_SYSCALL(\"opendir(/proc/self/fd)\", errno);\n      }\n      KJ_DEFER(KJ_SYSCALL(closedir(dir)) { break; });\n  \n      for (;;) {\n        struct dirent entry;\n        struct dirent* eptr = nullptr;\n        int error = readdir_r(dir, &entry, &eptr);\n        if (error != 0) {\n          KJ_FAIL_SYSCALL(\"readdir_r(/proc/self/fd)\", error);\n        }\n        if (eptr == nullptr) {\n          // End of directory.\n          break;\n        }\n  \n        if (eptr->d_name[0] != '.') {\n          char* end;\n          int fd = strtoul(eptr->d_name, &end, 10);\n          KJ_ASSERT(*end == '\\0' && end > eptr->d_name,\n                    \"File in /proc/self/fd had non-numeric name?\", eptr->d_name);\n          if (fd > STDERR_FILENO) {\n            fds.add(fd);\n          }\n        }\n      }\n    }\n  \n    int saveFd = systemConnector->getSaveFd().orDefault(0);\n  \n    for (int fd: fds) {\n      if (fd != saveFd) {\n        // Ignore close errors -- we don't care, as long as the file is closed.  (Also, one close()\n        // will always return EBADF because it's the directory FD closed in closedir().)\n        close(fd);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nSupervisorMain {\n  void SupervisorMain::setupSupervisor() {\n    // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n    // execing a suid-root binary.  Sandboxed apps should not need that.\n    KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n  \n    closeFds();\n    setResourceLimits();\n    checkPaths();\n    unshareOuter();\n    setupFilesystem();\n    setupStdio();\n  \n    // Note:  permanentlyDropSuperuser() is performed post-fork; see comment in function def.\n  }\n}"
  },
  {
    "function_name": "realPath",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "718-746",
    "snippet": "kj::String SupervisorMain::realPath(kj::StringPtr path) {\n  char* cResult = realpath(path.cStr(), nullptr);\n  if (cResult == nullptr) {\n    int error = errno;\n    if (error != ENOENT) {\n      KJ_FAIL_SYSCALL(\"realpath\", error, path);\n    }\n\n    // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n    // relative path to absolute whether it exists or not. So try resolving the parent instead.\n    KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n      if (*slashPos == 0) {\n        // Path is e.g. \"/foo\". The root directory obviously exists.\n        return kj::heapString(path);\n      } else {\n        return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                       path.slice(*slashPos));\n      }\n    } else {\n      // Path is a relative path with only one component.\n      char* cwd = getcwd(nullptr, 0);\n      KJ_DEFER(free(cwd));\n      if (cwd[0] == '/' && cwd[1] == '\\0') {\n        return kj::str('/', path);\n      } else {\n        return kj::str(cwd, '/', path);\n      }\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "cwd",
            "'/'",
            "path"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "'/'",
            "path"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "free(cwd)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cwd"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "nullptr",
            "0"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "realPath(kj::heapString(path.slice(0, *slashPos)))",
            "path.slice(*slashPos)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "*slashPos"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realPath",
          "args": [
            "kj::heapString(path.slice(0, *slashPos))"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "realPath",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "718-746",
          "snippet": "kj::String SupervisorMain::realPath(kj::StringPtr path) {\n  char* cResult = realpath(path.cStr(), nullptr);\n  if (cResult == nullptr) {\n    int error = errno;\n    if (error != ENOENT) {\n      KJ_FAIL_SYSCALL(\"realpath\", error, path);\n    }\n\n    // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n    // relative path to absolute whether it exists or not. So try resolving the parent instead.\n    KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n      if (*slashPos == 0) {\n        // Path is e.g. \"/foo\". The root directory obviously exists.\n        return kj::heapString(path);\n      } else {\n        return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                       path.slice(*slashPos));\n      }\n    } else {\n      // Path is a relative path with only one component.\n      char* cwd = getcwd(nullptr, 0);\n      KJ_DEFER(free(cwd));\n      if (cwd[0] == '/' && cwd[1] == '\\0') {\n        return kj::str('/', path);\n      } else {\n        return kj::str(cwd, '/', path);\n      }\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path.slice(0, *slashPos)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "0",
            "*slashPos"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "slashPos",
            "path.findLast('/')"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.findLast",
          "args": [
            "'/'"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"realpath\"",
            "error",
            "path"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "path.cStr()",
            "nullptr"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::String SupervisorMain::realPath(kj::StringPtr path) {\n    char* cResult = realpath(path.cStr(), nullptr);\n    if (cResult == nullptr) {\n      int error = errno;\n      if (error != ENOENT) {\n        KJ_FAIL_SYSCALL(\"realpath\", error, path);\n      }\n  \n      // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n      // relative path to absolute whether it exists or not. So try resolving the parent instead.\n      KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n        if (*slashPos == 0) {\n          // Path is e.g. \"/foo\". The root directory obviously exists.\n          return kj::heapString(path);\n        } else {\n          return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                         path.slice(*slashPos));\n        }\n      } else {\n        // Path is a relative path with only one component.\n        char* cwd = getcwd(nullptr, 0);\n        KJ_DEFER(free(cwd));\n        if (cwd[0] == '/' && cwd[1] == '\\0') {\n          return kj::str('/', path);\n        } else {\n          return kj::str(cwd, '/', path);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "bind",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "708-716",
    "snippet": "void SupervisorMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REMOUNT | MS_NOSUID | flags, nullptr),\n      src, dst);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REMOUNT | MS_NOSUID | flags, nullptr)",
            "src",
            "dst"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "src.cStr()",
            "dst.cStr()",
            "nullptr",
            "MS_BIND | MS_REMOUNT | MS_NOSUID | flags",
            "nullptr"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.cStr",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(src.cStr(), dst.cStr(), nullptr, MS_BIND, nullptr)",
            "src",
            "dst"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "src.cStr()",
            "dst.cStr()",
            "nullptr",
            "MS_BIND",
            "nullptr"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.cStr",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n    // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n    // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n    // them.\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND, nullptr), src, dst);\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                     MS_BIND | MS_REMOUNT | MS_NOSUID | flags, nullptr),\n        src, dst);\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "665-704",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::run() {\n  isIpTablesAvailable = checkIfIpTablesLoaded();\n\n  setupSupervisor();\n\n  // Exits if another supervisor is still running in this sandbox.\n  systemConnector->checkIfAlreadyRunning();\n\n  if (sandboxUid == nullptr) {\n    SANDSTORM_LOG(\"Starting up grain. Sandbox type: userns\");\n  } else {\n    SANDSTORM_LOG(\"Starting up grain. Sandbox type: privileged\");\n  }\n\n  registerSignalHandlers();\n\n  // Create eventfd that we'll use to block app startup until we've received an RPC requiring\n  // it. This is a hack to allow serving files out of the app's www directory without starting\n  // the app.\n  int _startEventFd;\n  KJ_SYSCALL(_startEventFd = eventfd(0, EFD_CLOEXEC));\n  kj::AutoCloseFd startEventFd(_startEventFd);\n\n  // Allocate the API socket.\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds));\n\n  // Now time to run the start command, in a further chroot.\n  KJ_SYSCALL(childPid = fork());\n  if (childPid == 0) {\n    // We're in the child.\n    KJ_SYSCALL(close(fds[0]));  // just to be safe, even though it's CLOEXEC.\n    runChild(fds[1], kj::mv(startEventFd));\n  } else {\n    // We're in the supervisor.\n    KJ_DEFER(killChild());\n    KJ_SYSCALL(close(fds[1]));\n    runSupervisor(fds[0], kj::mv(startEventFd));\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "runSupervisor",
          "args": [
            "fds[0]",
            "kj::mv(startEventFd)"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "runSupervisor",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "2309-2407",
          "snippet": "[[noreturn]] void SupervisorMain::runSupervisor(int apiFd, kj::AutoCloseFd startEventFd) {\n  // We're currently in a somewhat dangerous state: our root directory is controlled\n  // by the app.  If glibc reads, say, /etc/nsswitch.conf, the grain could take control\n  // of the supervisor.  Fix this by chrooting to the supervisor directory.\n  // TODO(someday): chroot somewhere that's guaranteed to be empty instead, so that if the\n  //   supervisor storage is itself compromised it can't be used to execute arbitrary code in\n  //   the supervisor process.\n  KJ_SYSCALL(chroot(\".\"));\n\n  permanentlyDropSuperuser();\n  setupSeccomp();\n\n  // TODO(soon): Somehow make sure all grandchildren die if supervisor dies. Currently SIGKILL\n  //   on the supervisor won't give it a chance to kill the sandbox pid tree. Perhaps the\n  //   supervisor should actually be the app's root process? We'd have to more carefully handle\n  //   SIGCHLD in that case and also worry about signals sent from the app process.\n\n  kj::UnixEventPort::captureSignal(SIGCHLD);\n  auto ioContext = kj::setupAsyncIo();\n\n  // Detect child exit.\n  auto exitPromise = ioContext.unixEventPort.onSignal(SIGCHLD).then([this](siginfo_t info) {\n    KJ_ASSERT(childPid != 0);\n    int status;\n    KJ_SYSCALL(waitpid(childPid, &status, 0));\n    childPid = 0;\n    KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n    if (WIFSIGNALED(status)) {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n          \" (\", strsignal(WTERMSIG(status)), \").\"));\n    } else {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status)));\n    }\n  }).eagerlyEvaluate([this](kj::Exception&& e) {\n    context.exitError(kj::str(\n        \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e));\n  });\n\n  auto coreRedirector = kj::refcounted<CapRedirector>();\n  SandstormCore::Client coreCap = static_cast<capnp::Capability::Client>(\n    kj::addRef(*coreRedirector)).castAs<SandstormCore>();\n  SupervisorRealmGateway::Client gateway = kj::heap<SupervisorRealmGatewayImpl>(coreCap);\n\n  // Compute grain size and watch for changes.\n  DiskUsageWatcher diskWatcher(ioContext.unixEventPort, ioContext.provider->getTimer(), coreCap);\n  auto diskWatcherTask = diskWatcher.init();\n\n  // Set up the RPC connection to the app and export the supervisor interface.\n  auto appConnection = ioContext.lowLevelProvider->wrapSocketFd(apiFd,\n      kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC |\n      kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP);\n  capnp::TwoPartyVatNetwork appNetwork(*appConnection, capnp::rpc::twoparty::Side::SERVER);\n  WakelockSet wakelockSet(grainId, coreCap);\n  auto server = capnp::makeRpcServer(appNetwork, kj::heap<SandstormApiImpl>(wakelockSet, grainId,\n      coreCap), kj::mv(gateway));\n\n  // Limit outstanding calls from the app to 1MiW (8MiB) in order to prevent an errant or malicious\n  // app from consuming excessive RAM elsewhere in the system.\n  server.setFlowLimit(1u << 20);\n\n  // Get the app's UiView by restoring a null SturdyRef from it.\n  capnp::MallocMessageBuilder message;\n  auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n  hostId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n  MainView<>::Client app = server.bootstrap(hostId).castAs<MainView<>>();\n\n  // Set up the external RPC interface, re-exporting the UiView.\n  // TODO(someday):  If there are multiple front-ends, or the front-ends restart a lot, we'll\n  //   want to wrap the UiView and cache session objects.  Perhaps we could do this by making\n  //   them persistable, though it's unclear how that would work with SessionContext.\n  Supervisor::Client mainCap = kj::heap<SupervisorImpl>(\n      ioContext.unixEventPort, kj::mv(app), wakelockSet, kj::mv(startEventFd),\n      coreCap, kj::addRef(*coreRedirector));\n\n  auto acceptTask = systemConnector->run(ioContext, kj::mv(mainCap), kj::mv(coreRedirector));\n\n  // Wait for disconnect or accept loop failure or disk watch failure, then exit. Also rotate log\n  // every 512k (thus having at most 1MB of logs at a time).\n  acceptTask.exclusiveJoin(kj::mv(diskWatcherTask))\n            .exclusiveJoin(appNetwork.onDisconnect())\n            .exclusiveJoin(rotateLog(ioContext.provider->getTimer(),\n                                     STDERR_FILENO, \"log\", 512u << 10))\n            .wait(ioContext.waitScope);\n\n  // Only onDisconnect() would return normally (rather than throw), so the app must have\n  // disconnected (i.e. from the Cap'n Proto API socket).\n\n  // Hmm, app disconnected API socket. The app probably exited and we just haven't gotten the\n  // signal yet, so sleep for a moment to let it arrive, so that we can report the exit status.\n  // Otherwise kill.\n  ioContext.provider->getTimer().afterDelay(1 * kj::SECONDS)\n      .exclusiveJoin(kj::mv(exitPromise))\n      .wait(ioContext.waitScope);\n\n  SANDSTORM_LOG(\"App disconnected API socket but didn't actually exit; killing it.\");\n  killChildAndExit(1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "WakelockSet& wakelockSet;",
            "kj::Own<CapRedirector> coreRedirector;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nWakelockSet& wakelockSet;\nkj::Own<CapRedirector> coreRedirector;\n\nSupervisorMain {\n  [[noreturn]] void SupervisorMain::runSupervisor(int apiFd, kj::AutoCloseFd startEventFd) {\n    // We're currently in a somewhat dangerous state: our root directory is controlled\n    // by the app.  If glibc reads, say, /etc/nsswitch.conf, the grain could take control\n    // of the supervisor.  Fix this by chrooting to the supervisor directory.\n    // TODO(someday): chroot somewhere that's guaranteed to be empty instead, so that if the\n    //   supervisor storage is itself compromised it can't be used to execute arbitrary code in\n    //   the supervisor process.\n    KJ_SYSCALL(chroot(\".\"));\n  \n    permanentlyDropSuperuser();\n    setupSeccomp();\n  \n    // TODO(soon): Somehow make sure all grandchildren die if supervisor dies. Currently SIGKILL\n    //   on the supervisor won't give it a chance to kill the sandbox pid tree. Perhaps the\n    //   supervisor should actually be the app's root process? We'd have to more carefully handle\n    //   SIGCHLD in that case and also worry about signals sent from the app process.\n  \n    kj::UnixEventPort::captureSignal(SIGCHLD);\n    auto ioContext = kj::setupAsyncIo();\n  \n    // Detect child exit.\n    auto exitPromise = ioContext.unixEventPort.onSignal(SIGCHLD).then([this](siginfo_t info) {\n      KJ_ASSERT(childPid != 0);\n      int status;\n      KJ_SYSCALL(waitpid(childPid, &status, 0));\n      childPid = 0;\n      KJ_ASSERT(WIFEXITED(status) || WIFSIGNALED(status));\n      if (WIFSIGNALED(status)) {\n        context.exitError(kj::str(\n            \"** SANDSTORM SUPERVISOR: App exited due to signal \", WTERMSIG(status),\n            \" (\", strsignal(WTERMSIG(status)), \").\"));\n      } else {\n        context.exitError(kj::str(\n            \"** SANDSTORM SUPERVISOR: App exited with status code: \", WEXITSTATUS(status)));\n      }\n    }).eagerlyEvaluate([this](kj::Exception&& e) {\n      context.exitError(kj::str(\n          \"** SANDSTORM SUPERVISOR: Uncaught exception waiting for child process:\\n\", e));\n    });\n  \n    auto coreRedirector = kj::refcounted<CapRedirector>();\n    SandstormCore::Client coreCap = static_cast<capnp::Capability::Client>(\n      kj::addRef(*coreRedirector)).castAs<SandstormCore>();\n    SupervisorRealmGateway::Client gateway = kj::heap<SupervisorRealmGatewayImpl>(coreCap);\n  \n    // Compute grain size and watch for changes.\n    DiskUsageWatcher diskWatcher(ioContext.unixEventPort, ioContext.provider->getTimer(), coreCap);\n    auto diskWatcherTask = diskWatcher.init();\n  \n    // Set up the RPC connection to the app and export the supervisor interface.\n    auto appConnection = ioContext.lowLevelProvider->wrapSocketFd(apiFd,\n        kj::LowLevelAsyncIoProvider::ALREADY_CLOEXEC |\n        kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP);\n    capnp::TwoPartyVatNetwork appNetwork(*appConnection, capnp::rpc::twoparty::Side::SERVER);\n    WakelockSet wakelockSet(grainId, coreCap);\n    auto server = capnp::makeRpcServer(appNetwork, kj::heap<SandstormApiImpl>(wakelockSet, grainId,\n        coreCap), kj::mv(gateway));\n  \n    // Limit outstanding calls from the app to 1MiW (8MiB) in order to prevent an errant or malicious\n    // app from consuming excessive RAM elsewhere in the system.\n    server.setFlowLimit(1u << 20);\n  \n    // Get the app's UiView by restoring a null SturdyRef from it.\n    capnp::MallocMessageBuilder message;\n    auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n    hostId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n    MainView<>::Client app = server.bootstrap(hostId).castAs<MainView<>>();\n  \n    // Set up the external RPC interface, re-exporting the UiView.\n    // TODO(someday):  If there are multiple front-ends, or the front-ends restart a lot, we'll\n    //   want to wrap the UiView and cache session objects.  Perhaps we could do this by making\n    //   them persistable, though it's unclear how that would work with SessionContext.\n    Supervisor::Client mainCap = kj::heap<SupervisorImpl>(\n        ioContext.unixEventPort, kj::mv(app), wakelockSet, kj::mv(startEventFd),\n        coreCap, kj::addRef(*coreRedirector));\n  \n    auto acceptTask = systemConnector->run(ioContext, kj::mv(mainCap), kj::mv(coreRedirector));\n  \n    // Wait for disconnect or accept loop failure or disk watch failure, then exit. Also rotate log\n    // every 512k (thus having at most 1MB of logs at a time).\n    acceptTask.exclusiveJoin(kj::mv(diskWatcherTask))\n              .exclusiveJoin(appNetwork.onDisconnect())\n              .exclusiveJoin(rotateLog(ioContext.provider->getTimer(),\n                                       STDERR_FILENO, \"log\", 512u << 10))\n              .wait(ioContext.waitScope);\n  \n    // Only onDisconnect() would return normally (rather than throw), so the app must have\n    // disconnected (i.e. from the Cap'n Proto API socket).\n  \n    // Hmm, app disconnected API socket. The app probably exited and we just haven't gotten the\n    // signal yet, so sleep for a moment to let it arrive, so that we can report the exit status.\n    // Otherwise kill.\n    ioContext.provider->getTimer().afterDelay(1 * kj::SECONDS)\n        .exclusiveJoin(kj::mv(exitPromise))\n        .wait(ioContext.waitScope);\n  \n    SANDSTORM_LOG(\"App disconnected API socket but didn't actually exit; killing it.\");\n    killChildAndExit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "startEventFd"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(fds[1])"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[1]"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "killChild()"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "killChild",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "killChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "464-472",
          "snippet": "void killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}"
        }
      },
      {
        "call_info": {
          "callee": "runChild",
          "args": [
            "fds[1]",
            "kj::mv(startEventFd)"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "runChild",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1607-1661",
          "snippet": "[[noreturn]] void SupervisorMain::runChild(int apiFd, kj::AutoCloseFd startEventFd) {\n  // We are the child.\n\n  enterSandbox();\n\n  // Wait until we get the signal to start. (It's important to do this after entering the sandbox\n  // so that the parent process has permission to send SIGKILL to the child even in\n  // privileged-mode.)\n  uint64_t dummy;\n  KJ_SYSCALL(read(startEventFd, &dummy, sizeof(dummy)));\n\n  // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n  // code likes to ignore e.g. SIGPIPE.)\n  // TODO(cleanup):  Is there a better way to do this?\n  for (uint i = 0; i < NSIG; i++) {\n    signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n  }\n\n  // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n  sigset_t sigmask;\n  sigemptyset(&sigmask);\n  KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n\n  // Make sure the API socket is on FD 3.\n  if (apiFd == 3) {\n    // Socket end already has correct fd.  Unset CLOEXEC.\n    KJ_SYSCALL(fcntl(apiFd, F_SETFD, 0));\n  } else {\n    // dup socket to correct fd.\n    KJ_SYSCALL(dup2(apiFd, 3));\n    KJ_SYSCALL(close(apiFd));\n  }\n\n  // Redirect stdout to stderr, so that our own stdout serves one purpose:  to notify the parent\n  // process when we're ready to accept connections.  We previously directed stderr to a log file.\n  KJ_SYSCALL(dup2(STDERR_FILENO, STDOUT_FILENO));\n\n  char* argv[command.size() + 1];\n  for (uint i: kj::indices(command)) {\n    argv[i] = const_cast<char*>(command[i].cStr());\n  }\n  argv[command.size()] = nullptr;\n\n  char* env[environment.size() + 1];\n  for (uint i: kj::indices(environment)) {\n    env[i] = const_cast<char*>(environment[i].cStr());\n  }\n  env[environment.size()] = nullptr;\n\n  char** argvp = argv;  // work-around Clang not liking lambda + vararray\n  char** envp = env;    // same\n\n  KJ_SYSCALL(execve(argvp[0], argvp, envp), argvp[0]);\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  [[noreturn]] void SupervisorMain::runChild(int apiFd, kj::AutoCloseFd startEventFd) {\n    // We are the child.\n  \n    enterSandbox();\n  \n    // Wait until we get the signal to start. (It's important to do this after entering the sandbox\n    // so that the parent process has permission to send SIGKILL to the child even in\n    // privileged-mode.)\n    uint64_t dummy;\n    KJ_SYSCALL(read(startEventFd, &dummy, sizeof(dummy)));\n  \n    // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n    // code likes to ignore e.g. SIGPIPE.)\n    // TODO(cleanup):  Is there a better way to do this?\n    for (uint i = 0; i < NSIG; i++) {\n      signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n    }\n  \n    // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n    sigset_t sigmask;\n    sigemptyset(&sigmask);\n    KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n  \n    // Make sure the API socket is on FD 3.\n    if (apiFd == 3) {\n      // Socket end already has correct fd.  Unset CLOEXEC.\n      KJ_SYSCALL(fcntl(apiFd, F_SETFD, 0));\n    } else {\n      // dup socket to correct fd.\n      KJ_SYSCALL(dup2(apiFd, 3));\n      KJ_SYSCALL(close(apiFd));\n    }\n  \n    // Redirect stdout to stderr, so that our own stdout serves one purpose:  to notify the parent\n    // process when we're ready to accept connections.  We previously directed stderr to a log file.\n    KJ_SYSCALL(dup2(STDERR_FILENO, STDOUT_FILENO));\n  \n    char* argv[command.size() + 1];\n    for (uint i: kj::indices(command)) {\n      argv[i] = const_cast<char*>(command[i].cStr());\n    }\n    argv[command.size()] = nullptr;\n  \n    char* env[environment.size() + 1];\n    for (uint i: kj::indices(environment)) {\n      env[i] = const_cast<char*>(environment[i].cStr());\n    }\n    env[environment.size()] = nullptr;\n  \n    char** argvp = argv;  // work-around Clang not liking lambda + vararray\n    char** envp = env;    // same\n  \n    KJ_SYSCALL(execve(argvp[0], argvp, envp), argvp[0]);\n    KJ_UNREACHABLE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "startEventFd"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "close(fds[0])"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fds[0]"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "childPid = fork()"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM | SOCK_CLOEXEC",
            "0",
            "fds"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "_startEventFd = eventfd(0, EFD_CLOEXEC)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd",
          "args": [
            "0",
            "EFD_CLOEXEC"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "registerSignalHandlers",
          "args": [],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "registerSignalHandlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "522-549",
          "snippet": "void registerSignalHandlers() {\n  // Create a sigaction that runs our signal handler with all signals blocked.  Our signal handler\n  // completes (or exits) quickly anyway, so let's not try to deal with it being interruptable.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_handler = &signalHandler;\n  sigfillset(&action.sa_mask);\n\n  // SIGALRM will fire every 1.5 minutes and will kill us if no keepalive was received in that\n  // time.\n  KJ_SYSCALL(sigaction(SIGALRM, &action, nullptr));\n\n  // Other death signals simply kill us immediately.\n  for (int signo: kj::ArrayPtr<int>(DEATH_SIGNALS)) {\n    KJ_SYSCALL(sigaction(signo, &action, nullptr));\n  }\n\n  // Set up the SIGALRM timer to check every 1.5 minutes whether we're idle. If we haven't received\n  // a keep-alive request in a 1.5-minute period, we kill ourselves. The client normally sends\n  // keep-alives every minute. Note that it's not the end of the world if we miss one; the server\n  // will transparently start back up on the next request from the client.\n  // Note that this is not inherited over fork.\n  struct itimerval timer;\n  memset(&timer, 0, sizeof(timer));\n  timer.it_interval.tv_sec = 90;\n  timer.it_value.tv_sec = 90;\n  KJ_SYSCALL(setitimer(ITIMER_REAL, &timer, nullptr));\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid registerSignalHandlers() {\n  // Create a sigaction that runs our signal handler with all signals blocked.  Our signal handler\n  // completes (or exits) quickly anyway, so let's not try to deal with it being interruptable.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_handler = &signalHandler;\n  sigfillset(&action.sa_mask);\n\n  // SIGALRM will fire every 1.5 minutes and will kill us if no keepalive was received in that\n  // time.\n  KJ_SYSCALL(sigaction(SIGALRM, &action, nullptr));\n\n  // Other death signals simply kill us immediately.\n  for (int signo: kj::ArrayPtr<int>(DEATH_SIGNALS)) {\n    KJ_SYSCALL(sigaction(signo, &action, nullptr));\n  }\n\n  // Set up the SIGALRM timer to check every 1.5 minutes whether we're idle. If we haven't received\n  // a keep-alive request in a 1.5-minute period, we kill ourselves. The client normally sends\n  // keep-alives every minute. Note that it's not the end of the world if we miss one; the server\n  // will transparently start back up on the next request from the client.\n  // Note that this is not inherited over fork.\n  struct itimerval timer;\n  memset(&timer, 0, sizeof(timer));\n  timer.it_interval.tv_sec = 90;\n  timer.it_value.tv_sec = 90;\n  KJ_SYSCALL(setitimer(ITIMER_REAL, &timer, nullptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Starting up grain. Sandbox type: privileged\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Starting up grain. Sandbox type: userns\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systemConnector->checkIfAlreadyRunning",
          "args": [],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "checkIfAlreadyRunning",
          "container": "SupervisorMain::DefaultSystemConnector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1554-1603",
          "snippet": "void SupervisorMain::DefaultSystemConnector::checkIfAlreadyRunning() const {\n  // Attempt to connect to any existing supervisor and call keepAlive().  If successful, we\n  // don't want to start a new instance; we should use the existing instance.\n\n  // TODO(soon):  There's a race condition if two supervisors are started up in rapid succession.\n  //   We could maybe avoid that with some filesystem locking.  It's currently unlikely to happen\n  //   in practice because it would require sending a request to the shell server to open the\n  //   grain, then restarting the shell server, then opening the grain again, all before the\n  //   first supervisor finished starting.  Or, I suppose, running two shell servers and trying\n  //   to open the same grain in both at once.\n\n  auto ioContext = kj::setupAsyncIo();\n\n  // Connect to the client.\n  auto addr = ioContext.provider->getNetwork().parseAddress(\"unix:socket\")\n      .wait(ioContext.waitScope);\n  kj::Own<kj::AsyncIoStream> connection;\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    connection = addr->connect().wait(ioContext.waitScope);\n  })) {\n    // Failed to connect.  Assume socket is stale.\n    return;\n  }\n\n  // Set up RPC.\n  capnp::TwoPartyVatNetwork vatNetwork(*connection, capnp::rpc::twoparty::Side::CLIENT);\n  auto client = capnp::makeRpcClient(vatNetwork);\n\n  // Restore the default capability (the Supervisor interface).\n  capnp::MallocMessageBuilder message;\n  auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n  hostId.setSide(capnp::rpc::twoparty::Side::SERVER);\n  Supervisor::Client cap = client.bootstrap(hostId).castAs<Supervisor>();\n\n  // Call keepAlive().\n  auto promise = cap.keepAliveRequest().send();\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    promise.wait(ioContext.waitScope);\n  })) {\n    // Failed to keep-alive.  Supervisor must have died just as we were connecting to it.  Go\n    // ahead and start a new one.\n    return;\n  }\n\n  // We successfully connected and keepalived the existing supervisor, so we can exit.  The\n  // caller is expecting us to write to stdout when the stocket is ready, so do that anyway.\n  KJ_SYSCALL(write(STDOUT_FILENO, \"Already running...\\n\", strlen(\"Already running...\\n\")));\n  _exit(0);\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nSupervisorMain {\n  DefaultSystemConnector {\n    void SupervisorMain::DefaultSystemConnector::checkIfAlreadyRunning() const {\n      // Attempt to connect to any existing supervisor and call keepAlive().  If successful, we\n      // don't want to start a new instance; we should use the existing instance.\n    \n      // TODO(soon):  There's a race condition if two supervisors are started up in rapid succession.\n      //   We could maybe avoid that with some filesystem locking.  It's currently unlikely to happen\n      //   in practice because it would require sending a request to the shell server to open the\n      //   grain, then restarting the shell server, then opening the grain again, all before the\n      //   first supervisor finished starting.  Or, I suppose, running two shell servers and trying\n      //   to open the same grain in both at once.\n    \n      auto ioContext = kj::setupAsyncIo();\n    \n      // Connect to the client.\n      auto addr = ioContext.provider->getNetwork().parseAddress(\"unix:socket\")\n          .wait(ioContext.waitScope);\n      kj::Own<kj::AsyncIoStream> connection;\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        connection = addr->connect().wait(ioContext.waitScope);\n      })) {\n        // Failed to connect.  Assume socket is stale.\n        return;\n      }\n    \n      // Set up RPC.\n      capnp::TwoPartyVatNetwork vatNetwork(*connection, capnp::rpc::twoparty::Side::CLIENT);\n      auto client = capnp::makeRpcClient(vatNetwork);\n    \n      // Restore the default capability (the Supervisor interface).\n      capnp::MallocMessageBuilder message;\n      auto hostId = message.initRoot<capnp::rpc::twoparty::VatId>();\n      hostId.setSide(capnp::rpc::twoparty::Side::SERVER);\n      Supervisor::Client cap = client.bootstrap(hostId).castAs<Supervisor>();\n    \n      // Call keepAlive().\n      auto promise = cap.keepAliveRequest().send();\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        promise.wait(ioContext.waitScope);\n      })) {\n        // Failed to keep-alive.  Supervisor must have died just as we were connecting to it.  Go\n        // ahead and start a new one.\n        return;\n      }\n    \n      // We successfully connected and keepalived the existing supervisor, so we can exit.  The\n      // caller is expecting us to write to stdout when the stocket is ready, so do that anyway.\n      KJ_SYSCALL(write(STDOUT_FILENO, \"Already running...\\n\", strlen(\"Already running...\\n\")));\n      _exit(0);\n      KJ_UNREACHABLE;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setupSupervisor",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "setupSupervisor",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "754-767",
          "snippet": "void SupervisorMain::setupSupervisor() {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary.  Sandboxed apps should not need that.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  closeFds();\n  setResourceLimits();\n  checkPaths();\n  unshareOuter();\n  setupFilesystem();\n  setupStdio();\n\n  // Note:  permanentlyDropSuperuser() is performed post-fork; see comment in function def.\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [
            "#define PR_SET_NO_NEW_PRIVS 38"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nSupervisorMain {\n  void SupervisorMain::setupSupervisor() {\n    // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n    // execing a suid-root binary.  Sandboxed apps should not need that.\n    KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n  \n    closeFds();\n    setResourceLimits();\n    checkPaths();\n    unshareOuter();\n    setupFilesystem();\n    setupStdio();\n  \n    // Note:  permanentlyDropSuperuser() is performed post-fork; see comment in function def.\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkIfIpTablesLoaded",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "checkIfIpTablesLoaded",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "1462-1482",
          "snippet": "bool SupervisorMain::checkIfIpTablesLoaded() {\n  // Detect if the iptables kernel module is available. Must be called before entering the\n  // sandbox since this requires /proc.\n  //\n  // TODO(soon): This check is wrong because iptables could be compiled directly into the kernel\n  //   rather than as a module. Indeed, /proc/modules is reported to be sometimes absent in the\n  //   wild, perhaps when the kernel is compiled without module support. For now we'll assume\n  //   iptables is unavailable in that case.\n\n  KJ_IF_MAYBE(procModules, raiiOpenIfExists(\"/proc/modules\", O_RDONLY)) {\n    kj::FdInputStream rawIn(kj::mv(*procModules));\n    kj::BufferedInputStreamWrapper bufferedIn(rawIn);\n\n    for (;;) {\n      KJ_IF_MAYBE(line, readLine(bufferedIn)) {\n        if (line->startsWith(\"ip_tables \")) return true;\n      } else {\n        break;\n      }\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  bool SupervisorMain::checkIfIpTablesLoaded() {\n    // Detect if the iptables kernel module is available. Must be called before entering the\n    // sandbox since this requires /proc.\n    //\n    // TODO(soon): This check is wrong because iptables could be compiled directly into the kernel\n    //   rather than as a module. Indeed, /proc/modules is reported to be sometimes absent in the\n    //   wild, perhaps when the kernel is compiled without module support. For now we'll assume\n    //   iptables is unavailable in that case.\n  \n    KJ_IF_MAYBE(procModules, raiiOpenIfExists(\"/proc/modules\", O_RDONLY)) {\n      kj::FdInputStream rawIn(kj::mv(*procModules));\n      kj::BufferedInputStreamWrapper bufferedIn(rawIn);\n  \n      for (;;) {\n        KJ_IF_MAYBE(line, readLine(bufferedIn)) {\n          if (line->startsWith(\"ip_tables \")) return true;\n        } else {\n          break;\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::run() {\n    isIpTablesAvailable = checkIfIpTablesLoaded();\n  \n    setupSupervisor();\n  \n    // Exits if another supervisor is still running in this sandbox.\n    systemConnector->checkIfAlreadyRunning();\n  \n    if (sandboxUid == nullptr) {\n      SANDSTORM_LOG(\"Starting up grain. Sandbox type: userns\");\n    } else {\n      SANDSTORM_LOG(\"Starting up grain. Sandbox type: privileged\");\n    }\n  \n    registerSignalHandlers();\n  \n    // Create eventfd that we'll use to block app startup until we've received an RPC requiring\n    // it. This is a hack to allow serving files out of the app's www directory without starting\n    // the app.\n    int _startEventFd;\n    KJ_SYSCALL(_startEventFd = eventfd(0, EFD_CLOEXEC));\n    kj::AutoCloseFd startEventFd(_startEventFd);\n  \n    // Allocate the API socket.\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds));\n  \n    // Now time to run the start command, in a further chroot.\n    KJ_SYSCALL(childPid = fork());\n    if (childPid == 0) {\n      // We're in the child.\n      KJ_SYSCALL(close(fds[0]));  // just to be safe, even though it's CLOEXEC.\n      runChild(fds[1], kj::mv(startEventFd));\n    } else {\n      // We're in the supervisor.\n      KJ_DEFER(killChild());\n      KJ_SYSCALL(close(fds[1]));\n      runSupervisor(fds[0], kj::mv(startEventFd));\n    }\n  }\n}"
  },
  {
    "function_name": "addCommandArg",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "658-661",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::addCommandArg(kj::StringPtr arg) {\n  command.add(kj::heapString(arg));\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "command.add",
          "args": [
            "kj::heapString(arg)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "arg"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::addCommandArg(kj::StringPtr arg) {\n    command.add(kj::heapString(arg));\n    return true;\n  }\n}"
  },
  {
    "function_name": "addEnv",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "653-656",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::addEnv(kj::StringPtr arg) {\n  environment.add(kj::heapString(arg));\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "environment.add",
          "args": [
            "kj::heapString(arg)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "arg"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::addEnv(kj::StringPtr arg) {\n    environment.add(kj::heapString(arg));\n    return true;\n  }\n}"
  },
  {
    "function_name": "setUid",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "637-650",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::setUid(kj::StringPtr arg) {\n  KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n    if (getuid() != 0) {\n      return \"must start as root to use --uid\";\n    }\n    if (*u == 0) {\n      return \"can't run sandbox as root\";\n    }\n    KJ_SYSCALL(seteuid(*u));\n    sandboxUid = *u;\n    return true;\n  } else {\n    return \"UID must be a number\";\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "seteuid(*u)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seteuid",
          "args": [
            "*u"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "u",
            "parseUInt(arg, 10)"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseUInt",
          "args": [
            "arg",
            "10"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "parseUInt64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "223-230",
          "snippet": "kj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setUid(kj::StringPtr arg) {\n    KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n      if (getuid() != 0) {\n        return \"must start as root to use --uid\";\n      }\n      if (*u == 0) {\n        return \"can't run sandbox as root\";\n      }\n      KJ_SYSCALL(seteuid(*u));\n      sandboxUid = *u;\n      return true;\n    } else {\n      return \"UID must be a number\";\n    }\n}"
  },
  {
    "function_name": "setVar",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "632-635",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::setVar(kj::StringPtr path) {\n  varPath = realPath(kj::heapString(path));\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realPath",
          "args": [
            "kj::heapString(path)"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "realPath",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "718-746",
          "snippet": "kj::String SupervisorMain::realPath(kj::StringPtr path) {\n  char* cResult = realpath(path.cStr(), nullptr);\n  if (cResult == nullptr) {\n    int error = errno;\n    if (error != ENOENT) {\n      KJ_FAIL_SYSCALL(\"realpath\", error, path);\n    }\n\n    // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n    // relative path to absolute whether it exists or not. So try resolving the parent instead.\n    KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n      if (*slashPos == 0) {\n        // Path is e.g. \"/foo\". The root directory obviously exists.\n        return kj::heapString(path);\n      } else {\n        return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                       path.slice(*slashPos));\n      }\n    } else {\n      // Path is a relative path with only one component.\n      char* cwd = getcwd(nullptr, 0);\n      KJ_DEFER(free(cwd));\n      if (cwd[0] == '/' && cwd[1] == '\\0') {\n        return kj::str('/', path);\n      } else {\n        return kj::str(cwd, '/', path);\n      }\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::String SupervisorMain::realPath(kj::StringPtr path) {\n    char* cResult = realpath(path.cStr(), nullptr);\n    if (cResult == nullptr) {\n      int error = errno;\n      if (error != ENOENT) {\n        KJ_FAIL_SYSCALL(\"realpath\", error, path);\n      }\n  \n      // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n      // relative path to absolute whether it exists or not. So try resolving the parent instead.\n      KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n        if (*slashPos == 0) {\n          // Path is e.g. \"/foo\". The root directory obviously exists.\n          return kj::heapString(path);\n        } else {\n          return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                         path.slice(*slashPos));\n        }\n      } else {\n        // Path is a relative path with only one component.\n        char* cwd = getcwd(nullptr, 0);\n        KJ_DEFER(free(cwd));\n        if (cwd[0] == '/' && cwd[1] == '\\0') {\n          return kj::str('/', path);\n        } else {\n          return kj::str(cwd, '/', path);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setVar(kj::StringPtr path) {\n    varPath = realPath(kj::heapString(path));\n    return true;\n  }\n}"
  },
  {
    "function_name": "setPkg",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "627-630",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::setPkg(kj::StringPtr path) {\n  pkgPath = realPath(kj::heapString(path));\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realPath",
          "args": [
            "kj::heapString(path)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "realPath",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "718-746",
          "snippet": "kj::String SupervisorMain::realPath(kj::StringPtr path) {\n  char* cResult = realpath(path.cStr(), nullptr);\n  if (cResult == nullptr) {\n    int error = errno;\n    if (error != ENOENT) {\n      KJ_FAIL_SYSCALL(\"realpath\", error, path);\n    }\n\n    // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n    // relative path to absolute whether it exists or not. So try resolving the parent instead.\n    KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n      if (*slashPos == 0) {\n        // Path is e.g. \"/foo\". The root directory obviously exists.\n        return kj::heapString(path);\n      } else {\n        return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                       path.slice(*slashPos));\n      }\n    } else {\n      // Path is a relative path with only one component.\n      char* cwd = getcwd(nullptr, 0);\n      KJ_DEFER(free(cwd));\n      if (cwd[0] == '/' && cwd[1] == '\\0') {\n        return kj::str('/', path);\n      } else {\n        return kj::str(cwd, '/', path);\n      }\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::String SupervisorMain::realPath(kj::StringPtr path) {\n    char* cResult = realpath(path.cStr(), nullptr);\n    if (cResult == nullptr) {\n      int error = errno;\n      if (error != ENOENT) {\n        KJ_FAIL_SYSCALL(\"realpath\", error, path);\n      }\n  \n      // realpath() fails if the target doesn't exist, but our goal here is just to convert a\n      // relative path to absolute whether it exists or not. So try resolving the parent instead.\n      KJ_IF_MAYBE(slashPos, path.findLast('/')) {\n        if (*slashPos == 0) {\n          // Path is e.g. \"/foo\". The root directory obviously exists.\n          return kj::heapString(path);\n        } else {\n          return kj::str(realPath(kj::heapString(path.slice(0, *slashPos))),\n                         path.slice(*slashPos));\n        }\n      } else {\n        // Path is a relative path with only one component.\n        char* cwd = getcwd(nullptr, 0);\n        KJ_DEFER(free(cwd));\n        if (cwd[0] == '/' && cwd[1] == '\\0') {\n          return kj::str('/', path);\n        } else {\n          return kj::str(cwd, '/', path);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setPkg(kj::StringPtr path) {\n    pkgPath = realPath(kj::heapString(path));\n    return true;\n  }\n}"
  },
  {
    "function_name": "setGrainId",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "619-625",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n  if (id == nullptr || id.findFirst('/') != nullptr) {\n    return \"Invalid grain id.\";\n  }\n  grainId = kj::heapString(id);\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "id"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id.findFirst",
          "args": [
            "'/'"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setGrainId(kj::StringPtr id) {\n    if (id == nullptr || id.findFirst('/') != nullptr) {\n      return \"Invalid grain id.\";\n    }\n    grainId = kj::heapString(id);\n    return true;\n  }\n}"
  },
  {
    "function_name": "setAppName",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "611-617",
    "snippet": "kj::MainBuilder::Validity SupervisorMain::setAppName(kj::StringPtr name) {\n  if (name == nullptr || name.findFirst('/') != nullptr) {\n    return \"Invalid app name.\";\n  }\n  appName = kj::heapString(name);\n  return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.findFirst",
          "args": [
            "'/'"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainBuilder::Validity SupervisorMain::setAppName(kj::StringPtr name) {\n    if (name == nullptr || name.findFirst('/') != nullptr) {\n      return \"Invalid app name.\";\n    }\n    appName = kj::heapString(name);\n    return true;\n  }\n}"
  },
  {
    "function_name": "setMountProc",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "604-609",
    "snippet": "void SupervisorMain::setMountProc(bool mountProc) {\n  if (mountProc) {\n    context.warning(\"WARNING: --proc is dangerous.  Only use it when debugging code you trust.\");\n  }\n  this->mountProc = mountProc;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"WARNING: --proc is dangerous.  Only use it when debugging code you trust.\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setMountProc(bool mountProc) {\n    if (mountProc) {\n      context.warning(\"WARNING: --proc is dangerous.  Only use it when debugging code you trust.\");\n    }\n    this->mountProc = mountProc;\n  }\n}"
  },
  {
    "function_name": "setIsNew",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "600-602",
    "snippet": "void SupervisorMain::setIsNew(bool isNew) {\n  this->isNew = isNew;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setIsNew(bool isNew) {\n    this->isNew = isNew;\n  }\n}"
  },
  {
    "function_name": "getMain",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "562-595",
    "snippet": "kj::MainFunc SupervisorMain::getMain() {\n  return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                         \"Runs a Sandstorm grain supervisor for the grain <grain-id>, which is \"\n                         \"an instance of app <app-id>.  Executes <command> inside the grain \"\n                         \"sandbox.\")\n      .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                        \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\")\n      .addOptionWithArg({\"pkg\"}, KJ_BIND_METHOD(*this, setPkg), \"<path>\",\n                        \"Set directory containing the app package.  \"\n                        \"Defaults to '$SANDSTORM_HOME/var/sandstorm/apps/<app-name>'.\")\n      .addOptionWithArg({\"var\"}, KJ_BIND_METHOD(*this, setVar), \"<path>\",\n                        \"Set directory where grain's mutable persistent data will be stored.  \"\n                        \"Defaults to '$SANDSTORM_HOME/var/sandstorm/grains/<grain-id>'.\")\n      .addOptionWithArg({'e', \"env\"}, KJ_BIND_METHOD(*this, addEnv), \"<name>=<val>\",\n                        \"Set the environment variable <name> to <val> inside the sandbox.  Note \"\n                        \"that *no* environment variables are set by default.\")\n      .addOption({\"proc\"}, [this]() { setMountProc(true); return true; },\n                 \"Mount procfs inside the sandbox.  For security reasons, this is NOT \"\n                 \"RECOMMENDED during normal use, but it may be useful for debugging.\")\n      .addOption({\"stdio\"}, [this]() { keepStdio = true; return true; },\n                 \"Don't redirect the sandbox's stdio.  Useful for debugging.\")\n      .addOption({\"dev\"}, [this]() { devmode = true; return true; },\n                 \"Allow some system calls useful for debugging which are blocked in production.\")\n      .addOption({\"seccomp-dump-pfc\"}, [this]() { seccompDumpPfc = true; return true; },\n                 \"Dump libseccomp PFC output.\")\n      .addOption({'n', \"new\"}, [this]() { setIsNew(true); return true; },\n                 \"Initializes a new grain.  (Otherwise, runs an existing one.)\")\n      .expectArg(\"<app-name>\", KJ_BIND_METHOD(*this, setAppName))\n      .expectArg(\"<grain-id>\", KJ_BIND_METHOD(*this, setGrainId))\n      .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n      .callAfterParsing(KJ_BIND_METHOD(*this, run))\n      .build();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<command>\"",
            "KJ_BIND_METHOD(*this, addCommandArg)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addCommandArg"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<grain-id>\"",
            "KJ_BIND_METHOD(*this, setGrainId)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setGrainId"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<app-name>\"",
            "KJ_BIND_METHOD(*this, setAppName)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setAppName"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'n', \"new\"}",
            "[this]() { setIsNew(true); return true; }",
            "\"Initializes a new grain.  (Otherwise, runs an existing one.)\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setIsNew",
          "args": [
            "true"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "setIsNew",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "600-602",
          "snippet": "void SupervisorMain::setIsNew(bool isNew) {\n  this->isNew = isNew;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setIsNew(bool isNew) {\n    this->isNew = isNew;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"seccomp-dump-pfc\"}",
            "[this]() { seccompDumpPfc = true; return true; }",
            "\"Dump libseccomp PFC output.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"dev\"}",
            "[this]() { devmode = true; return true; }",
            "\"Allow some system calls useful for debugging which are blocked in production.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"stdio\"}",
            "[this]() { keepStdio = true; return true; }",
            "\"Don't redirect the sandbox's stdio.  Useful for debugging.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"proc\"}",
            "[this]() { setMountProc(true); return true; }",
            "\"Mount procfs inside the sandbox.  For security reasons, this is NOT \"\n                 \"RECOMMENDED during normal use, but it may be useful for debugging.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setMountProc",
          "args": [
            "true"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "setMountProc",
          "container": "SupervisorMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "604-609",
          "snippet": "void SupervisorMain::setMountProc(bool mountProc) {\n  if (mountProc) {\n    context.warning(\"WARNING: --proc is dangerous.  Only use it when debugging code you trust.\");\n  }\n  this->mountProc = mountProc;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  void SupervisorMain::setMountProc(bool mountProc) {\n    if (mountProc) {\n      context.warning(\"WARNING: --proc is dangerous.  Only use it when debugging code you trust.\");\n    }\n    this->mountProc = mountProc;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'e', \"env\"}",
            "KJ_BIND_METHOD(*this, addEnv)",
            "\"<name>=<val>\"",
            "\"Set the environment variable <name> to <val> inside the sandbox.  Note \"\n                        \"that *no* environment variables are set by default.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addEnv"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"var\"}",
            "KJ_BIND_METHOD(*this, setVar)",
            "\"<path>\"",
            "\"Set directory where grain's mutable persistent data will be stored.  \"\n                        \"Defaults to '$SANDSTORM_HOME/var/sandstorm/grains/<grain-id>'.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setVar"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"pkg\"}",
            "KJ_BIND_METHOD(*this, setPkg)",
            "\"<path>\"",
            "\"Set directory containing the app package.  \"\n                        \"Defaults to '$SANDSTORM_HOME/var/sandstorm/apps/<app-name>'.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setPkg"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"uid\"}",
            "KJ_BIND_METHOD(*this, setUid)",
            "\"<uid>\"",
            "\"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUid"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Runs a Sandstorm grain supervisor for the grain <grain-id>, which is \"\n                         \"an instance of app <app-id>.  Executes <command> inside the grain \"\n                         \"sandbox.\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nSupervisorMain {\n  kj::MainFunc SupervisorMain::getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Runs a Sandstorm grain supervisor for the grain <grain-id>, which is \"\n                           \"an instance of app <app-id>.  Executes <command> inside the grain \"\n                           \"sandbox.\")\n        .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                          \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                          \"to <uid> to run the app.\")\n        .addOptionWithArg({\"pkg\"}, KJ_BIND_METHOD(*this, setPkg), \"<path>\",\n                          \"Set directory containing the app package.  \"\n                          \"Defaults to '$SANDSTORM_HOME/var/sandstorm/apps/<app-name>'.\")\n        .addOptionWithArg({\"var\"}, KJ_BIND_METHOD(*this, setVar), \"<path>\",\n                          \"Set directory where grain's mutable persistent data will be stored.  \"\n                          \"Defaults to '$SANDSTORM_HOME/var/sandstorm/grains/<grain-id>'.\")\n        .addOptionWithArg({'e', \"env\"}, KJ_BIND_METHOD(*this, addEnv), \"<name>=<val>\",\n                          \"Set the environment variable <name> to <val> inside the sandbox.  Note \"\n                          \"that *no* environment variables are set by default.\")\n        .addOption({\"proc\"}, [this]() { setMountProc(true); return true; },\n                   \"Mount procfs inside the sandbox.  For security reasons, this is NOT \"\n                   \"RECOMMENDED during normal use, but it may be useful for debugging.\")\n        .addOption({\"stdio\"}, [this]() { keepStdio = true; return true; },\n                   \"Don't redirect the sandbox's stdio.  Useful for debugging.\")\n        .addOption({\"dev\"}, [this]() { devmode = true; return true; },\n                   \"Allow some system calls useful for debugging which are blocked in production.\")\n        .addOption({\"seccomp-dump-pfc\"}, [this]() { seccompDumpPfc = true; return true; },\n                   \"Dump libseccomp PFC output.\")\n        .addOption({'n', \"new\"}, [this]() { setIsNew(true); return true; },\n                   \"Initializes a new grain.  (Otherwise, runs an existing one.)\")\n        .expectArg(\"<app-name>\", KJ_BIND_METHOD(*this, setAppName))\n        .expectArg(\"<grain-id>\", KJ_BIND_METHOD(*this, setGrainId))\n        .expectOneOrMoreArgs(\"<command>\", KJ_BIND_METHOD(*this, addCommandArg))\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }\n}"
  },
  {
    "function_name": "SupervisorMain",
    "container": "SupervisorMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "553-560",
    "snippet": "SupervisorMain::SupervisorMain(kj::ProcessContext& context)\n    : context(context), systemConnector(&DEFAULT_CONNECTOR_INSTANCE) {\n  // Make sure we didn't inherit a weird signal mask from the parent process.  Gotta do this as\n  // early as possible so as not to confuse KJ code that deals with signals.\n  sigset_t sigset;\n  KJ_SYSCALL(sigemptyset(&sigset));\n  KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigset, nullptr));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "constexpr SupervisorMain::DefaultSystemConnector SupervisorMain::DEFAULT_CONNECTOR_INSTANCE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &sigset, nullptr)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigset",
            "nullptr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&sigset)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sigset"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nconstexpr SupervisorMain::DefaultSystemConnector SupervisorMain::DEFAULT_CONNECTOR_INSTANCE;\n\nSupervisorMain {\n  SupervisorMain::SupervisorMain(kj::ProcessContext& context)\n      : context(context), systemConnector(&DEFAULT_CONNECTOR_INSTANCE) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.  Gotta do this as\n    // early as possible so as not to confuse KJ code that deals with signals.\n    sigset_t sigset;\n    KJ_SYSCALL(sigemptyset(&sigset));\n    KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigset, nullptr));\n  }\n}"
  },
  {
    "function_name": "registerSignalHandlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "522-549",
    "snippet": "void registerSignalHandlers() {\n  // Create a sigaction that runs our signal handler with all signals blocked.  Our signal handler\n  // completes (or exits) quickly anyway, so let's not try to deal with it being interruptable.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_handler = &signalHandler;\n  sigfillset(&action.sa_mask);\n\n  // SIGALRM will fire every 1.5 minutes and will kill us if no keepalive was received in that\n  // time.\n  KJ_SYSCALL(sigaction(SIGALRM, &action, nullptr));\n\n  // Other death signals simply kill us immediately.\n  for (int signo: kj::ArrayPtr<int>(DEATH_SIGNALS)) {\n    KJ_SYSCALL(sigaction(signo, &action, nullptr));\n  }\n\n  // Set up the SIGALRM timer to check every 1.5 minutes whether we're idle. If we haven't received\n  // a keep-alive request in a 1.5-minute period, we kill ourselves. The client normally sends\n  // keep-alives every minute. Note that it's not the end of the world if we miss one; the server\n  // will transparently start back up on the next request from the client.\n  // Note that this is not inherited over fork.\n  struct itimerval timer;\n  memset(&timer, 0, sizeof(timer));\n  timer.it_interval.tv_sec = 90;\n  timer.it_value.tv_sec = 90;\n  KJ_SYSCALL(setitimer(ITIMER_REAL, &timer, nullptr));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setitimer(ITIMER_REAL, &timer, nullptr)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setitimer",
          "args": [
            "ITIMER_REAL",
            "&timer",
            "nullptr"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&timer",
            "0",
            "sizeof(timer)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(signo, &action, nullptr)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "signo",
            "&action",
            "nullptr"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::ArrayPtr<int>",
          "args": [
            "DEATH_SIGNALS"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGALRM, &action, nullptr)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGALRM",
            "&action",
            "nullptr"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&action.sa_mask"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&action",
            "0",
            "sizeof(action)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid registerSignalHandlers() {\n  // Create a sigaction that runs our signal handler with all signals blocked.  Our signal handler\n  // completes (or exits) quickly anyway, so let's not try to deal with it being interruptable.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_handler = &signalHandler;\n  sigfillset(&action.sa_mask);\n\n  // SIGALRM will fire every 1.5 minutes and will kill us if no keepalive was received in that\n  // time.\n  KJ_SYSCALL(sigaction(SIGALRM, &action, nullptr));\n\n  // Other death signals simply kill us immediately.\n  for (int signo: kj::ArrayPtr<int>(DEATH_SIGNALS)) {\n    KJ_SYSCALL(sigaction(signo, &action, nullptr));\n  }\n\n  // Set up the SIGALRM timer to check every 1.5 minutes whether we're idle. If we haven't received\n  // a keep-alive request in a 1.5-minute period, we kill ourselves. The client normally sends\n  // keep-alives every minute. Note that it's not the end of the world if we miss one; the server\n  // will transparently start back up on the next request from the client.\n  // Note that this is not inherited over fork.\n  struct itimerval timer;\n  memset(&timer, 0, sizeof(timer));\n  timer.it_interval.tv_sec = 90;\n  timer.it_value.tv_sec = 90;\n  KJ_SYSCALL(setitimer(ITIMER_REAL, &timer, nullptr));\n}"
  },
  {
    "function_name": "signalHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "482-514",
    "snippet": "void signalHandler(int signo) {\n  switch (signo) {\n    case SIGALRM:\n      if (keepAlive) {\n        SANDSTORM_LOG(\"Grain still in use; staying up for now.\");\n        keepAlive = false;\n        return;\n      } else if (wakelockCount > 0) {\n        SANDSTORM_LOG(\"Grain has been backgrounded; staying up for now.\");\n        return;\n      }\n      SANDSTORM_LOG(\"Grain no longer in use; shutting down.\");\n      killChildAndExit(0);\n\n    case SIGINT:\n    case SIGTERM:\n      SANDSTORM_LOG(\"Grain supervisor terminated by signal.\");\n      killChildAndExit(0);\n\n    default:\n      // Some signal that should cause death.\n      SANDSTORM_LOG(\"Grain supervisor crashed due to signal.\");\n\n//      // uncomment if trace is needed, but note that this is not really signal-safe.\n//      {\n//        void* trace[16];\n//        uint n = backtrace(trace, 16);\n//        KJ_LOG(ERROR, kj::strArray(kj::arrayPtr(trace, n), \" \"));\n//      }\n\n      killChildAndExit(1);\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "class SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "killChildAndExit",
          "args": [
            "1"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "killChildAndExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "474-480",
          "snippet": "[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain supervisor crashed due to signal.\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain supervisor terminated by signal.\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain no longer in use; shutting down.\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain has been backgrounded; staying up for now.\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SANDSTORM_LOG",
          "args": [
            "\"Grain still in use; staying up for now.\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nclass SupervisorMain::SupervisorImpl final: public Supervisor::Server {\npublic:\n  inline SupervisorImpl(kj::UnixEventPort& eventPort, MainView<>::Client&& mainView,\n                        WakelockSet& wakelockSet, kj::AutoCloseFd startAppEvent,\n                        SandstormCore::Client sandstormCore, kj::Own<CapRedirector> coreRedirector)\n      : eventPort(eventPort), mainView(kj::mv(mainView)),\n        wakelockSet(wakelockSet), sandstormCore(sandstormCore),\n        coreRedirector(kj::mv(coreRedirector)), startAppEvent(kj::mv(startAppEvent)) {}\n\n  kj::Promise<void> getMainView(GetMainViewContext context) override {\n    ensureStarted();\n    context.getResults(capnp::MessageSize {4, 1}).setView(mainView);\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> keepAlive(KeepAliveContext context) override {\n    sandstorm::keepAlive = true;\n\n    auto params = context.getParams();\n    if (params.hasCore()) {\n      coreRedirector->setTarget(params.getCore());\n    }\n\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> syncStorage(SyncStorageContext context) override {\n    auto fd = raiiOpen(\".\", O_RDONLY | O_DIRECTORY);\n    KJ_SYSCALL(syncfs(fd));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> shutdown(ShutdownContext context) override {\n    SANDSTORM_LOG(\"Grain shutdown requested.\");\n    killChildAndExit(0);\n  }\n\n  kj::Promise<void> watchLog(WatchLogContext context) override {\n    auto params = context.getParams();\n    auto logFile = sandstorm::raiiOpen(\"log\", O_RDONLY | O_CLOEXEC);\n\n    // Seek to desired start point.\n    struct stat stats;\n    KJ_SYSCALL(fstat(logFile, &stats));\n    uint64_t requestedBacklog = params.getBacklogAmount();\n    uint64_t backlog = kj::min(requestedBacklog, stats.st_size);\n    KJ_SYSCALL(lseek(logFile, stats.st_size - backlog, SEEK_SET));\n\n    // If the existing log file doesn't cover the whole request, check the previous log file.\n    kj::Maybe<kj::Promise<void>> firstWrite;\n    if (stats.st_size < requestedBacklog) {\n      KJ_IF_MAYBE(log1, raiiOpenIfExists(\"log.1\", O_RDONLY)) {\n        struct stat stats1;\n        KJ_SYSCALL(fstat(*log1, &stats1));\n        uint64_t requestedBacklog1 = requestedBacklog - stats.st_size;\n        uint64_t backlog1 = kj::min(requestedBacklog1, stats1.st_size);\n        KJ_SYSCALL(lseek(*log1, stats1.st_size - backlog1, SEEK_SET));\n\n        kj::FdInputStream in(log1->get());\n        auto req = params.getStream().writeRequest();\n        auto data = req.initData(backlog1);\n        in.read(data.begin(), backlog1);\n        firstWrite = req.send().ignoreResult();\n      }\n    }\n\n    // Create the watcher.\n    auto watcher = kj::heap<LogWatcher>(eventPort, \"log\", kj::mv(logFile), params.getStream());\n\n    KJ_IF_MAYBE(f, firstWrite) {\n      watcher->addTask(kj::mv(*f));\n    }\n\n    context.releaseParams();\n    context.getResults(capnp::MessageSize { 4, 1 }).setHandle(kj::mv(watcher));\n    return kj::READY_NOW;\n  }\n\n  kj::Promise<void> restore(RestoreContext context) override {\n    // # Wraps `MainView.restore()`. Can also restore capabilities hosted by the supervisor.\n    ensureStarted();\n    auto params = context.getParams();\n    auto objectId = params.getRef();\n\n    switch (objectId.which()) {\n      case SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION: {\n        context.getResults().setCap(wakelockSet.restore(objectId.getWakeLockNotification()));\n        return kj::READY_NOW;\n      }\n      case SupervisorObjectId<>::APP_REF: {\n        auto req = mainView.restoreRequest();\n        req.setObjectId(objectId.getAppRef());\n        return req.send().then([this, params, context](auto args) mutable -> void {\n          context.getResults().setCap(kj::heap<SaveWrapper>(\n            args.getCap().template castAs<AppPersistent<>>(), params.getRequirements(), params.getParentToken(), sandstormCore));\n        });\n      }\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown objectId type\");\n    }\n  }\n\n  kj::Promise<void> drop(DropContext context) override {\n    ensureStarted();\n    auto objectId = context.getParams().getRef();\n\n    if (objectId.which() == SupervisorObjectId<>::WAKE_LOCK_NOTIFICATION) {\n      wakelockSet.drop(objectId.getWakeLockNotification());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_REQUIRE(\"Supervisor can only drop wakelocks for now.\");\n    }\n  }\n\n  kj::Promise<void> getWwwFileHack(GetWwwFileHackContext context) override {\n    context.allowCancellation();\n\n    auto params = context.getParams();\n    auto path = params.getPath();\n\n    {\n      // Prohibit non-canonical requests.\n      auto parts = split(path, '/');\n      if (parts.back().size() == 0) parts.removeLast();  // allow trailing '/'\n      for (auto part: parts) {\n        if (part.size() == 0 ||\n            (part.size() == 1 && part[0] == '.') ||\n            (part.size() == 2 && part[0] == '.' && part[1] == '.')) {\n          context.getResults(capnp::MessageSize {4, 0})\n              .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n          return kj::READY_NOW;\n        }\n      }\n    }\n\n    auto fullPath = kj::str(\"sandbox/www/\", path);\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(fullPath, O_RDONLY)) {\n      struct stat stats;\n      KJ_SYSCALL(fstat(*fd, &stats));\n\n      if (S_ISREG(stats.st_mode)) {\n        auto stream = params.getStream();\n        context.releaseParams();\n        auto req = stream.expectSizeRequest();\n        req.setSize(stats.st_size);\n        auto expectSizeTask = req.send();\n        auto inStream = kj::heap<kj::FdInputStream>(kj::mv(*fd));\n        return pump(*inStream, kj::mv(stream)).attach(kj::mv(inStream), kj::mv(expectSizeTask));\n      } else if (S_ISDIR(stats.st_mode)) {\n        context.getResults(capnp::MessageSize {4, 0})\n            .setStatus(Supervisor::WwwFileStatus::DIRECTORY);\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"not a regular file\");\n      }\n    } else {\n      context.getResults(capnp::MessageSize {4, 0})\n          .setStatus(Supervisor::WwwFileStatus::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  kj::UnixEventPort& eventPort;\n\nvoid signalHandler(int signo) {\n  switch (signo) {\n    case SIGALRM:\n      if (keepAlive) {\n        SANDSTORM_LOG(\"Grain still in use; staying up for now.\");\n        keepAlive = false;\n        return;\n      } else if (wakelockCount > 0) {\n        SANDSTORM_LOG(\"Grain has been backgrounded; staying up for now.\");\n        return;\n      }\n      SANDSTORM_LOG(\"Grain no longer in use; shutting down.\");\n      killChildAndExit(0);\n\n    case SIGINT:\n    case SIGTERM:\n      SANDSTORM_LOG(\"Grain supervisor terminated by signal.\");\n      killChildAndExit(0);\n\n    default:\n      // Some signal that should cause death.\n      SANDSTORM_LOG(\"Grain supervisor crashed due to signal.\");\n\n//      // uncomment if trace is needed, but note that this is not really signal-safe.\n//      {\n//        void* trace[16];\n//        uint n = backtrace(trace, 16);\n//        KJ_LOG(ERROR, kj::strArray(kj::arrayPtr(trace, n), \" \"));\n//      }\n\n      killChildAndExit(1);\n  }\n}"
  },
  {
    "function_name": "killChildAndExit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "474-480",
    "snippet": "[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "status"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "killChild",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "killChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "464-472",
          "snippet": "void killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\n[[noreturn]] void killChildAndExit(int status) {\n  killChild();\n\n  // TODO(cleanup):  Decide what exit status is supposed to mean.  Maybe it should just always be\n  //   zero?\n  _exit(status);\n}"
  },
  {
    "function_name": "killChild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "464-472",
    "snippet": "void killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "childPid",
            "SIGKILL"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "killChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "2377-2413",
          "snippet": "void killChild(kj::StringPtr title, pid_t pid) {\n    if (pid == 0) {\n      // We use PID = 0 to indicate that a process isn't running, so there's nothing to do.\n      context.warning(kj::str(\"Not killing \", title, \" because it is not running.\"));\n      return;\n    }\n\n    int status;\n\n    KJ_SYSCALL(kill(pid, SIGTERM));\n\n    alarmed = false;\n    uint timeout = 5;\n    KJ_SYSCALL(alarm(timeout));\n\n    for (;;) {\n      if (waitpid(pid, &status, 0) >= 0) {\n        KJ_SYSCALL(alarm(0));\n        return;\n      }\n\n      int error = errno;\n      if (error == EINTR) {\n        if (alarmed) {\n          // Termination timed out.  Kill hard.\n          context.warning(kj::str(\n              title, \" did not terminate after \", timeout, \" seconds; killing.\"));\n          KJ_SYSCALL(kill(pid, SIGKILL));\n          alarmed = false;\n        } else {\n          // Some other signal; ignore.\n        }\n      } else {\n        KJ_FAIL_SYSCALL(\"waitpid()\", error, title);\n      }\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid killChild() {\n  if (childPid != 0) {\n    kill(childPid, SIGKILL);\n    childPid = 0;\n  }\n\n  // We don't have to waitpid() because when we exit the child will be adopted by init which will\n  // automatically reap it.\n}"
  },
  {
    "function_name": "logSafely",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "451-459",
    "snippet": "void logSafely(const char* text) {\n  // Log a message in an async-signal-safe way.\n\n  while (text[0] != '\\0') {\n    ssize_t n = write(STDERR_FILENO, text, strlen(text));\n    if (n < 0) return;\n    text += n;\n  }\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDERR_FILENO",
            "text",
            "strlen(text)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "text"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nvoid logSafely(const char* text) {\n  // Log a message in an async-signal-safe way.\n\n  while (text[0] != '\\0') {\n    ssize_t n = write(STDERR_FILENO, text, strlen(text));\n    if (n < 0) return;\n    text += n;\n  }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "437-439",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, exception);\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, exception);\n    }\n}"
  },
  {
    "function_name": "maybeReportSize",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "398-435",
    "snippet": "void maybeReportSize() {\n    // Don't send multiple reports at once. When the first one finishes we'll send another one if\n    // the size has changed in the meantime.\n    if (reportInFlight) return;\n\n    // If the last reported size is still correct, don't report.\n    if (reportedSize == totalSize) return;\n\n    reportInFlight = true;\n\n    // Wait 500ms before reporting to gather other changes.\n    tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n        .then([this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    }));\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "timer.afterDelay(500 * kj::MILLISECONDS)\n        .then([this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    })"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "[this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    }"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }",
            "[this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      }"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::throwFatalException",
          "args": [
            "kj::mv(e)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybeReportSize",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "maybeReportSize",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "398-435",
          "snippet": "void maybeReportSize() {\n    // Don't send multiple reports at once. When the first one finishes we'll send another one if\n    // the size has changed in the meantime.\n    if (reportInFlight) return;\n\n    // If the last reported size is still correct, don't report.\n    if (reportedSize == totalSize) return;\n\n    reportInFlight = true;\n\n    // Wait 500ms before reporting to gather other changes.\n    tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n        .then([this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    }));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setBytes",
          "args": [
            "sizeBeingReported"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core.reportGrainSizeRequest",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "500 * kj::MILLISECONDS"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void maybeReportSize() {\n      // Don't send multiple reports at once. When the first one finishes we'll send another one if\n      // the size has changed in the meantime.\n      if (reportInFlight) return;\n  \n      // If the last reported size is still correct, don't report.\n      if (reportedSize == totalSize) return;\n  \n      reportInFlight = true;\n  \n      // Wait 500ms before reporting to gather other changes.\n      tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n          .then([this]() -> kj::Promise<void> {\n        auto req = core.reportGrainSizeRequest();\n        uint64_t sizeBeingReported = totalSize;\n        req.setBytes(sizeBeingReported);\n  \n        return req.send().then([this,sizeBeingReported](auto) -> void {\n          reportInFlight = false;\n          reportedSize = sizeBeingReported;\n  \n          // If the size has changed further, initiate a new report.\n          maybeReportSize();\n        }, [this](kj::Exception&& e) {\n          reportInFlight = false;\n  \n          if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n            // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n            // eventually, and in fact further calls to SandstormCore should block until than\n            // happens. So, initiate a new report immediately.\n            maybeReportSize();\n          } else {\n            // Some other error. Propagate.\n            kj::throwFatalException(kj::mv(e));\n          }\n        });\n      }));\n    }\n}"
  },
  {
    "function_name": "getDiskUsage",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "353-396",
    "snippet": "DiskUsage getDiskUsage(kj::StringPtr parent, kj::StringPtr name) {\n    // Get the disk usage of the given file within the given parent directory. This is not exactly\n    // the file size; it also includes estimates of storage overhead, such as rounding up to the\n    // block size. If the file no longer exists, its size is reported as zero.\n\n    kj::String path = parent == nullptr ? kj::heapString(name) : kj::str(parent, '/', name);\n    for (;;) {\n      struct stat stats;\n      if (lstat(path.cStr(), &stats) >= 0) {\n        // Success.\n\n        DiskUsage result;\n        result.path = kj::mv(path);\n        result.isDir = S_ISDIR(stats.st_mode);\n\n        // Count blocks, not length, because what we care about is allocated space.\n        result.bytes = stats.st_blocks * 512;\n\n        if (stats.st_nlink != 0) {\n          // Note: sometimes the link count actually is zero; it often is, for example, during\n          // `git init`, which rapidly creates and deletes some temporary files.\n\n          // Divide by link count so that files with many hardlinks aren't overcounted.\n          result.bytes /= stats.st_nlink;\n        }\n\n        return result;\n      }\n\n      // There was an error.\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          // continue loop\n          break;\n        case ENOENT:   // File no longer exists...\n        case ENOTDIR:  // ... and a parent directory was replaced.\n          return {kj::mv(path), 0, false};\n        default:\n          // Default\n          KJ_FAIL_SYSCALL(\"lstat\", error, path);\n      }\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto result = kj::heapString(cResult);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"lstat\"",
            "error",
            "path"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "parent",
            "'/'",
            "name"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nDiskUsageWatcher {\n  DiskUsage getDiskUsage(kj::StringPtr parent, kj::StringPtr name) {\n      // Get the disk usage of the given file within the given parent directory. This is not exactly\n      // the file size; it also includes estimates of storage overhead, such as rounding up to the\n      // block size. If the file no longer exists, its size is reported as zero.\n  \n      kj::String path = parent == nullptr ? kj::heapString(name) : kj::str(parent, '/', name);\n      for (;;) {\n        struct stat stats;\n        if (lstat(path.cStr(), &stats) >= 0) {\n          // Success.\n  \n          DiskUsage result;\n          result.path = kj::mv(path);\n          result.isDir = S_ISDIR(stats.st_mode);\n  \n          // Count blocks, not length, because what we care about is allocated space.\n          result.bytes = stats.st_blocks * 512;\n  \n          if (stats.st_nlink != 0) {\n            // Note: sometimes the link count actually is zero; it often is, for example, during\n            // `git init`, which rapidly creates and deletes some temporary files.\n  \n            // Divide by link count so that files with many hardlinks aren't overcounted.\n            result.bytes /= stats.st_nlink;\n          }\n  \n          return result;\n        }\n  \n        // There was an error.\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            // continue loop\n            break;\n          case ENOENT:   // File no longer exists...\n          case ENOTDIR:  // ... and a parent directory was replaced.\n            return {kj::mv(path), 0, false};\n          default:\n            // Default\n            KJ_FAIL_SYSCALL(\"lstat\", error, path);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "childEvent",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "293-345",
    "snippet": "void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n    // Called to update the child table when we receive an inotify event with the given name.\n\n    // OK, we received notification that something happened to the child named `name`.\n    // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n    // number of other events may have occurred since this one was generated. For example,\n    // the event may have been on a file that has subsequently been deleted, and maybe even\n    // recreated as a different kind of node. If we lstat() it, we get information about\n    // what is currently on disk, not whatever generated this event.\n    //\n    // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n    // that something happened at this child. We have to compare what we know about the child\n    // vs. what we knew in the past to determine what has changed. Note that if inotify\n    // provided a `struct stat` along with the event then we wouldn't have this problem!\n\n    auto usage = getDiskUsage(watchInfo.path, name);\n    totalSize += usage.bytes;\n\n    auto iter = watchInfo.childSizes.find(name);\n    if (usage.bytes == 0) {\n      // There is no longer a child by this name on disk. Remove whatever is in the map.\n      if (iter != watchInfo.childSizes.end()) {\n        totalSize -= iter->second.size;\n        watchInfo.childSizes.erase(iter);\n      }\n    } else if (iter == watchInfo.childSizes.end()) {\n      // There is a child by this name on disk, but not in the map. Add it.\n      ChildInfo newChild = { kj::heapString(name), usage.bytes };\n      kj::StringPtr namePtr = newChild.name;\n      KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n    } else {\n      // There is a child by this name on disk and in the map. Check for a change in size.\n      totalSize -= iter->second.size;\n      iter->second.size = usage.bytes;\n    }\n\n    maybeReportSize();\n\n    // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n    // are not generated for subdirectories (only files), so if we got an event on a directory it\n    // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n    // exist anymore, so usage.isDir would be false. So, we know this directory is either\n    // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n    // start watching the directory. In the moved-in case, we are probably already watching the\n    // directory, however it is necessary to redo the watch because the path has changed and the\n    // directory state may have become inconsistent in the time that the path was wrong.\n    if (usage.isDir) {\n      // We can't actually add the new watch now because we need to process the remaining\n      // events from the last read() in order to make sure we're caught up with inotify's\n      // state.\n      pendingWatches.add(kj::mv(usage.path));\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pendingWatches.add",
          "args": [
            "kj::mv(usage.path)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "usage.path"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybeReportSize",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "maybeReportSize",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "398-435",
          "snippet": "void maybeReportSize() {\n    // Don't send multiple reports at once. When the first one finishes we'll send another one if\n    // the size has changed in the meantime.\n    if (reportInFlight) return;\n\n    // If the last reported size is still correct, don't report.\n    if (reportedSize == totalSize) return;\n\n    reportInFlight = true;\n\n    // Wait 500ms before reporting to gather other changes.\n    tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n        .then([this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    }));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void maybeReportSize() {\n      // Don't send multiple reports at once. When the first one finishes we'll send another one if\n      // the size has changed in the meantime.\n      if (reportInFlight) return;\n  \n      // If the last reported size is still correct, don't report.\n      if (reportedSize == totalSize) return;\n  \n      reportInFlight = true;\n  \n      // Wait 500ms before reporting to gather other changes.\n      tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n          .then([this]() -> kj::Promise<void> {\n        auto req = core.reportGrainSizeRequest();\n        uint64_t sizeBeingReported = totalSize;\n        req.setBytes(sizeBeingReported);\n  \n        return req.send().then([this,sizeBeingReported](auto) -> void {\n          reportInFlight = false;\n          reportedSize = sizeBeingReported;\n  \n          // If the size has changed further, initiate a new report.\n          maybeReportSize();\n        }, [this](kj::Exception&& e) {\n          reportInFlight = false;\n  \n          if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n            // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n            // eventually, and in fact further calls to SandstormCore should block until than\n            // happens. So, initiate a new report immediately.\n            maybeReportSize();\n          } else {\n            // Some other error. Propagate.\n            kj::throwFatalException(kj::mv(e));\n          }\n        });\n      }));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.insert",
          "args": [
            "std::make_pair(namePtr, kj::mv(newChild))"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "namePtr",
            "kj::mv(newChild)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newChild"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.end",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.erase",
          "args": [
            "iter"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.end",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.find",
          "args": [
            "name"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDiskUsage",
          "args": [
            "watchInfo.path",
            "name"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "getDiskUsage",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "353-396",
          "snippet": "DiskUsage getDiskUsage(kj::StringPtr parent, kj::StringPtr name) {\n    // Get the disk usage of the given file within the given parent directory. This is not exactly\n    // the file size; it also includes estimates of storage overhead, such as rounding up to the\n    // block size. If the file no longer exists, its size is reported as zero.\n\n    kj::String path = parent == nullptr ? kj::heapString(name) : kj::str(parent, '/', name);\n    for (;;) {\n      struct stat stats;\n      if (lstat(path.cStr(), &stats) >= 0) {\n        // Success.\n\n        DiskUsage result;\n        result.path = kj::mv(path);\n        result.isDir = S_ISDIR(stats.st_mode);\n\n        // Count blocks, not length, because what we care about is allocated space.\n        result.bytes = stats.st_blocks * 512;\n\n        if (stats.st_nlink != 0) {\n          // Note: sometimes the link count actually is zero; it often is, for example, during\n          // `git init`, which rapidly creates and deletes some temporary files.\n\n          // Divide by link count so that files with many hardlinks aren't overcounted.\n          result.bytes /= stats.st_nlink;\n        }\n\n        return result;\n      }\n\n      // There was an error.\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          // continue loop\n          break;\n        case ENOENT:   // File no longer exists...\n        case ENOTDIR:  // ... and a parent directory was replaced.\n          return {kj::mv(path), 0, false};\n        default:\n          // Default\n          KJ_FAIL_SYSCALL(\"lstat\", error, path);\n      }\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto result = kj::heapString(cResult);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nauto result = kj::heapString(cResult);\n\nDiskUsageWatcher {\n  DiskUsage getDiskUsage(kj::StringPtr parent, kj::StringPtr name) {\n      // Get the disk usage of the given file within the given parent directory. This is not exactly\n      // the file size; it also includes estimates of storage overhead, such as rounding up to the\n      // block size. If the file no longer exists, its size is reported as zero.\n  \n      kj::String path = parent == nullptr ? kj::heapString(name) : kj::str(parent, '/', name);\n      for (;;) {\n        struct stat stats;\n        if (lstat(path.cStr(), &stats) >= 0) {\n          // Success.\n  \n          DiskUsage result;\n          result.path = kj::mv(path);\n          result.isDir = S_ISDIR(stats.st_mode);\n  \n          // Count blocks, not length, because what we care about is allocated space.\n          result.bytes = stats.st_blocks * 512;\n  \n          if (stats.st_nlink != 0) {\n            // Note: sometimes the link count actually is zero; it often is, for example, during\n            // `git init`, which rapidly creates and deletes some temporary files.\n  \n            // Divide by link count so that files with many hardlinks aren't overcounted.\n            result.bytes /= stats.st_nlink;\n          }\n  \n          return result;\n        }\n  \n        // There was an error.\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            // continue loop\n            break;\n          case ENOENT:   // File no longer exists...\n          case ENOTDIR:  // ... and a parent directory was replaced.\n            return {kj::mv(path), 0, false};\n          default:\n            // Default\n            KJ_FAIL_SYSCALL(\"lstat\", error, path);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n      // Called to update the child table when we receive an inotify event with the given name.\n  \n      // OK, we received notification that something happened to the child named `name`.\n      // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n      // number of other events may have occurred since this one was generated. For example,\n      // the event may have been on a file that has subsequently been deleted, and maybe even\n      // recreated as a different kind of node. If we lstat() it, we get information about\n      // what is currently on disk, not whatever generated this event.\n      //\n      // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n      // that something happened at this child. We have to compare what we know about the child\n      // vs. what we knew in the past to determine what has changed. Note that if inotify\n      // provided a `struct stat` along with the event then we wouldn't have this problem!\n  \n      auto usage = getDiskUsage(watchInfo.path, name);\n      totalSize += usage.bytes;\n  \n      auto iter = watchInfo.childSizes.find(name);\n      if (usage.bytes == 0) {\n        // There is no longer a child by this name on disk. Remove whatever is in the map.\n        if (iter != watchInfo.childSizes.end()) {\n          totalSize -= iter->second.size;\n          watchInfo.childSizes.erase(iter);\n        }\n      } else if (iter == watchInfo.childSizes.end()) {\n        // There is a child by this name on disk, but not in the map. Add it.\n        ChildInfo newChild = { kj::heapString(name), usage.bytes };\n        kj::StringPtr namePtr = newChild.name;\n        KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n      } else {\n        // There is a child by this name on disk and in the map. Check for a change in size.\n        totalSize -= iter->second.size;\n        iter->second.size = usage.bytes;\n      }\n  \n      maybeReportSize();\n  \n      // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n      // are not generated for subdirectories (only files), so if we got an event on a directory it\n      // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n      // exist anymore, so usage.isDir would be false. So, we know this directory is either\n      // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n      // start watching the directory. In the moved-in case, we are probably already watching the\n      // directory, however it is necessary to redo the watch because the path has changed and the\n      // directory state may have become inconsistent in the time that the path was wrong.\n      if (usage.isDir) {\n        // We can't actually add the new watch now because we need to process the remaining\n        // events from the last read() in order to make sure we're caught up with inotify's\n        // state.\n        pendingWatches.add(kj::mv(usage.path));\n      }\n    }\n}"
  },
  {
    "function_name": "readLoop",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "237-291",
    "snippet": "kj::Promise<void> readLoop() {\n    addPendingWatches();\n    maybeReportSize();\n    return observer->whenBecomesReadable().then([this]() {\n      alignas(uint64_t) kj::byte buffer[4096];\n\n      for (;;) {\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n\n        if (n < 0) {\n          // EAGAIN; try again later.\n          return readLoop();\n        }\n\n        KJ_ASSERT(n > 0, \"inotify EOF?\");\n\n        kj::byte* pos = buffer;\n        while (n > 0) {\n          // Split off one event.\n          auto event = reinterpret_cast<struct inotify_event*>(pos);\n          size_t eventSize = sizeof(struct inotify_event) + event->len;\n          KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n          KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n          n -= eventSize;\n          pos += eventSize;\n\n          if (event->mask & IN_Q_OVERFLOW) {\n            // Queue overflow; start over from scratch.\n            inotifyFd = nullptr;\n            KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n            return init();\n          }\n\n          auto iter = watchMap.find(event->wd);\n          KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n\n          if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n            childEvent(iter->second, event->name);\n          }\n\n          if (event->mask & IN_IGNORED) {\n            // This watch descriptor is being removed, probably because it was deleted.\n\n            // There shouldn't be any children left, but if there are, go ahead and un-count them.\n            for (auto& child: iter->second.childSizes) {\n              totalSize -= child.second.size;\n            }\n\n            watchMap.erase(iter);\n          }\n        }\n      }\n    });\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "observer->whenBecomesReadable",
          "args": [
            "[this]() {\n      alignas(uint64_t) kj::byte buffer[4096];\n\n      for (;;) {\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n\n        if (n < 0) {\n          // EAGAIN; try again later.\n          return readLoop();\n        }\n\n        KJ_ASSERT(n > 0, \"inotify EOF?\");\n\n        kj::byte* pos = buffer;\n        while (n > 0) {\n          // Split off one event.\n          auto event = reinterpret_cast<struct inotify_event*>(pos);\n          size_t eventSize = sizeof(struct inotify_event) + event->len;\n          KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n          KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n          n -= eventSize;\n          pos += eventSize;\n\n          if (event->mask & IN_Q_OVERFLOW) {\n            // Queue overflow; start over from scratch.\n            inotifyFd = nullptr;\n            KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n            return init();\n          }\n\n          auto iter = watchMap.find(event->wd);\n          KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n\n          if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n            childEvent(iter->second, event->name);\n          }\n\n          if (event->mask & IN_IGNORED) {\n            // This watch descriptor is being removed, probably because it was deleted.\n\n            // There shouldn't be any children left, but if there are, go ahead and un-count them.\n            for (auto& child: iter->second.childSizes) {\n              totalSize -= child.second.size;\n            }\n\n            watchMap.erase(iter);\n          }\n        }\n      }\n    }"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchMap.erase",
          "args": [
            "iter"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "childEvent",
          "args": [
            "iter->second",
            "event->name"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "childEvent",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "293-345",
          "snippet": "void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n    // Called to update the child table when we receive an inotify event with the given name.\n\n    // OK, we received notification that something happened to the child named `name`.\n    // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n    // number of other events may have occurred since this one was generated. For example,\n    // the event may have been on a file that has subsequently been deleted, and maybe even\n    // recreated as a different kind of node. If we lstat() it, we get information about\n    // what is currently on disk, not whatever generated this event.\n    //\n    // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n    // that something happened at this child. We have to compare what we know about the child\n    // vs. what we knew in the past to determine what has changed. Note that if inotify\n    // provided a `struct stat` along with the event then we wouldn't have this problem!\n\n    auto usage = getDiskUsage(watchInfo.path, name);\n    totalSize += usage.bytes;\n\n    auto iter = watchInfo.childSizes.find(name);\n    if (usage.bytes == 0) {\n      // There is no longer a child by this name on disk. Remove whatever is in the map.\n      if (iter != watchInfo.childSizes.end()) {\n        totalSize -= iter->second.size;\n        watchInfo.childSizes.erase(iter);\n      }\n    } else if (iter == watchInfo.childSizes.end()) {\n      // There is a child by this name on disk, but not in the map. Add it.\n      ChildInfo newChild = { kj::heapString(name), usage.bytes };\n      kj::StringPtr namePtr = newChild.name;\n      KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n    } else {\n      // There is a child by this name on disk and in the map. Check for a change in size.\n      totalSize -= iter->second.size;\n      iter->second.size = usage.bytes;\n    }\n\n    maybeReportSize();\n\n    // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n    // are not generated for subdirectories (only files), so if we got an event on a directory it\n    // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n    // exist anymore, so usage.isDir would be false. So, we know this directory is either\n    // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n    // start watching the directory. In the moved-in case, we are probably already watching the\n    // directory, however it is necessary to redo the watch because the path has changed and the\n    // directory state may have become inconsistent in the time that the path was wrong.\n    if (usage.isDir) {\n      // We can't actually add the new watch now because we need to process the remaining\n      // events from the last read() in order to make sure we're caught up with inotify's\n      // state.\n      pendingWatches.add(kj::mv(usage.path));\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n      // Called to update the child table when we receive an inotify event with the given name.\n  \n      // OK, we received notification that something happened to the child named `name`.\n      // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n      // number of other events may have occurred since this one was generated. For example,\n      // the event may have been on a file that has subsequently been deleted, and maybe even\n      // recreated as a different kind of node. If we lstat() it, we get information about\n      // what is currently on disk, not whatever generated this event.\n      //\n      // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n      // that something happened at this child. We have to compare what we know about the child\n      // vs. what we knew in the past to determine what has changed. Note that if inotify\n      // provided a `struct stat` along with the event then we wouldn't have this problem!\n  \n      auto usage = getDiskUsage(watchInfo.path, name);\n      totalSize += usage.bytes;\n  \n      auto iter = watchInfo.childSizes.find(name);\n      if (usage.bytes == 0) {\n        // There is no longer a child by this name on disk. Remove whatever is in the map.\n        if (iter != watchInfo.childSizes.end()) {\n          totalSize -= iter->second.size;\n          watchInfo.childSizes.erase(iter);\n        }\n      } else if (iter == watchInfo.childSizes.end()) {\n        // There is a child by this name on disk, but not in the map. Add it.\n        ChildInfo newChild = { kj::heapString(name), usage.bytes };\n        kj::StringPtr namePtr = newChild.name;\n        KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n      } else {\n        // There is a child by this name on disk and in the map. Check for a change in size.\n        totalSize -= iter->second.size;\n        iter->second.size = usage.bytes;\n      }\n  \n      maybeReportSize();\n  \n      // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n      // are not generated for subdirectories (only files), so if we got an event on a directory it\n      // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n      // exist anymore, so usage.isDir would be false. So, we know this directory is either\n      // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n      // start watching the directory. In the moved-in case, we are probably already watching the\n      // directory, however it is necessary to redo the watch because the path has changed and the\n      // directory state may have become inconsistent in the time that the path was wrong.\n      if (usage.isDir) {\n        // We can't actually add the new watch now because we need to process the remaining\n        // events from the last read() in order to make sure we're caught up with inotify's\n        // state.\n        pendingWatches.add(kj::mv(usage.path));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != watchMap.end()",
            "\"inotify gave unknown watch descriptor?\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchMap.end",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchMap.find",
          "args": [
            "event->wd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "98-118",
          "snippet": "kj::Promise<void> init() {\n    // Start watching the current directory.\n\n    // Note: this function is also called to restart watching from scratch when the inotify event\n    //   queue overflows (hopefully rare).\n\n    int fd;\n    KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n    inotifyFd = kj::AutoCloseFd(fd);\n\n    // Note that because we create the FdObserver before creating any watches, we don't have\n    // to worry about the possibility that we missed an event between creation of the fd and\n    // creation of the FdObserver.\n    observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n        kj::UnixEventPort::FdObserver::OBSERVE_READ);\n\n    totalSize = 0;\n    watchMap.clear();\n    pendingWatches.add(nullptr);  // root directory\n    return readLoop();\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> init() {\n      // Start watching the current directory.\n  \n      // Note: this function is also called to restart watching from scratch when the inotify event\n      //   queue overflows (hopefully rare).\n  \n      int fd;\n      KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      inotifyFd = kj::AutoCloseFd(fd);\n  \n      // Note that because we create the FdObserver before creating any watches, we don't have\n      // to worry about the possibility that we missed an event between creation of the fd and\n      // creation of the FdObserver.\n      observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n          kj::UnixEventPort::FdObserver::OBSERVE_READ);\n  \n      totalSize = 0;\n      watchMap.clear();\n      pendingWatches.add(nullptr);  // root directory\n      return readLoop();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"inotify event queue overflow; restarting watch from scratch\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "eventSize % sizeof(size_t) == 0",
            "\"inotify event not aligned?\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "eventSize <= n",
            "\"inotify returned partial event?\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct inotify_event*>",
          "args": [
            "pos"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n > 0",
            "\"inotify EOF?\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readLoop",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "readLoop",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "237-291",
          "snippet": "kj::Promise<void> readLoop() {\n    addPendingWatches();\n    maybeReportSize();\n    return observer->whenBecomesReadable().then([this]() {\n      alignas(uint64_t) kj::byte buffer[4096];\n\n      for (;;) {\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n\n        if (n < 0) {\n          // EAGAIN; try again later.\n          return readLoop();\n        }\n\n        KJ_ASSERT(n > 0, \"inotify EOF?\");\n\n        kj::byte* pos = buffer;\n        while (n > 0) {\n          // Split off one event.\n          auto event = reinterpret_cast<struct inotify_event*>(pos);\n          size_t eventSize = sizeof(struct inotify_event) + event->len;\n          KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n          KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n          n -= eventSize;\n          pos += eventSize;\n\n          if (event->mask & IN_Q_OVERFLOW) {\n            // Queue overflow; start over from scratch.\n            inotifyFd = nullptr;\n            KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n            return init();\n          }\n\n          auto iter = watchMap.find(event->wd);\n          KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n\n          if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n            childEvent(iter->second, event->name);\n          }\n\n          if (event->mask & IN_IGNORED) {\n            // This watch descriptor is being removed, probably because it was deleted.\n\n            // There shouldn't be any children left, but if there are, go ahead and un-count them.\n            for (auto& child: iter->second.childSizes) {\n              totalSize -= child.second.size;\n            }\n\n            watchMap.erase(iter);\n          }\n        }\n      }\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = read(inotifyFd, buffer, sizeof(buffer))"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "inotifyFd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "908-910",
          "snippet": "kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->read(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->read(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer->whenBecomesReadable",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybeReportSize",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "maybeReportSize",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "398-435",
          "snippet": "void maybeReportSize() {\n    // Don't send multiple reports at once. When the first one finishes we'll send another one if\n    // the size has changed in the meantime.\n    if (reportInFlight) return;\n\n    // If the last reported size is still correct, don't report.\n    if (reportedSize == totalSize) return;\n\n    reportInFlight = true;\n\n    // Wait 500ms before reporting to gather other changes.\n    tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n        .then([this]() -> kj::Promise<void> {\n      auto req = core.reportGrainSizeRequest();\n      uint64_t sizeBeingReported = totalSize;\n      req.setBytes(sizeBeingReported);\n\n      return req.send().then([this,sizeBeingReported](auto) -> void {\n        reportInFlight = false;\n        reportedSize = sizeBeingReported;\n\n        // If the size has changed further, initiate a new report.\n        maybeReportSize();\n      }, [this](kj::Exception&& e) {\n        reportInFlight = false;\n\n        if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n          // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n          // eventually, and in fact further calls to SandstormCore should block until than\n          // happens. So, initiate a new report immediately.\n          maybeReportSize();\n        } else {\n          // Some other error. Propagate.\n          kj::throwFatalException(kj::mv(e));\n        }\n      });\n    }));\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void maybeReportSize() {\n      // Don't send multiple reports at once. When the first one finishes we'll send another one if\n      // the size has changed in the meantime.\n      if (reportInFlight) return;\n  \n      // If the last reported size is still correct, don't report.\n      if (reportedSize == totalSize) return;\n  \n      reportInFlight = true;\n  \n      // Wait 500ms before reporting to gather other changes.\n      tasks.add(timer.afterDelay(500 * kj::MILLISECONDS)\n          .then([this]() -> kj::Promise<void> {\n        auto req = core.reportGrainSizeRequest();\n        uint64_t sizeBeingReported = totalSize;\n        req.setBytes(sizeBeingReported);\n  \n        return req.send().then([this,sizeBeingReported](auto) -> void {\n          reportInFlight = false;\n          reportedSize = sizeBeingReported;\n  \n          // If the size has changed further, initiate a new report.\n          maybeReportSize();\n        }, [this](kj::Exception&& e) {\n          reportInFlight = false;\n  \n          if (e.getType() == kj::Exception::Type::DISCONNECTED) {\n            // SandstormCore disconnected. Due to our CoreRedirector logic, it will restore itself\n            // eventually, and in fact further calls to SandstormCore should block until than\n            // happens. So, initiate a new report immediately.\n            maybeReportSize();\n          } else {\n            // Some other error. Propagate.\n            kj::throwFatalException(kj::mv(e));\n          }\n        });\n      }));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addPendingWatches",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "addPendingWatches",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "148-157",
          "snippet": "void addPendingWatches() {\n    // Start watching everything that has been added to the pendingWatches list.\n\n    // We treat pendingWatches as a stack here in order to get DFS traversal of the directory tree.\n    while (pendingWatches.size() > 0) {\n      auto path = kj::mv(pendingWatches.end()[-1]);\n      pendingWatches.removeLast();\n      addWatch(kj::mv(path));\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void addPendingWatches() {\n      // Start watching everything that has been added to the pendingWatches list.\n  \n      // We treat pendingWatches as a stack here in order to get DFS traversal of the directory tree.\n      while (pendingWatches.size() > 0) {\n        auto path = kj::mv(pendingWatches.end()[-1]);\n        pendingWatches.removeLast();\n        addWatch(kj::mv(path));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> readLoop() {\n      addPendingWatches();\n      maybeReportSize();\n      return observer->whenBecomesReadable().then([this]() {\n        alignas(uint64_t) kj::byte buffer[4096];\n  \n        for (;;) {\n          ssize_t n;\n          KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n  \n          if (n < 0) {\n            // EAGAIN; try again later.\n            return readLoop();\n          }\n  \n          KJ_ASSERT(n > 0, \"inotify EOF?\");\n  \n          kj::byte* pos = buffer;\n          while (n > 0) {\n            // Split off one event.\n            auto event = reinterpret_cast<struct inotify_event*>(pos);\n            size_t eventSize = sizeof(struct inotify_event) + event->len;\n            KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n            KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n            n -= eventSize;\n            pos += eventSize;\n  \n            if (event->mask & IN_Q_OVERFLOW) {\n              // Queue overflow; start over from scratch.\n              inotifyFd = nullptr;\n              KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n              return init();\n            }\n  \n            auto iter = watchMap.find(event->wd);\n            KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n  \n            if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n              childEvent(iter->second, event->name);\n            }\n  \n            if (event->mask & IN_IGNORED) {\n              // This watch descriptor is being removed, probably because it was deleted.\n  \n              // There shouldn't be any children left, but if there are, go ahead and un-count them.\n              for (auto& child: iter->second.childSizes) {\n                totalSize -= child.second.size;\n              }\n  \n              watchMap.erase(iter);\n            }\n          }\n        }\n      });\n    }\n}"
  },
  {
    "function_name": "addWatch",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "159-235",
    "snippet": "void addWatch(kj::String&& path) {\n    // Start watching `path`. This is idempotent -- it's safe to watch the same path multiple\n    // times.\n\n    static const uint32_t FLAGS =\n        IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_FROM | IN_MOVED_TO |\n        IN_DONT_FOLLOW | IN_ONLYDIR | IN_EXCL_UNLINK;\n\n    for (;;) {\n      const char* pathPtr = path == nullptr ? \".\" : path.cStr();\n      int wd = inotify_add_watch(inotifyFd, pathPtr,\n          FLAGS | IN_DONT_FOLLOW | IN_EXCL_UNLINK);\n\n      if (wd >= 0) {\n        WatchInfo& watchInfo = watchMap[wd];\n\n        // Update the watch map. Note that it's possible that inotify_add_watch() returned a\n        // pre-existing watch descriptor, if we tried to add a watch on a directory we're\n        // already watching. This can happen in various race conditions. Replacing the path is\n        // actually exactly what we want to do in these cases anyway.\n        watchInfo.path = kj::mv(path);\n\n        // In the case that we are reusing an existing watch descriptor, we want to clear out the\n        // existing contents as they may be stale due to, again, race conditions.\n        for (auto& child: watchInfo.childSizes) {\n          totalSize -= child.second.size;\n        }\n        watchInfo.childSizes.clear();\n\n        // Now repopulate the children by listing the directory.\n        DIR* dir = opendir(pathPtr);\n        if (dir != nullptr) {\n          KJ_DEFER(closedir(dir));\n          for (;;) {\n            errno = 0;\n            struct dirent* entry = readdir(dir);\n            if (entry == nullptr) {\n              int error = errno;\n              if (error == 0) {\n                break;\n              } else {\n                KJ_FAIL_SYSCALL(\"readdir\", error, pathPtr);\n              }\n            }\n\n            kj::StringPtr name = entry->d_name;\n            if (name != \".\" && name != \"..\") {\n              childEvent(watchInfo, name);\n            }\n          }\n        }\n\n        return;\n      }\n\n      // Error occurred.\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          // Keep trying.\n          break;\n\n        case ENOENT:\n        case ENOTDIR:\n          // Apparently there is no longer a directory at this path. Perhaps it was deleted.\n          // No matter.\n          return;\n\n        case ENOSPC:\n          // No more inotify watches available.\n          // TODO(someday): Revert to some sort of polling mode? For now, fall through to error\n          //   case.\n        default:\n          KJ_FAIL_SYSCALL(\"inotify_add_watch\", error, path);\n      }\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"inotify_add_watch\"",
            "error",
            "path"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "childEvent",
          "args": [
            "watchInfo",
            "name"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "childEvent",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "293-345",
          "snippet": "void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n    // Called to update the child table when we receive an inotify event with the given name.\n\n    // OK, we received notification that something happened to the child named `name`.\n    // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n    // number of other events may have occurred since this one was generated. For example,\n    // the event may have been on a file that has subsequently been deleted, and maybe even\n    // recreated as a different kind of node. If we lstat() it, we get information about\n    // what is currently on disk, not whatever generated this event.\n    //\n    // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n    // that something happened at this child. We have to compare what we know about the child\n    // vs. what we knew in the past to determine what has changed. Note that if inotify\n    // provided a `struct stat` along with the event then we wouldn't have this problem!\n\n    auto usage = getDiskUsage(watchInfo.path, name);\n    totalSize += usage.bytes;\n\n    auto iter = watchInfo.childSizes.find(name);\n    if (usage.bytes == 0) {\n      // There is no longer a child by this name on disk. Remove whatever is in the map.\n      if (iter != watchInfo.childSizes.end()) {\n        totalSize -= iter->second.size;\n        watchInfo.childSizes.erase(iter);\n      }\n    } else if (iter == watchInfo.childSizes.end()) {\n      // There is a child by this name on disk, but not in the map. Add it.\n      ChildInfo newChild = { kj::heapString(name), usage.bytes };\n      kj::StringPtr namePtr = newChild.name;\n      KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n    } else {\n      // There is a child by this name on disk and in the map. Check for a change in size.\n      totalSize -= iter->second.size;\n      iter->second.size = usage.bytes;\n    }\n\n    maybeReportSize();\n\n    // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n    // are not generated for subdirectories (only files), so if we got an event on a directory it\n    // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n    // exist anymore, so usage.isDir would be false. So, we know this directory is either\n    // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n    // start watching the directory. In the moved-in case, we are probably already watching the\n    // directory, however it is necessary to redo the watch because the path has changed and the\n    // directory state may have become inconsistent in the time that the path was wrong.\n    if (usage.isDir) {\n      // We can't actually add the new watch now because we need to process the remaining\n      // events from the last read() in order to make sure we're caught up with inotify's\n      // state.\n      pendingWatches.add(kj::mv(usage.path));\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void childEvent(WatchInfo& watchInfo, kj::StringPtr name) {\n      // Called to update the child table when we receive an inotify event with the given name.\n  \n      // OK, we received notification that something happened to the child named `name`.\n      // Unfortunately, we don't have any idea how long ago this event happened. Worse, any\n      // number of other events may have occurred since this one was generated. For example,\n      // the event may have been on a file that has subsequently been deleted, and maybe even\n      // recreated as a different kind of node. If we lstat() it, we get information about\n      // what is currently on disk, not whatever generated this event.\n      //\n      // Therefore, the inotify event mask is mostly useless. We can only use the event as a hint\n      // that something happened at this child. We have to compare what we know about the child\n      // vs. what we knew in the past to determine what has changed. Note that if inotify\n      // provided a `struct stat` along with the event then we wouldn't have this problem!\n  \n      auto usage = getDiskUsage(watchInfo.path, name);\n      totalSize += usage.bytes;\n  \n      auto iter = watchInfo.childSizes.find(name);\n      if (usage.bytes == 0) {\n        // There is no longer a child by this name on disk. Remove whatever is in the map.\n        if (iter != watchInfo.childSizes.end()) {\n          totalSize -= iter->second.size;\n          watchInfo.childSizes.erase(iter);\n        }\n      } else if (iter == watchInfo.childSizes.end()) {\n        // There is a child by this name on disk, but not in the map. Add it.\n        ChildInfo newChild = { kj::heapString(name), usage.bytes };\n        kj::StringPtr namePtr = newChild.name;\n        KJ_ASSERT(watchInfo.childSizes.insert(std::make_pair(namePtr, kj::mv(newChild))).second);\n      } else {\n        // There is a child by this name on disk and in the map. Check for a change in size.\n        totalSize -= iter->second.size;\n        iter->second.size = usage.bytes;\n      }\n  \n      maybeReportSize();\n  \n      // If the child is a directory, plan to start watching it later. Note that IN_MODIFY events\n      // are not generated for subdirectories (only files), so if we got an event on a directory it\n      // must be create, move to, move from, or delete. In the latter two cases, the node wouldn't\n      // exist anymore, so usage.isDir would be false. So, we know this directory is either\n      // newly-created or newly moved in from elsewhere. In the creation case, we clearly need to\n      // start watching the directory. In the moved-in case, we are probably already watching the\n      // directory, however it is necessary to redo the watch because the path has changed and the\n      // directory state may have become inconsistent in the time that the path was wrong.\n      if (usage.isDir) {\n        // We can't actually add the new watch now because we need to process the remaining\n        // events from the last read() in order to make sure we're caught up with inotify's\n        // state.\n        pendingWatches.add(kj::mv(usage.path));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"readdir\"",
            "error",
            "pathPtr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "closedir(dir)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "pathPtr"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchInfo.childSizes.clear",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_add_watch",
          "args": [
            "inotifyFd",
            "pathPtr",
            "FLAGS | IN_DONT_FOLLOW | IN_EXCL_UNLINK"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void addWatch(kj::String&& path) {\n      // Start watching `path`. This is idempotent -- it's safe to watch the same path multiple\n      // times.\n  \n      static const uint32_t FLAGS =\n          IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_FROM | IN_MOVED_TO |\n          IN_DONT_FOLLOW | IN_ONLYDIR | IN_EXCL_UNLINK;\n  \n      for (;;) {\n        const char* pathPtr = path == nullptr ? \".\" : path.cStr();\n        int wd = inotify_add_watch(inotifyFd, pathPtr,\n            FLAGS | IN_DONT_FOLLOW | IN_EXCL_UNLINK);\n  \n        if (wd >= 0) {\n          WatchInfo& watchInfo = watchMap[wd];\n  \n          // Update the watch map. Note that it's possible that inotify_add_watch() returned a\n          // pre-existing watch descriptor, if we tried to add a watch on a directory we're\n          // already watching. This can happen in various race conditions. Replacing the path is\n          // actually exactly what we want to do in these cases anyway.\n          watchInfo.path = kj::mv(path);\n  \n          // In the case that we are reusing an existing watch descriptor, we want to clear out the\n          // existing contents as they may be stale due to, again, race conditions.\n          for (auto& child: watchInfo.childSizes) {\n            totalSize -= child.second.size;\n          }\n          watchInfo.childSizes.clear();\n  \n          // Now repopulate the children by listing the directory.\n          DIR* dir = opendir(pathPtr);\n          if (dir != nullptr) {\n            KJ_DEFER(closedir(dir));\n            for (;;) {\n              errno = 0;\n              struct dirent* entry = readdir(dir);\n              if (entry == nullptr) {\n                int error = errno;\n                if (error == 0) {\n                  break;\n                } else {\n                  KJ_FAIL_SYSCALL(\"readdir\", error, pathPtr);\n                }\n              }\n  \n              kj::StringPtr name = entry->d_name;\n              if (name != \".\" && name != \"..\") {\n                childEvent(watchInfo, name);\n              }\n            }\n          }\n  \n          return;\n        }\n  \n        // Error occurred.\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            // Keep trying.\n            break;\n  \n          case ENOENT:\n          case ENOTDIR:\n            // Apparently there is no longer a directory at this path. Perhaps it was deleted.\n            // No matter.\n            return;\n  \n          case ENOSPC:\n            // No more inotify watches available.\n            // TODO(someday): Revert to some sort of polling mode? For now, fall through to error\n            //   case.\n          default:\n            KJ_FAIL_SYSCALL(\"inotify_add_watch\", error, path);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "addPendingWatches",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "148-157",
    "snippet": "void addPendingWatches() {\n    // Start watching everything that has been added to the pendingWatches list.\n\n    // We treat pendingWatches as a stack here in order to get DFS traversal of the directory tree.\n    while (pendingWatches.size() > 0) {\n      auto path = kj::mv(pendingWatches.end()[-1]);\n      pendingWatches.removeLast();\n      addWatch(kj::mv(path));\n    }\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addWatch",
          "args": [
            "kj::mv(path)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "addWatch",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "159-235",
          "snippet": "void addWatch(kj::String&& path) {\n    // Start watching `path`. This is idempotent -- it's safe to watch the same path multiple\n    // times.\n\n    static const uint32_t FLAGS =\n        IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_FROM | IN_MOVED_TO |\n        IN_DONT_FOLLOW | IN_ONLYDIR | IN_EXCL_UNLINK;\n\n    for (;;) {\n      const char* pathPtr = path == nullptr ? \".\" : path.cStr();\n      int wd = inotify_add_watch(inotifyFd, pathPtr,\n          FLAGS | IN_DONT_FOLLOW | IN_EXCL_UNLINK);\n\n      if (wd >= 0) {\n        WatchInfo& watchInfo = watchMap[wd];\n\n        // Update the watch map. Note that it's possible that inotify_add_watch() returned a\n        // pre-existing watch descriptor, if we tried to add a watch on a directory we're\n        // already watching. This can happen in various race conditions. Replacing the path is\n        // actually exactly what we want to do in these cases anyway.\n        watchInfo.path = kj::mv(path);\n\n        // In the case that we are reusing an existing watch descriptor, we want to clear out the\n        // existing contents as they may be stale due to, again, race conditions.\n        for (auto& child: watchInfo.childSizes) {\n          totalSize -= child.second.size;\n        }\n        watchInfo.childSizes.clear();\n\n        // Now repopulate the children by listing the directory.\n        DIR* dir = opendir(pathPtr);\n        if (dir != nullptr) {\n          KJ_DEFER(closedir(dir));\n          for (;;) {\n            errno = 0;\n            struct dirent* entry = readdir(dir);\n            if (entry == nullptr) {\n              int error = errno;\n              if (error == 0) {\n                break;\n              } else {\n                KJ_FAIL_SYSCALL(\"readdir\", error, pathPtr);\n              }\n            }\n\n            kj::StringPtr name = entry->d_name;\n            if (name != \".\" && name != \"..\") {\n              childEvent(watchInfo, name);\n            }\n          }\n        }\n\n        return;\n      }\n\n      // Error occurred.\n      int error = errno;\n      switch (error) {\n        case EINTR:\n          // Keep trying.\n          break;\n\n        case ENOENT:\n        case ENOTDIR:\n          // Apparently there is no longer a directory at this path. Perhaps it was deleted.\n          // No matter.\n          return;\n\n        case ENOSPC:\n          // No more inotify watches available.\n          // TODO(someday): Revert to some sort of polling mode? For now, fall through to error\n          //   case.\n        default:\n          KJ_FAIL_SYSCALL(\"inotify_add_watch\", error, path);\n      }\n    }\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void addWatch(kj::String&& path) {\n      // Start watching `path`. This is idempotent -- it's safe to watch the same path multiple\n      // times.\n  \n      static const uint32_t FLAGS =\n          IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_FROM | IN_MOVED_TO |\n          IN_DONT_FOLLOW | IN_ONLYDIR | IN_EXCL_UNLINK;\n  \n      for (;;) {\n        const char* pathPtr = path == nullptr ? \".\" : path.cStr();\n        int wd = inotify_add_watch(inotifyFd, pathPtr,\n            FLAGS | IN_DONT_FOLLOW | IN_EXCL_UNLINK);\n  \n        if (wd >= 0) {\n          WatchInfo& watchInfo = watchMap[wd];\n  \n          // Update the watch map. Note that it's possible that inotify_add_watch() returned a\n          // pre-existing watch descriptor, if we tried to add a watch on a directory we're\n          // already watching. This can happen in various race conditions. Replacing the path is\n          // actually exactly what we want to do in these cases anyway.\n          watchInfo.path = kj::mv(path);\n  \n          // In the case that we are reusing an existing watch descriptor, we want to clear out the\n          // existing contents as they may be stale due to, again, race conditions.\n          for (auto& child: watchInfo.childSizes) {\n            totalSize -= child.second.size;\n          }\n          watchInfo.childSizes.clear();\n  \n          // Now repopulate the children by listing the directory.\n          DIR* dir = opendir(pathPtr);\n          if (dir != nullptr) {\n            KJ_DEFER(closedir(dir));\n            for (;;) {\n              errno = 0;\n              struct dirent* entry = readdir(dir);\n              if (entry == nullptr) {\n                int error = errno;\n                if (error == 0) {\n                  break;\n                } else {\n                  KJ_FAIL_SYSCALL(\"readdir\", error, pathPtr);\n                }\n              }\n  \n              kj::StringPtr name = entry->d_name;\n              if (name != \".\" && name != \"..\") {\n                childEvent(watchInfo, name);\n              }\n            }\n          }\n  \n          return;\n        }\n  \n        // Error occurred.\n        int error = errno;\n        switch (error) {\n          case EINTR:\n            // Keep trying.\n            break;\n  \n          case ENOENT:\n          case ENOTDIR:\n            // Apparently there is no longer a directory at this path. Perhaps it was deleted.\n            // No matter.\n            return;\n  \n          case ENOSPC:\n            // No more inotify watches available.\n            // TODO(someday): Revert to some sort of polling mode? For now, fall through to error\n            //   case.\n          default:\n            KJ_FAIL_SYSCALL(\"inotify_add_watch\", error, path);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pendingWatches.removeLast",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pendingWatches.end()[-1]"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pendingWatches.end",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pendingWatches.size",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  void addPendingWatches() {\n      // Start watching everything that has been added to the pendingWatches list.\n  \n      // We treat pendingWatches as a stack here in order to get DFS traversal of the directory tree.\n      while (pendingWatches.size() > 0) {\n        auto path = kj::mv(pendingWatches.end()[-1]);\n        pendingWatches.removeLast();\n        addWatch(kj::mv(path));\n      }\n    }\n}"
  },
  {
    "function_name": "init",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "98-118",
    "snippet": "kj::Promise<void> init() {\n    // Start watching the current directory.\n\n    // Note: this function is also called to restart watching from scratch when the inotify event\n    //   queue overflows (hopefully rare).\n\n    int fd;\n    KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n    inotifyFd = kj::AutoCloseFd(fd);\n\n    // Note that because we create the FdObserver before creating any watches, we don't have\n    // to worry about the possibility that we missed an event between creation of the fd and\n    // creation of the FdObserver.\n    observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n        kj::UnixEventPort::FdObserver::OBSERVE_READ);\n\n    totalSize = 0;\n    watchMap.clear();\n    pendingWatches.add(nullptr);  // root directory\n    return readLoop();\n  }",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readLoop",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "readLoop",
          "container": "DiskUsageWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
          "lines": "237-291",
          "snippet": "kj::Promise<void> readLoop() {\n    addPendingWatches();\n    maybeReportSize();\n    return observer->whenBecomesReadable().then([this]() {\n      alignas(uint64_t) kj::byte buffer[4096];\n\n      for (;;) {\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n\n        if (n < 0) {\n          // EAGAIN; try again later.\n          return readLoop();\n        }\n\n        KJ_ASSERT(n > 0, \"inotify EOF?\");\n\n        kj::byte* pos = buffer;\n        while (n > 0) {\n          // Split off one event.\n          auto event = reinterpret_cast<struct inotify_event*>(pos);\n          size_t eventSize = sizeof(struct inotify_event) + event->len;\n          KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n          KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n          n -= eventSize;\n          pos += eventSize;\n\n          if (event->mask & IN_Q_OVERFLOW) {\n            // Queue overflow; start over from scratch.\n            inotifyFd = nullptr;\n            KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n            return init();\n          }\n\n          auto iter = watchMap.find(event->wd);\n          KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n\n          if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n            childEvent(iter->second, event->name);\n          }\n\n          if (event->mask & IN_IGNORED) {\n            // This watch descriptor is being removed, probably because it was deleted.\n\n            // There shouldn't be any children left, but if there are, go ahead and un-count them.\n            for (auto& child: iter->second.childSizes) {\n              totalSize -= child.second.size;\n            }\n\n            watchMap.erase(iter);\n          }\n        }\n      }\n    });\n  }",
          "includes": [
            "#include \"util.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <sandstorm/supervisor.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <seccomp.h>",
            "#include <sys/resource.h>",
            "#include <sys/eventfd.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <execinfo.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <sys/inotify.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <sched.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <linux/netfilter/nf_nat.h>",
            "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
            "#include <linux/route.h>",
            "#include <linux/sockios.h>",
            "#include <sys/syscall.h>",
            "#include <sys/ptrace.h>",
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <netinet/in.h> // needs to be included before sys/capability.h",
            "#include <unistd.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>",
            "#include \"supervisor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> readLoop() {\n      addPendingWatches();\n      maybeReportSize();\n      return observer->whenBecomesReadable().then([this]() {\n        alignas(uint64_t) kj::byte buffer[4096];\n  \n        for (;;) {\n          ssize_t n;\n          KJ_NONBLOCKING_SYSCALL(n = read(inotifyFd, buffer, sizeof(buffer)));\n  \n          if (n < 0) {\n            // EAGAIN; try again later.\n            return readLoop();\n          }\n  \n          KJ_ASSERT(n > 0, \"inotify EOF?\");\n  \n          kj::byte* pos = buffer;\n          while (n > 0) {\n            // Split off one event.\n            auto event = reinterpret_cast<struct inotify_event*>(pos);\n            size_t eventSize = sizeof(struct inotify_event) + event->len;\n            KJ_ASSERT(eventSize <= n, \"inotify returned partial event?\");\n            KJ_ASSERT(eventSize % sizeof(size_t) == 0, \"inotify event not aligned?\");\n            n -= eventSize;\n            pos += eventSize;\n  \n            if (event->mask & IN_Q_OVERFLOW) {\n              // Queue overflow; start over from scratch.\n              inotifyFd = nullptr;\n              KJ_LOG(WARNING, \"inotify event queue overflow; restarting watch from scratch\");\n              return init();\n            }\n  \n            auto iter = watchMap.find(event->wd);\n            KJ_ASSERT(iter != watchMap.end(), \"inotify gave unknown watch descriptor?\");\n  \n            if (event->mask & (IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVE)) {\n              childEvent(iter->second, event->name);\n            }\n  \n            if (event->mask & IN_IGNORED) {\n              // This watch descriptor is being removed, probably because it was deleted.\n  \n              // There shouldn't be any children left, but if there are, go ahead and un-count them.\n              for (auto& child: iter->second.childSizes) {\n                totalSize -= child.second.size;\n              }\n  \n              watchMap.erase(iter);\n            }\n          }\n        }\n      });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pendingWatches.add",
          "args": [
            "nullptr"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchMap.clear",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<kj::UnixEventPort::FdObserver>",
          "args": [
            "eventPort",
            "inotifyFd",
            "kj::UnixEventPort::FdObserver::OBSERVE_READ"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_init1",
          "args": [
            "IN_NONBLOCK | IN_CLOEXEC"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  kj::Promise<void> init() {\n      // Start watching the current directory.\n  \n      // Note: this function is also called to restart watching from scratch when the inotify event\n      //   queue overflows (hopefully rare).\n  \n      int fd;\n      KJ_SYSCALL(fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC));\n      inotifyFd = kj::AutoCloseFd(fd);\n  \n      // Note that because we create the FdObserver before creating any watches, we don't have\n      // to worry about the possibility that we missed an event between creation of the fd and\n      // creation of the FdObserver.\n      observer = kj::heap<kj::UnixEventPort::FdObserver>(eventPort, inotifyFd,\n          kj::UnixEventPort::FdObserver::OBSERVE_READ);\n  \n      totalSize = 0;\n      watchMap.clear();\n      pendingWatches.add(nullptr);  // root directory\n      return readLoop();\n    }\n}"
  },
  {
    "function_name": "DiskUsageWatcher",
    "container": "DiskUsageWatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/supervisor.c++",
    "lines": "95-96",
    "snippet": "DiskUsageWatcher(kj::UnixEventPort& eventPort, kj::Timer& timer, SandstormCore::Client core)\n      : eventPort(eventPort), timer(timer), core(kj::mv(core)), tasks(*this) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"send-fd.h\"",
      "#include \"version.h\"",
      "#include <sandstorm/supervisor.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <seccomp.h>",
      "#include <sys/resource.h>",
      "#include <sys/eventfd.h>",
      "#include <linux/rtnetlink.h>",
      "#include <linux/netlink.h>",
      "#include <execinfo.h>",
      "#include <unordered_map>",
      "#include <map>",
      "#include <sys/inotify.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <sched.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <linux/netfilter/nf_nat.h>",
      "#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>",
      "#include <linux/route.h>",
      "#include <linux/sockios.h>",
      "#include <sys/syscall.h>",
      "#include <sys/ptrace.h>",
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <netinet/in.h> // needs to be included before sys/capability.h",
      "#include <unistd.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/io.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/async-io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>",
      "#include \"supervisor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "core"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <sandstorm/supervisor.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <seccomp.h>\n#include <sys/resource.h>\n#include <sys/eventfd.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <execinfo.h>\n#include <unordered_map>\n#include <map>\n#include <sys/inotify.h>\n#include <grp.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <sched.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netfilter/nf_nat.h>\n#include <sandstorm/ip_tables.h>  // created by Makefile from <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <sys/syscall.h>\n#include <sys/ptrace.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <netinet/in.h> // needs to be included before sys/capability.h\n#include <unistd.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n#include \"supervisor.h\"\n\nDiskUsageWatcher {\n  DiskUsageWatcher(kj::UnixEventPort& eventPort, kj::Timer& timer, SandstormCore::Client core)\n        : eventPort(eventPort), timer(timer), core(kj::mv(core)), tasks(*this) {}\n}"
  }
]