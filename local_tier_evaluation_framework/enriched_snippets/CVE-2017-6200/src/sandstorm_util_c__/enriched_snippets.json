[
  {
    "function_name": "taskFailed",
    "container": "TwoPartyServerWithClientBootstrap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1254-1256",
    "snippet": "void TwoPartyServerWithClientBootstrap::taskFailed(kj::Exception&& exception) {\n  KJ_LOG(ERROR, exception);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "exception"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nTwoPartyServerWithClientBootstrap {\n  void TwoPartyServerWithClientBootstrap::taskFailed(kj::Exception&& exception) {\n    KJ_LOG(ERROR, exception);\n  }\n}"
  },
  {
    "function_name": "getBootstrap",
    "container": "TwoPartyServerWithClientBootstrap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1250-1252",
    "snippet": "capnp::Capability::Client TwoPartyServerWithClientBootstrap::getBootstrap() {\n  return kj::addRef(*redirector);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*redirector"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nTwoPartyServerWithClientBootstrap {\n  capnp::Capability::Client TwoPartyServerWithClientBootstrap::getBootstrap() {\n    return kj::addRef(*redirector);\n  }\n}"
  },
  {
    "function_name": "listen",
    "container": "TwoPartyServerWithClientBootstrap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1227-1247",
    "snippet": "kj::Promise<void> TwoPartyServerWithClientBootstrap::listen(\n  kj::Own<kj::ConnectionReceiver>&& listener) {\n  return listener->accept()\n      .then([this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    auto connectionState = kj::heap<AcceptedConnection>(bootstrapInterface, kj::mv(connection));\n\n    // Update the bootstrap redirector to point at the new connection's bootstrap.\n    capnp::MallocMessageBuilder message(8);\n    auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n    vatId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n    uint iteration = redirector->setTarget(connectionState->rpcSystem.bootstrap(vatId));\n\n    // Run the connection until disconnect.\n    auto promise = connectionState->network.onDisconnect();\n    tasks.add(promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    })));\n\n    return listen(kj::mv(listener));\n  }",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "kj::mv(listener)"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "listen",
          "container": "TwoPartyServerWithClientBootstrap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1227-1247",
          "snippet": "kj::Promise<void> TwoPartyServerWithClientBootstrap::listen(\n  kj::Own<kj::ConnectionReceiver>&& listener) {\n  return listener->accept()\n      .then([this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n    auto connectionState = kj::heap<AcceptedConnection>(bootstrapInterface, kj::mv(connection));\n\n    // Update the bootstrap redirector to point at the new connection's bootstrap.\n    capnp::MallocMessageBuilder message(8);\n    auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n    vatId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n    uint iteration = redirector->setTarget(connectionState->rpcSystem.bootstrap(vatId));\n\n    // Run the connection until disconnect.\n    auto promise = connectionState->network.onDisconnect();\n    tasks.add(promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    })));\n\n    return listen(kj::mv(listener));\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    }))"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(connectionState)",
            "kj::defer([this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    })"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::defer",
          "args": [
            "[this,iteration]() {\n      // Disconnect the redirector when the client disconnects.\n      redirector->setDisconnected(iteration);\n    }"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirector->setDisconnected",
          "args": [
            "iteration"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "setDisconnected",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1151-1164",
          "snippet": "void CapRedirector::setDisconnected(uint oldIteration) {\n  if (iteration == oldIteration) {\n    // Our current client was disconnected.\n    ++iteration;\n\n    if (state.is<Passive>()) {\n      auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n      target = kj::mv(paf.promise);\n      state.get<Passive>() = kj::mv(paf.fulfiller);\n    } else {\n      target = state.get<Active>()();\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  void CapRedirector::setDisconnected(uint oldIteration) {\n    if (iteration == oldIteration) {\n      // Our current client was disconnected.\n      ++iteration;\n  \n      if (state.is<Passive>()) {\n        auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n        target = kj::mv(paf.promise);\n        state.get<Passive>() = kj::mv(paf.fulfiller);\n      } else {\n        target = state.get<Active>()();\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionState"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->network.onDisconnect",
          "args": [],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "BackendImpl::RunningGrain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backend.h",
          "lines": "70-70",
          "snippet": "inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/one-of.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async-io.h>",
            "#include <map>",
            "#include <sandstorm/backend.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/one-of.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <map>\n#include <sandstorm/backend.capnp.h>\n\nBackendImpl {\n  RunningGrain {\n    inline kj::Promise<void> onDisconnect() { return client.onDisconnect(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirector->setTarget",
          "args": [
            "connectionState->rpcSystem.bootstrap(vatId)"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "setTarget",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1139-1149",
          "snippet": "uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n  KJ_REQUIRE(state.is<Passive>());\n\n  ++iteration;\n  target = newTarget;\n\n  // If the previous target was a promise target, fulfill it.\n  state.get<Passive>()->fulfill(kj::mv(newTarget));\n\n  return iteration;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n    KJ_REQUIRE(state.is<Passive>());\n  \n    ++iteration;\n    target = newTarget;\n  \n    // If the previous target was a promise target, fulfill it.\n    state.get<Passive>()->fulfill(kj::mv(newTarget));\n  \n    return iteration;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->rpcSystem.bootstrap",
          "args": [
            "vatId"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vatId.setSide",
          "args": [
            "capnp::rpc::twoparty::Side::CLIENT"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<capnp::rpc::twoparty::VatId>",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<AcceptedConnection>",
          "args": [
            "bootstrapInterface",
            "kj::mv(connection)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connection"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listener->accept",
          "args": [
            "[this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listener->accept",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nTwoPartyServerWithClientBootstrap {\n  kj::Promise<void> TwoPartyServerWithClientBootstrap::listen(\n    kj::Own<kj::ConnectionReceiver>&& listener) {\n    return listener->accept()\n        .then([this,KJ_MVCAP(listener)](kj::Own<kj::AsyncIoStream>&& connection) mutable {\n      auto connectionState = kj::heap<AcceptedConnection>(bootstrapInterface, kj::mv(connection));\n  \n      // Update the bootstrap redirector to point at the new connection's bootstrap.\n      capnp::MallocMessageBuilder message(8);\n      auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n      vatId.setSide(capnp::rpc::twoparty::Side::CLIENT);\n      uint iteration = redirector->setTarget(connectionState->rpcSystem.bootstrap(vatId));\n  \n      // Run the connection until disconnect.\n      auto promise = connectionState->network.onDisconnect();\n      tasks.add(promise.attach(kj::mv(connectionState), kj::defer([this,iteration]() {\n        // Disconnect the redirector when the client disconnects.\n        redirector->setDisconnected(iteration);\n      })));\n  \n      return listen(kj::mv(listener));\n    }\n}"
  },
  {
    "function_name": "AcceptedConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1220-1224",
    "snippet": "explicit AcceptedConnection(capnp::Capability::Client bootstrapInterface,\n                              kj::Own<kj::AsyncIoStream>&& connectionParam)\n      : connection(kj::mv(connectionParam)),\n        network(*connection, capnp::rpc::twoparty::Side::SERVER),\n        rpcSystem(capnp::makeRpcServer(network, kj::mv(bootstrapInterface))) {}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capnp::makeRpcServer",
          "args": [
            "network",
            "kj::mv(bootstrapInterface)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bootstrapInterface"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionParam"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nexplicit AcceptedConnection(capnp::Capability::Client bootstrapInterface,\n                              kj::Own<kj::AsyncIoStream>&& connectionParam)\n      : connection(kj::mv(connectionParam)),\n        network(*connection, capnp::rpc::twoparty::Side::SERVER),\n        rpcSystem(capnp::makeRpcServer(network, kj::mv(bootstrapInterface))) {}"
  },
  {
    "function_name": "TwoPartyServerWithClientBootstrap",
    "container": "TwoPartyServerWithClientBootstrap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1210-1213",
    "snippet": "TwoPartyServerWithClientBootstrap::TwoPartyServerWithClientBootstrap(\n  capnp::Capability::Client bootstrapInterface, kj::Own<CapRedirector> redirector)\n    : bootstrapInterface(kj::mv(bootstrapInterface)), redirector(kj::mv(redirector)),\n      tasks(*this) {}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "redirector"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bootstrapInterface"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nTwoPartyServerWithClientBootstrap {\n  TwoPartyServerWithClientBootstrap::TwoPartyServerWithClientBootstrap(\n    capnp::Capability::Client bootstrapInterface, kj::Own<CapRedirector> redirector)\n      : bootstrapInterface(kj::mv(bootstrapInterface)), redirector(kj::mv(redirector)),\n        tasks(*this) {}\n}"
  },
  {
    "function_name": "dispatchCall",
    "container": "CapRedirector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1166-1206",
    "snippet": "kj::Promise<void> CapRedirector::dispatchCall(\n    uint64_t interfaceId, uint16_t methodId,\n    capnp::CallContext<capnp::AnyPointer, capnp::AnyPointer> context) {\n  capnp::AnyPointer::Reader params = context.getParams();\n  auto req = target.typelessRequest(interfaceId, methodId, params.targetSize());\n  req.set(params);\n\n  auto oldIteration = iteration;\n\n  return req.send().then([context](auto&& response) mutable -> kj::Promise<void> {\n    context.initResults(response.targetSize()).set(response);\n    return kj::READY_NOW;\n  }, [this,oldIteration](kj::Exception&& e) -> kj::Promise<void> {\n    if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n      return kj::mv(e);\n    }\n\n    // Disconnected. Did we notice already?\n    if (iteration > oldIteration) {\n      // Yes, so stop here.\n      return kj::mv(e);\n    }\n\n    // OK, this disconnect is new to us. We need to determine if this disconnected capability\n    // is our direct target or something else that was accessed as part of the call. So, send\n    // a dummy call to check.\n    auto ping = target.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n    ping.initAsAnyStruct(0, 0);\n    return ping.send().then([](auto&&) -> void {\n      KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n      // But clearly we are still connected, so don't call setDisconnected()...\n    }, [this,oldIteration](kj::Exception&& e2) {\n      if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n        // Yep, really disconnected.\n        setDisconnected(oldIteration);\n      }\n    }).then([KJ_MVCAP(e)]() mutable -> kj::Promise<void> {\n      return kj::mv(e);\n    });\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto&& response) mutable -> kj::Promise<void> {\n    context.initResults(response.targetSize()).set(response);\n    return kj::READY_NOW;\n  }",
            "[this,oldIteration](kj::Exception&& e) -> kj::Promise<void> {\n    if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n      return kj::mv(e);\n    }\n\n    // Disconnected. Did we notice already?\n    if (iteration > oldIteration) {\n      // Yes, so stop here.\n      return kj::mv(e);\n    }\n\n    // OK, this disconnect is new to us. We need to determine if this disconnected capability\n    // is our direct target or something else that was accessed as part of the call. So, send\n    // a dummy call to check.\n    auto ping = target.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n    ping.initAsAnyStruct(0, 0);\n    return ping.send().then([](auto&&) -> void {\n      KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n      // But clearly we are still connected, so don't call setDisconnected()...\n    }, [this,oldIteration](kj::Exception&& e2) {\n      if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n        // Yep, really disconnected.\n        setDisconnected(oldIteration);\n      }\n    }).then([KJ_MVCAP(e)]() mutable -> kj::Promise<void> {\n      return kj::mv(e);\n    });\n  }"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.send",
          "args": [
            "[KJ_MVCAP(e)]() mutable -> kj::Promise<void> {\n      return kj::mv(e);\n    }"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.send",
          "args": [
            "[](auto&&) -> void {\n      KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n      // But clearly we are still connected, so don't call setDisconnected()...\n    }",
            "[this,oldIteration](kj::Exception&& e2) {\n      if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n        // Yep, really disconnected.\n        setDisconnected(oldIteration);\n      }\n    }"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setDisconnected",
          "args": [
            "oldIteration"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "setDisconnected",
          "container": "CapRedirector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1151-1164",
          "snippet": "void CapRedirector::setDisconnected(uint oldIteration) {\n  if (iteration == oldIteration) {\n    // Our current client was disconnected.\n    ++iteration;\n\n    if (state.is<Passive>()) {\n      auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n      target = kj::mv(paf.promise);\n      state.get<Passive>() = kj::mv(paf.fulfiller);\n    } else {\n      target = state.get<Active>()();\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  void CapRedirector::setDisconnected(uint oldIteration) {\n    if (iteration == oldIteration) {\n      // Our current client was disconnected.\n      ++iteration;\n  \n      if (state.is<Passive>()) {\n        auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n        target = kj::mv(paf.promise);\n        state.get<Passive>() = kj::mv(paf.fulfiller);\n      } else {\n        target = state.get<Active>()();\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e2.getType",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"dummy ping request should have failed with UNIMPLEMENTED\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.send",
          "args": [],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ping.initAsAnyStruct",
          "args": [
            "0",
            "0"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.typelessRequest",
          "args": [
            "0",
            "65535",
            "capnp::MessageSize { 4, 0 }"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [
            "response"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [
            "response.targetSize()"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.targetSize",
          "args": [],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.set",
          "args": [
            "params"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.typelessRequest",
          "args": [
            "interfaceId",
            "methodId",
            "params.targetSize()"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.targetSize",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  kj::Promise<void> CapRedirector::dispatchCall(\n      uint64_t interfaceId, uint16_t methodId,\n      capnp::CallContext<capnp::AnyPointer, capnp::AnyPointer> context) {\n    capnp::AnyPointer::Reader params = context.getParams();\n    auto req = target.typelessRequest(interfaceId, methodId, params.targetSize());\n    req.set(params);\n  \n    auto oldIteration = iteration;\n  \n    return req.send().then([context](auto&& response) mutable -> kj::Promise<void> {\n      context.initResults(response.targetSize()).set(response);\n      return kj::READY_NOW;\n    }, [this,oldIteration](kj::Exception&& e) -> kj::Promise<void> {\n      if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n        return kj::mv(e);\n      }\n  \n      // Disconnected. Did we notice already?\n      if (iteration > oldIteration) {\n        // Yes, so stop here.\n        return kj::mv(e);\n      }\n  \n      // OK, this disconnect is new to us. We need to determine if this disconnected capability\n      // is our direct target or something else that was accessed as part of the call. So, send\n      // a dummy call to check.\n      auto ping = target.typelessRequest(0, 65535, capnp::MessageSize { 4, 0 });\n      ping.initAsAnyStruct(0, 0);\n      return ping.send().then([](auto&&) -> void {\n        KJ_LOG(ERROR, \"dummy ping request should have failed with UNIMPLEMENTED\");\n        // But clearly we are still connected, so don't call setDisconnected()...\n      }, [this,oldIteration](kj::Exception&& e2) {\n        if (e2.getType() == kj::Exception::Type::DISCONNECTED) {\n          // Yep, really disconnected.\n          setDisconnected(oldIteration);\n        }\n      }).then([KJ_MVCAP(e)]() mutable -> kj::Promise<void> {\n        return kj::mv(e);\n      });\n    });\n  }\n}"
  },
  {
    "function_name": "setDisconnected",
    "container": "CapRedirector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1151-1164",
    "snippet": "void CapRedirector::setDisconnected(uint oldIteration) {\n  if (iteration == oldIteration) {\n    // Our current client was disconnected.\n    ++iteration;\n\n    if (state.is<Passive>()) {\n      auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n      target = kj::mv(paf.promise);\n      state.get<Passive>() = kj::mv(paf.fulfiller);\n    } else {\n      target = state.get<Active>()();\n    }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.get<Active>",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.get<Active>",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.get<Passive>",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<capnp::Capability::Client>",
          "args": [],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.is<Passive>",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  void CapRedirector::setDisconnected(uint oldIteration) {\n    if (iteration == oldIteration) {\n      // Our current client was disconnected.\n      ++iteration;\n  \n      if (state.is<Passive>()) {\n        auto paf = kj::newPromiseAndFulfiller<capnp::Capability::Client>();\n        target = kj::mv(paf.promise);\n        state.get<Passive>() = kj::mv(paf.fulfiller);\n      } else {\n        target = state.get<Active>()();\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "setTarget",
    "container": "CapRedirector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1139-1149",
    "snippet": "uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n  KJ_REQUIRE(state.is<Passive>());\n\n  ++iteration;\n  target = newTarget;\n\n  // If the previous target was a promise target, fulfill it.\n  state.get<Passive>()->fulfill(kj::mv(newTarget));\n\n  return iteration;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.get<Passive>",
          "args": [
            "kj::mv(newTarget)"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "RequestSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "2053-2107",
          "snippet": "kj::Promise<void> get(GetContext context) override {\n    auto params = context.getParams();\n    auto path = params.getPath();\n    auto results = context.getResults();\n\n    if (path == \"\") {\n      // Determine the subset of PowerboxApis which the user has permission to choose.\n      //\n      // TODO(soon): Also match against descriptors.\n      kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n      for (auto api: bridgeContext.getPowerboxApis()) {\n        bool requirementsMet = true;\n\n        if (api.hasPermissions()) {\n          auto requiredPermissions = api.getPermissions();\n          for (size_t i: kj::indices(requiredPermissions)) {\n            if (requiredPermissions[i]) {\n              if (permissions.size() <= i || !permissions[i]) {\n                requirementsMet = false;\n                break;\n              }\n            }\n          }\n        }\n\n        if (requirementsMet) {\n          apis.add(api);\n        }\n      }\n\n      // JSON-ify that list as the config blob.\n      capnp::MallocMessageBuilder filteredConfig;\n      auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n      for (size_t i: kj::indices(apis)) {\n        list.setWithCaveats(i, apis[i]);\n      }\n\n      capnp::JsonCodec codec;\n      auto config = codec.encode(list);\n\n      // Send back our static HTML with the config blob injected into it.\n      auto content = results.initContent();\n      content.setMimeType(\"text/html; charset=UTF-8\");\n      auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n      memcpy(body.begin(), prefix.begin(), prefix.size());\n      memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n      memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n      return kj::READY_NOW;\n    } else {\n      auto error = results.initClientError();\n      error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n      error.setDescriptionHtml(\"404 not found\");\n      return kj::READY_NOW;\n    }\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "BridgeContext& bridgeContext;",
            "kj::String permissions;",
            "spk::BridgeConfig::Reader config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nBridgeContext& bridgeContext;\nkj::String permissions;\nspk::BridgeConfig::Reader config;\n\nRequestSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      auto params = context.getParams();\n      auto path = params.getPath();\n      auto results = context.getResults();\n  \n      if (path == \"\") {\n        // Determine the subset of PowerboxApis which the user has permission to choose.\n        //\n        // TODO(soon): Also match against descriptors.\n        kj::Vector<spk::BridgeConfig::PowerboxApi::Reader> apis;\n        for (auto api: bridgeContext.getPowerboxApis()) {\n          bool requirementsMet = true;\n  \n          if (api.hasPermissions()) {\n            auto requiredPermissions = api.getPermissions();\n            for (size_t i: kj::indices(requiredPermissions)) {\n              if (requiredPermissions[i]) {\n                if (permissions.size() <= i || !permissions[i]) {\n                  requirementsMet = false;\n                  break;\n                }\n              }\n            }\n          }\n  \n          if (requirementsMet) {\n            apis.add(api);\n          }\n        }\n  \n        // JSON-ify that list as the config blob.\n        capnp::MallocMessageBuilder filteredConfig;\n        auto list = filteredConfig.getRoot<spk::BridgeConfig>().initPowerboxApis(apis.size());\n        for (size_t i: kj::indices(apis)) {\n          list.setWithCaveats(i, apis[i]);\n        }\n  \n        capnp::JsonCodec codec;\n        auto config = codec.encode(list);\n  \n        // Send back our static HTML with the config blob injected into it.\n        auto content = results.initContent();\n        content.setMimeType(\"text/html; charset=UTF-8\");\n        auto body = content.initBody().initBytes(prefix.size() + config.size() + suffix.size());\n        memcpy(body.begin(), prefix.begin(), prefix.size());\n        memcpy(body.begin() + prefix.size(), config.begin(), config.size());\n        memcpy(body.begin() + prefix.size() + config.size(), suffix.begin(), suffix.size());\n        return kj::READY_NOW;\n      } else {\n        auto error = results.initClientError();\n        error.setStatusCode(WebSession::Response::ClientErrorCode::NOT_FOUND);\n        error.setDescriptionHtml(\"404 not found\");\n        return kj::READY_NOW;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newTarget"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.get<Passive>",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "state.is<Passive>()"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.is<Passive>",
          "args": [],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  uint CapRedirector::setTarget(capnp::Capability::Client newTarget) {\n    KJ_REQUIRE(state.is<Passive>());\n  \n    ++iteration;\n    target = newTarget;\n  \n    // If the previous target was a promise target, fulfill it.\n    state.get<Passive>()->fulfill(kj::mv(newTarget));\n  \n    return iteration;\n  }\n}"
  },
  {
    "function_name": "CapRedirector",
    "container": "CapRedirector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1134-1137",
    "snippet": "CapRedirector::CapRedirector(kj::PromiseFulfillerPair<capnp::Capability::Client> paf)\n    : target(kj::mv(paf.promise)) {\n  state.init<Passive>(kj::mv(paf.fulfiller));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.init<Passive>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  CapRedirector::CapRedirector(kj::PromiseFulfillerPair<capnp::Capability::Client> paf)\n      : target(kj::mv(paf.promise)) {\n    state.init<Passive>(kj::mv(paf.fulfiller));\n  }\n}"
  },
  {
    "function_name": "CapRedirector",
    "container": "CapRedirector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1129-1132",
    "snippet": "CapRedirector::CapRedirector(kj::Function<capnp::Capability::Client()> reconnect)\n    : target(reconnect()) {\n  state.init<Active>(kj::mv(reconnect));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.init<Active>",
          "args": [
            "kj::mv(reconnect)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reconnect"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reconnect",
          "args": [],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nCapRedirector {\n  CapRedirector::CapRedirector(kj::Function<capnp::Capability::Client()> reconnect)\n      : target(reconnect()) {\n    state.init<Active>(kj::mv(reconnect));\n  }\n}"
  },
  {
    "function_name": "alreadyReaped",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1123-1125",
    "snippet": "void SubprocessSet::alreadyReaped(pid_t pid) {\n  waitMap->pids.erase(pid);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitMap->pids.erase",
          "args": [
            "pid"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  void SubprocessSet::alreadyReaped(pid_t pid) {\n    waitMap->pids.erase(pid);\n  }\n}"
  },
  {
    "function_name": "waitLoop",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1101-1121",
    "snippet": "kj::Promise<void> SubprocessSet::waitLoop() {\n  return eventPort.onSignal(SIGCHLD).then([this](auto&&) {\n    while (!waitMap->pids.empty()) {\n      int status;\n      pid_t pid;\n      KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n      if (pid == 0) break;\n\n      auto iter = waitMap->pids.find(pid);\n      if (iter == waitMap->pids.end()) {\n        KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                      \"outside this set?\", pid);\n      } else {\n        iter->second.subprocess->notifyExited(status);\n        iter->second.fulfiller->fulfill(kj::mv(status));\n        waitMap->pids.erase(iter);\n      }\n    }\n    return waitLoop();\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "[this](auto&&) {\n    while (!waitMap->pids.empty()) {\n      int status;\n      pid_t pid;\n      KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n      if (pid == 0) break;\n\n      auto iter = waitMap->pids.find(pid);\n      if (iter == waitMap->pids.end()) {\n        KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                      \"outside this set?\", pid);\n      } else {\n        iter->second.subprocess->notifyExited(status);\n        iter->second.fulfiller->fulfill(kj::mv(status));\n        waitMap->pids.erase(iter);\n      }\n    }\n    return waitLoop();\n  }"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitLoop",
          "args": [],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "waitLoop",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1101-1121",
          "snippet": "kj::Promise<void> SubprocessSet::waitLoop() {\n  return eventPort.onSignal(SIGCHLD).then([this](auto&&) {\n    while (!waitMap->pids.empty()) {\n      int status;\n      pid_t pid;\n      KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n      if (pid == 0) break;\n\n      auto iter = waitMap->pids.find(pid);\n      if (iter == waitMap->pids.end()) {\n        KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                      \"outside this set?\", pid);\n      } else {\n        iter->second.subprocess->notifyExited(status);\n        iter->second.fulfiller->fulfill(kj::mv(status));\n        waitMap->pids.erase(iter);\n      }\n    }\n    return waitLoop();\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "waitMap->pids.erase",
          "args": [
            "iter"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.fulfiller->fulfill",
          "args": [
            "kj::mv(status)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "status"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.subprocess->notifyExited",
          "args": [
            "status"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "notifyExited",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "374-383",
          "snippet": "void notifyExited(int status) {\n    // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n    // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n    // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n    //\n    // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n    //   async I/O.\n\n    pid = 0;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  void notifyExited(int status) {\n      // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n      // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n      // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n      //\n      // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n      //   async I/O.\n  \n      pid = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"waitpid() returned unexpected PID; is this process running subprocesses \"\n                      \"outside this set?\"",
            "pid"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitMap->pids.end",
          "args": [],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitMap->pids.find",
          "args": [
            "pid"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pid = waitpid(-1, &status, WNOHANG)"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "WNOHANG"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitMap->pids.empty",
          "args": [],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.onSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<void> SubprocessSet::waitLoop() {\n    return eventPort.onSignal(SIGCHLD).then([this](auto&&) {\n      while (!waitMap->pids.empty()) {\n        int status;\n        pid_t pid;\n        KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n        if (pid == 0) break;\n  \n        auto iter = waitMap->pids.find(pid);\n        if (iter == waitMap->pids.end()) {\n          KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                        \"outside this set?\", pid);\n        } else {\n          iter->second.subprocess->notifyExited(status);\n          iter->second.fulfiller->fulfill(kj::mv(status));\n          waitMap->pids.erase(iter);\n        }\n      }\n      return waitLoop();\n    });\n  }\n}"
  },
  {
    "function_name": "waitForExitOrSignal",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1095-1099",
    "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExitOrSignal(*heap);\n  return promise.attach(kj::mv(heap));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(heap)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "heap"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForExitOrSignal",
          "args": [
            "*heap"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1095-1099",
          "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExitOrSignal(*heap);\n  return promise.attach(kj::mv(heap));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<Subprocess>",
          "args": [
            "kj::mv(subprocess)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "subprocess"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForExitOrSignal(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
  },
  {
    "function_name": "waitForExit",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1090-1094",
    "snippet": "kj::Promise<int> SubprocessSet::waitForExit(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExit(*heap);\n  return promise.attach(kj::mv(heap));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(heap)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "heap"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForExit",
          "args": [
            "*heap"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1095-1099",
          "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExitOrSignal(*heap);\n  return promise.attach(kj::mv(heap));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForExitOrSignal(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<Subprocess>",
          "args": [
            "kj::mv(subprocess)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "subprocess"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExit(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForExit(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
  },
  {
    "function_name": "waitForSuccess",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1085-1089",
    "snippet": "kj::Promise<void> SubprocessSet::waitForSuccess(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForSuccess(*heap);\n  return promise.attach(kj::mv(heap));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.attach",
          "args": [
            "kj::mv(heap)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "heap"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForSuccess",
          "args": [
            "*heap"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1085-1089",
          "snippet": "kj::Promise<void> SubprocessSet::waitForSuccess(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForSuccess(*heap);\n  return promise.attach(kj::mv(heap));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<Subprocess>",
          "args": [
            "kj::mv(subprocess)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "subprocess"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<void> SubprocessSet::waitForSuccess(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForSuccess(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
  },
  {
    "function_name": "waitForExitOrSignal",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1075-1083",
    "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess& subprocess) {\n  auto paf = kj::newPromiseAndFulfiller<int>();\n  waitMap->pids.insert(std::make_pair(subprocess.getPid(),\n      WaitMap::ProcInfo { kj::mv(paf.fulfiller), &subprocess }));\n  subprocess.subprocessSet = *this;\n  return paf.promise.then([&subprocess](int status) {\n    return status;\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&subprocess](int status) {\n    return status;\n  }"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitMap->pids.insert",
          "args": [
            "std::make_pair(subprocess.getPid(),\n      WaitMap::ProcInfo { kj::mv(paf.fulfiller), &subprocess })"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "subprocess.getPid()",
            "WaitMap::ProcInfo { kj::mv(paf.fulfiller), &subprocess }"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subprocess.getPid",
          "args": [],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "getPid",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "365-368",
          "snippet": "pid_t getPid() {\n    KJ_IREQUIRE(pid != 0, \"already exited\");\n    return pid;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  pid_t getPid() {\n      KJ_IREQUIRE(pid != 0, \"already exited\");\n      return pid;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<int>",
          "args": [],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess& subprocess) {\n    auto paf = kj::newPromiseAndFulfiller<int>();\n    waitMap->pids.insert(std::make_pair(subprocess.getPid(),\n        WaitMap::ProcInfo { kj::mv(paf.fulfiller), &subprocess }));\n    subprocess.subprocessSet = *this;\n    return paf.promise.then([&subprocess](int status) {\n      return status;\n    });\n  }\n}"
  },
  {
    "function_name": "waitForExit",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1062-1073",
    "snippet": "kj::Promise<int> SubprocessSet::waitForExit(Subprocess& subprocess) {\n  return waitForExitOrSignal(subprocess).then([&subprocess](int status) {\n    if (WIFEXITED(status)) {\n      return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n      int signo = WTERMSIG(status);\n      KJ_FAIL_ASSERT(\"child process killed by signal\", subprocess.name, signo, strsignal(signo));\n    } else {\n      KJ_FAIL_ASSERT(\"unknown child wait status\", subprocess.name, status);\n    }\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitForExitOrSignal",
          "args": [
            "[&subprocess](int status) {\n    if (WIFEXITED(status)) {\n      return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n      int signo = WTERMSIG(status);\n      KJ_FAIL_ASSERT(\"child process killed by signal\", subprocess.name, signo, strsignal(signo));\n    } else {\n      KJ_FAIL_ASSERT(\"unknown child wait status\", subprocess.name, status);\n    }\n  }"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1095-1099",
          "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExitOrSignal(*heap);\n  return promise.attach(kj::mv(heap));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForExitOrSignal(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"unknown child wait status\"",
            "subprocess.name",
            "status"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"child process killed by signal\"",
            "subprocess.name",
            "signo",
            "strsignal(signo)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "signo"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExit(Subprocess& subprocess) {\n    return waitForExitOrSignal(subprocess).then([&subprocess](int status) {\n      if (WIFEXITED(status)) {\n        return WEXITSTATUS(status);\n      } else if (WIFSIGNALED(status)) {\n        int signo = WTERMSIG(status);\n        KJ_FAIL_ASSERT(\"child process killed by signal\", subprocess.name, signo, strsignal(signo));\n      } else {\n        KJ_FAIL_ASSERT(\"unknown child wait status\", subprocess.name, status);\n      }\n    });\n  }\n}"
  },
  {
    "function_name": "waitForSuccess",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1056-1060",
    "snippet": "kj::Promise<void> SubprocessSet::waitForSuccess(Subprocess& subprocess) {\n  return waitForExit(subprocess).then([&subprocess](int exitCode) {\n    KJ_ASSERT(exitCode == 0, \"child process failed\", subprocess.name, exitCode);\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitForExit",
          "args": [
            "[&subprocess](int exitCode) {\n    KJ_ASSERT(exitCode == 0, \"child process failed\", subprocess.name, exitCode);\n  }"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1095-1099",
          "snippet": "kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n  auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n  auto promise = waitForExitOrSignal(*heap);\n  return promise.attach(kj::mv(heap));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<int> SubprocessSet::waitForExitOrSignal(Subprocess&& subprocess) {\n    auto heap = kj::heap<Subprocess>(kj::mv(subprocess));\n    auto promise = waitForExitOrSignal(*heap);\n    return promise.attach(kj::mv(heap));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "exitCode == 0",
            "\"child process failed\"",
            "subprocess.name",
            "exitCode"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<void> SubprocessSet::waitForSuccess(Subprocess& subprocess) {\n    return waitForExit(subprocess).then([&subprocess](int exitCode) {\n      KJ_ASSERT(exitCode == 0, \"child process failed\", subprocess.name, exitCode);\n    });\n  }\n}"
  },
  {
    "function_name": "~SubprocessSet",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1054-1054",
    "snippet": "SubprocessSet::~SubprocessSet() noexcept(false) {}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  SubprocessSet::~SubprocessSet() noexcept(false) {}\n}"
  },
  {
    "function_name": "SubprocessSet",
    "container": "SubprocessSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1044-1052",
    "snippet": "SubprocessSet::SubprocessSet(kj::UnixEventPort& eventPort)\n    : eventPort(eventPort), waitMap(kj::heap<WaitMap>()),\n      waitTask(waitLoop().eagerlyEvaluate([](kj::Exception&& exception) {\n        KJ_LOG(FATAL, \"subprocess wait loop failed\", exception);\n        // The server is probably hosed by this. Best to abort.\n        abort();\n      })) {\n  kj::UnixEventPort::captureSignal(SIGCHLD);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::UnixEventPort::captureSignal",
          "args": [
            "SIGCHLD"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitLoop",
          "args": [
            "[](kj::Exception&& exception) {\n        KJ_LOG(FATAL, \"subprocess wait loop failed\", exception);\n        // The server is probably hosed by this. Best to abort.\n        abort();\n      }"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "FATAL",
            "\"subprocess wait loop failed\"",
            "exception"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitLoop",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "waitLoop",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1101-1121",
          "snippet": "kj::Promise<void> SubprocessSet::waitLoop() {\n  return eventPort.onSignal(SIGCHLD).then([this](auto&&) {\n    while (!waitMap->pids.empty()) {\n      int status;\n      pid_t pid;\n      KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n      if (pid == 0) break;\n\n      auto iter = waitMap->pids.find(pid);\n      if (iter == waitMap->pids.end()) {\n        KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                      \"outside this set?\", pid);\n      } else {\n        iter->second.subprocess->notifyExited(status);\n        iter->second.fulfiller->fulfill(kj::mv(status));\n        waitMap->pids.erase(iter);\n      }\n    }\n    return waitLoop();\n  });\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  kj::Promise<void> SubprocessSet::waitLoop() {\n    return eventPort.onSignal(SIGCHLD).then([this](auto&&) {\n      while (!waitMap->pids.empty()) {\n        int status;\n        pid_t pid;\n        KJ_SYSCALL(pid = waitpid(-1, &status, WNOHANG));\n        if (pid == 0) break;\n  \n        auto iter = waitMap->pids.find(pid);\n        if (iter == waitMap->pids.end()) {\n          KJ_LOG(ERROR, \"waitpid() returned unexpected PID; is this process running subprocesses \"\n                        \"outside this set?\", pid);\n        } else {\n          iter->second.subprocess->notifyExited(status);\n          iter->second.fulfiller->fulfill(kj::mv(status));\n          waitMap->pids.erase(iter);\n        }\n      }\n      return waitLoop();\n    });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<WaitMap>",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  SubprocessSet::SubprocessSet(kj::UnixEventPort& eventPort)\n      : eventPort(eventPort), waitMap(kj::heap<WaitMap>()),\n        waitTask(waitLoop().eagerlyEvaluate([](kj::Exception&& exception) {\n          KJ_LOG(FATAL, \"subprocess wait loop failed\", exception);\n          // The server is probably hosed by this. Best to abort.\n          abort();\n        })) {\n    kj::UnixEventPort::captureSignal(SIGCHLD);\n  }\n}"
  },
  {
    "function_name": "forceFdAbove",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1021-1031",
    "snippet": "void Subprocess::forceFdAbove(int& fd, int minValue) {\n  // Force `fd` to have a numeric value of at least `minValue`.\n\n  if (fd < minValue) {\n    // We'll need to move this FD to a different slot. fcntl()'s F_DUPFD searches for a slot\n    // greater than or equal to some value, which is exactly what we need! We want to set\n    // O_CLOEXEC on this new FD because it is NOT the FD that we plan to keep in the child process;\n    // we still plan to dup2() it back to the right slot.\n    KJ_SYSCALL(fd = fcntl(fd, F_DUPFD_CLOEXEC, minValue));\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = fcntl(fd, F_DUPFD_CLOEXEC, minValue)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_DUPFD_CLOEXEC",
            "minValue"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::forceFdAbove(int& fd, int minValue) {\n    // Force `fd` to have a numeric value of at least `minValue`.\n  \n    if (fd < minValue) {\n      // We'll need to move this FD to a different slot. fcntl()'s F_DUPFD searches for a slot\n      // greater than or equal to some value, which is exactly what we need! We want to set\n      // O_CLOEXEC on this new FD because it is NOT the FD that we plan to keep in the child process;\n      // we still plan to dup2() it back to the right slot.\n      KJ_SYSCALL(fd = fcntl(fd, F_DUPFD_CLOEXEC, minValue));\n    }\n  }\n}"
  },
  {
    "function_name": "waitForExitOrSignal",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "1010-1019",
    "snippet": "int Subprocess::waitForExitOrSignal() {\n  KJ_REQUIRE(pid != 0, \"already waited for this child\");\n  int status;\n  KJ_SYSCALL(waitpid(pid, &status, 0));\n  KJ_IF_MAYBE(s, subprocessSet) {\n    s->alreadyReaped(pid);\n  }\n  pid = 0;\n  return status;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s->alreadyReaped",
          "args": [
            "pid"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "alreadyReaped",
          "container": "SubprocessSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1123-1125",
          "snippet": "void SubprocessSet::alreadyReaped(pid_t pid) {\n  waitMap->pids.erase(pid);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocessSet {\n  void SubprocessSet::alreadyReaped(pid_t pid) {\n    waitMap->pids.erase(pid);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitpid(pid, &status, 0)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "pid != 0",
            "\"already waited for this child\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExitOrSignal() {\n    KJ_REQUIRE(pid != 0, \"already waited for this child\");\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0));\n    KJ_IF_MAYBE(s, subprocessSet) {\n      s->alreadyReaped(pid);\n    }\n    pid = 0;\n    return status;\n  }\n}"
  },
  {
    "function_name": "waitForExit",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "998-1008",
    "snippet": "int Subprocess::waitForExit() {\n  int status = waitForExitOrSignal();\n  if (WIFEXITED(status)) {\n    return WEXITSTATUS(status);\n  } else if (WIFSIGNALED(status)) {\n    int signo = WTERMSIG(status);\n    KJ_FAIL_ASSERT(\"child process killed by signal\", name, signo, strsignal(signo));\n  } else {\n    KJ_FAIL_ASSERT(\"unknown child wait status\", name, status);\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"unknown child wait status\"",
            "name",
            "status"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"child process killed by signal\"",
            "name",
            "signo",
            "strsignal(signo)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "signo"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForExitOrSignal",
          "args": [],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1010-1019",
          "snippet": "int Subprocess::waitForExitOrSignal() {\n  KJ_REQUIRE(pid != 0, \"already waited for this child\");\n  int status;\n  KJ_SYSCALL(waitpid(pid, &status, 0));\n  KJ_IF_MAYBE(s, subprocessSet) {\n    s->alreadyReaped(pid);\n  }\n  pid = 0;\n  return status;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExitOrSignal() {\n    KJ_REQUIRE(pid != 0, \"already waited for this child\");\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0));\n    KJ_IF_MAYBE(s, subprocessSet) {\n      s->alreadyReaped(pid);\n    }\n    pid = 0;\n    return status;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExit() {\n    int status = waitForExitOrSignal();\n    if (WIFEXITED(status)) {\n      return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n      int signo = WTERMSIG(status);\n      KJ_FAIL_ASSERT(\"child process killed by signal\", name, signo, strsignal(signo));\n    } else {\n      KJ_FAIL_ASSERT(\"unknown child wait status\", name, status);\n    }\n  }\n}"
  },
  {
    "function_name": "waitForSuccess",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "993-996",
    "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "exitCode == 0",
            "\"child process failed\"",
            "name",
            "exitCode"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForExit",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1010-1019",
          "snippet": "int Subprocess::waitForExitOrSignal() {\n  KJ_REQUIRE(pid != 0, \"already waited for this child\");\n  int status;\n  KJ_SYSCALL(waitpid(pid, &status, 0));\n  KJ_IF_MAYBE(s, subprocessSet) {\n    s->alreadyReaped(pid);\n  }\n  pid = 0;\n  return status;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExitOrSignal() {\n    KJ_REQUIRE(pid != 0, \"already waited for this child\");\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0));\n    KJ_IF_MAYBE(s, subprocessSet) {\n      s->alreadyReaped(pid);\n    }\n    pid = 0;\n    return status;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
  },
  {
    "function_name": "signal",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "987-991",
    "snippet": "void Subprocess::signal(int signo) {\n  if (pid != 0) {\n    KJ_SYSCALL(kill(pid, signo), name);\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "kill(pid, signo)",
            "name"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "signo"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "killChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "2377-2413",
          "snippet": "void killChild(kj::StringPtr title, pid_t pid) {\n    if (pid == 0) {\n      // We use PID = 0 to indicate that a process isn't running, so there's nothing to do.\n      context.warning(kj::str(\"Not killing \", title, \" because it is not running.\"));\n      return;\n    }\n\n    int status;\n\n    KJ_SYSCALL(kill(pid, SIGTERM));\n\n    alarmed = false;\n    uint timeout = 5;\n    KJ_SYSCALL(alarm(timeout));\n\n    for (;;) {\n      if (waitpid(pid, &status, 0) >= 0) {\n        KJ_SYSCALL(alarm(0));\n        return;\n      }\n\n      int error = errno;\n      if (error == EINTR) {\n        if (alarmed) {\n          // Termination timed out.  Kill hard.\n          context.warning(kj::str(\n              title, \" did not terminate after \", timeout, \" seconds; killing.\"));\n          KJ_SYSCALL(kill(pid, SIGKILL));\n          alarmed = false;\n        } else {\n          // Some other signal; ignore.\n        }\n      } else {\n        KJ_FAIL_SYSCALL(\"waitpid()\", error, title);\n      }\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\n\nvoid killChild(kj::StringPtr title, pid_t pid) {\n    if (pid == 0) {\n      // We use PID = 0 to indicate that a process isn't running, so there's nothing to do.\n      context.warning(kj::str(\"Not killing \", title, \" because it is not running.\"));\n      return;\n    }\n\n    int status;\n\n    KJ_SYSCALL(kill(pid, SIGTERM));\n\n    alarmed = false;\n    uint timeout = 5;\n    KJ_SYSCALL(alarm(timeout));\n\n    for (;;) {\n      if (waitpid(pid, &status, 0) >= 0) {\n        KJ_SYSCALL(alarm(0));\n        return;\n      }\n\n      int error = errno;\n      if (error == EINTR) {\n        if (alarmed) {\n          // Termination timed out.  Kill hard.\n          context.warning(kj::str(\n              title, \" did not terminate after \", timeout, \" seconds; killing.\"));\n          KJ_SYSCALL(kill(pid, SIGKILL));\n          alarmed = false;\n        } else {\n          // Some other signal; ignore.\n        }\n      } else {\n        KJ_FAIL_SYSCALL(\"waitpid()\", error, title);\n      }\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::signal(int signo) {\n    if (pid != 0) {\n      KJ_SYSCALL(kill(pid, signo), name);\n    }\n  }\n}"
  },
  {
    "function_name": "~Subprocess",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "978-985",
    "snippet": "Subprocess::~Subprocess() noexcept(false) {\n  if (pid != 0) {\n    unwindDetector.catchExceptionsIfUnwinding([this]() {\n      signal(SIGKILL);\n      (void)waitForExitOrSignal();\n    });\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unwindDetector.catchExceptionsIfUnwinding",
          "args": [
            "[this]() {\n      signal(SIGKILL);\n      (void)waitForExitOrSignal();\n    }"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitForExitOrSignal",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "waitForExitOrSignal",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1010-1019",
          "snippet": "int Subprocess::waitForExitOrSignal() {\n  KJ_REQUIRE(pid != 0, \"already waited for this child\");\n  int status;\n  KJ_SYSCALL(waitpid(pid, &status, 0));\n  KJ_IF_MAYBE(s, subprocessSet) {\n    s->alreadyReaped(pid);\n  }\n  pid = 0;\n  return status;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  int Subprocess::waitForExitOrSignal() {\n    KJ_REQUIRE(pid != 0, \"already waited for this child\");\n    int status;\n    KJ_SYSCALL(waitpid(pid, &status, 0));\n    KJ_IF_MAYBE(s, subprocessSet) {\n      s->alreadyReaped(pid);\n    }\n    pid = 0;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGKILL"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "signal",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "987-991",
          "snippet": "void Subprocess::signal(int signo) {\n  if (pid != 0) {\n    KJ_SYSCALL(kill(pid, signo), name);\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::signal(int signo) {\n    if (pid != 0) {\n      KJ_SYSCALL(kill(pid, signo), name);\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  Subprocess::~Subprocess() noexcept(false) {\n    if (pid != 0) {\n      unwindDetector.catchExceptionsIfUnwinding([this]() {\n        signal(SIGKILL);\n        (void)waitForExitOrSignal();\n      });\n    }\n  }\n}"
  },
  {
    "function_name": "Subprocess",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "965-976",
    "snippet": "Subprocess::Subprocess(kj::Function<int()> func) {\n  KJ_SYSCALL(pid = fork());\n  if (pid == 0) {\n    KJ_DEFER(_exit(1));  // Do not under any circumstances return from this stack frame!\n\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      _exit(func());\n    })) {\n      KJ_LOG(FATAL, *exception);\n    }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "FATAL",
            "*exception"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n      _exit(func());\n    })"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      _exit(func());\n    }"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "func()"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "_exit(1)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pid = fork()"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  Subprocess::Subprocess(kj::Function<int()> func) {\n    KJ_SYSCALL(pid = fork());\n    if (pid == 0) {\n      KJ_DEFER(_exit(1));  // Do not under any circumstances return from this stack frame!\n  \n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        _exit(func());\n      })) {\n        KJ_LOG(FATAL, *exception);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "Subprocess",
    "container": "Subprocess",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "873-963",
    "snippet": "Subprocess::Subprocess(Options&& options)\n    : name(kj::heapString(options.argv.size() > 0 ? options.argv[0] : options.executable)) {\n  KJ_SYSCALL(pid = fork());\n  if (pid == 0) {\n    KJ_DEFER(_exit(1));  // Do not under any circumstances return from this stack frame!\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n      // code likes to ignore e.g. SIGPIPE.)\n      // TODO(cleanup):  Is there a better way to do this?\n      for (uint i = 0; i < NSIG; i++) {\n        ::signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n      }\n\n      // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n      sigset_t sigmask;\n      sigemptyset(&sigmask);\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n\n      // Make sure all of the incoming FDs are outside of our map range (except for standard I/O if\n      // it is already exactly in the right slot).\n      int minFd = STDERR_FILENO + options.moreFds.size() + 1;\n\n      if (options.stdin != STDIN_FILENO) forceFdAbove(options.stdin, minFd);\n      if (options.stdout != STDOUT_FILENO) forceFdAbove(options.stdout, minFd);\n      if (options.stderr != STDERR_FILENO) forceFdAbove(options.stderr, minFd);\n\n      // Now remap.\n      for (auto& fd: options.moreFds) {\n        forceFdAbove(fd, minFd);\n      }\n\n      if (options.stdin != STDIN_FILENO) {\n        KJ_SYSCALL(dup2(options.stdin, STDIN_FILENO));\n      }\n      if (options.stdout != STDOUT_FILENO) {\n        KJ_SYSCALL(dup2(options.stdout, STDOUT_FILENO));\n      }\n      if (options.stderr != STDERR_FILENO) {\n        KJ_SYSCALL(dup2(options.stderr, STDERR_FILENO));\n      }\n\n      for (auto i: kj::indices(options.moreFds)) {\n        KJ_SYSCALL(dup2(options.moreFds[i], STDERR_FILENO + 1 + i));\n      }\n\n      // Drop privileges if requested.\n      KJ_IF_MAYBE(g, options.gid) {\n        KJ_SYSCALL(setresgid(*g, *g, *g));\n      }\n      KJ_IF_MAYBE(u, options.uid) {\n        KJ_SYSCALL(setresuid(*u, *u, *u));\n      }\n\n      // Make the args vector.\n      char* argv[options.argv.size() + 1];\n      for (auto i: kj::indices(options.argv)) {\n        // exec*() is not const-correct. :(\n        argv[i] = const_cast<char*>(options.argv[i].cStr());\n      }\n      argv[options.argv.size()] = nullptr;\n      char** argvp = argv;  // lambda can't capture variable-size array\n\n      KJ_IF_MAYBE(e, options.environment) {\n        // Make the environment vector.\n        char* environ[e->size() + 1];\n        for (auto i: kj::indices(*e)) {\n          // exec*() is not const-correct. :(\n          environ[i] = const_cast<char*>((*e)[i].cStr());\n        }\n        environ[e->size()] = nullptr;\n        char** environp = environ;  // lambda can't capture variable-size array\n\n        if (options.searchPath) {\n          KJ_SYSCALL(execvpe(options.executable.cStr(), argvp, environp), options.executable);\n        } else {\n          KJ_SYSCALL(execve(options.executable.cStr(), argvp, environp), options.executable);\n        }\n      } else {\n        if (options.searchPath) {\n          KJ_SYSCALL(execvp(options.executable.cStr(), argvp), options.executable);\n        } else {\n          KJ_SYSCALL(execv(options.executable.cStr(), argvp), options.executable);\n        }\n      }\n\n      KJ_UNREACHABLE;\n    })) {\n      KJ_LOG(FATAL, *exception);\n    }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "FATAL",
            "*exception"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n      // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n      // code likes to ignore e.g. SIGPIPE.)\n      // TODO(cleanup):  Is there a better way to do this?\n      for (uint i = 0; i < NSIG; i++) {\n        ::signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n      }\n\n      // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n      sigset_t sigmask;\n      sigemptyset(&sigmask);\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n\n      // Make sure all of the incoming FDs are outside of our map range (except for standard I/O if\n      // it is already exactly in the right slot).\n      int minFd = STDERR_FILENO + options.moreFds.size() + 1;\n\n      if (options.stdin != STDIN_FILENO) forceFdAbove(options.stdin, minFd);\n      if (options.stdout != STDOUT_FILENO) forceFdAbove(options.stdout, minFd);\n      if (options.stderr != STDERR_FILENO) forceFdAbove(options.stderr, minFd);\n\n      // Now remap.\n      for (auto& fd: options.moreFds) {\n        forceFdAbove(fd, minFd);\n      }\n\n      if (options.stdin != STDIN_FILENO) {\n        KJ_SYSCALL(dup2(options.stdin, STDIN_FILENO));\n      }\n      if (options.stdout != STDOUT_FILENO) {\n        KJ_SYSCALL(dup2(options.stdout, STDOUT_FILENO));\n      }\n      if (options.stderr != STDERR_FILENO) {\n        KJ_SYSCALL(dup2(options.stderr, STDERR_FILENO));\n      }\n\n      for (auto i: kj::indices(options.moreFds)) {\n        KJ_SYSCALL(dup2(options.moreFds[i], STDERR_FILENO + 1 + i));\n      }\n\n      // Drop privileges if requested.\n      KJ_IF_MAYBE(g, options.gid) {\n        KJ_SYSCALL(setresgid(*g, *g, *g));\n      }\n      KJ_IF_MAYBE(u, options.uid) {\n        KJ_SYSCALL(setresuid(*u, *u, *u));\n      }\n\n      // Make the args vector.\n      char* argv[options.argv.size() + 1];\n      for (auto i: kj::indices(options.argv)) {\n        // exec*() is not const-correct. :(\n        argv[i] = const_cast<char*>(options.argv[i].cStr());\n      }\n      argv[options.argv.size()] = nullptr;\n      char** argvp = argv;  // lambda can't capture variable-size array\n\n      KJ_IF_MAYBE(e, options.environment) {\n        // Make the environment vector.\n        char* environ[e->size() + 1];\n        for (auto i: kj::indices(*e)) {\n          // exec*() is not const-correct. :(\n          environ[i] = const_cast<char*>((*e)[i].cStr());\n        }\n        environ[e->size()] = nullptr;\n        char** environp = environ;  // lambda can't capture variable-size array\n\n        if (options.searchPath) {\n          KJ_SYSCALL(execvpe(options.executable.cStr(), argvp, environp), options.executable);\n        } else {\n          KJ_SYSCALL(execve(options.executable.cStr(), argvp, environp), options.executable);\n        }\n      } else {\n        if (options.searchPath) {\n          KJ_SYSCALL(execvp(options.executable.cStr(), argvp), options.executable);\n        } else {\n          KJ_SYSCALL(execv(options.executable.cStr(), argvp), options.executable);\n        }\n      }\n\n      KJ_UNREACHABLE;\n    })"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n      // code likes to ignore e.g. SIGPIPE.)\n      // TODO(cleanup):  Is there a better way to do this?\n      for (uint i = 0; i < NSIG; i++) {\n        ::signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n      }\n\n      // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n      sigset_t sigmask;\n      sigemptyset(&sigmask);\n      KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n\n      // Make sure all of the incoming FDs are outside of our map range (except for standard I/O if\n      // it is already exactly in the right slot).\n      int minFd = STDERR_FILENO + options.moreFds.size() + 1;\n\n      if (options.stdin != STDIN_FILENO) forceFdAbove(options.stdin, minFd);\n      if (options.stdout != STDOUT_FILENO) forceFdAbove(options.stdout, minFd);\n      if (options.stderr != STDERR_FILENO) forceFdAbove(options.stderr, minFd);\n\n      // Now remap.\n      for (auto& fd: options.moreFds) {\n        forceFdAbove(fd, minFd);\n      }\n\n      if (options.stdin != STDIN_FILENO) {\n        KJ_SYSCALL(dup2(options.stdin, STDIN_FILENO));\n      }\n      if (options.stdout != STDOUT_FILENO) {\n        KJ_SYSCALL(dup2(options.stdout, STDOUT_FILENO));\n      }\n      if (options.stderr != STDERR_FILENO) {\n        KJ_SYSCALL(dup2(options.stderr, STDERR_FILENO));\n      }\n\n      for (auto i: kj::indices(options.moreFds)) {\n        KJ_SYSCALL(dup2(options.moreFds[i], STDERR_FILENO + 1 + i));\n      }\n\n      // Drop privileges if requested.\n      KJ_IF_MAYBE(g, options.gid) {\n        KJ_SYSCALL(setresgid(*g, *g, *g));\n      }\n      KJ_IF_MAYBE(u, options.uid) {\n        KJ_SYSCALL(setresuid(*u, *u, *u));\n      }\n\n      // Make the args vector.\n      char* argv[options.argv.size() + 1];\n      for (auto i: kj::indices(options.argv)) {\n        // exec*() is not const-correct. :(\n        argv[i] = const_cast<char*>(options.argv[i].cStr());\n      }\n      argv[options.argv.size()] = nullptr;\n      char** argvp = argv;  // lambda can't capture variable-size array\n\n      KJ_IF_MAYBE(e, options.environment) {\n        // Make the environment vector.\n        char* environ[e->size() + 1];\n        for (auto i: kj::indices(*e)) {\n          // exec*() is not const-correct. :(\n          environ[i] = const_cast<char*>((*e)[i].cStr());\n        }\n        environ[e->size()] = nullptr;\n        char** environp = environ;  // lambda can't capture variable-size array\n\n        if (options.searchPath) {\n          KJ_SYSCALL(execvpe(options.executable.cStr(), argvp, environp), options.executable);\n        } else {\n          KJ_SYSCALL(execve(options.executable.cStr(), argvp, environp), options.executable);\n        }\n      } else {\n        if (options.searchPath) {\n          KJ_SYSCALL(execvp(options.executable.cStr(), argvp), options.executable);\n        } else {\n          KJ_SYSCALL(execv(options.executable.cStr(), argvp), options.executable);\n        }\n      }\n\n      KJ_UNREACHABLE;\n    }"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execv(options.executable.cStr(), argvp)",
            "options.executable"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "options.executable.cStr()",
            "argvp"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.executable.cStr",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execvp(options.executable.cStr(), argvp)",
            "options.executable"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "options.executable.cStr()",
            "argvp"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.executable.cStr",
          "args": [],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "options.searchPath"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "notifyExited",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "374-383",
          "snippet": "void notifyExited(int status) {\n    // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n    // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n    // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n    //\n    // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n    //   async I/O.\n\n    pid = 0;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  void notifyExited(int status) {\n      // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n      // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n      // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n      //\n      // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n      //   async I/O.\n  \n      pid = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execve(options.executable.cStr(), argvp, environp)",
            "options.executable"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "options.executable.cStr()",
            "argvp",
            "environp"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.executable.cStr",
          "args": [],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "execvpe(options.executable.cStr(), argvp, environp)",
            "options.executable"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvpe",
          "args": [
            "options.executable.cStr()",
            "argvp",
            "environp"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.executable.cStr",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->size",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "(*e)[i].cStr()"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "*e"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "options.argv[i].cStr()"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.argv[i].cStr",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "options.argv"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setresuid(*u, *u, *u)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "*u",
            "*u",
            "*u"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setresgid(*g, *g, *g)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "*g",
            "*g",
            "*g"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(options.moreFds[i], STDERR_FILENO + 1 + i)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options.moreFds[i]",
            "STDERR_FILENO + 1 + i"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "options.moreFds"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(options.stderr, STDERR_FILENO)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options.stderr",
            "STDERR_FILENO"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(options.stdout, STDOUT_FILENO)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options.stdout",
            "STDOUT_FILENO"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(options.stdin, STDIN_FILENO)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "options.stdin",
            "STDIN_FILENO"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forceFdAbove",
          "args": [
            "fd",
            "minFd"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "forceFdAbove",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "1021-1031",
          "snippet": "void Subprocess::forceFdAbove(int& fd, int minValue) {\n  // Force `fd` to have a numeric value of at least `minValue`.\n\n  if (fd < minValue) {\n    // We'll need to move this FD to a different slot. fcntl()'s F_DUPFD searches for a slot\n    // greater than or equal to some value, which is exactly what we need! We want to set\n    // O_CLOEXEC on this new FD because it is NOT the FD that we plan to keep in the child process;\n    // we still plan to dup2() it back to the right slot.\n    KJ_SYSCALL(fd = fcntl(fd, F_DUPFD_CLOEXEC, minValue));\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::forceFdAbove(int& fd, int minValue) {\n    // Force `fd` to have a numeric value of at least `minValue`.\n  \n    if (fd < minValue) {\n      // We'll need to move this FD to a different slot. fcntl()'s F_DUPFD searches for a slot\n      // greater than or equal to some value, which is exactly what we need! We want to set\n      // O_CLOEXEC on this new FD because it is NOT the FD that we plan to keep in the child process;\n      // we still plan to dup2() it back to the right slot.\n      KJ_SYSCALL(fd = fcntl(fd, F_DUPFD_CLOEXEC, minValue));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_SETMASK, &sigmask, nullptr)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigmask",
            "nullptr"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sigmask"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::signal",
          "args": [
            "i",
            "SIG_DFL"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "_exit(1)"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pid = fork()"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "options.argv.size() > 0 ? options.argv[0] : options.executable"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  Subprocess::Subprocess(Options&& options)\n      : name(kj::heapString(options.argv.size() > 0 ? options.argv[0] : options.executable)) {\n    KJ_SYSCALL(pid = fork());\n    if (pid == 0) {\n      KJ_DEFER(_exit(1));  // Do not under any circumstances return from this stack frame!\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        // Reset all signal handlers to default.  (exec() will leave ignored signals ignored, and KJ\n        // code likes to ignore e.g. SIGPIPE.)\n        // TODO(cleanup):  Is there a better way to do this?\n        for (uint i = 0; i < NSIG; i++) {\n          ::signal(i, SIG_DFL);  // Only possible error is EINVAL (invalid signum); we don't care.\n        }\n  \n        // Unblock all signals.  (Yes, the signal mask is inherited over exec...)\n        sigset_t sigmask;\n        sigemptyset(&sigmask);\n        KJ_SYSCALL(sigprocmask(SIG_SETMASK, &sigmask, nullptr));\n  \n        // Make sure all of the incoming FDs are outside of our map range (except for standard I/O if\n        // it is already exactly in the right slot).\n        int minFd = STDERR_FILENO + options.moreFds.size() + 1;\n  \n        if (options.stdin != STDIN_FILENO) forceFdAbove(options.stdin, minFd);\n        if (options.stdout != STDOUT_FILENO) forceFdAbove(options.stdout, minFd);\n        if (options.stderr != STDERR_FILENO) forceFdAbove(options.stderr, minFd);\n  \n        // Now remap.\n        for (auto& fd: options.moreFds) {\n          forceFdAbove(fd, minFd);\n        }\n  \n        if (options.stdin != STDIN_FILENO) {\n          KJ_SYSCALL(dup2(options.stdin, STDIN_FILENO));\n        }\n        if (options.stdout != STDOUT_FILENO) {\n          KJ_SYSCALL(dup2(options.stdout, STDOUT_FILENO));\n        }\n        if (options.stderr != STDERR_FILENO) {\n          KJ_SYSCALL(dup2(options.stderr, STDERR_FILENO));\n        }\n  \n        for (auto i: kj::indices(options.moreFds)) {\n          KJ_SYSCALL(dup2(options.moreFds[i], STDERR_FILENO + 1 + i));\n        }\n  \n        // Drop privileges if requested.\n        KJ_IF_MAYBE(g, options.gid) {\n          KJ_SYSCALL(setresgid(*g, *g, *g));\n        }\n        KJ_IF_MAYBE(u, options.uid) {\n          KJ_SYSCALL(setresuid(*u, *u, *u));\n        }\n  \n        // Make the args vector.\n        char* argv[options.argv.size() + 1];\n        for (auto i: kj::indices(options.argv)) {\n          // exec*() is not const-correct. :(\n          argv[i] = const_cast<char*>(options.argv[i].cStr());\n        }\n        argv[options.argv.size()] = nullptr;\n        char** argvp = argv;  // lambda can't capture variable-size array\n  \n        KJ_IF_MAYBE(e, options.environment) {\n          // Make the environment vector.\n          char* environ[e->size() + 1];\n          for (auto i: kj::indices(*e)) {\n            // exec*() is not const-correct. :(\n            environ[i] = const_cast<char*>((*e)[i].cStr());\n          }\n          environ[e->size()] = nullptr;\n          char** environp = environ;  // lambda can't capture variable-size array\n  \n          if (options.searchPath) {\n            KJ_SYSCALL(execvpe(options.executable.cStr(), argvp, environp), options.executable);\n          } else {\n            KJ_SYSCALL(execve(options.executable.cStr(), argvp, environp), options.executable);\n          }\n        } else {\n          if (options.searchPath) {\n            KJ_SYSCALL(execvp(options.executable.cStr(), argvp), options.executable);\n          } else {\n            KJ_SYSCALL(execv(options.executable.cStr(), argvp), options.executable);\n          }\n        }\n  \n        KJ_UNREACHABLE;\n      })) {\n        KJ_LOG(FATAL, *exception);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "matches",
    "container": "HeaderWhitelist",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "842-869",
    "snippet": "bool HeaderWhitelist::matches(kj::StringPtr header) const {\n  // Convert to lower-case on stack.\n  KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n  memcpy(buffer.begin(), header.begin(), buffer.size());\n  toLower(buffer);\n  header = kj::StringPtr(buffer.begin(), header.size());\n\n  auto iter = patterns.lower_bound(header);\n  if (iter != patterns.end() && *iter == header) {\n    return true;\n  }\n\n  if (iter == patterns.begin()) return false;\n\n  // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n  // because the character '*' sorts before all characters that are valid inside headers.\n  --iter;\n  if (iter->endsWith(\"*\")) {\n    // Check if prefix matches.\n    auto prefix = iter->slice(0, iter->size() - 1);\n    if (header.size() >= prefix.size() &&\n        memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "header.begin()",
            "prefix.begin()",
            "prefix.size()"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.begin",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header.begin",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->slice",
          "args": [
            "0",
            "iter->size() - 1"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->endsWith",
          "args": [
            "\"*\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patterns.begin",
          "args": [],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patterns.end",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patterns.lower_bound",
          "args": [
            "header"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "buffer.begin()",
            "header.size()"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toLower",
          "args": [
            "buffer"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "toLower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "206-212",
          "snippet": "void toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer.begin()",
            "header.begin()",
            "buffer.size()"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "header.begin",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nHeaderWhitelist {\n  bool HeaderWhitelist::matches(kj::StringPtr header) const {\n    // Convert to lower-case on stack.\n    KJ_STACK_ARRAY(char, buffer, header.size() + 1, 64, 256);\n    memcpy(buffer.begin(), header.begin(), buffer.size());\n    toLower(buffer);\n    header = kj::StringPtr(buffer.begin(), header.size());\n  \n    auto iter = patterns.lower_bound(header);\n    if (iter != patterns.end() && *iter == header) {\n      return true;\n    }\n  \n    if (iter == patterns.begin()) return false;\n  \n    // If there is a prefix that matches, it will be the item immediately before the lower_bound,\n    // because the character '*' sorts before all characters that are valid inside headers.\n    --iter;\n    if (iter->endsWith(\"*\")) {\n      // Check if prefix matches.\n      auto prefix = iter->slice(0, iter->size() - 1);\n      if (header.size() >= prefix.size() &&\n          memcmp(header.begin(), prefix.begin(), prefix.size()) == 0) {\n        return true;\n      }\n    }\n  \n    return false;\n  }\n}"
  },
  {
    "function_name": "percentDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "822-840",
    "snippet": "kj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.releaseAsArray",
          "args": [],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "*ptr++"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "b"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fromDigit",
          "args": [
            "*ptr++"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "fromDigit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "789-799",
          "snippet": "static uint fromDigit(char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - ('a' - 10);\n  } else if ('A' <= c && c <= 'Z') {\n    return c - ('A' - 10);\n  } else {\n    return 0;\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nstatic uint fromDigit(char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - ('a' - 10);\n  } else if ('A' <= c && c <= 'Z') {\n    return c - ('A' - 10);\n  } else {\n    return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.cStr",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> percentDecode(kj::StringPtr text) {\n  kj::Vector<byte> result(text.size());\n\n  const char* ptr = text.cStr();\n  while (*ptr != 0) {\n    if (*ptr == '%') {\n      ++ptr;\n      if (*ptr == 0) break;\n      byte b = fromDigit(*ptr++) << 4;\n      if (*ptr == 0) break;\n      b |= fromDigit(*ptr++);\n      result.add(b);\n    } else {\n      result.add(*ptr++);\n    }\n  }\n\n  return result.releaseAsArray();\n}"
  },
  {
    "function_name": "percentEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "818-820",
    "snippet": "kj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percentEncode",
          "args": [
            "text.asBytes()"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "percentEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "818-820",
          "snippet": "kj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "text.asBytes",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String percentEncode(kj::StringPtr text) {\n  return percentEncode(text.asBytes());\n}"
  },
  {
    "function_name": "percentEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "801-816",
    "snippet": "kj::String percentEncode(kj::ArrayPtr<const byte> bytes) {\n  const char HEX_DIGITS[] = \"0123456789abcdef\";\n  kj::Vector<char> result(bytes.size() + 1);\n  for (byte b: bytes) {\n    if (('A' <= b && b <= 'Z') || ('a' <= b && b <= 'z') || ('0' <= b && b <= '9') ||\n        b == '-' || b == '_' || b == '.' || b == '~') {\n      result.add(b);\n    } else {\n      result.add('%');\n      result.add(HEX_DIGITS[b/16]);\n      result.add(HEX_DIGITS[b%16]);\n    }\n  }\n  result.add('\\0');\n  return kj::String(result.releaseAsArray());\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "result.releaseAsArray()"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.releaseAsArray",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "'\\0'"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "HEX_DIGITS[b%16]"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "HEX_DIGITS[b/16]"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "'%'"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "b"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.size",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String percentEncode(kj::ArrayPtr<const byte> bytes) {\n  const char HEX_DIGITS[] = \"0123456789abcdef\";\n  kj::Vector<char> result(bytes.size() + 1);\n  for (byte b: bytes) {\n    if (('A' <= b && b <= 'Z') || ('a' <= b && b <= 'z') || ('0' <= b && b <= '9') ||\n        b == '-' || b == '_' || b == '.' || b == '~') {\n      result.add(b);\n    } else {\n      result.add('%');\n      result.add(HEX_DIGITS[b/16]);\n      result.add(HEX_DIGITS[b%16]);\n    }\n  }\n  result.add('\\0');\n  return kj::String(result.releaseAsArray());\n}"
  },
  {
    "function_name": "fromDigit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "789-799",
    "snippet": "static uint fromDigit(char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - ('a' - 10);\n  } else if ('A' <= c && c <= 'Z') {\n    return c - ('A' - 10);\n  } else {\n    return 0;\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nstatic uint fromDigit(char c) {\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  } else if ('a' <= c && c <= 'z') {\n    return c - ('a' - 10);\n  } else if ('A' <= c && c <= 'Z') {\n    return c - ('A' - 10);\n  } else {\n    return 0;\n  }\n}"
  },
  {
    "function_name": "hexEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "784-787",
    "snippet": "kj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "KJ_MAP(b, input){ return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }",
            "\"\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<char>",
          "args": [
            "{DIGITS[b/16], DIGITS[b%16]}"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "b",
            "input"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String hexEncode(kj::ArrayPtr<const byte> input) {\n  const char DIGITS[] = \"0123456789abcdef\";\n  return kj::strArray(KJ_MAP(b, input) { return kj::heapArray<char>({DIGITS[b/16], DIGITS[b%16]}); }, \"\");\n}"
  },
  {
    "function_name": "base64Decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "764-780",
    "snippet": "kj::Array<byte> base64Decode(kj::StringPtr input) {\n  base64_decodestate state;\n  base64_init_decodestate(&state);\n\n  auto output = kj::heapArray<byte>((input.size() * 6 + 7) / 8);\n\n  size_t n = base64_decode_block(input.begin(), input.size(),\n      reinterpret_cast<char*>(output.begin()), &state);\n\n  if (n < output.size()) {\n    auto copy = kj::heapArray<byte>(n);\n    memcpy(copy.begin(), output.begin(), n);\n    output = kj::mv(copy);\n  }\n\n  return output;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "copy"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "copy.begin()",
            "output.begin()",
            "n"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.begin",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy.begin",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<byte>",
          "args": [
            "n"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.size",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base64_decode_block",
          "args": [
            "input.begin()",
            "input.size()",
            "reinterpret_cast<char*>(output.begin())",
            "&state"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "base64_decode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "702-760",
          "snippet": "int base64_decode_block(const char* code_in, const int length_in,\n                        char* plaintext_out, base64_decodestate* state_in) {\n  const char* codechar = code_in;\n  char* plainchar = plaintext_out;\n  char fragment;\n\n  *plainchar = state_in->plainchar;\n\n  switch (state_in->step)\n  {\n    while (1)\n    {\n  case step_a:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_a;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar    = (fragment & 0x03f) << 2;\n  case step_b:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_b;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x030) >> 4;\n      *plainchar    = (fragment & 0x00f) << 4;\n  case step_c:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_c;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x03c) >> 2;\n      *plainchar    = (fragment & 0x003) << 6;\n  case step_d:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_d;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++   |= (fragment & 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_decode_block(const char* code_in, const int length_in,\n                        char* plaintext_out, base64_decodestate* state_in) {\n  const char* codechar = code_in;\n  char* plainchar = plaintext_out;\n  char fragment;\n\n  *plainchar = state_in->plainchar;\n\n  switch (state_in->step)\n  {\n    while (1)\n    {\n  case step_a:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_a;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar    = (fragment & 0x03f) << 2;\n  case step_b:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_b;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x030) >> 4;\n      *plainchar    = (fragment & 0x00f) << 4;\n  case step_c:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_c;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x03c) >> 2;\n      *plainchar    = (fragment & 0x003) << 6;\n  case step_d:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_d;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++   |= (fragment & 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "output.begin()"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.begin",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.begin",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<byte>",
          "args": [
            "(input.size() * 6 + 7) / 8"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64_init_decodestate",
          "args": [
            "&state"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "base64_init_decodestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "697-700",
          "snippet": "void base64_init_decodestate(base64_decodestate* state_in) {\n  state_in->step = step_a;\n  state_in->plainchar = 0;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid base64_init_decodestate(base64_decodestate* state_in) {\n  state_in->step = step_a;\n  state_in->plainchar = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> base64Decode(kj::StringPtr input) {\n  base64_decodestate state;\n  base64_init_decodestate(&state);\n\n  auto output = kj::heapArray<byte>((input.size() * 6 + 7) / 8);\n\n  size_t n = base64_decode_block(input.begin(), input.size(),\n      reinterpret_cast<char*>(output.begin()), &state);\n\n  if (n < output.size()) {\n    auto copy = kj::heapArray<byte>(n);\n    memcpy(copy.begin(), output.begin(), n);\n    output = kj::mv(copy);\n  }\n\n  return output;\n}"
  },
  {
    "function_name": "base64_decode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "702-760",
    "snippet": "int base64_decode_block(const char* code_in, const int length_in,\n                        char* plaintext_out, base64_decodestate* state_in) {\n  const char* codechar = code_in;\n  char* plainchar = plaintext_out;\n  char fragment;\n\n  *plainchar = state_in->plainchar;\n\n  switch (state_in->step)\n  {\n    while (1)\n    {\n  case step_a:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_a;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar    = (fragment & 0x03f) << 2;\n  case step_b:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_b;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x030) >> 4;\n      *plainchar    = (fragment & 0x00f) << 4;\n  case step_c:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_c;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x03c) >> 2;\n      *plainchar    = (fragment & 0x003) << 6;\n  case step_d:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_d;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++   |= (fragment & 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base64_decode_value",
          "args": [
            "*codechar++"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "base64_decode_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "686-695",
          "snippet": "int base64_decode_value(char value_in) {\n  static const char decoding[] = {\n    62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,\n    26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const char decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in < 0 || value_in > decoding_size) return -1;\n  return decoding[(int)value_in];\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_decode_value(char value_in) {\n  static const char decoding[] = {\n    62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,\n    26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const char decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in < 0 || value_in > decoding_size) return -1;\n  return decoding[(int)value_in];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_decode_block(const char* code_in, const int length_in,\n                        char* plaintext_out, base64_decodestate* state_in) {\n  const char* codechar = code_in;\n  char* plainchar = plaintext_out;\n  char fragment;\n\n  *plainchar = state_in->plainchar;\n\n  switch (state_in->step)\n  {\n    while (1)\n    {\n  case step_a:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_a;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar    = (fragment & 0x03f) << 2;\n  case step_b:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_b;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x030) >> 4;\n      *plainchar    = (fragment & 0x00f) << 4;\n  case step_c:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_c;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++ |= (fragment & 0x03c) >> 2;\n      *plainchar    = (fragment & 0x003) << 6;\n  case step_d:\n      do {\n        if (codechar == code_in+length_in) {\n          state_in->step = step_d;\n          state_in->plainchar = *plainchar;\n          return plainchar - plaintext_out;\n        }\n        fragment = (char)base64_decode_value(*codechar++);\n      } while (fragment < 0);\n      *plainchar++   |= (fragment & 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}"
  },
  {
    "function_name": "base64_init_decodestate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "697-700",
    "snippet": "void base64_init_decodestate(base64_decodestate* state_in) {\n  state_in->step = step_a;\n  state_in->plainchar = 0;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid base64_init_decodestate(base64_decodestate* state_in) {\n  state_in->step = step_a;\n  state_in->plainchar = 0;\n}"
  },
  {
    "function_name": "base64_decode_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "686-695",
    "snippet": "int base64_decode_value(char value_in) {\n  static const char decoding[] = {\n    62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,\n    26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const char decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in < 0 || value_in > decoding_size) return -1;\n  return decoding[(int)value_in];\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_decode_value(char value_in) {\n  static const char decoding[] = {\n    62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,\n    26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const char decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in < 0 || value_in > decoding_size) return -1;\n  return decoding[(int)value_in];\n}"
  },
  {
    "function_name": "base64Encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "630-670",
    "snippet": "kj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "total == output.size()",
            "total",
            "output.size()"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.size",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base64_encode_blockend",
          "args": [
            "c",
            "&s",
            "breakLines"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "base64_encode_blockend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "603-626",
          "snippet": "int base64_encode_blockend(char* code_out, base64_encodestate* state_in, bool breakLines) {\n  char* codechar = code_out;\n\n  switch (state_in->step) {\n  case step_B:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_C:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_A:\n    break;\n  }\n  if (breakLines && state_in->stepcount > 0) {\n    *codechar++ = '\\n';\n  }\n\n  return codechar - code_out;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in, bool breakLines) {\n  char* codechar = code_out;\n\n  switch (state_in->step) {\n  case step_B:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_C:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_A:\n    break;\n  }\n  if (breakLines && state_in->stepcount > 0) {\n    *codechar++ = '\\n';\n  }\n\n  return codechar - code_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base64_encode_block",
          "args": [
            "(const char *)input.begin()",
            "input.size()",
            "c",
            "&s",
            "breakLines"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "base64_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "548-601",
          "snippet": "int base64_encode_block(const char* plaintext_in, int length_in,\n                        char* code_out, base64_encodestate* state_in, bool breakLines) {\n  const char* plainchar = plaintext_in;\n  const char* const plaintextend = plaintext_in + length_in;\n  char* codechar = code_out;\n  char result;\n  char fragment;\n\n  result = state_in->result;\n\n  switch (state_in->step) {\n    while (1) {\n  case step_A:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_A;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result = (fragment & 0x0fc) >> 2;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x003) << 4;\n  case step_B:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_B;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0f0) >> 4;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x00f) << 2;\n  case step_C:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_C;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0c0) >> 6;\n      *codechar++ = base64_encode_value(result);\n      result  = (fragment & 0x03f) >> 0;\n      *codechar++ = base64_encode_value(result);\n\n      ++(state_in->stepcount);\n      if (breakLines && state_in->stepcount == CHARS_PER_LINE/4) {\n        *codechar++ = '\\n';\n        state_in->stepcount = 0;\n      }\n    }\n  }\n  /* control should not reach here */\n  return codechar - code_out;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_encode_block(const char* plaintext_in, int length_in,\n                        char* code_out, base64_encodestate* state_in, bool breakLines) {\n  const char* plainchar = plaintext_in;\n  const char* const plaintextend = plaintext_in + length_in;\n  char* codechar = code_out;\n  char result;\n  char fragment;\n\n  result = state_in->result;\n\n  switch (state_in->step) {\n    while (1) {\n  case step_A:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_A;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result = (fragment & 0x0fc) >> 2;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x003) << 4;\n  case step_B:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_B;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0f0) >> 4;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x00f) << 2;\n  case step_C:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_C;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0c0) >> 6;\n      *codechar++ = base64_encode_value(result);\n      result  = (fragment & 0x03f) >> 0;\n      *codechar++ = base64_encode_value(result);\n\n      ++(state_in->stepcount);\n      if (breakLines && state_in->stepcount == CHARS_PER_LINE/4) {\n        *codechar++ = '\\n';\n        state_in->stepcount = 0;\n      }\n    }\n  }\n  /* control should not reach here */\n  return codechar - code_out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.begin",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base64_init_encodestate",
          "args": [
            "&s"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "base64_init_encodestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "536-540",
          "snippet": "void base64_init_encodestate(base64_encodestate* state_in) {\n  state_in->step = step_A;\n  state_in->result = 0;\n  state_in->stepcount = 0;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid base64_init_encodestate(base64_encodestate* state_in) {\n  state_in->step = step_A;\n  state_in->result = 0;\n  state_in->stepcount = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.begin",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "numChars"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String base64Encode(kj::ArrayPtr<const byte> input, bool breakLines) {\n  /* set up a destination buffer large enough to hold the encoded data */\n  // equivalent to ceil(input.size() / 3) * 4\n  auto numChars = (input.size() + 2) / 3 * 4;\n  if (breakLines) {\n    // Add space for newline characters.\n    uint lineCount = numChars / CHARS_PER_LINE;\n    if (numChars % CHARS_PER_LINE > 0) {\n      // Partial line.\n      ++lineCount;\n    }\n    numChars = numChars + lineCount;\n  }\n  auto output = kj::heapString(numChars);\n  /* keep track of our encoded position */\n  char* c = output.begin();\n  /* store the number of bytes encoded by a single call */\n  int cnt = 0;\n  size_t total = 0;\n  /* we need an encoder state */\n  base64_encodestate s;\n\n  /*---------- START ENCODING ----------*/\n  /* initialise the encoder state */\n  base64_init_encodestate(&s);\n  /* gather data from the input and send it to the output */\n  cnt = base64_encode_block((const char *)input.begin(), input.size(), c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n\n  /* since we have encoded the entire input string, we know that\n     there is no more input data; finalise the encoding */\n  cnt = base64_encode_blockend(c, &s, breakLines);\n  c += cnt;\n  total += cnt;\n  /*---------- STOP ENCODING  ----------*/\n\n  KJ_ASSERT(total == output.size(), total, output.size());\n\n  return output;\n}"
  },
  {
    "function_name": "base64_encode_blockend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "603-626",
    "snippet": "int base64_encode_blockend(char* code_out, base64_encodestate* state_in, bool breakLines) {\n  char* codechar = code_out;\n\n  switch (state_in->step) {\n  case step_B:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_C:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_A:\n    break;\n  }\n  if (breakLines && state_in->stepcount > 0) {\n    *codechar++ = '\\n';\n  }\n\n  return codechar - code_out;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base64_encode_value",
          "args": [
            "state_in->result"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "base64_encode_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "542-546",
          "snippet": "char base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nchar base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in, bool breakLines) {\n  char* codechar = code_out;\n\n  switch (state_in->step) {\n  case step_B:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_C:\n    *codechar++ = base64_encode_value(state_in->result);\n    *codechar++ = '=';\n    ++state_in->stepcount;\n    break;\n  case step_A:\n    break;\n  }\n  if (breakLines && state_in->stepcount > 0) {\n    *codechar++ = '\\n';\n  }\n\n  return codechar - code_out;\n}"
  },
  {
    "function_name": "base64_encode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "548-601",
    "snippet": "int base64_encode_block(const char* plaintext_in, int length_in,\n                        char* code_out, base64_encodestate* state_in, bool breakLines) {\n  const char* plainchar = plaintext_in;\n  const char* const plaintextend = plaintext_in + length_in;\n  char* codechar = code_out;\n  char result;\n  char fragment;\n\n  result = state_in->result;\n\n  switch (state_in->step) {\n    while (1) {\n  case step_A:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_A;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result = (fragment & 0x0fc) >> 2;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x003) << 4;\n  case step_B:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_B;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0f0) >> 4;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x00f) << 2;\n  case step_C:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_C;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0c0) >> 6;\n      *codechar++ = base64_encode_value(result);\n      result  = (fragment & 0x03f) >> 0;\n      *codechar++ = base64_encode_value(result);\n\n      ++(state_in->stepcount);\n      if (breakLines && state_in->stepcount == CHARS_PER_LINE/4) {\n        *codechar++ = '\\n';\n        state_in->stepcount = 0;\n      }\n    }\n  }\n  /* control should not reach here */\n  return codechar - code_out;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base64_encode_value",
          "args": [
            "result"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "base64_encode_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "542-546",
          "snippet": "char base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nchar base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nint base64_encode_block(const char* plaintext_in, int length_in,\n                        char* code_out, base64_encodestate* state_in, bool breakLines) {\n  const char* plainchar = plaintext_in;\n  const char* const plaintextend = plaintext_in + length_in;\n  char* codechar = code_out;\n  char result;\n  char fragment;\n\n  result = state_in->result;\n\n  switch (state_in->step) {\n    while (1) {\n  case step_A:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_A;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result = (fragment & 0x0fc) >> 2;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x003) << 4;\n  case step_B:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_B;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0f0) >> 4;\n      *codechar++ = base64_encode_value(result);\n      result = (fragment & 0x00f) << 2;\n  case step_C:\n      if (plainchar == plaintextend) {\n        state_in->result = result;\n        state_in->step = step_C;\n        return codechar - code_out;\n      }\n      fragment = *plainchar++;\n      result |= (fragment & 0x0c0) >> 6;\n      *codechar++ = base64_encode_value(result);\n      result  = (fragment & 0x03f) >> 0;\n      *codechar++ = base64_encode_value(result);\n\n      ++(state_in->stepcount);\n      if (breakLines && state_in->stepcount == CHARS_PER_LINE/4) {\n        *codechar++ = '\\n';\n        state_in->stepcount = 0;\n      }\n    }\n  }\n  /* control should not reach here */\n  return codechar - code_out;\n}"
  },
  {
    "function_name": "base64_encode_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "542-546",
    "snippet": "char base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nchar base64_encode_value(char value_in) {\n  static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  if (value_in > 63) return '=';\n  return encoding[(int)value_in];\n}"
  },
  {
    "function_name": "base64_init_encodestate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "536-540",
    "snippet": "void base64_init_encodestate(base64_encodestate* state_in) {\n  state_in->step = step_A;\n  state_in->result = 0;\n  state_in->stepcount = 0;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid base64_init_encodestate(base64_encodestate* state_in) {\n  state_in->step = step_A;\n  state_in->result = 0;\n  state_in->stepcount = 0;\n}"
  },
  {
    "function_name": "rotateLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "480-513",
    "snippet": "kj::Promise<void> rotateLog(kj::Timer& timer, int logFd, kj::StringPtr path, size_t threshold) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(logFd, &stats));\n  if (stats.st_size >= threshold) {\n    // TODO(someday): If .1 exists, we could move it to .2, which we could move to .3, etc. We could\n    //   also gzip older logs to save space. But does anyone actually care? Probably not? Note that\n    //   if this changes, the lseek() below probably needs to be replaced with something more\n    //   sophisticated.\n    auto out = raiiOpen(kj::str(path, \".1\"), O_WRONLY | O_CREAT | O_TRUNC);\n\n    // `logFd` might be write-only, so we reopen it for read.\n    auto in = raiiOpen(path, O_RDONLY);\n\n    // Only copy over the last `threshold` bytes of the log. We do this specifically to help deal\n    // with old grains that grew enormous logs before log rotation was introduced -- we'd like them\n    // to chop their logs down to size the first time they are opened. Note that this means \"log.1\"\n    // will tend to start mid-line, which is ugly, but it's probably not worth trying to avoid.\n    KJ_SYSCALL(lseek(in, stats.st_size - threshold, SEEK_SET));\n\n    // Transfer data using `sendfile()` to avoid unnecessary copies and context switches.\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = sendfile(out, in, nullptr, threshold));\n      if (n == 0) break;\n    }\n\n    // EOF. Quick, truncate before any other log data appears.\n    KJ_SYSCALL(ftruncate(logFd, 0));\n  }\n\n  return timer.afterDelay(5 * kj::MINUTES).then([=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "[=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  }"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rotateLog",
          "args": [
            "timer",
            "logFd",
            "path",
            "threshold"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "rotateLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "480-513",
          "snippet": "kj::Promise<void> rotateLog(kj::Timer& timer, int logFd, kj::StringPtr path, size_t threshold) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(logFd, &stats));\n  if (stats.st_size >= threshold) {\n    // TODO(someday): If .1 exists, we could move it to .2, which we could move to .3, etc. We could\n    //   also gzip older logs to save space. But does anyone actually care? Probably not? Note that\n    //   if this changes, the lseek() below probably needs to be replaced with something more\n    //   sophisticated.\n    auto out = raiiOpen(kj::str(path, \".1\"), O_WRONLY | O_CREAT | O_TRUNC);\n\n    // `logFd` might be write-only, so we reopen it for read.\n    auto in = raiiOpen(path, O_RDONLY);\n\n    // Only copy over the last `threshold` bytes of the log. We do this specifically to help deal\n    // with old grains that grew enormous logs before log rotation was introduced -- we'd like them\n    // to chop their logs down to size the first time they are opened. Note that this means \"log.1\"\n    // will tend to start mid-line, which is ugly, but it's probably not worth trying to avoid.\n    KJ_SYSCALL(lseek(in, stats.st_size - threshold, SEEK_SET));\n\n    // Transfer data using `sendfile()` to avoid unnecessary copies and context switches.\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = sendfile(out, in, nullptr, threshold));\n      if (n == 0) break;\n    }\n\n    // EOF. Quick, truncate before any other log data appears.\n    KJ_SYSCALL(ftruncate(logFd, 0));\n  }\n\n  return timer.afterDelay(5 * kj::MINUTES).then([=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "timer.afterDelay",
          "args": [
            "5 * kj::MINUTES"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "ftruncate(logFd, 0)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "logFd",
            "0"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = sendfile(out, in, nullptr, threshold)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendfile",
          "args": [
            "out",
            "in",
            "nullptr",
            "threshold"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lseek(in, stats.st_size - threshold, SEEK_SET)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "in",
            "stats.st_size - threshold",
            "SEEK_SET"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "kj::str(path, \".1\")",
            "O_WRONLY | O_CREAT | O_TRUNC"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "\".1\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(logFd, &stats)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "logFd",
            "&stats"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Promise<void> rotateLog(kj::Timer& timer, int logFd, kj::StringPtr path, size_t threshold) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(logFd, &stats));\n  if (stats.st_size >= threshold) {\n    // TODO(someday): If .1 exists, we could move it to .2, which we could move to .3, etc. We could\n    //   also gzip older logs to save space. But does anyone actually care? Probably not? Note that\n    //   if this changes, the lseek() below probably needs to be replaced with something more\n    //   sophisticated.\n    auto out = raiiOpen(kj::str(path, \".1\"), O_WRONLY | O_CREAT | O_TRUNC);\n\n    // `logFd` might be write-only, so we reopen it for read.\n    auto in = raiiOpen(path, O_RDONLY);\n\n    // Only copy over the last `threshold` bytes of the log. We do this specifically to help deal\n    // with old grains that grew enormous logs before log rotation was introduced -- we'd like them\n    // to chop their logs down to size the first time they are opened. Note that this means \"log.1\"\n    // will tend to start mid-line, which is ugly, but it's probably not worth trying to avoid.\n    KJ_SYSCALL(lseek(in, stats.st_size - threshold, SEEK_SET));\n\n    // Transfer data using `sendfile()` to avoid unnecessary copies and context switches.\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = sendfile(out, in, nullptr, threshold));\n      if (n == 0) break;\n    }\n\n    // EOF. Quick, truncate before any other log data appears.\n    KJ_SYSCALL(ftruncate(logFd, 0));\n  }\n\n  return timer.afterDelay(5 * kj::MINUTES).then([=,&timer]() mutable {\n    return rotateLog(timer, logFd, path, threshold);\n  });\n}"
  },
  {
    "function_name": "extractProtocolFromUrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "472-477",
    "snippet": "kj::ArrayPtr<const char> extractProtocolFromUrl(kj::StringPtr url) {\n  KJ_IF_MAYBE(colonPos, url.findFirst(':')) {\n    return url.slice(0, *colonPos);\n  } else {\n    KJ_FAIL_REQUIRE(\"Base URL does not have a protocol scheme.\", url);\n  }",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Base URL does not have a protocol scheme.\"",
            "url"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.slice",
          "args": [
            "0",
            "*colonPos"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "colonPos",
            "url.findFirst(':')"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "url.findFirst",
          "args": [
            "':'"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> extractProtocolFromUrl(kj::StringPtr url) {\n  KJ_IF_MAYBE(colonPos, url.findFirst(':')) {\n    return url.slice(0, *colonPos);\n  } else {\n    KJ_FAIL_REQUIRE(\"Base URL does not have a protocol scheme.\", url);\n  }"
  },
  {
    "function_name": "extractHostFromUrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "459-470",
    "snippet": "kj::ArrayPtr<const char> extractHostFromUrl(kj::StringPtr url) {\n  while (url.size() > 0 && 'a' <= url[0] && url[0] <= 'z') {\n    url = url.slice(1);\n  }\n  KJ_REQUIRE(url.startsWith(\"://\"), \"Base URL does not have a protocol scheme?\");\n  url = url.slice(3);\n  KJ_IF_MAYBE(slashPos, url.findFirst('/')) {\n    return url.slice(0, *slashPos);\n  } else {\n    return url;\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "url.slice",
          "args": [
            "0",
            "*slashPos"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "slashPos",
            "url.findFirst('/')"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "url.findFirst",
          "args": [
            "'/'"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.slice",
          "args": [
            "3"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "url.startsWith(\"://\")",
            "\"Base URL does not have a protocol scheme?\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.startsWith",
          "args": [
            "\"://\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.slice",
          "args": [
            "1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.size",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> extractHostFromUrl(kj::StringPtr url) {\n  while (url.size() > 0 && 'a' <= url[0] && url[0] <= 'z') {\n    url = url.slice(1);\n  }\n  KJ_REQUIRE(url.startsWith(\"://\"), \"Base URL does not have a protocol scheme?\");\n  url = url.slice(3);\n  KJ_IF_MAYBE(slashPos, url.findFirst('/')) {\n    return url.slice(0, *slashPos);\n  } else {\n    return url;\n  }\n}"
  },
  {
    "function_name": "splitFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "448-457",
    "snippet": "kj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "i + 1",
            "input.size()"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "0",
            "i"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "input"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::ArrayPtr<const char>> splitFirst(kj::ArrayPtr<const char>& input, char delim) {\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      auto result = input.slice(0, i);\n      input = input.slice(i + 1, input.size());\n      return result;\n    }\n  }\n  return nullptr;\n}"
  },
  {
    "function_name": "splitSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "430-446",
    "snippet": "kj::Vector<kj::ArrayPtr<const char>> splitSpace(kj::ArrayPtr<const char> input) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (isspace(input[i])) {\n      if (i > start) {\n        result.add(input.slice(start, i));\n      }\n      start = i + 1;\n    }\n  }\n  if (input.size() > start) {\n    result.add(input.slice(start, input.size()));\n  }\n  return result;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "input.slice(start, input.size())"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "start",
            "input.size()"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "input.slice(start, i)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "start",
            "i"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "input[i]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "input"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Vector<kj::ArrayPtr<const char>> splitSpace(kj::ArrayPtr<const char> input) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (isspace(input[i])) {\n      if (i > start) {\n        result.add(input.slice(start, i));\n      }\n      start = i + 1;\n    }\n  }\n  if (input.size() > start) {\n    result.add(input.slice(start, input.size()));\n  }\n  return result;\n}"
  },
  {
    "function_name": "split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "416-428",
    "snippet": "kj::Vector<kj::ArrayPtr<const char>> split(kj::ArrayPtr<const char> input, char delim) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      result.add(input.slice(start, i));\n      start = i + 1;\n    }\n  }\n  result.add(input.slice(start, input.size()));\n  return result;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "input.slice(start, input.size())"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "start",
            "input.size()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "input.slice(start, i)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "start",
            "i"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "input"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Vector<kj::ArrayPtr<const char>> split(kj::ArrayPtr<const char> input, char delim) {\n  kj::Vector<kj::ArrayPtr<const char>> result;\n\n  size_t start = 0;\n  for (size_t i: kj::indices(input)) {\n    if (input[i] == delim) {\n      result.add(input.slice(start, i));\n      start = i + 1;\n    }\n  }\n  result.add(input.slice(start, input.size()));\n  return result;\n}"
  },
  {
    "function_name": "splitLines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "387-414",
    "snippet": "kj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.releaseAsArray",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.add",
          "args": [
            "kj::mv(lastLine)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "lastLine"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lastLine.size",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "input.slice(lineStart)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "202-204",
          "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "lineStart"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.add",
          "args": [
            "kj::mv(line)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "line"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.slice",
          "args": [
            "lineStart",
            "i"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> splitLines(kj::StringPtr input) {\n  size_t lineStart = 0;\n  kj::Vector<kj::String> results;\n  for (size_t i = 0; i < input.size(); i++) {\n    if (input[i] == '\\n' || input[i] == '#') {\n      bool hasComment = input[i] == '#';\n      auto line = trim(input.slice(lineStart, i));\n      if (line.size() > 0) {\n        results.add(kj::mv(line));\n      }\n      if (hasComment) {\n        // Ignore through newline.\n        ++i;\n        while (i < input.size() && input[i] != '\\n') ++i;\n      }\n      lineStart = i + 1;\n    }\n  }\n\n  if (lineStart < input.size()) {\n    auto lastLine = trim(input.slice(lineStart));\n    if (lastLine.size() > 0) {\n      results.add(kj::mv(lastLine));\n    }\n  }\n\n  return results.releaseAsArray();\n}"
  },
  {
    "function_name": "readAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "383-385",
    "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "raiiOpen(name, O_RDONLY)"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "383-385",
          "snippet": "kj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "name",
            "O_RDONLY"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(kj::StringPtr name) {\n  return readAll(raiiOpen(name, O_RDONLY));\n}"
  },
  {
    "function_name": "readAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "367-381",
    "snippet": "kj::String readAll(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<char> content;\n  for (;;) {\n    char buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  content.add('\\0');\n  return kj::String(content.releaseAsArray());\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "content.releaseAsArray()"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.releaseAsArray",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.add",
          "args": [
            "'\\0'"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.addAll",
          "args": [
            "buffer",
            "buffer + n"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "sizeof(buffer)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String readAll(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<char> content;\n  for (;;) {\n    char buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  content.add('\\0');\n  return kj::String(content.releaseAsArray());\n}"
  },
  {
    "function_name": "readAllBytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "352-365",
    "snippet": "kj::Array<byte> readAllBytes(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<byte> content;\n  for (;;) {\n    byte buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  return content.releaseAsArray();\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "content.releaseAsArray",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.addAll",
          "args": [
            "buffer",
            "buffer + n"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "sizeof(buffer)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> readAllBytes(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<byte> content;\n  for (;;) {\n    byte buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  return content.releaseAsArray();\n}"
  },
  {
    "function_name": "recursivelyCreateParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "331-350",
    "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mkdir(parent)\"",
            "error",
            "parent"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyCreateParent",
          "args": [
            "parent"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyCreateParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "331-350",
          "snippet": "void recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "parent.cStr()",
            "0777"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.cStr",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "path.slice(0, *pos)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "0",
            "*pos"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "pos",
            "path.findLast('/')"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.findLast",
          "args": [
            "'/'"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyCreateParent(kj::StringPtr path) {\n  KJ_IF_MAYBE(pos, path.findLast('/')) {\n    if (*pos == 0) return;\n\n    kj::String parent = kj::heapString(path.slice(0, *pos));\n\n    bool firstTry = true;\n    while (mkdir(parent.cStr(), 0777) < 0) {\n      int error = errno;\n      if (firstTry && error == ENOENT) {\n        recursivelyCreateParent(parent);\n        firstTry = false;\n      } else if (error == EEXIST) {\n        break;\n      } else if (error != EINTR) {\n        KJ_FAIL_SYSCALL(\"mkdir(parent)\", error, parent);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "recursivelyDeleteAt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "315-329",
    "snippet": "void recursivelyDeleteAt(int fd, kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(fstatat(fd, path.cStr(), &stats, AT_SYMLINK_NOFOLLOW), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectoryAt(fd, path)) {\n      recursivelyDeleteAt(fd, kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), AT_REMOVEDIR), path) { break; }\n  } else {\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), 0), path) { break; }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unlinkat(fd, path.cStr(), 0)",
            "path"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlinkat",
          "args": [
            "fd",
            "path.cStr()",
            "0"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unlinkat(fd, path.cStr(), AT_REMOVEDIR)",
            "path"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlinkat",
          "args": [
            "fd",
            "path.cStr()",
            "AT_REMOVEDIR"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyDeleteAt",
          "args": [
            "fd",
            "kj::str(path, \"/\", file)"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyDeleteAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "315-329",
          "snippet": "void recursivelyDeleteAt(int fd, kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(fstatat(fd, path.cStr(), &stats, AT_SYMLINK_NOFOLLOW), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectoryAt(fd, path)) {\n      recursivelyDeleteAt(fd, kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), AT_REMOVEDIR), path) { break; }\n  } else {\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), 0), path) { break; }\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "\"/\"",
            "file"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listDirectoryAt",
          "args": [
            "fd",
            "path"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "282-290",
          "snippet": "kj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstatat(fd, path.cStr(), &stats, AT_SYMLINK_NOFOLLOW)",
            "path"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "fd",
            "path.cStr()",
            "&stats",
            "AT_SYMLINK_NOFOLLOW"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!path.endsWith(\"/\")",
            "\"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyDeleteAt(int fd, kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(fstatat(fd, path.cStr(), &stats, AT_SYMLINK_NOFOLLOW), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectoryAt(fd, path)) {\n      recursivelyDeleteAt(fd, kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), AT_REMOVEDIR), path) { break; }\n  } else {\n    KJ_SYSCALL(unlinkat(fd, path.cStr(), 0), path) { break; }\n  }\n}"
  },
  {
    "function_name": "recursivelyDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "299-313",
    "snippet": "void recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unlink(path.cStr())",
            "path"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path.cStr()"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "rmdir(path.cStr())",
            "path"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "path.cStr()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recursivelyDelete",
          "args": [
            "kj::str(path, \"/\", file)"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "recursivelyDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "299-313",
          "snippet": "void recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "\"/\"",
            "file"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listDirectory",
          "args": [
            "path"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "292-297",
          "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(path.cStr(), &stats)",
            "path"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!path.endsWith(\"/\")",
            "\"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid recursivelyDelete(kj::StringPtr path) {\n  KJ_REQUIRE(!path.endsWith(\"/\"),\n      \"refusing to recursively delete directory name with trailing / to reduce risk of \"\n      \"catastrophic empty-string bugs\");\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats), path) { return; }\n  if (S_ISDIR(stats.st_mode)) {\n    for (auto& file: listDirectory(path)) {\n      recursivelyDelete(kj::str(path, \"/\", file));\n    }\n    KJ_SYSCALL(rmdir(path.cStr()), path) { break; }\n  } else {\n    KJ_SYSCALL(unlink(path.cStr()), path) { break; }\n  }\n}"
  },
  {
    "function_name": "listDirectoryFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "292-297",
    "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listDirectoryAt",
          "args": [
            "dirfd",
            "\".\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "282-290",
          "snippet": "kj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
  },
  {
    "function_name": "listDirectoryAt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "282-290",
    "snippet": "kj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listDirectoryAndClose",
          "args": [
            "dir"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryAndClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "249-272",
          "snippet": "static kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nstatic kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"fdopendir\"",
            "errno"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopendir",
          "args": [
            "fd"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd",
            "path.cStr()",
            "O_RDONLY | O_DIRECTORY"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryAt(int dirfd, kj::StringPtr path) {\n  int fd;\n  KJ_SYSCALL(fd = openat(dirfd, path.cStr(), O_RDONLY | O_DIRECTORY));\n  DIR* dir = fdopendir(fd);\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"fdopendir\", errno);\n  }\n  return listDirectoryAndClose(dir);\n}"
  },
  {
    "function_name": "listDirectory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "274-280",
    "snippet": "kj::Array<kj::String> listDirectory(kj::StringPtr dirname) {\n  DIR* dir = opendir(dirname.cStr());\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"opendir\", errno, dirname);\n  }\n  return listDirectoryAndClose(dir);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listDirectoryAndClose",
          "args": [
            "dir"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryAndClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "249-272",
          "snippet": "static kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nstatic kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"opendir\"",
            "errno",
            "dirname"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname.cStr()"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.cStr",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectory(kj::StringPtr dirname) {\n  DIR* dir = opendir(dirname.cStr());\n  if (dir == nullptr) {\n    KJ_FAIL_SYSCALL(\"opendir\", errno, dirname);\n  }\n  return listDirectoryAndClose(dir);\n}"
  },
  {
    "function_name": "listDirectoryAndClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "249-272",
    "snippet": "static kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entries.releaseAsArray",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entries.add",
          "args": [
            "kj::heapString(entry->d_name)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "entry->d_name"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"readdir\"",
            "error"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "closedir(dir)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nstatic kj::Array<kj::String> listDirectoryAndClose(DIR* dir) {\n  KJ_DEFER(closedir(dir));\n  kj::Vector<kj::String> entries;\n\n  for (;;) {\n    errno = 0;\n    struct dirent* entry = readdir(dir);\n    if (entry == nullptr) {\n      int error = errno;\n      if (error == 0) {\n        break;\n      } else {\n        KJ_FAIL_SYSCALL(\"readdir\", error);\n      }\n    }\n\n    kj::StringPtr name = entry->d_name;\n    if (name != \".\" && name != \"..\") {\n      entries.add(kj::heapString(entry->d_name));\n    }\n  }\n\n  return entries.releaseAsArray();\n}"
  },
  {
    "function_name": "isDirectory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "243-247",
    "snippet": "bool isDirectory(kj::StringPtr path) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  return S_ISDIR(stats.st_mode);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(path.cStr(), &stats)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nbool isDirectory(kj::StringPtr path) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  return S_ISDIR(stats.st_mode);\n}"
  },
  {
    "function_name": "openTemporary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "232-241",
    "snippet": "kj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unlink(name.cStr())"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "name.cStr()"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = mkostemp(name.begin(), O_CLOEXEC)",
            "name"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkostemp",
          "args": [
            "name.begin()",
            "O_CLOEXEC"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.begin",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "near",
            "\".XXXXXX\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd openTemporary(kj::StringPtr near) {\n  // TODO(someday):  Use O_TMPFILE?  New in Linux 3.11.\n\n  int fd;\n  auto name = kj::str(near, \".XXXXXX\");\n  KJ_SYSCALL(fd = mkostemp(name.begin(), O_CLOEXEC), name);\n  kj::AutoCloseFd result(fd);\n  KJ_SYSCALL(unlink(name.cStr()));\n  return result;\n}"
  },
  {
    "function_name": "parseUInt64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "223-230",
    "snippet": "kj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "s.cStr()",
            "&end",
            "base"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.cStr",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}"
  },
  {
    "function_name": "parseUInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "214-221",
    "snippet": "kj::Maybe<uint> parseUInt(kj::StringPtr s, int base) {\n  char* end;\n  uint result = strtoul(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "s.cStr()",
            "&end",
            "base"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.cStr",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<uint> parseUInt(kj::StringPtr s, int base) {\n  char* end;\n  uint result = strtoul(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}"
  },
  {
    "function_name": "toLower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "206-212",
    "snippet": "void toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nvoid toLower(kj::ArrayPtr<char> text) {\n  for (char& c: text) {\n    if ('A' <= c && c <= 'Z') {\n      c = c - 'A' + 'a';\n    }\n  }\n}"
  },
  {
    "function_name": "trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "202-204",
    "snippet": "kj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "trimArray(slice)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trimArray",
          "args": [
            "slice"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "trimArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "191-200",
          "snippet": "kj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::String trim(kj::ArrayPtr<const char> slice) {\n  return kj::heapString(trimArray(slice));\n}"
  },
  {
    "function_name": "trimArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "191-200",
    "snippet": "kj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slice.slice",
          "args": [
            "0",
            "slice.size() - 1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slice.size",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "slice[slice.size() - 1]"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slice.slice",
          "args": [
            "1",
            "slice.size()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "slice[0]"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::ArrayPtr<const char> trimArray(kj::ArrayPtr<const char> slice) {\n  while (slice.size() > 0 && isspace(slice[0])) {\n    slice = slice.slice(1, slice.size());\n  }\n  while (slice.size() > 0 && isspace(slice[slice.size() - 1])) {\n    slice = slice.slice(0, slice.size() - 1);\n  }\n\n  return slice;\n}"
  },
  {
    "function_name": "pump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "170-189",
    "snippet": "kj::Promise<void> pump(kj::InputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  size_t n = input.tryRead(buffer.begin(), 1, buffer.size());\n  if (n == 0) {\n    return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n  }\n\n  orphan.truncate(n);\n  req.adoptData(kj::mv(orphan));\n\n  // TODO(perf): Parallelize writes.\n  return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n    return pump(input, kj::mv(stream));\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[&input,KJ_MVCAP(stream)](auto&&) mutable {\n    return pump(input, kj::mv(stream));\n  }"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "input",
            "kj::mv(stream)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "170-189",
          "snippet": "kj::Promise<void> pump(kj::InputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  size_t n = input.tryRead(buffer.begin(), 1, buffer.size());\n  if (n == 0) {\n    return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n  }\n\n  orphan.truncate(n);\n  req.adoptData(kj::mv(orphan));\n\n  // TODO(perf): Parallelize writes.\n  return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n    return pump(input, kj::mv(stream));\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.adoptData",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.truncate",
          "args": [
            "n"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [
            "[](auto&&) {}"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [
            "capnp::MessageSize {4, 0}"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "buffer.begin()",
            "1",
            "buffer.size()"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.get",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<capnp::Data>",
          "args": [
            "8192"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "kj::implicitCast<ByteStream::WriteParams::Builder>(req)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<ByteStream::WriteParams::Builder>",
          "args": [
            "req"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.writeRequest",
          "args": [
            "capnp::MessageSize { 2100, 0 }"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Promise<void> pump(kj::InputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  size_t n = input.tryRead(buffer.begin(), 1, buffer.size());\n  if (n == 0) {\n    return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n  }\n\n  orphan.truncate(n);\n  req.adoptData(kj::mv(orphan));\n\n  // TODO(perf): Parallelize writes.\n  return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n    return pump(input, kj::mv(stream));\n  });\n}"
  },
  {
    "function_name": "pump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "146-168",
    "snippet": "kj::Promise<void> pump(kj::AsyncInputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  return input.tryRead(buffer.begin(), 1, buffer.size())\n      .then([&input,KJ_MVCAP(stream),KJ_MVCAP(req),KJ_MVCAP(orphan)](size_t n) mutable\n            -> kj::Promise<void> {\n    if (n == 0) {\n      return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n    }\n\n    orphan.truncate(n);\n    req.adoptData(kj::mv(orphan));\n\n    // TODO(perf): Parallelize writes.\n    return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n      return pump(input, kj::mv(stream));\n    });\n  });\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[&input,KJ_MVCAP(stream)](auto&&) mutable {\n      return pump(input, kj::mv(stream));\n    }"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "input",
            "kj::mv(stream)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "170-189",
          "snippet": "kj::Promise<void> pump(kj::InputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  size_t n = input.tryRead(buffer.begin(), 1, buffer.size());\n  if (n == 0) {\n    return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n  }\n\n  orphan.truncate(n);\n  req.adoptData(kj::mv(orphan));\n\n  // TODO(perf): Parallelize writes.\n  return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n    return pump(input, kj::mv(stream));\n  });\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.adoptData",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.truncate",
          "args": [
            "n"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [
            "[](auto&&) {}"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.doneRequest",
          "args": [
            "capnp::MessageSize {4, 0}"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "[&input,KJ_MVCAP(stream),KJ_MVCAP(req)",
            "KJ_MVCAP(orphan)](size_t n"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "orphan"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MVCAP",
          "args": [
            "req"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryRead",
          "args": [
            "buffer.begin()",
            "1",
            "buffer.size()"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.get",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<capnp::Data>",
          "args": [
            "8192"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::Orphanage::getForMessageContaining",
          "args": [
            "kj::implicitCast<ByteStream::WriteParams::Builder>(req)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<ByteStream::WriteParams::Builder>",
          "args": [
            "req"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.writeRequest",
          "args": [
            "capnp::MessageSize { 2100, 0 }"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Promise<void> pump(kj::AsyncInputStream& input, ByteStream::Client stream) {\n  auto req = stream.writeRequest(capnp::MessageSize { 2100, 0 });\n  auto orphanage = capnp::Orphanage::getForMessageContaining(\n      kj::implicitCast<ByteStream::WriteParams::Builder>(req));\n  auto orphan = orphanage.newOrphan<capnp::Data>(8192);\n  auto buffer = orphan.get();\n\n  return input.tryRead(buffer.begin(), 1, buffer.size())\n      .then([&input,KJ_MVCAP(stream),KJ_MVCAP(req),KJ_MVCAP(orphan)](size_t n) mutable\n            -> kj::Promise<void> {\n    if (n == 0) {\n      return stream.doneRequest(capnp::MessageSize {4, 0}).send().then([](auto&&) {});\n    }\n\n    orphan.truncate(n);\n    req.adoptData(kj::mv(orphan));\n\n    // TODO(perf): Parallelize writes.\n    return req.send().then([&input,KJ_MVCAP(stream)](auto&&) mutable {\n      return pump(input, kj::mv(stream));\n    });\n  });\n}"
  },
  {
    "function_name": "readLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "124-144",
    "snippet": "kj::Maybe<kj::String> readLine(kj::BufferedInputStream& input) {\n  kj::Vector<char> result(80);\n\n  for (;;) {\n    auto buffer = input.tryGetReadBuffer();\n    if (buffer.size() == 0) {\n      KJ_REQUIRE(result.size() == 0, \"Got partial line.\");\n      return nullptr;\n    }\n    for (size_t i: kj::indices(buffer)) {\n      if (buffer[i] == '\\n') {\n        input.skip(i+1);\n        result.add('\\0');\n        return kj::String(result.releaseAsArray());\n      } else {\n        result.add(buffer[i]);\n      }\n    }\n    input.skip(buffer.size());\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input.skip",
          "args": [
            "buffer.size()"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "buffer[i]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::String",
          "args": [
            "result.releaseAsArray()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.releaseAsArray",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "'\\0'"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.skip",
          "args": [
            "i+1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "buffer"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "result.size() == 0",
            "\"Got partial line.\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.tryGetReadBuffer",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::String> readLine(kj::BufferedInputStream& input) {\n  kj::Vector<char> result(80);\n\n  for (;;) {\n    auto buffer = input.tryGetReadBuffer();\n    if (buffer.size() == 0) {\n      KJ_REQUIRE(result.size() == 0, \"Got partial line.\");\n      return nullptr;\n    }\n    for (size_t i: kj::indices(buffer)) {\n      if (buffer[i] == '\\n') {\n        input.skip(i+1);\n        result.add('\\0');\n        return kj::String(result.releaseAsArray());\n      } else {\n        result.add(buffer[i]);\n      }\n    }\n    input.skip(buffer.size());\n  }\n}"
  },
  {
    "function_name": "~MemoryMapping",
    "container": "MemoryMapping",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "118-122",
    "snippet": "MemoryMapping::~MemoryMapping() noexcept(false) {\n  if (content != nullptr) {\n    KJ_SYSCALL(munmap(content.begin(), content.size()));\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "munmap(content.begin(), content.size())"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "content.begin()",
            "content.size()"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nMemoryMapping {\n  MemoryMapping::~MemoryMapping() noexcept(false) {\n    if (content != nullptr) {\n      KJ_SYSCALL(munmap(content.begin(), content.size()));\n    }\n  }\n}"
  },
  {
    "function_name": "MemoryMapping",
    "container": "MemoryMapping",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "105-116",
    "snippet": "MemoryMapping::MemoryMapping(int fd, kj::StringPtr filename): content(nullptr) {\n  size_t size = getFileSize(fd, filename);\n\n  if (size != 0) {\n    void* ptr = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (ptr == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n    }\n\n    content = kj::arrayPtr(reinterpret_cast<byte*>(ptr), size);\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<byte*>(ptr)",
            "size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "ptr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mmap\"",
            "errno",
            "filename"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "nullptr",
            "size",
            "PROT_READ",
            "MAP_PRIVATE",
            "fd",
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getFileSize",
          "args": [
            "fd",
            "filename"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "getFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "98-103",
          "snippet": "size_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nsize_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nMemoryMapping {\n  MemoryMapping::MemoryMapping(int fd, kj::StringPtr filename): content(nullptr) {\n    size_t size = getFileSize(fd, filename);\n  \n    if (size != 0) {\n      void* ptr = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);\n      if (ptr == MAP_FAILED) {\n        KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n      }\n  \n      content = kj::arrayPtr(reinterpret_cast<byte*>(ptr), size);\n    }\n  }\n}"
  },
  {
    "function_name": "getFileSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "98-103",
    "snippet": "size_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "S_ISREG(stats.st_mode)",
            "\"Not a regular file.\"",
            "filename"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(fd, &stats)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stats"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nsize_t getFileSize(int fd, kj::StringPtr filename) {\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n  KJ_REQUIRE(S_ISREG(stats.st_mode), \"Not a regular file.\", filename);\n  return stats.st_size;\n}"
  },
  {
    "function_name": "raiiOpenAtIfExists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "84-96",
    "snippet": "kj::Maybe<kj::AutoCloseFd> raiiOpenAtIfExists(\n    int dirfd, kj::StringPtr name, int flags, mode_t mode) {\n  int fd = openat(dirfd, name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"open\"",
            "errno",
            "name"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd",
            "name.cStr()",
            "flags",
            "mode"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::AutoCloseFd> raiiOpenAtIfExists(\n    int dirfd, kj::StringPtr name, int flags, mode_t mode) {\n  int fd = openat(dirfd, name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}"
  },
  {
    "function_name": "raiiOpenIfExists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "71-82",
    "snippet": "kj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"open\"",
            "errno",
            "name"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name.cStr()",
            "flags",
            "mode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}"
  },
  {
    "function_name": "raiiOpenAt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "60-69",
    "snippet": "kj::AutoCloseFd raiiOpenAt(int dirfd, kj::StringPtr name, int flags, mode_t mode) {\n  int fd;\n  if ((flags & O_TMPFILE) == O_TMPFILE) {\n    // work around glibc bug: https://sourceware.org/bugzilla/show_bug.cgi?id=17523\n    KJ_SYSCALL(fd = syscall(SYS_openat, dirfd, name.cStr(), flags, mode), name);\n  } else {\n    KJ_SYSCALL(fd = openat(dirfd, name.cStr(), flags, mode), name);\n  }\n  return kj::AutoCloseFd(fd);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = openat(dirfd, name.cStr(), flags, mode)",
            "name"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd",
            "name.cStr()",
            "flags",
            "mode"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = syscall(SYS_openat, dirfd, name.cStr(), flags, mode)",
            "name"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_openat",
            "dirfd",
            "name.cStr()",
            "flags",
            "mode"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd raiiOpenAt(int dirfd, kj::StringPtr name, int flags, mode_t mode) {\n  int fd;\n  if ((flags & O_TMPFILE) == O_TMPFILE) {\n    // work around glibc bug: https://sourceware.org/bugzilla/show_bug.cgi?id=17523\n    KJ_SYSCALL(fd = syscall(SYS_openat, dirfd, name.cStr(), flags, mode), name);\n  } else {\n    KJ_SYSCALL(fd = openat(dirfd, name.cStr(), flags, mode), name);\n  }\n  return kj::AutoCloseFd(fd);\n}"
  },
  {
    "function_name": "raiiOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "54-58",
    "snippet": "kj::AutoCloseFd raiiOpen(kj::StringPtr name, int flags, mode_t mode) {\n  int fd;\n  KJ_SYSCALL(fd = open(name.cStr(), flags, mode), name);\n  return kj::AutoCloseFd(fd);\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = open(name.cStr(), flags, mode)",
            "name"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name.cStr()",
            "flags",
            "mode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.cStr",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::AutoCloseFd raiiOpen(kj::StringPtr name, int flags, mode_t mode) {\n  int fd;\n  KJ_SYSCALL(fd = open(name.cStr(), flags, mode), name);\n  return kj::AutoCloseFd(fd);\n}"
  },
  {
    "function_name": "makeTwoWayAsync",
    "container": "Pipe",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "48-52",
    "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[1]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[0]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC",
            "0",
            "fds"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
  },
  {
    "function_name": "makeAsync",
    "container": "Pipe",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "42-46",
    "snippet": "Pipe Pipe::makeAsync() {\n  int fds[2];\n  KJ_SYSCALL(pipe2(fds, O_CLOEXEC | O_ASYNC));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[1]"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[0]"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe2(fds, O_CLOEXEC | O_ASYNC)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "fds",
            "O_CLOEXEC | O_ASYNC"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeAsync() {\n    int fds[2];\n    KJ_SYSCALL(pipe2(fds, O_CLOEXEC | O_ASYNC));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
  },
  {
    "function_name": "make",
    "container": "Pipe",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
    "lines": "36-40",
    "snippet": "Pipe Pipe::make() {\n  int fds[2];\n  KJ_SYSCALL(pipe2(fds, O_CLOEXEC));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
    "includes": [
      "#include <sys/sendfile.h>",
      "#include <sys/socket.h>",
      "#include <sys/mman.h>",
      "#include <map>",
      "#include <sys/wait.h>",
      "#include <signal.h>",
      "#include <syscall.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <ctype.h>",
      "#include <kj/async-unix.h>",
      "#include <kj/vector.h>",
      "#include <errno.h>",
      "#include \"util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[1]"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::AutoCloseFd",
          "args": [
            "fds[0]"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe2(fds, O_CLOEXEC)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "fds",
            "O_CLOEXEC"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::make() {\n    int fds[2];\n    KJ_SYSCALL(pipe2(fds, O_CLOEXEC));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
  }
]