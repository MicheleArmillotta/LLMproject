[
  {
    "function_name": "getPublicKeyForApp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements.c++",
    "lines": "77-94",
    "snippet": "kj::Array<kj::byte> getPublicKeyForApp(kj::ArrayPtr<const kj::byte> appId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  auto appidOwnStr = appIdString(appId);\n  kj::StringPtr appidStr = appidOwnStr;\n  auto result = kj::heapArray(appId);\n\nretry:\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      appidStr = item.getReplacement();\n      KJ_ASSERT(tryParseAppId(appidStr, result));\n      goto retry;\n    }\n  }\n\n  return result;\n}",
    "includes": [
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "tryParseAppId(appidStr, result)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParseAppId",
          "args": [
            "appidStr",
            "result"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "tryParseAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "180-183",
          "snippet": "bool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nbool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item.getReplacement",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.getOriginal",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "appId"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "appId"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "appId.size() == APP_ID_BYTE_SIZE"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appId.size",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nkj::Array<kj::byte> getPublicKeyForApp(kj::ArrayPtr<const kj::byte> appId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  auto appidOwnStr = appIdString(appId);\n  kj::StringPtr appidStr = appidOwnStr;\n  auto result = kj::heapArray(appId);\n\nretry:\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      appidStr = item.getReplacement();\n      KJ_ASSERT(tryParseAppId(appidStr, result));\n      goto retry;\n    }\n  }\n\n  return result;\n}"
  },
  {
    "function_name": "applyAppidReplacements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/appid-replacements.c++",
    "lines": "22-75",
    "snippet": "void applyAppidReplacements(\n    kj::ArrayPtr<kj::byte> appId, kj::ArrayPtr<const kj::byte> packageId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  // Given an input app ID that was just verified to have signed the given package ID,\n  // check appid-replacements.capnp to see if the app ID is revoked (throws exception) or the\n  // package should be treated as some other app (replaces appId).\n\n  // The logic here is slightly weird because the replacement list is organized into events --\n  // which makes it easier for people modifying it to understand what to do -- rather than into\n  // rules -- which could be more directly processed. Each event introduces one or two rules:\n  // a revocation of an original key (except for grandfathered whitelist) and a mapping of a\n  // replacement key to and original key.\n\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n\n  auto appidStr = appIdString(appId);\n  auto pkgidStr = packageIdString(packageId);\n\n  // First check if this app ID is revoked.\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      // The app ID matches the `original` of this entry. Check if it was revoked.\n      if (item.hasRevokeExceptPackageIds()) {\n        // This app ID is revoked, except for specific package IDs...\n        for (auto allowed: item.getRevokeExceptPackageIds()) {\n          if (pkgidStr == allowed) {\n            goto checkReplacements;  // Need to break outer loop...\n          }\n        }\n        KJ_FAIL_REQUIRE(\"package is signed with an app key that has been revoked\",\n                        appidStr, pkgidStr);\n      }\n    }\n  }\n\ncheckReplacements:\n  // Not revoked. Now check if it is a replacement.\n  for (auto item: replacements) {\n    if (item.getReplacement() == appidStr) {\n      // The app ID is a replacement. We want to make this package look like it uses the original\n      // ID, therefore we want to replace the replacement with the original.\n      KJ_ASSERT(tryParseAppId(item.getOriginal(), appId));\n\n      // We may have mapped the replacement ID back to an ID which has itself been replaced.\n      // So, we need to apply the replacements step again. We could make the rule that a second\n      // replacement for the same app should list the app's original-original ID as `original`, but\n      // this would mean that if the first replacement key needs to be revoked then two entries\n      // would need to be made, which is not intuitive.\n      appidStr = appIdString(appId);\n      goto checkReplacements;\n    }\n  }\n}",
    "includes": [
      "#include \"id-to-text.h\"",
      "#include \"appid-replacements.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appIdString",
          "args": [
            "appId"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "appIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "171-174",
          "snippet": "kj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String appIdString(kj::ArrayPtr<const kj::byte> appId) {\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  return base32Encode(appId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "tryParseAppId(item.getOriginal(), appId)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParseAppId",
          "args": [
            "item.getOriginal()",
            "appId"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tryParseAppId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "180-183",
          "snippet": "bool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nbool tryParseAppId(kj::StringPtr in, kj::ArrayPtr<kj::byte> out) {\n  KJ_REQUIRE(out.size() == APP_ID_BYTE_SIZE);\n  return BASE32_DECODER.tryDecode(in, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item.getOriginal",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.getReplacement",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"package is signed with an app key that has been revoked\"",
            "appidStr",
            "pkgidStr"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.getRevokeExceptPackageIds",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.hasRevokeExceptPackageIds",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.getOriginal",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageIdString",
          "args": [
            "packageId"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "packageIdString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/id-to-text.c++",
          "lines": "189-192",
          "snippet": "kj::String packageIdString(kj::ArrayPtr<const kj::byte> packageId) {\n  KJ_ASSERT(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n  return hexEncode(packageId);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"id-to-text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"id-to-text.h\"\n\nkj::String packageIdString(kj::ArrayPtr<const kj::byte> packageId) {\n  KJ_ASSERT(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n  return hexEncode(packageId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "packageId.size() == PACKAGE_ID_BYTE_SIZE"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packageId.size",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "appId.size() == APP_ID_BYTE_SIZE"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"id-to-text.h\"\n#include \"appid-replacements.h\"\n\nvoid applyAppidReplacements(\n    kj::ArrayPtr<kj::byte> appId, kj::ArrayPtr<const kj::byte> packageId,\n    capnp::List<spk::AppIdReplacement>::Reader replacements) {\n  // Given an input app ID that was just verified to have signed the given package ID,\n  // check appid-replacements.capnp to see if the app ID is revoked (throws exception) or the\n  // package should be treated as some other app (replaces appId).\n\n  // The logic here is slightly weird because the replacement list is organized into events --\n  // which makes it easier for people modifying it to understand what to do -- rather than into\n  // rules -- which could be more directly processed. Each event introduces one or two rules:\n  // a revocation of an original key (except for grandfathered whitelist) and a mapping of a\n  // replacement key to and original key.\n\n  KJ_REQUIRE(appId.size() == APP_ID_BYTE_SIZE);\n  KJ_REQUIRE(packageId.size() == PACKAGE_ID_BYTE_SIZE);\n\n  auto appidStr = appIdString(appId);\n  auto pkgidStr = packageIdString(packageId);\n\n  // First check if this app ID is revoked.\n  for (auto item: replacements) {\n    if (item.getOriginal() == appidStr) {\n      // The app ID matches the `original` of this entry. Check if it was revoked.\n      if (item.hasRevokeExceptPackageIds()) {\n        // This app ID is revoked, except for specific package IDs...\n        for (auto allowed: item.getRevokeExceptPackageIds()) {\n          if (pkgidStr == allowed) {\n            goto checkReplacements;  // Need to break outer loop...\n          }\n        }\n        KJ_FAIL_REQUIRE(\"package is signed with an app key that has been revoked\",\n                        appidStr, pkgidStr);\n      }\n    }\n  }\n\ncheckReplacements:\n  // Not revoked. Now check if it is a replacement.\n  for (auto item: replacements) {\n    if (item.getReplacement() == appidStr) {\n      // The app ID is a replacement. We want to make this package look like it uses the original\n      // ID, therefore we want to replace the replacement with the original.\n      KJ_ASSERT(tryParseAppId(item.getOriginal(), appId));\n\n      // We may have mapped the replacement ID back to an ID which has itself been replaced.\n      // So, we need to apply the replacements step again. We could make the rule that a second\n      // replacement for the same app should list the app's original-original ID as `original`, but\n      // this would mean that if the first replacement key needs to be revoked then two entries\n      // would need to be made, which is not intuitive.\n      appidStr = appIdString(appId);\n      goto checkReplacements;\n    }\n  }\n}"
  }
]