[
  {
    "function_name": "findFilesToZip",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "253-291",
    "snippet": "bool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "pieces"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "ByteStreamImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "712-716",
          "snippet": "kj::Promise<void> write(WriteContext context) override {\n      auto& stream = ensureStarted(nullptr);\n      auto data = context.getParams().getData();\n      return stream.write(data.begin(), data.size());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nByteStreamImpl {\n  kj::Promise<void> write(WriteContext context) override {\n        auto& stream = ensureStarted(nullptr);\n        auto data = context.getParams().getData();\n        return stream.write(data.begin(), data.size());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "\"\\n\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.asBytes",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findFilesToZip",
          "args": [
            "kj::str(path, '/', entry)",
            "out"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "findFilesToZip",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "253-291",
          "snippet": "bool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "path",
            "'/'",
            "entry"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listDirectory",
          "args": [
            "path"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "292-297",
          "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"tried to backup file containing newlines\"",
            "path"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "\"\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.asBytes",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.findFirst",
          "args": [
            "'\\n'"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "stats.st_mode"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "lstat(path.cStr(), &stats)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path.cStr()",
            "&stats"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n    struct stat stats;\n    KJ_SYSCALL(lstat(path.cStr(), &stats));\n    if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n      // Regular file or link can be zipped; write to file stream.\n      // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n      // one file per line. For security reasons, we must detect and filter out these files.\n      // Hopefully this never happens legitimately?\n      if (path.findFirst('\\n') == nullptr) {\n        kj::ArrayPtr<const byte> pieces[2];\n        pieces[0] = path.asBytes();\n        pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n        out.write(pieces);\n        return true;\n      } else {\n        KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n        return false;\n      }\n    } else if (S_ISDIR(stats.st_mode)) {\n      // Subdirectory; enumerate contents.\n      bool packedAny = false;\n      for (auto& entry: listDirectory(path)) {\n        if (findFilesToZip(kj::str(path, '/', entry), out)) {\n          packedAny = true;\n        }\n      }\n  \n      if (!packedAny) {\n        // Empty directory. Need to make sure it gets into the zip.\n        kj::ArrayPtr<const byte> pieces[2];\n        pieces[0] = path.asBytes();\n        pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n        out.write(pieces);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"
  },
  {
    "function_name": "pump",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "246-251",
    "snippet": "void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "buffer",
            "n"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "914-916",
          "snippet": "kj::Promise<void> write(const void* buffer, size_t size) override {\n    return stream->write(buffer, size);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<void> write(const void* buffer, size_t size) override {\n      return stream->write(buffer, size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.tryRead",
          "args": [
            "buffer",
            "1",
            "sizeof(buffer)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "RefcountedAsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "911-913",
          "snippet": "kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return stream->tryRead(buffer, minBytes, maxBytes);\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nRefcountedAsyncIoStream {\n  kj::Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      return stream->tryRead(buffer, minBytes, maxBytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n    byte buffer[4096];\n    while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n      out.write(buffer, n);\n    }\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "108-244",
    "snippet": "bool BackupMain::run(kj::StringPtr grainDir) {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n  // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  // Create files / directories before we potentially change the UID, so that they are created\n  // with the right owner.\n  if (restore) {\n    KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n  } else if (filename != \"-\") {\n    // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n    KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n  }\n\n  if (sandboxUid == nullptr) {\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n  } else {\n    KJ_SYSCALL(seteuid(0));\n    KJ_SYSCALL(unshare(CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Mount root read-only.\n  bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n\n  if (access(\"/tmp/dev/null\", F_OK) != 0) {\n    // Looks like we need to bind in /dev.\n    KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Hide sensitive directories.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n\n  // Mount inner tmpfs.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n\n  // Bind in the grain's `data` (=`sandbox`).\n  KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n  bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n       MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n\n  // Bind in the grain's `log`. When restoring, we discard the log.\n  if (!restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n    bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n  }\n\n  // Bind in the file.\n  if (restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n  // See supervisor-main.c++ for more discussion.\n  {\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/tmp\"));\n  }\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    KJ_SYSCALL(setresuid(*u, *u, *u));\n  }\n\n  // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n  //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n  //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n  //   supervisor.c++...\n\n  if (!restore) {\n    // Read stdin to metadata file.\n    kj::FdInputStream in(STDIN_FILENO);\n    kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n    pump(in, out);\n  }\n\n  {\n    // Drop crapabilities.\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n    umask(0007);\n  }\n\n  // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n  //   to zip/unzip.\n  if (restore) {\n    Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n\n    // Read metadata file to stdout.\n    kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n    kj::FdOutputStream out(STDOUT_FILENO);\n    pump(in, out);\n  } else {\n    Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n    auto inPipe = Pipe::make();\n    zipOptions.stdin = inPipe.readEnd;\n    Subprocess zip(kj::mv(zipOptions));\n    inPipe.readEnd = nullptr;\n\n    {\n      kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n      for (auto& entry: listDirectory(\".\")) {\n        findFilesToZip(entry, out);\n      }\n    }\n\n    zip.waitForSuccess();\n  }\n\n  return true;\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [
      "#define PR_SET_NO_NEW_PRIVS 38"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zip.waitForSuccess",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "waitForSuccess",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "993-996",
          "snippet": "void Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nSubprocess {\n  void Subprocess::waitForSuccess() {\n    int exitCode = waitForExit();\n    KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findFilesToZip",
          "args": [
            "entry",
            "out"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "findFilesToZip",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "253-291",
          "snippet": "bool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n    struct stat stats;\n    KJ_SYSCALL(lstat(path.cStr(), &stats));\n    if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n      // Regular file or link can be zipped; write to file stream.\n      // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n      // one file per line. For security reasons, we must detect and filter out these files.\n      // Hopefully this never happens legitimately?\n      if (path.findFirst('\\n') == nullptr) {\n        kj::ArrayPtr<const byte> pieces[2];\n        pieces[0] = path.asBytes();\n        pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n        out.write(pieces);\n        return true;\n      } else {\n        KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n        return false;\n      }\n    } else if (S_ISDIR(stats.st_mode)) {\n      // Subdirectory; enumerate contents.\n      bool packedAny = false;\n      for (auto& entry: listDirectory(path)) {\n        if (findFilesToZip(kj::str(path, '/', entry), out)) {\n          packedAny = true;\n        }\n      }\n  \n      if (!packedAny) {\n        // Empty directory. Need to make sure it gets into the zip.\n        kj::ArrayPtr<const byte> pieces[2];\n        pieces[0] = path.asBytes();\n        pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n        out.write(pieces);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "listDirectory",
          "args": [
            "\".\""
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "listDirectoryFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "292-297",
          "snippet": "kj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inPipe.writeEnd"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pipe::make",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "makeTwoWayAsync",
          "container": "Pipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "48-52",
          "snippet": "Pipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nPipe {\n  Pipe Pipe::makeTwoWayAsync() {\n    int fds[2];\n    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n    return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pump",
          "args": [
            "in",
            "out"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "pump",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "246-251",
          "snippet": "void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n    byte buffer[4096];\n    while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n      out.write(buffer, n);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"metadata\"",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Subprocess",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "detach",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "385-391",
          "snippet": "void detach() {\n    // Indicates that you don't intend to wait for this process to complete and do not want it to\n    // be killed when the Subprocess object is destroyed. The parent process needs a wait loop\n    // somewhere to clean up zombies.\n\n    pid = 0;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  void detach() {\n      // Indicates that you don't intend to wait for this process to complete and do not want it to\n      // be killed when the Subprocess object is destroyed. The parent process needs a wait loop\n      // somewhere to clean up zombies.\n  \n      pid = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Subprocess",
          "args": [
            "{\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "notifyExited",
          "container": "Subprocess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "374-383",
          "snippet": "void notifyExited(int status) {\n    // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n    // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n    // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n    //\n    // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n    //   async I/O.\n\n    pid = 0;\n  }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nSubprocess {\n  void notifyExited(int status) {\n      // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n      // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n      // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n      //\n      // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n      //   async I/O.\n  \n      pid = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0007"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "capset(&hdr, data)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capset",
          "args": [
            "&hdr",
            "data"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "sizeof(data)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"metadata\"",
            "O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setresuid(*u, *u, *u)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "*u",
            "*u",
            "*u"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "chdir(\"/tmp\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/tmp\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "umount2(\".\", MNT_DETACH)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\".\"",
            "MNT_DETACH"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fchdir(oldRootDir)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "oldRootDir"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "syscall(SYS_pivot_root, \"/tmp\", \"/tmp\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_pivot_root",
            "\"/tmp\"",
            "\"/tmp\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "\"/\"",
            "O_RDONLY | O_DIRECTORY | O_CLOEXEC"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "filename.cStr()",
            "\"/tmp/tmp/file.zip\"",
            "nullptr",
            "MS_BIND",
            "nullptr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.cStr",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "\"/tmp/tmp/file.zip\"",
            "S_IFREG | 0666",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "kj::str(grainDir, \"/log\")",
            "\"/tmp/tmp/log\"",
            "MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "98-106",
          "snippet": "void BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n      src, dst);\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n    // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n    // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n    // them.\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                     MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n        src, dst);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "grainDir",
            "\"/log\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "\"/tmp/tmp/log\"",
            "S_IFREG | 0666",
            "0"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "grainDir",
            "\"/sandbox\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(\"/tmp/tmp/data\", 0777)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "\"/tmp/tmp/data\"",
            "0777"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/tmp\"",
            "\"tmpfs\"",
            "0",
            "\"size=8m,nr_inodes=128,mode=777\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/etc\"",
            "\"tmpfs\"",
            "0",
            "\"size=32k,nr_inodes=8,mode=000\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\")"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/var\"",
            "\"tmpfs\"",
            "0",
            "\"size=32k,nr_inodes=8,mode=000\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\")"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/proc\"",
            "\"tmpfs\"",
            "0",
            "\"size=32k,nr_inodes=8,mode=000\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "\"/tmp/dev\"",
            "nullptr",
            "MS_BIND",
            "nullptr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/tmp/dev/null\"",
            "F_OK"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "root",
            "\"/\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"none\"",
            "\"/\"",
            "nullptr",
            "MS_REC | MS_PRIVATE",
            "nullptr"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unshare(CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "seteuid(0)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seteuid",
          "args": [
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeUserNSMap",
          "args": [
            "\"gid\"",
            "kj::str(\"1000 \", gid, \" 1\\n\")"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "writeUserNSMap",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "93-96",
          "snippet": "void BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n    kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n        .write(contents.begin(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"1000 \"",
            "gid",
            "\" 1\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"1000 \"",
            "uid",
            "\" 1\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeSetgroupsIfPresent",
          "args": [
            "\"deny\\n\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "writeSetgroupsIfPresent",
          "container": "BackupMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
          "lines": "87-91",
          "snippet": "void BackupMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <sys/prctl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <kj/debug.h>",
            "#include \"version.h\"",
            "#include \"util.h\"",
            "#include \"backup.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::writeSetgroupsIfPresent(const char *contents) {\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n      kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "unshare(CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC)",
            "STDOUT_FILENO"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "filename",
            "O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "kj::str(grainDir, \"/sandbox\").cStr()",
            "0770"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "grainDir",
            "\"/sandbox\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nBackupMain {\n  bool BackupMain::run(kj::StringPtr grainDir) {\n    // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n    // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n    // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n    KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n  \n    // Create files / directories before we potentially change the UID, so that they are created\n    // with the right owner.\n    if (restore) {\n      KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n    } else if (filename != \"-\") {\n      // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n      KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n    }\n  \n    if (sandboxUid == nullptr) {\n      uid_t uid = getuid();\n      gid_t gid = getgid();\n  \n      KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n      writeSetgroupsIfPresent(\"deny\\n\");\n      writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n      writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n    } else {\n      KJ_SYSCALL(seteuid(0));\n      KJ_SYSCALL(unshare(CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    }\n  \n    // To really unshare the mount namespace, we also have to make sure all mounts are private.\n    // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n    // are undocumented.  :(\n    KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n  \n    // Mount root read-only.\n    bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n  \n    if (access(\"/tmp/dev/null\", F_OK) != 0) {\n      // Looks like we need to bind in /dev.\n      KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Hide sensitive directories.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  \n    // Mount inner tmpfs.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n  \n    // Bind in the grain's `data` (=`sandbox`).\n    KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n    bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n         MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n  \n    // Bind in the grain's `log`. When restoring, we discard the log.\n    if (!restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n      bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n    }\n  \n    // Bind in the file.\n    if (restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n      KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n    // See supervisor-main.c++ for more discussion.\n    {\n      auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n      KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n      KJ_SYSCALL(fchdir(oldRootDir));\n      KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n      KJ_SYSCALL(chdir(\"/tmp\"));\n    }\n  \n    KJ_IF_MAYBE(u, sandboxUid) {\n      KJ_SYSCALL(setresuid(*u, *u, *u));\n    }\n  \n    // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n    //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n    //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n    //   supervisor.c++...\n  \n    if (!restore) {\n      // Read stdin to metadata file.\n      kj::FdInputStream in(STDIN_FILENO);\n      kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n      pump(in, out);\n    }\n  \n    {\n      // Drop crapabilities.\n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n      umask(0007);\n    }\n  \n    // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n    //   to zip/unzip.\n    if (restore) {\n      Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n  \n      // Read metadata file to stdout.\n      kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n      kj::FdOutputStream out(STDOUT_FILENO);\n      pump(in, out);\n    } else {\n      Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n      auto inPipe = Pipe::make();\n      zipOptions.stdin = inPipe.readEnd;\n      Subprocess zip(kj::mv(zipOptions));\n      inPipe.readEnd = nullptr;\n  \n      {\n        kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n        for (auto& entry: listDirectory(\".\")) {\n          findFilesToZip(entry, out);\n        }\n      }\n  \n      zip.waitForSuccess();\n    }\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "bind",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "98-106",
    "snippet": "void BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n      src, dst);\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr)",
            "src",
            "dst"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "src.cStr()",
            "dst.cStr()",
            "nullptr",
            "MS_BIND | MS_REC | MS_REMOUNT | flags",
            "nullptr"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.cStr",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr)",
            "src",
            "dst"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "src.cStr()",
            "dst.cStr()",
            "nullptr",
            "MS_BIND | MS_REC",
            "nullptr"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.cStr",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.cStr",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n    // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n    // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n    // them.\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n    KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                     MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n        src, dst);\n  }\n}"
  },
  {
    "function_name": "writeUserNSMap",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "93-96",
    "snippet": "void BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "contents.begin()",
            "contents.size()"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.size",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.begin",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "kj::str(\"/proc/self/\", type, \"_map\").cStr()",
            "O_WRONLY | O_CLOEXEC"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"/proc/self/\"",
            "type",
            "\"_map\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n    kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n        .write(contents.begin(), contents.size());\n  }\n}"
  },
  {
    "function_name": "writeSetgroupsIfPresent",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "87-91",
    "snippet": "void BackupMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "contents",
            "strlen(contents)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "contents"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "kj::mv(*fd)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*fd"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fd",
            "raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpenIfExists",
          "args": [
            "\"/proc/self/setgroups\"",
            "O_WRONLY | O_CLOEXEC"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  void BackupMain::writeSetgroupsIfPresent(const char *contents) {\n    KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n      kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n    }\n  }\n}"
  },
  {
    "function_name": "setUid",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "71-85",
    "snippet": "bool BackupMain::setUid(kj::StringPtr arg) {\n  KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n    if (getuid() != 0) {\n      return false;\n    }\n    if (*u == 0) {\n      return false;\n    }\n    KJ_SYSCALL(seteuid(*u));\n    sandboxUid = *u;\n    return true;\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "seteuid(*u)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seteuid",
          "args": [
            "*u"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "u",
            "parseUInt(arg, 10)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "BridgeProxy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/bridge-proxy.c++",
          "lines": "144-150",
          "snippet": "KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n      if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n        auto token = auth->slice(strlen(\"bearer \"));\n        auto session = getHttpSession(token);\n        return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n      }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include <kj/debug.h>",
            "#include <capnp/compat/json.h>",
            "#include <sandstorm/bridge-proxy.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <map>",
            "#include \"bridge-proxy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <kj/debug.h>\n#include <capnp/compat/json.h>\n#include <sandstorm/bridge-proxy.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <map>\n#include \"bridge-proxy.h\"\n\nBridgeProxy {\n  KJ_IF_MAYBE(auth, headers.get(hAuthorization)) {\n        if (auth->startsWith(\"bearer \") || auth->startsWith(\"Bearer \")) {\n          auto token = auth->slice(strlen(\"bearer \"));\n          auto session = getHttpSession(token);\n          return dispatchToSession(kj::mv(session), method, url, headers, requestBody, response);\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseUInt",
          "args": [
            "arg",
            "10"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "parseUInt64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "223-230",
          "snippet": "kj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<uint64_t> parseUInt64(kj::StringPtr s, int base) {\n  char* end;\n  uint64_t result = strtoull(s.cStr(), &end, base);\n  if (s.size() == 0 || *end != '\\0') {\n    return nullptr;\n  }\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setUid(kj::StringPtr arg) {\n    KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n      if (getuid() != 0) {\n        return false;\n      }\n      if (*u == 0) {\n        return false;\n      }\n      KJ_SYSCALL(seteuid(*u));\n      sandboxUid = *u;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"
  },
  {
    "function_name": "setRoot",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "66-69",
    "snippet": "bool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRoot(kj::StringPtr arg) {\n    root = arg;\n    return true;\n  }\n}"
  },
  {
    "function_name": "setFile",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "61-64",
    "snippet": "bool BackupMain::setFile(kj::StringPtr arg) {\n  filename = arg;\n  return true;\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setFile(kj::StringPtr arg) {\n    filename = arg;\n    return true;\n  }\n}"
  },
  {
    "function_name": "setRestore",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "56-59",
    "snippet": "bool BackupMain::setRestore() {\n  restore = true;\n  return true;\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  bool BackupMain::setRestore() {\n    restore = true;\n    return true;\n  }\n}"
  },
  {
    "function_name": "getMain",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "38-54",
    "snippet": "kj::MainFunc BackupMain::getMain() {\n  return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                         \"Backs up the grain directory in <grain> to <file>, reading the grain \"\n                         \"metadata struct on stdin. Or, restores the backup in <file>, \"\n                         \"unpacking it to <grain>, and writing the metadata to stdout. In \"\n                         \"backup mode, <file> can be `-` to write the data to stdout.\")\n      .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                        \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\")\n      .addOption({'r', \"restore\"}, KJ_BIND_METHOD(*this, setRestore),\n                 \"Restore a backup, rather than create a backup.\")\n      .addOptionWithArg({\"root\"}, KJ_BIND_METHOD(*this, setRoot), \"<root>\",\n                 \"Set the \\\"root directory\\\" to map in, which contains the zip/unzip binaries.\")\n      .expectArg(\"<file>\", KJ_BIND_METHOD(*this, setFile))\n      .expectArg(\"<grain>\", KJ_BIND_METHOD(*this, run))\n      .build();\n}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<grain>\"",
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<file>\"",
            "KJ_BIND_METHOD(*this, setFile)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setFile"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"root\"}",
            "KJ_BIND_METHOD(*this, setRoot)",
            "\"<root>\"",
            "\"Set the \\\"root directory\\\" to map in, which contains the zip/unzip binaries.\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setRoot"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{'r', \"restore\"}",
            "KJ_BIND_METHOD(*this, setRestore)",
            "\"Restore a backup, rather than create a backup.\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setRestore"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"uid\"}",
            "KJ_BIND_METHOD(*this, setUid)",
            "\"<uid>\"",
            "\"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setUid"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Backs up the grain directory in <grain> to <file>, reading the grain \"\n                         \"metadata struct on stdin. Or, restores the backup in <file>, \"\n                         \"unpacking it to <grain>, and writing the metadata to stdout. In \"\n                         \"backup mode, <file> can be `-` to write the data to stdout.\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  kj::MainFunc BackupMain::getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Backs up the grain directory in <grain> to <file>, reading the grain \"\n                           \"metadata struct on stdin. Or, restores the backup in <file>, \"\n                           \"unpacking it to <grain>, and writing the metadata to stdout. In \"\n                           \"backup mode, <file> can be `-` to write the data to stdout.\")\n        .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                          \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                          \"to <uid> to run the app.\")\n        .addOption({'r', \"restore\"}, KJ_BIND_METHOD(*this, setRestore),\n                   \"Restore a backup, rather than create a backup.\")\n        .addOptionWithArg({\"root\"}, KJ_BIND_METHOD(*this, setRoot), \"<root>\",\n                   \"Set the \\\"root directory\\\" to map in, which contains the zip/unzip binaries.\")\n        .expectArg(\"<file>\", KJ_BIND_METHOD(*this, setFile))\n        .expectArg(\"<grain>\", KJ_BIND_METHOD(*this, run))\n        .build();\n  }\n}"
  },
  {
    "function_name": "BackupMain",
    "container": "BackupMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
    "lines": "36-36",
    "snippet": "BackupMain::BackupMain(kj::ProcessContext& context): context(context) {}",
    "includes": [
      "#include <sys/capability.h>",
      "#include <sys/prctl.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/syscall.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <kj/debug.h>",
      "#include \"version.h\"",
      "#include \"util.h\"",
      "#include \"backup.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\nBackupMain {\n  BackupMain::BackupMain(kj::ProcessContext& context): context(context) {}\n}"
  }
]