[
  {
    "function_name": "printKey",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "223-229",
    "snippet": "void printKey(PublicSigningKey::Reader key) {\n    auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                        \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                        \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                        \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n    kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "str.begin()",
            "str.size()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.size",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.begin",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"(key0 = 0x\"",
            "kj::hex(key.getKey0())",
            "\", \"\n                        \"key1 = 0x\"",
            "kj::hex(key.getKey1())",
            "\", \"\n                        \"key2 = 0x\"",
            "kj::hex(key.getKey2())",
            "\", \"\n                        \"key3 = 0x\"",
            "kj::hex(key.getKey3())",
            "\"),\\n\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "key.getKey3()"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getKey3",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "key.getKey2()"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getKey2",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "key.getKey1()"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getKey1",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "key.getKey0()"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.getKey0",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  void printKey(PublicSigningKey::Reader key) {\n      auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                          \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                          \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                          \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n      kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n    }\n}"
  },
  {
    "function_name": "doList",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "187-201",
    "snippet": "kj::MainBuilder::Validity doList() {\n    if (keyring == nullptr) {\n      for (auto key: *UPDATE_PUBLIC_KEYS) printKey(key);\n    } else {\n      capnp::MallocMessageBuilder message;\n      auto keys = message.getRoot<capnp::AnyPointer>()\n          .initAs<capnp::List<PublicSigningKey>>(keyring.size());\n      for (auto i: kj::indices(keyring)) {\n        KJ_ASSERT(crypto_sign_ed25519_sk_to_pk(\n            getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES), keyring[i].key) == 0);\n      }\n      for (auto key: keys) printKey(key);\n    }\n    context.exit();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printKey",
          "args": [
            "key"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "printKey",
          "container": "UpdateToolMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
          "lines": "223-229",
          "snippet": "void printKey(PublicSigningKey::Reader key) {\n    auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                        \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                        \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                        \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n    kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n  }",
          "includes": [
            "#include <capnp/pretty-print.h>",
            "#include <sodium/randombytes.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include \"util.h\"",
            "#include <capnp/serialize.h>",
            "#include \"version.h\"",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  void printKey(PublicSigningKey::Reader key) {\n      auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                          \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                          \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                          \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n      kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_sign_ed25519_sk_to_pk(\n            getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES), keyring[i].key) == 0"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_ed25519_sk_to_pk",
          "args": [
            "getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES)",
            "keyring[i].key"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "keys[i]",
            "crypto_sign_ed25519_PUBLICKEYBYTES"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "keyring"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<capnp::AnyPointer>",
          "args": [
            "keyring.size()"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring.size",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.getRoot<capnp::AnyPointer>",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity doList() {\n      if (keyring == nullptr) {\n        for (auto key: *UPDATE_PUBLIC_KEYS) printKey(key);\n      } else {\n        capnp::MallocMessageBuilder message;\n        auto keys = message.getRoot<capnp::AnyPointer>()\n            .initAs<capnp::List<PublicSigningKey>>(keyring.size());\n        for (auto i: kj::indices(keyring)) {\n          KJ_ASSERT(crypto_sign_ed25519_sk_to_pk(\n              getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES), keyring[i].key) == 0);\n        }\n        for (auto key: keys) printKey(key);\n      }\n      context.exit();\n    }\n}"
  },
  {
    "function_name": "getListMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "178-185",
    "snippet": "kj::MainFunc getListMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"List public keys for keys in <keyring>, or compiled keys if \"\n                           \"<keyring> is not provided.\")\n        .expectOptionalArg(\"<keyring>\", KJ_BIND_METHOD(*this, loadKeyring))\n        .callAfterParsing(KJ_BIND_METHOD(*this, doList))\n        .build();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, doList)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doList"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<keyring>\"",
            "KJ_BIND_METHOD(*this, loadKeyring)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "loadKeyring"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"List public keys for keys in <keyring>, or compiled keys if \"\n                           \"<keyring> is not provided.\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainFunc getListMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"List public keys for keys in <keyring>, or compiled keys if \"\n                             \"<keyring> is not provided.\")\n          .expectOptionalArg(\"<keyring>\", KJ_BIND_METHOD(*this, loadKeyring))\n          .callAfterParsing(KJ_BIND_METHOD(*this, doList))\n          .build();\n    }\n}"
  },
  {
    "function_name": "doAdd",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "157-176",
    "snippet": "kj::MainBuilder::Validity doAdd(kj::StringPtr arg) {\n    if (access(arg.cStr(), F_OK) == 0) {\n      // Verify that this keyring looks right.\n      auto loadResult = loadKeyring(arg);\n      if (loadResult.getError() != nullptr) return loadResult;\n    }\n\n    // Add a new key seed.\n    byte random[crypto_sign_ed25519_SEEDBYTES];\n    randombytes(random, sizeof(random));\n    kj::FdOutputStream(raiiOpen(arg, O_WRONLY | O_APPEND | O_CREAT, 0600))\n        .write(random, sizeof(random));\n\n    // Write key.\n    capnp::MallocMessageBuilder message;\n    auto key = message.getRoot<PublicSigningKey>();\n    memcpy(getUnderlyingBytes(kj::cp(key), sizeof(random)), random, sizeof(random));\n    printKey(key);\n    context.exitInfo(\"*** Don't forget to back up the keyring! ***\");\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exitInfo",
          "args": [
            "\"*** Don't forget to back up the keyring! ***\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printKey",
          "args": [
            "key"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "printKey",
          "container": "UpdateToolMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
          "lines": "223-229",
          "snippet": "void printKey(PublicSigningKey::Reader key) {\n    auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                        \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                        \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                        \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n    kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n  }",
          "includes": [
            "#include <capnp/pretty-print.h>",
            "#include <sodium/randombytes.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include \"util.h\"",
            "#include <capnp/serialize.h>",
            "#include \"version.h\"",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  void printKey(PublicSigningKey::Reader key) {\n      auto str = kj::str(\"(key0 = 0x\", kj::hex(key.getKey0()), \", \"\n                          \"key1 = 0x\", kj::hex(key.getKey1()), \", \"\n                          \"key2 = 0x\", kj::hex(key.getKey2()), \", \"\n                          \"key3 = 0x\", kj::hex(key.getKey3()), \"),\\n\");\n      kj::FdOutputStream(STDOUT_FILENO).write(str.begin(), str.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "getUnderlyingBytes(kj::cp(key), sizeof(random))",
            "random",
            "sizeof(random)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "kj::cp(key)",
            "sizeof(random)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "key"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<PublicSigningKey>",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "random",
            "sizeof(random)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "raiiOpen(arg, O_WRONLY | O_APPEND | O_CREAT, 0600)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "arg",
            "O_WRONLY | O_APPEND | O_CREAT",
            "0600"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "raiiOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "71-82",
          "snippet": "kj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Maybe<kj::AutoCloseFd> raiiOpenIfExists(kj::StringPtr name, int flags, mode_t mode) {\n  int fd = open(name.cStr(), flags, mode);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      return nullptr;\n    } else {\n      KJ_FAIL_SYSCALL(\"open\", errno, name);\n    }\n  } else {\n    return kj::AutoCloseFd(fd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "randombytes",
          "args": [
            "random",
            "sizeof(random)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadResult.getError",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadKeyring",
          "args": [
            "arg"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "loadKeyring",
          "container": "UpdateToolMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
          "lines": "53-91",
          "snippet": "kj::MainBuilder::Validity loadKeyring(kj::StringPtr arg) {\n    // The keyring file is actually 100% random. Every 32 bytes is a seed used to generate a\n    // keypair.\n\n    auto bytes = readAllBytes(raiiOpen(arg, O_RDONLY));\n    if (bytes == nullptr) return \"file is empty\";\n\n    size_t count = bytes.size() / crypto_sign_ed25519_SEEDBYTES;\n    if (bytes.size() % crypto_sign_ed25519_SEEDBYTES != 0) return \"invalid keyring\";\n\n    auto publicKeys = *UPDATE_PUBLIC_KEYS;\n\n    auto builder = kj::heapArrayBuilder<PrivateKey>(count);\n    for (size_t i = 0; i < count; i++) {\n      byte publicKey[crypto_sign_ed25519_PUBLICKEYBYTES];\n      KJ_ASSERT(crypto_sign_ed25519_seed_keypair(publicKey, builder.add().key,\n          bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES) == 0);\n\n      if (i < publicKeys.size()) {\n        if (memcmp(publicKey, getUnderlyingBytes(publicKeys[i], crypto_sign_ed25519_PUBLICKEYBYTES),\n                   crypto_sign_ed25519_PUBLICKEYBYTES) != 0) {\n          return kj::str(\"keyring does not match public key #\", i);\n        }\n      }\n    }\n\n    if (count < publicKeys.size()) {\n      return kj::str(\"keyring is missing keys starting at #\", count);\n    }\n\n    if (count > publicKeys.size()) {\n      context.warning(kj::str(\n          \"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\"));\n    }\n\n    keyring = builder.finish();\n\n    return true;\n  }",
          "includes": [
            "#include <capnp/pretty-print.h>",
            "#include <sodium/randombytes.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include \"util.h\"",
            "#include <capnp/serialize.h>",
            "#include \"version.h\"",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity loadKeyring(kj::StringPtr arg) {\n      // The keyring file is actually 100% random. Every 32 bytes is a seed used to generate a\n      // keypair.\n  \n      auto bytes = readAllBytes(raiiOpen(arg, O_RDONLY));\n      if (bytes == nullptr) return \"file is empty\";\n  \n      size_t count = bytes.size() / crypto_sign_ed25519_SEEDBYTES;\n      if (bytes.size() % crypto_sign_ed25519_SEEDBYTES != 0) return \"invalid keyring\";\n  \n      auto publicKeys = *UPDATE_PUBLIC_KEYS;\n  \n      auto builder = kj::heapArrayBuilder<PrivateKey>(count);\n      for (size_t i = 0; i < count; i++) {\n        byte publicKey[crypto_sign_ed25519_PUBLICKEYBYTES];\n        KJ_ASSERT(crypto_sign_ed25519_seed_keypair(publicKey, builder.add().key,\n            bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES) == 0);\n  \n        if (i < publicKeys.size()) {\n          if (memcmp(publicKey, getUnderlyingBytes(publicKeys[i], crypto_sign_ed25519_PUBLICKEYBYTES),\n                     crypto_sign_ed25519_PUBLICKEYBYTES) != 0) {\n            return kj::str(\"keyring does not match public key #\", i);\n          }\n        }\n      }\n  \n      if (count < publicKeys.size()) {\n        return kj::str(\"keyring is missing keys starting at #\", count);\n      }\n  \n      if (count > publicKeys.size()) {\n        context.warning(kj::str(\n            \"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\"));\n      }\n  \n      keyring = builder.finish();\n  \n      return true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "arg.cStr()",
            "F_OK"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg.cStr",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity doAdd(kj::StringPtr arg) {\n      if (access(arg.cStr(), F_OK) == 0) {\n        // Verify that this keyring looks right.\n        auto loadResult = loadKeyring(arg);\n        if (loadResult.getError() != nullptr) return loadResult;\n      }\n  \n      // Add a new key seed.\n      byte random[crypto_sign_ed25519_SEEDBYTES];\n      randombytes(random, sizeof(random));\n      kj::FdOutputStream(raiiOpen(arg, O_WRONLY | O_APPEND | O_CREAT, 0600))\n          .write(random, sizeof(random));\n  \n      // Write key.\n      capnp::MallocMessageBuilder message;\n      auto key = message.getRoot<PublicSigningKey>();\n      memcpy(getUnderlyingBytes(kj::cp(key), sizeof(random)), random, sizeof(random));\n      printKey(key);\n      context.exitInfo(\"*** Don't forget to back up the keyring! ***\");\n    }\n}"
  },
  {
    "function_name": "getAddMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "150-155",
    "snippet": "kj::MainFunc getAddMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Add a new key to <keyring>.\")\n        .expectArg(\"<keyring>\", KJ_BIND_METHOD(*this, doAdd))\n        .build();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<keyring>\"",
            "KJ_BIND_METHOD(*this, doAdd)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doAdd"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Add a new key to <keyring>.\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainFunc getAddMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Add a new key to <keyring>.\")\n          .expectArg(\"<keyring>\", KJ_BIND_METHOD(*this, doAdd))\n          .build();\n    }\n}"
  },
  {
    "function_name": "doVerify",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "119-148",
    "snippet": "kj::MainBuilder::Validity doVerify(kj::StringPtr arg) {\n    auto bundle = raiiOpen(arg, O_RDONLY);\n    MemoryMapping mapping(bundle, arg);\n    capnp::Data::Reader data = mapping;\n\n    capnp::StreamFdMessageReader signatureMessage(STDIN_FILENO);\n    auto signatures = signatureMessage.getRoot<UpdateSignature>().getSignatures();\n    auto keys = *UPDATE_PUBLIC_KEYS;\n\n    for (auto i: kj::indices(keys)) {\n      if (i >= signatures.size()) {\n        context.error(kj::str(\"key \", i, \": NO SIGNATURE\"));\n        continue;\n      } else if (crypto_sign_ed25519_verify_detached(\n          getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES),\n          data.begin(), data.size(),\n          getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES)) == 0) {\n        context.warning(kj::str(\"key \", i, \": PASS\"));\n      } else {\n        context.error(kj::str(\"key \", i, \": FAIL\"));\n      }\n    }\n\n    if (keys.size() < signatures.size()) {\n      context.warning(kj::str(\n          \"signature has \", signatures.size() - keys.size(), \" additional keys.\"));\n    }\n\n    context.exit();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\n          \"signature has \", signatures.size() - keys.size(), \" additional keys.\")"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"signature has \"",
            "signatures.size() - keys.size()",
            "\" additional keys.\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keys.size",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "kj::str(\"key \", i, \": FAIL\")"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"key \"",
            "i",
            "\": FAIL\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\"key \", i, \": PASS\")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"key \"",
            "i",
            "\": PASS\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_ed25519_verify_detached",
          "args": [
            "getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES)",
            "data.begin()",
            "data.size()",
            "getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "keys[i]",
            "crypto_sign_ed25519_PUBLICKEYBYTES"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "signatures[i]",
            "crypto_sign_ed25519_BYTES"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "kj::str(\"key \", i, \": NO SIGNATURE\")"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"key \"",
            "i",
            "\": NO SIGNATURE\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "keys"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signatureMessage.getRoot<UpdateSignature>",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signatureMessage.getRoot<UpdateSignature>",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "arg",
            "O_RDONLY"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity doVerify(kj::StringPtr arg) {\n      auto bundle = raiiOpen(arg, O_RDONLY);\n      MemoryMapping mapping(bundle, arg);\n      capnp::Data::Reader data = mapping;\n  \n      capnp::StreamFdMessageReader signatureMessage(STDIN_FILENO);\n      auto signatures = signatureMessage.getRoot<UpdateSignature>().getSignatures();\n      auto keys = *UPDATE_PUBLIC_KEYS;\n  \n      for (auto i: kj::indices(keys)) {\n        if (i >= signatures.size()) {\n          context.error(kj::str(\"key \", i, \": NO SIGNATURE\"));\n          continue;\n        } else if (crypto_sign_ed25519_verify_detached(\n            getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES),\n            data.begin(), data.size(),\n            getUnderlyingBytes(keys[i], crypto_sign_ed25519_PUBLICKEYBYTES)) == 0) {\n          context.warning(kj::str(\"key \", i, \": PASS\"));\n        } else {\n          context.error(kj::str(\"key \", i, \": FAIL\"));\n        }\n      }\n  \n      if (keys.size() < signatures.size()) {\n        context.warning(kj::str(\n            \"signature has \", signatures.size() - keys.size(), \" additional keys.\"));\n      }\n  \n      context.exit();\n    }\n}"
  },
  {
    "function_name": "getVerifyMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "112-117",
    "snippet": "kj::MainFunc getVerifyMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Verify <file> against the signature read from standard input.\")\n        .expectArg(\"<file>\", KJ_BIND_METHOD(*this, doVerify))\n        .build();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<file>\"",
            "KJ_BIND_METHOD(*this, doVerify)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doVerify"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Verify <file> against the signature read from standard input.\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainFunc getVerifyMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Verify <file> against the signature read from standard input.\")\n          .expectArg(\"<file>\", KJ_BIND_METHOD(*this, doVerify))\n          .build();\n    }\n}"
  },
  {
    "function_name": "doSign",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "93-110",
    "snippet": "kj::MainBuilder::Validity doSign(kj::StringPtr arg) {\n    auto bundle = raiiOpen(arg, O_RDONLY);\n    MemoryMapping mapping(bundle, arg);\n    capnp::Data::Reader data = mapping;\n\n    capnp::MallocMessageBuilder output;\n    auto signatures = output.getRoot<UpdateSignature>().initSignatures(keyring.size());\n\n    for (auto i: kj::indices(keyring)) {\n      KJ_ASSERT(crypto_sign_ed25519_detached(\n          getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES),\n          nullptr, data.begin(), data.size(), keyring[i].key) == 0);\n    }\n\n    capnp::writeMessageToFd(STDOUT_FILENO, output);\n\n    context.exit();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::writeMessageToFd",
          "args": [
            "STDOUT_FILENO",
            "output"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_sign_ed25519_detached(\n          getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES),\n          nullptr, data.begin(), data.size(), keyring[i].key) == 0"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_ed25519_detached",
          "args": [
            "getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES)",
            "nullptr",
            "data.begin()",
            "data.size()",
            "keyring[i].key"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "signatures[i]",
            "crypto_sign_ed25519_BYTES"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "keyring"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.getRoot<UpdateSignature>",
          "args": [
            "keyring.size()"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.getRoot<UpdateSignature>",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "arg",
            "O_RDONLY"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity doSign(kj::StringPtr arg) {\n      auto bundle = raiiOpen(arg, O_RDONLY);\n      MemoryMapping mapping(bundle, arg);\n      capnp::Data::Reader data = mapping;\n  \n      capnp::MallocMessageBuilder output;\n      auto signatures = output.getRoot<UpdateSignature>().initSignatures(keyring.size());\n  \n      for (auto i: kj::indices(keyring)) {\n        KJ_ASSERT(crypto_sign_ed25519_detached(\n            getUnderlyingBytes(signatures[i], crypto_sign_ed25519_BYTES),\n            nullptr, data.begin(), data.size(), keyring[i].key) == 0);\n      }\n  \n      capnp::writeMessageToFd(STDOUT_FILENO, output);\n  \n      context.exit();\n    }\n}"
  },
  {
    "function_name": "loadKeyring",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "53-91",
    "snippet": "kj::MainBuilder::Validity loadKeyring(kj::StringPtr arg) {\n    // The keyring file is actually 100% random. Every 32 bytes is a seed used to generate a\n    // keypair.\n\n    auto bytes = readAllBytes(raiiOpen(arg, O_RDONLY));\n    if (bytes == nullptr) return \"file is empty\";\n\n    size_t count = bytes.size() / crypto_sign_ed25519_SEEDBYTES;\n    if (bytes.size() % crypto_sign_ed25519_SEEDBYTES != 0) return \"invalid keyring\";\n\n    auto publicKeys = *UPDATE_PUBLIC_KEYS;\n\n    auto builder = kj::heapArrayBuilder<PrivateKey>(count);\n    for (size_t i = 0; i < count; i++) {\n      byte publicKey[crypto_sign_ed25519_PUBLICKEYBYTES];\n      KJ_ASSERT(crypto_sign_ed25519_seed_keypair(publicKey, builder.add().key,\n          bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES) == 0);\n\n      if (i < publicKeys.size()) {\n        if (memcmp(publicKey, getUnderlyingBytes(publicKeys[i], crypto_sign_ed25519_PUBLICKEYBYTES),\n                   crypto_sign_ed25519_PUBLICKEYBYTES) != 0) {\n          return kj::str(\"keyring does not match public key #\", i);\n        }\n      }\n    }\n\n    if (count < publicKeys.size()) {\n      return kj::str(\"keyring is missing keys starting at #\", count);\n    }\n\n    if (count > publicKeys.size()) {\n      context.warning(kj::str(\n          \"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\"));\n    }\n\n    keyring = builder.finish();\n\n    return true;\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "kj::str(\n          \"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\")"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "publicKeys.size",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StructyMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.h",
          "lines": "139-139",
          "snippet": "size_t size() { return pos - bytes; }",
          "includes": [
            "#include <set>",
            "#include <sandstorm/util.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/async.h>",
            "#include <kj/function.h>",
            "#include <unistd.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/one-of.h>",
            "#include <kj/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <set>\n#include <sandstorm/util.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async.h>\n#include <kj/function.h>\n#include <unistd.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/one-of.h>\n#include <kj/io.h>\n\nStructyMessage {\n  size_t size() { return pos - bytes; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"keyring is missing keys starting at #\"",
            "count"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"keyring does not match public key #\"",
            "i"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "publicKey",
            "getUnderlyingBytes(publicKeys[i], crypto_sign_ed25519_PUBLICKEYBYTES)",
            "crypto_sign_ed25519_PUBLICKEYBYTES"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnderlyingBytes",
          "args": [
            "publicKeys[i]",
            "crypto_sign_ed25519_PUBLICKEYBYTES"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "crypto_sign_ed25519_seed_keypair(publicKey, builder.add().key,\n          bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES) == 0"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_sign_ed25519_seed_keypair",
          "args": [
            "publicKey",
            "builder.add().key",
            "bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes.begin",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<PrivateKey>",
          "args": [
            "count"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readAllBytes",
          "args": [
            "raiiOpen(arg, O_RDONLY)"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "readAllBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/util.c++",
          "lines": "352-365",
          "snippet": "kj::Array<byte> readAllBytes(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<byte> content;\n  for (;;) {\n    byte buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  return content.releaseAsArray();\n}",
          "includes": [
            "#include <sys/sendfile.h>",
            "#include <sys/socket.h>",
            "#include <sys/mman.h>",
            "#include <map>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <syscall.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/vector.h>",
            "#include <errno.h>",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <map>\n#include <sys/wait.h>\n#include <signal.h>\n#include <syscall.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <kj/async-unix.h>\n#include <kj/vector.h>\n#include <errno.h>\n#include \"util.h\"\n\nkj::Array<byte> readAllBytes(int fd) {\n  kj::FdInputStream input(fd);\n  kj::Vector<byte> content;\n  for (;;) {\n    byte buffer[4096];\n    size_t n = input.tryRead(buffer, sizeof(buffer), sizeof(buffer));\n    content.addAll(buffer, buffer + n);\n    if (n < sizeof(buffer)) {\n      // Done!\n      break;\n    }\n  }\n  return content.releaseAsArray();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raiiOpen",
          "args": [
            "arg",
            "O_RDONLY"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainBuilder::Validity loadKeyring(kj::StringPtr arg) {\n      // The keyring file is actually 100% random. Every 32 bytes is a seed used to generate a\n      // keypair.\n  \n      auto bytes = readAllBytes(raiiOpen(arg, O_RDONLY));\n      if (bytes == nullptr) return \"file is empty\";\n  \n      size_t count = bytes.size() / crypto_sign_ed25519_SEEDBYTES;\n      if (bytes.size() % crypto_sign_ed25519_SEEDBYTES != 0) return \"invalid keyring\";\n  \n      auto publicKeys = *UPDATE_PUBLIC_KEYS;\n  \n      auto builder = kj::heapArrayBuilder<PrivateKey>(count);\n      for (size_t i = 0; i < count; i++) {\n        byte publicKey[crypto_sign_ed25519_PUBLICKEYBYTES];\n        KJ_ASSERT(crypto_sign_ed25519_seed_keypair(publicKey, builder.add().key,\n            bytes.begin() + i * crypto_sign_ed25519_SEEDBYTES) == 0);\n  \n        if (i < publicKeys.size()) {\n          if (memcmp(publicKey, getUnderlyingBytes(publicKeys[i], crypto_sign_ed25519_PUBLICKEYBYTES),\n                     crypto_sign_ed25519_PUBLICKEYBYTES) != 0) {\n            return kj::str(\"keyring does not match public key #\", i);\n          }\n        }\n      }\n  \n      if (count < publicKeys.size()) {\n        return kj::str(\"keyring is missing keys starting at #\", count);\n      }\n  \n      if (count > publicKeys.size()) {\n        context.warning(kj::str(\n            \"WARNING: keyring contains keys than are not yet listed in updatePublicKeys\"));\n      }\n  \n      keyring = builder.finish();\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "getSignMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "44-51",
    "snippet": "kj::MainFunc getSignMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Sign a file with each key in the keyring and output the signature \"\n                           \"list to stdout.\")\n        .expectArg(\"<keyring>\", KJ_BIND_METHOD(*this, loadKeyring))\n        .expectArg(\"<file>\", KJ_BIND_METHOD(*this, doSign))\n        .build();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<file>\"",
            "KJ_BIND_METHOD(*this, doSign)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "doSign"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"<keyring>\"",
            "KJ_BIND_METHOD(*this, loadKeyring)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "loadKeyring"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Sign a file with each key in the keyring and output the signature \"\n                           \"list to stdout.\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainFunc getSignMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Sign a file with each key in the keyring and output the signature \"\n                             \"list to stdout.\")\n          .expectArg(\"<keyring>\", KJ_BIND_METHOD(*this, loadKeyring))\n          .expectArg(\"<file>\", KJ_BIND_METHOD(*this, doSign))\n          .build();\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "34-42",
    "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                           \"Tool used to sign Sandstorm updates.\")\n        .addSubCommand(\"sign\", KJ_BIND_METHOD(*this, getSignMain), \"sign an update\")\n        .addSubCommand(\"verify\", KJ_BIND_METHOD(*this, getVerifyMain), \"verify an update\")\n        .addSubCommand(\"add\", KJ_BIND_METHOD(*this, getAddMain), \"create a new key\")\n        .addSubCommand(\"list\", KJ_BIND_METHOD(*this, getListMain), \"list public keys\")\n        .build();\n  }",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"list\"",
            "KJ_BIND_METHOD(*this, getListMain)",
            "\"list public keys\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getListMain"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"add\"",
            "KJ_BIND_METHOD(*this, getAddMain)",
            "\"create a new key\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getAddMain"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"verify\"",
            "KJ_BIND_METHOD(*this, getVerifyMain)",
            "\"verify an update\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getVerifyMain"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "\"sign\"",
            "KJ_BIND_METHOD(*this, getSignMain)",
            "\"sign an update\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getSignMain"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm version \"SANDSTORM_VERSION",
            "\"Tool used to sign Sandstorm updates.\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                             \"Tool used to sign Sandstorm updates.\")\n          .addSubCommand(\"sign\", KJ_BIND_METHOD(*this, getSignMain), \"sign an update\")\n          .addSubCommand(\"verify\", KJ_BIND_METHOD(*this, getVerifyMain), \"verify an update\")\n          .addSubCommand(\"add\", KJ_BIND_METHOD(*this, getAddMain), \"create a new key\")\n          .addSubCommand(\"list\", KJ_BIND_METHOD(*this, getListMain), \"list public keys\")\n          .build();\n    }\n}"
  },
  {
    "function_name": "UpdateToolMain",
    "container": "UpdateToolMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/update-tool.c++",
    "lines": "32-32",
    "snippet": "UpdateToolMain(kj::ProcessContext& context): context(context) {}",
    "includes": [
      "#include <capnp/pretty-print.h>",
      "#include <sodium/randombytes.h>",
      "#include <sodium/crypto_sign_ed25519.h>",
      "#include \"util.h\"",
      "#include <capnp/serialize.h>",
      "#include \"version.h\"",
      "#include <sandstorm/update-tool.capnp.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/pretty-print.h>\n#include <sodium/randombytes.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include \"util.h\"\n#include <capnp/serialize.h>\n#include \"version.h\"\n#include <sandstorm/update-tool.capnp.h>\n#include <kj/main.h>\n\nUpdateToolMain {\n  UpdateToolMain(kj::ProcessContext& context): context(context) {}\n}"
  }
]