[
  {
    "function_name": "run",
    "container": "ServerMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "190-209",
    "snippet": "kj::MainBuilder::Validity run() {\n    // Set up RPC on file descriptor 3.\n    auto stream = ioContext.lowLevelProvider->wrapSocketFd(3);\n    capnp::TwoPartyVatNetwork network(*stream, capnp::rpc::twoparty::Side::CLIENT);\n    auto rpcSystem = capnp::makeRpcServer(network, kj::heap<UiViewImpl>());\n\n    // The `CLIENT` side of a `capnp::TwoPartyVatNetwork` does not serve its bootstrap capability\n    // until it has initiated a request for the bootstrap capability of the `SERVER` side.\n    // Therefore, we need to restore the supervisor's `SandstormApi` capability, even if we are not\n    // going to use it.\n    {\n      capnp::MallocMessageBuilder message;\n      auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n      vatId.setSide(capnp::rpc::twoparty::Side::SERVER);\n      sandstorm::SandstormApi<>::Client api =\n          rpcSystem.bootstrap(vatId).castAs<sandstorm::SandstormApi<>>();\n    }\n\n    kj::NEVER_DONE.wait(ioContext.waitScope);\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::NEVER_DONE.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcSystem.bootstrap",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcSystem.bootstrap",
          "args": [
            "vatId"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vatId.setSide",
          "args": [
            "capnp::rpc::twoparty::Side::SERVER"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<capnp::rpc::twoparty::VatId>",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::makeRpcServer",
          "args": [
            "network",
            "kj::heap<UiViewImpl>()"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<UiViewImpl>",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.lowLevelProvider->wrapSocketFd",
          "args": [
            "3"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nServerMain {\n  kj::MainBuilder::Validity run() {\n      // Set up RPC on file descriptor 3.\n      auto stream = ioContext.lowLevelProvider->wrapSocketFd(3);\n      capnp::TwoPartyVatNetwork network(*stream, capnp::rpc::twoparty::Side::CLIENT);\n      auto rpcSystem = capnp::makeRpcServer(network, kj::heap<UiViewImpl>());\n  \n      // The `CLIENT` side of a `capnp::TwoPartyVatNetwork` does not serve its bootstrap capability\n      // until it has initiated a request for the bootstrap capability of the `SERVER` side.\n      // Therefore, we need to restore the supervisor's `SandstormApi` capability, even if we are not\n      // going to use it.\n      {\n        capnp::MallocMessageBuilder message;\n        auto vatId = message.getRoot<capnp::rpc::twoparty::VatId>();\n        vatId.setSide(capnp::rpc::twoparty::Side::SERVER);\n        sandstorm::SandstormApi<>::Client api =\n            rpcSystem.bootstrap(vatId).castAs<sandstorm::SandstormApi<>>();\n      }\n  \n      kj::NEVER_DONE.wait(ioContext.waitScope);\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "ServerMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "183-188",
    "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Sandstorm Thin Server\",\n                           \"Intended to be run as the root process of a Sandstorm app.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "Validity inheritPidfileFd",
          "container": "kj::MainBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/run-bundle.c++",
          "lines": "432-752",
          "snippet": "class RunBundleMain {\n  // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n  // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n  // to run a Sandstorm server.  Just unpack and run!\n\n  struct Config;\n\npublic:\n  RunBundleMain(kj::ProcessContext& context): context(context) {\n    // Make sure we didn't inherit a weird signal mask from the parent process.\n    clearSignalMask();\n    umask(0022);\n\n    if (!isKernelNewEnough()) {\n      context.exitError(\n          \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n    }\n  }\n\n  kj::MainFunc getMain() {\n    static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n\n    {\n      auto programName = context.getProgramName();\n      if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n        alternateMain = kj::heap<SupervisorMain>(context);\n        return alternateMain->getMain();\n      } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n        alternateMain = getSpkMain(context);\n        return alternateMain->getMain();\n      } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n        alternateMain = kj::heap<BackupMain>(context);\n        return alternateMain->getMain();\n      }\n    }\n\n    return kj::MainBuilder(context, VERSION,\n            \"Controls the Sandstorm server.\\n\\n\"\n            \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n        .addSubCommand(\"start\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                  .build();\n            },\n            \"Start the sandstorm server.\")\n        .addSubCommand(\"stop\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                  .build();\n            },\n            \"Stop the sandstorm server.\")\n        .addSubCommand(\"start-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                    \"the `stop-fe` command.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                  .build();\n            },\n            \"Undo previous stop-fe.\")\n        .addSubCommand(\"stop-fe\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                    \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                    \"want to run the front-end in dev mode in front of the existing database \"\n                    \"and grains.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                  .build();\n            },\n            \"Stop the sandstorm front-end.\")\n        .addSubCommand(\"status\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                      \"if so; exits with an error otherwise.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                  .build();\n            },\n            \"Check if Sandstorm is running.\")\n        .addSubCommand(\"restart\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                  .build();\n            },\n            \"Restart Sandstorm server.\")\n        .addSubCommand(\"mongo\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                  \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                  .build();\n            },\n            \"Run MongoDB shell.\")\n        .addSubCommand(\"update\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                      \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                      \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                      \"securely check the web for an update. If <release> is not provided, we \"\n                      \"use the channel specified in the config file.\")\n                  .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                  .build();\n            },\n            \"Update the Sandstorm platform.\")\n        .addSubCommand(\"spk\",\n            [this]() {\n              alternateMain = getSpkMain(context);\n              return alternateMain->getMain();\n            },\n            \"Manipulate spk files.\")\n        .addSubCommand(\"continue\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Continues running Sandstorm after an update. \"\n                      \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                      \"directly.\")\n                  .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                      \"Pass this flag if the parent has already set up and entered a UID \"\n                      \"namespace.\")\n                  .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                  .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                  .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"dev\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"For internal use only: Runs an app in dev mode. This command is \"\n                      \"invoked by the `spk` tool. Do not run it directly.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                  .build();\n            },\n            \"For internal use only.\")\n        .addSubCommand(\"admin-token\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Generates a new admin token that you can use to access the admin settings \"\n                      \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                  .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                      \"Output only the token.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                  .build();\n            },\n            \"Generate admin token.\")\n        .addSubCommand(\"uninstall\",\n            [this]() {\n              return kj::MainBuilder(context, VERSION,\n                      \"Uninstalls Sandstorm.\")\n                  .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                      \"Also delete all user data.\")\n                  .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                  .build();\n            },\n            \"Uninstall Sandstorm.\")\n        .build();\n  }\n\n  kj::MainBuilder::Validity start() {\n    changeToInstallDir();\n    const Config config = readConfig();\n\n    // Check / lock the pidfile.\n    auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n        int error = errno;\n        if (error == EACCES || error == EAGAIN) {\n          context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n        } else {\n          KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n        }\n      }\n\n      // It's ours.  Truncate for now so we can write in the new PID later.\n      KJ_SYSCALL(ftruncate(pidfile, 0));\n    }\n\n    if (!runningAsRoot) unshareUidNamespaceOnce();\n\n    // Unshare PID namespace so that daemon process becomes the root process of its own PID\n    // namespace and therefore if it dies the whole namespace is killed.\n    KJ_SYSCALL(unshare(CLONE_NEWPID));\n\n    // Daemonize ourselves.\n    pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n    {\n      int pipeFds[2];\n      KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n      kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n\n      KJ_SYSCALL(mainPid = fork());\n      if (mainPid != 0) {\n        // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n        // unhelpfully return 1.\n        pipeIn = nullptr;\n        kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n\n        // Write the pidfile before exiting.\n        {\n          auto pidstr = kj::str(mainPid, '\\n');\n          kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n        }\n\n        // Exit success.\n        context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n        return true;\n      }\n\n      // Read our (global) PID in from the parent process.\n      pipeOut = nullptr;\n      kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n    }\n\n    // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n    // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n    // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n    KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n\n    // Lock the pidfile and make sure it still belongs to us.\n    //\n    // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n    // However, if another Sandstorm server is started simultaneously and manages to steal\n    // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n    {\n      struct flock lock;\n      memset(&lock, 0, sizeof(lock));\n      lock.l_type = F_RDLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;  // entire file\n      KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n\n      // Verify that we still own the file.\n      KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n      pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n      if (pidfilePid != mainPid) {\n        context.exitInfo(kj::str(\n            \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n            \"PID \", mainPid, \" exiting in deference.\"));\n      }\n    }\n\n    // Redirect stdio.\n    {\n      auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n      if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n      KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n      KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n    }\n    {\n      auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n      KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n    }\n\n    // Write time to log.\n    time_t now;\n    time(&now);\n    context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n\n    // Detach from controlling terminal and make ourselves session leader.\n    KJ_SYSCALL(setsid());\n\n    FdBundle fdBundle(config);\n\n    runUpdateMonitor(config, fdBundle, pidfile);\n  }\n\n  kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n    auto parts = split(mapping, ':');\n    if (parts.size() != 3) {\n      return \"invalid syntax for port mapping\";\n    }\n\n    int fd;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n      fd = *p;\n    } else {\n      return \"invalid fd\";\n    }\n\n    kj::String type = kj::str(parts[1]);\n    if (type != \"tcp\") {\n      return \"invalid type\";\n    }\n\n    uint port;\n    KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n      port = *p;\n    } else {\n      return \"invalid port\";\n    }\n\n    KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n    if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n      return \"duplicate port\";\n    }\n\n    return true;\n  }\n\n  kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n    KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n      inheritedPidfile = kj::AutoCloseFd(*p);\n      KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n      return true;\n    } else {\n      return \"invalid fd\";\n    }\n  }",
          "includes": [
            "#include \"backup.h\"",
            "#include \"backend.h\"",
            "#include \"spk.h\"",
            "#include \"util.h\"",
            "#include \"supervisor.h\"",
            "#include \"send-fd.h\"",
            "#include \"version.h\"",
            "#include <arpa/inet.h>",
            "#include <dirent.h>",
            "#include <netdb.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>  // rename()",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <grp.h>",
            "#include <sched.h>",
            "#include <linux/securebits.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/capability.h>",
            "#include <sys/utsname.h>",
            "#include <sys/syscall.h>",
            "#include <sys/prctl.h>",
            "#include <sys/sendfile.h>",
            "#include <sys/wait.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <sodium/crypto_sign_ed25519.h>",
            "#include <sodium/randombytes.h>",
            "#include <sandstorm/update-tool.capnp.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/parse/common.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid;",
            "kj::Own<AbstractMain> alternateMain;",
            "kj::AutoCloseFd inheritedPidfile;",
            "std::map<uint, kj::AutoCloseFd> inheritedTcpPorts;",
            "bool unsharedUidNamespace = false;",
            "bool runningAsRoot = getuid() == 0;",
            "bool shortOutput = false;",
            "bool deleteUserData = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backup.h\"\n#include \"backend.h\"\n#include \"spk.h\"\n#include \"util.h\"\n#include \"supervisor.h\"\n#include \"send-fd.h\"\n#include \"version.h\"\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <netdb.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <stdio.h>  // rename()\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <grp.h>\n#include <sched.h>\n#include <linux/securebits.h>\n#include <sys/ioctl.h>\n#include <sys/eventfd.h>\n#include <sys/capability.h>\n#include <sys/utsname.h>\n#include <sys/syscall.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/wait.h>\n#include <sys/signalfd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sodium/crypto_sign_ed25519.h>\n#include <sodium/randombytes.h>\n#include <sandstorm/update-tool.capnp.h>\n#include <sandstorm/package.capnp.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.h>\n#include <kj/parse/char.h>\n#include <kj/parse/common.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\npid_t pid;\nkj::Own<AbstractMain> alternateMain;\nkj::AutoCloseFd inheritedPidfile;\nstd::map<uint, kj::AutoCloseFd> inheritedTcpPorts;\nbool unsharedUidNamespace = false;\nbool runningAsRoot = getuid() == 0;\nbool shortOutput = false;\nbool deleteUserData = false;\n\nkj {\n  MainBuilder {\n    class RunBundleMain {\n      // Main class for the Sandstorm bundle runner.  This is a convenience tool for running the\n      // Sandstorm binary bundle, which is a packaged chroot environment containing everything needed\n      // to run a Sandstorm server.  Just unpack and run!\n    \n      struct Config;\n    \n    public:\n      RunBundleMain(kj::ProcessContext& context): context(context) {\n        // Make sure we didn't inherit a weird signal mask from the parent process.\n        clearSignalMask();\n        umask(0022);\n    \n        if (!isKernelNewEnough()) {\n          context.exitError(\n              \"ERROR: Your Linux kernel is too old. You need at least kernel version 3.10.\");\n        }\n      }\n    \n      kj::MainFunc getMain() {\n        static const char* VERSION = \"Sandstorm version \" SANDSTORM_VERSION;\n    \n        {\n          auto programName = context.getProgramName();\n          if (programName.endsWith(\"supervisor\")) {  // historically \"sandstorm-supervisor\"\n            alternateMain = kj::heap<SupervisorMain>(context);\n            return alternateMain->getMain();\n          } else if (programName == \"spk\" || programName.endsWith(\"/spk\")) {\n            alternateMain = getSpkMain(context);\n            return alternateMain->getMain();\n          } else if (programName == \"backup\" || programName.endsWith(\"/backup\")) {\n            alternateMain = kj::heap<BackupMain>(context);\n            return alternateMain->getMain();\n          }\n        }\n    \n        return kj::MainBuilder(context, VERSION,\n                \"Controls the Sandstorm server.\\n\\n\"\n                \"Something not working? Check the logs in SANDSTORM_HOME/var/log.\")\n            .addSubCommand(\"start\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Starts the Sandstorm server (default).\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, start))\n                      .build();\n                },\n                \"Start the sandstorm server.\")\n            .addSubCommand(\"stop\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Stops the Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stop))\n                      .build();\n                },\n                \"Stop the sandstorm server.\")\n            .addSubCommand(\"start-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Starts the Sandstorm front-end after it has previously been stopped using \"\n                        \"the `stop-fe` command.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, startFe))\n                      .build();\n                },\n                \"Undo previous stop-fe.\")\n            .addSubCommand(\"stop-fe\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                        \"Stops the Sandstorm front-end, but leaves Mongo running. Useful when you \"\n                        \"want to run the front-end in dev mode in front of the existing database \"\n                        \"and grains.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, stopFe))\n                      .build();\n                },\n                \"Stop the sandstorm front-end.\")\n            .addSubCommand(\"status\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Checks whether Sandstorm is running. Prints the pid and exits successfully \"\n                          \"if so; exits with an error otherwise.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, status))\n                      .build();\n                },\n                \"Check if Sandstorm is running.\")\n            .addSubCommand(\"restart\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION, \"Restarts Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, restart))\n                      .build();\n                },\n                \"Restart Sandstorm server.\")\n            .addSubCommand(\"mongo\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                      \"Runs MongoDB shell, connecting to the already-running Sandstorm server.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, mongo))\n                      .build();\n                },\n                \"Run MongoDB shell.\")\n            .addSubCommand(\"update\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Updates the Sandstorm platform to a new version. If <release> is provided \"\n                          \"and specifies a bundle file (something like sandstorm-1234.tar.xz) it is \"\n                          \"used as the update. If <release> is a channel name, e.g. \\\"dev\\\", we \"\n                          \"securely check the web for an update. If <release> is not provided, we \"\n                          \"use the channel specified in the config file.\")\n                      .expectOptionalArg(\"<release>\", KJ_BIND_METHOD(*this, setUpdateFile))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, update))\n                      .build();\n                },\n                \"Update the Sandstorm platform.\")\n            .addSubCommand(\"spk\",\n                [this]() {\n                  alternateMain = getSpkMain(context);\n                  return alternateMain->getMain();\n                },\n                \"Manipulate spk files.\")\n            .addSubCommand(\"continue\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Continues running Sandstorm after an update. \"\n                          \"This command is invoked by the Sandstorm server itself. Do not run it \"\n                          \"directly.\")\n                      .addOption({\"userns\"}, [this]() { unsharedUidNamespace = true; return true; },\n                          \"Pass this flag if the parent has already set up and entered a UID \"\n                          \"namespace.\")\n                      .expectArg(\"<pidfile-fd>\", KJ_BIND_METHOD(*this, inheritPidfileFd))\n                      .expectZeroOrMoreArgs(\"<fd>:tcp:<port>\", KJ_BIND_METHOD(*this, inheritFd))\n                      .callAfterParsing(KJ_BIND_METHOD(*this, continue_))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"dev\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"For internal use only: Runs an app in dev mode. This command is \"\n                          \"invoked by the `spk` tool. Do not run it directly.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, dev))\n                      .build();\n                },\n                \"For internal use only.\")\n            .addSubCommand(\"admin-token\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Generates a new admin token that you can use to access the admin settings \"\n                          \"page. This is meant for initial setup, or if an admin account is locked out.\")\n                      .addOption({'q', \"quiet\"}, [this]() { shortOutput = true; return true; },\n                          \"Output only the token.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, adminToken))\n                      .build();\n                },\n                \"Generate admin token.\")\n            .addSubCommand(\"uninstall\",\n                [this]() {\n                  return kj::MainBuilder(context, VERSION,\n                          \"Uninstalls Sandstorm.\")\n                      .addOption({\"delete-user-data\"}, [this]() { deleteUserData = true; return true; },\n                          \"Also delete all user data.\")\n                      .callAfterParsing(KJ_BIND_METHOD(*this, uninstall))\n                      .build();\n                },\n                \"Uninstall Sandstorm.\")\n            .build();\n      }\n    \n      kj::MainBuilder::Validity start() {\n        changeToInstallDir();\n        const Config config = readConfig();\n    \n        // Check / lock the pidfile.\n        auto pidfile = raiiOpen(\"../var/pid/sandstorm.pid\", O_RDWR | O_CREAT | O_CLOEXEC, 0660);\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_WRLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          if (fcntl(pidfile, F_SETLK, &lock) < 0) {\n            int error = errno;\n            if (error == EACCES || error == EAGAIN) {\n              context.exitInfo(kj::str(\"Sandstorm is already running.  PID = \", readAll(pidfile)));\n            } else {\n              KJ_FAIL_SYSCALL(\"fcntl(pidfile, F_SETLK)\", error);\n            }\n          }\n    \n          // It's ours.  Truncate for now so we can write in the new PID later.\n          KJ_SYSCALL(ftruncate(pidfile, 0));\n        }\n    \n        if (!runningAsRoot) unshareUidNamespaceOnce();\n    \n        // Unshare PID namespace so that daemon process becomes the root process of its own PID\n        // namespace and therefore if it dies the whole namespace is killed.\n        KJ_SYSCALL(unshare(CLONE_NEWPID));\n    \n        // Daemonize ourselves.\n        pid_t mainPid;  // PID of the main process as seen *outside* the PID namespace.\n        {\n          int pipeFds[2];\n          KJ_SYSCALL(pipe2(pipeFds, O_CLOEXEC));\n          kj::AutoCloseFd pipeIn(pipeFds[0]), pipeOut(pipeFds[1]);\n    \n          KJ_SYSCALL(mainPid = fork());\n          if (mainPid != 0) {\n            // Tell the child process its own PID, since being in a PID namespace its own getpid() will\n            // unhelpfully return 1.\n            pipeIn = nullptr;\n            kj::FdOutputStream(kj::mv(pipeOut)).write(&mainPid, sizeof(mainPid));\n    \n            // Write the pidfile before exiting.\n            {\n              auto pidstr = kj::str(mainPid, '\\n');\n              kj::FdOutputStream((int)pidfile).write(pidstr.begin(), pidstr.size());\n            }\n    \n            // Exit success.\n            context.exitInfo(kj::str(\"Sandstorm started. PID = \", mainPid));\n            return true;\n          }\n    \n          // Read our (global) PID in from the parent process.\n          pipeOut = nullptr;\n          kj::FdInputStream(kj::mv(pipeIn)).read(&mainPid, sizeof(mainPid));\n        }\n    \n        // Since we unshared the PID namespace, the first fork() should have produced pid 1 in the\n        // new namespace.  That means that if this pid ever exits, everything under it dies.  That's\n        // perfect!  Otherwise we'd have to carefully kill node and mongo separately.\n        KJ_ASSERT(getpid() == 1, \"unshare(CLONE_NEWPID) didn't do what I expected.\", getpid());\n    \n        // Lock the pidfile and make sure it still belongs to us.\n        //\n        // We need to wait for the parent process to release its lock, so we use F_SETLKW.\n        // However, if another Sandstorm server is started simultaneously and manages to steal\n        // ownership, we want to detect this and exit, so we take a shared (read-only) lock.\n        {\n          struct flock lock;\n          memset(&lock, 0, sizeof(lock));\n          lock.l_type = F_RDLCK;\n          lock.l_whence = SEEK_SET;\n          lock.l_start = 0;\n          lock.l_len = 0;  // entire file\n          KJ_SYSCALL(fcntl(pidfile, F_SETLKW, &lock));\n    \n          // Verify that we still own the file.\n          KJ_SYSCALL(lseek(pidfile, 0, SEEK_SET));\n          pid_t pidfilePid = KJ_ASSERT_NONNULL(parseUInt(trim(readAll(pidfile)), 10));\n          if (pidfilePid != mainPid) {\n            context.exitInfo(kj::str(\n                \"Oops, Sandstorm PID \", pidfilePid, \" just started. \"\n                \"PID \", mainPid, \" exiting in deference.\"));\n          }\n        }\n    \n        // Redirect stdio.\n        {\n          auto logFd = raiiOpen(\"../var/log/sandstorm.log\", O_WRONLY | O_APPEND | O_CREAT, 0660);\n          if (runningAsRoot) { KJ_SYSCALL(fchown(logFd, config.uids.uid, config.uids.gid)); }\n          KJ_SYSCALL(dup2(logFd, STDOUT_FILENO));\n          KJ_SYSCALL(dup2(logFd, STDERR_FILENO));\n        }\n        {\n          auto nullFd = raiiOpen(\"/dev/null\", O_RDONLY);\n          KJ_SYSCALL(dup2(nullFd, STDIN_FILENO));\n        }\n    \n        // Write time to log.\n        time_t now;\n        time(&now);\n        context.warning(kj::str(\"** Starting Sandstorm at: \", ctime(&now)));\n    \n        // Detach from controlling terminal and make ourselves session leader.\n        KJ_SYSCALL(setsid());\n    \n        FdBundle fdBundle(config);\n    \n        runUpdateMonitor(config, fdBundle, pidfile);\n      }\n    \n      kj::MainBuilder::Validity inheritFd(kj::StringPtr mapping) {\n        auto parts = split(mapping, ':');\n        if (parts.size() != 3) {\n          return \"invalid syntax for port mapping\";\n        }\n    \n        int fd;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[0]), 10)) {\n          fd = *p;\n        } else {\n          return \"invalid fd\";\n        }\n    \n        kj::String type = kj::str(parts[1]);\n        if (type != \"tcp\") {\n          return \"invalid type\";\n        }\n    \n        uint port;\n        KJ_IF_MAYBE(p, parseUInt(kj::str(parts[2]), 10)) {\n          port = *p;\n        } else {\n          return \"invalid port\";\n        }\n    \n        KJ_SYSCALL(ioctl(fd, FIOCLEX));  // set CLOEXEC\n        if (!inheritedTcpPorts.insert(std::make_pair(port, kj::AutoCloseFd(fd))).second) {\n          return \"duplicate port\";\n        }\n    \n        return true;\n      }\n    \n      kj::MainBuilder::Validity inheritPidfileFd(kj::StringPtr pidfileFdStr) {\n        KJ_IF_MAYBE(p, parseUInt(pidfileFdStr, 10)) {\n          inheritedPidfile = kj::AutoCloseFd(*p);\n          KJ_SYSCALL(ioctl(inheritedPidfile, FIOCLEX));  // set CLOEXEC\n          return true;\n        } else {\n          return \"invalid fd\";\n        }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Sandstorm Thin Server\"",
            "\"Intended to be run as the root process of a Sandstorm app.\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nServerMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Sandstorm Thin Server\",\n                             \"Intended to be run as the root process of a Sandstorm app.\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
  },
  {
    "function_name": "ServerMain",
    "container": "ServerMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "181-181",
    "snippet": "ServerMain(kj::ProcessContext& context): context(context), ioContext(kj::setupAsyncIo()) {}",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nServerMain {\n  ServerMain(kj::ProcessContext& context): context(context), ioContext(kj::setupAsyncIo()) {}\n}"
  },
  {
    "function_name": "restore",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "170-174",
    "snippet": "kj::Promise<void> restore(RestoreContext context) override {\n    context.getResults().setCap(kj::heap<TestPowerboxCapImpl>(\n        kj::str(context.getParams().getObjectId())));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<TestPowerboxCapImpl>(\n        kj::str(context.getParams().getObjectId()))"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestPowerboxCapImpl>",
          "args": [
            "kj::str(context.getParams().getObjectId())"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "context.getParams().getObjectId()"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nUiViewImpl {\n  kj::Promise<void> restore(RestoreContext context) override {\n      context.getResults().setCap(kj::heap<TestPowerboxCapImpl>(\n          kj::str(context.getParams().getObjectId())));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "newRequestSession",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "156-168",
    "snippet": "kj::Promise<void> newRequestSession(NewRequestSessionContext context) override {\n    auto params = context.getParams();\n\n    KJ_REQUIRE(params.getSessionType() == capnp::typeId<sandstorm::WebSession>(),\n               \"Unsupported session type.\");\n\n    context.getResults().setSession(\n        kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                 params.getSessionParams().getAs<sandstorm::WebSession::Params>(),\n                                 true));\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                 params.getSessionParams().getAs<sandstorm::WebSession::Params>(),\n                                 true)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSessionImpl>",
          "args": [
            "params.getUserInfo()",
            "params.getContext()",
            "params.getSessionParams().getAs<sandstorm::WebSession::Params>()",
            "true"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getUserInfo",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.getSessionType() == capnp::typeId<sandstorm::WebSession>()",
            "\"Unsupported session type.\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<sandstorm::WebSession>",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionType",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nUiViewImpl {\n  kj::Promise<void> newRequestSession(NewRequestSessionContext context) override {\n      auto params = context.getParams();\n  \n      KJ_REQUIRE(params.getSessionType() == capnp::typeId<sandstorm::WebSession>(),\n                 \"Unsupported session type.\");\n  \n      context.getResults().setSession(\n          kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                   params.getSessionParams().getAs<sandstorm::WebSession::Params>(),\n                                   true));\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "newSession",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "143-154",
    "snippet": "kj::Promise<void> newSession(NewSessionContext context) override {\n    auto params = context.getParams();\n\n    KJ_REQUIRE(params.getSessionType() == capnp::typeId<sandstorm::WebSession>(),\n               \"Unsupported session type.\");\n\n    context.getResults().setSession(\n        kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                 params.getSessionParams().getAs<sandstorm::WebSession::Params>()));\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                 params.getSessionParams().getAs<sandstorm::WebSession::Params>())"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<WebSessionImpl>",
          "args": [
            "params.getUserInfo()",
            "params.getContext()",
            "params.getSessionParams().getAs<sandstorm::WebSession::Params>()"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionParams",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getContext",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getUserInfo",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.getSessionType() == capnp::typeId<sandstorm::WebSession>()",
            "\"Unsupported session type.\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<sandstorm::WebSession>",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getSessionType",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nUiViewImpl {\n  kj::Promise<void> newSession(NewSessionContext context) override {\n      auto params = context.getParams();\n  \n      KJ_REQUIRE(params.getSessionType() == capnp::typeId<sandstorm::WebSession>(),\n                 \"Unsupported session type.\");\n  \n      context.getResults().setSession(\n          kj::heap<WebSessionImpl>(params.getUserInfo(), params.getContext(),\n                                   params.getSessionParams().getAs<sandstorm::WebSession::Params>()));\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "getViewInfo",
    "container": "UiViewImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "132-141",
    "snippet": "kj::Promise<void> getViewInfo(GetViewInfoContext context) override {\n    auto viewInfo = context.initResults();\n\n    auto descriptor = viewInfo.initMatchRequests(1)[0];\n    auto tag = descriptor.initTags(1)[0];\n    tag.setId(capnp::typeId<TestPowerboxCap>());\n    tag.initValue().setAs<TestPowerboxCap::PowerboxTag>(TEST_TAG);\n\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tag.initValue",
          "args": [
            "TEST_TAG"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.initValue",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag.setId",
          "args": [
            "capnp::typeId<TestPowerboxCap>()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::typeId<TestPowerboxCap>",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor.initTags",
          "args": [
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "viewInfo.initMatchRequests",
          "args": [
            "1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nUiViewImpl {\n  kj::Promise<void> getViewInfo(GetViewInfoContext context) override {\n      auto viewInfo = context.initResults();\n  \n      auto descriptor = viewInfo.initMatchRequests(1)[0];\n      auto tag = descriptor.initTags(1)[0];\n      tag.setId(capnp::typeId<TestPowerboxCap>());\n      tag.initValue().setAs<TestPowerboxCap::PowerboxTag>(TEST_TAG);\n  \n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "post",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "91-120",
    "snippet": "kj::Promise<void> post(PostContext context) override {\n    // HTTP GET request.\n\n    auto path = context.getParams().getPath();\n\n    if (path == \"fulfill\") {\n      // Fulfill powerbox request by creating a new capability with the input text.\n      context.getResults().initNoContent();\n\n      auto req = sessionContext.fulfillRequestRequest();\n      req.setCap(kj::heap<TestPowerboxCapImpl>(\n          kj::str(context.getParams().getContent().getContent().asChars())));\n      req.setDescriptor(TEST_DESC);\n\n      return req.send().ignoreResult();\n    } else if (path == \"accept\") {\n      // Accept capability from powerbox request. Call read() and return the text.\n      auto req = sessionContext.claimRequestRequest();\n      req.setRequestToken(\n          kj::str(context.getParams().getContent().getContent().asChars()));\n      return req.send().getCap().castAs<TestPowerboxCap>().readRequest().send()\n          .then([context](auto response) mutable -> void {\n        auto httpResponse = context.getResults().initContent();\n        httpResponse.setMimeType(\"text/plain\");\n        httpResponse.getBody().setBytes(response.getText().asBytes());\n      });\n    } else {\n      KJ_FAIL_REQUIRE(\"unknown post path\", path);\n    }\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"unknown post path\"",
            "path"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "[context](auto response) mutable -> void {\n        auto httpResponse = context.getResults().initContent();\n        httpResponse.setMimeType(\"text/plain\");\n        httpResponse.getBody().setBytes(response.getText().asBytes());\n      }"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "EmailSessionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/sandstorm-http-bridge.c++",
          "lines": "1885-1944",
          "snippet": "kj::Promise<void> send(SendContext context) override {\n    // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n\n    auto email = context.getParams().getEmail();\n    auto id = genRandomString();\n\n    // TODO(perf): The following does a lot more copying than necessary.\n\n    // Construct the mail file.\n    kj::Vector<kj::String> lines;\n\n    addDateHeader(lines, email.getDate());\n\n    addHeader(lines, \"To\", email.getTo());\n    addHeader(lines, \"From\", email.getFrom());\n    addHeader(lines, \"Reply-To\", email.getReplyTo());\n    addHeader(lines, \"CC\", email.getCc());\n    addHeader(lines, \"BCC\", email.getBcc());\n    addHeader(lines, \"Subject\", email.getSubject());\n\n    addHeader(lines, \"Message-Id\", email.getMessageId());\n    addHeader(lines, \"References\", email.getReferences());\n    addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n\n    addHeader(lines, \"Content-Type\",\n        kj::str(\"multipart/alternative; boundary=\", id));\n\n    lines.add(nullptr);  // blank line starts body.\n\n    if (email.hasText()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getText()));\n    }\n    if (email.hasHtml()) {\n      lines.add(kj::str(\"--\", id));\n      addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n      lines.add(nullptr);\n      lines.add(kj::str(email.getHtml()));\n    }\n    for (auto attachment : email.getAttachments()) {\n      addAttachment(lines, id, attachment);\n    }\n    lines.add(kj::str(\"--\", id, \"--\"));\n\n    lines.add(nullptr);\n    auto text = kj::strArray(lines, \"\\n\");\n\n    // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n    auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n    auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n    kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n    mailFd = nullptr;\n\n    // Move to final location.\n    KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n\n    return kj::READY_NOW;\n  }",
          "includes": [
            "#include \"bridge-proxy.h\"",
            "#include \"util.h\"",
            "#include \"version.h\"",
            "#include <joyent-http/http_parser.h>",
            "#include <sandstorm/package.capnp.h>",
            "#include <sandstorm/hack-session.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>",
            "#include <sandstorm/sandstorm-http-bridge.capnp.h>",
            "#include <sandstorm/email.capnp.h>",
            "#include <sandstorm/web-session.capnp.h>",
            "#include <sandstorm/api-session.capnp.h>",
            "#include <sandstorm/grain.capnp.h>",
            "#include <sandstorm/util.capnp.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <unordered_map>",
            "#include <map>",
            "#include <unistd.h>",
            "#include <arpa/inet.h>",
            "#include <capnp/compat/json.h>",
            "#include <capnp/serialize.h>",
            "#include <capnp/schema.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include <capnp/rpc-twoparty.h>",
            "#include <kj/io.h>",
            "#include <kj/async-unix.h>",
            "#include <kj/async-io.h>",
            "#include <kj/debug.h>",
            "#include <kj/main.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bridge-proxy.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <joyent-http/http_parser.h>\n#include <sandstorm/package.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/sandstorm-http-bridge-internal.capnp.h>\n#include <sandstorm/sandstorm-http-bridge.capnp.h>\n#include <sandstorm/email.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/api-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <sandstorm/util.capnp.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unordered_map>\n#include <map>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <capnp/compat/json.h>\n#include <capnp/serialize.h>\n#include <capnp/schema.h>\n#include <capnp/rpc.capnp.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/io.h>\n#include <kj/async-unix.h>\n#include <kj/async-io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nEmailSessionImpl {\n  kj::Promise<void> send(SendContext context) override {\n      // We're receiving an e-mail. We place the message in maildir format under /var/mail.\n  \n      auto email = context.getParams().getEmail();\n      auto id = genRandomString();\n  \n      // TODO(perf): The following does a lot more copying than necessary.\n  \n      // Construct the mail file.\n      kj::Vector<kj::String> lines;\n  \n      addDateHeader(lines, email.getDate());\n  \n      addHeader(lines, \"To\", email.getTo());\n      addHeader(lines, \"From\", email.getFrom());\n      addHeader(lines, \"Reply-To\", email.getReplyTo());\n      addHeader(lines, \"CC\", email.getCc());\n      addHeader(lines, \"BCC\", email.getBcc());\n      addHeader(lines, \"Subject\", email.getSubject());\n  \n      addHeader(lines, \"Message-Id\", email.getMessageId());\n      addHeader(lines, \"References\", email.getReferences());\n      addHeader(lines, \"In-Reply-To\", email.getInReplyTo());\n  \n      addHeader(lines, \"Content-Type\",\n          kj::str(\"multipart/alternative; boundary=\", id));\n  \n      lines.add(nullptr);  // blank line starts body.\n  \n      if (email.hasText()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/plain; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getText()));\n      }\n      if (email.hasHtml()) {\n        lines.add(kj::str(\"--\", id));\n        addHeader(lines, \"Content-Type\", kj::str(\"text/html; charset=UTF-8\"));\n        lines.add(nullptr);\n        lines.add(kj::str(email.getHtml()));\n      }\n      for (auto attachment : email.getAttachments()) {\n        addAttachment(lines, id, attachment);\n      }\n      lines.add(kj::str(\"--\", id, \"--\"));\n  \n      lines.add(nullptr);\n      auto text = kj::strArray(lines, \"\\n\");\n  \n      // Write to temp file. Prefix name with _ in case `id` starts with '.'.\n      auto tmpFilename = kj::str(\"/var/mail/tmp/_\", id);\n      auto mailFd = raiiOpen(tmpFilename, O_WRONLY | O_CREAT | O_EXCL);\n      kj::FdOutputStream((int)mailFd).write(text.begin(), text.size());\n      mailFd = nullptr;\n  \n      // Move to final location.\n      KJ_SYSCALL(rename(tmpFilename.cStr(), kj::str(\"/var/mail/new/_\", id).cStr()));\n  \n      return kj::READY_NOW;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpResponse.getBody",
          "args": [
            "response.getText().asBytes()"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getText",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getText",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpResponse.getBody",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpResponse.setMimeType",
          "args": [
            "\"text/plain\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setRequestToken",
          "args": [
            "kj::str(context.getParams().getContent().getContent().asChars())"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "context.getParams().getContent().getContent().asChars()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionContext.claimRequestRequest",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setDescriptor",
          "args": [
            "TEST_DESC"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.setCap",
          "args": [
            "kj::heap<TestPowerboxCapImpl>(\n          kj::str(context.getParams().getContent().getContent().asChars()))"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestPowerboxCapImpl>",
          "args": [
            "kj::str(context.getParams().getContent().getContent().asChars())"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "context.getParams().getContent().getContent().asChars()"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sessionContext.fulfillRequestRequest",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> post(PostContext context) override {\n      // HTTP GET request.\n  \n      auto path = context.getParams().getPath();\n  \n      if (path == \"fulfill\") {\n        // Fulfill powerbox request by creating a new capability with the input text.\n        context.getResults().initNoContent();\n  \n        auto req = sessionContext.fulfillRequestRequest();\n        req.setCap(kj::heap<TestPowerboxCapImpl>(\n            kj::str(context.getParams().getContent().getContent().asChars())));\n        req.setDescriptor(TEST_DESC);\n  \n        return req.send().ignoreResult();\n      } else if (path == \"accept\") {\n        // Accept capability from powerbox request. Call read() and return the text.\n        auto req = sessionContext.claimRequestRequest();\n        req.setRequestToken(\n            kj::str(context.getParams().getContent().getContent().asChars()));\n        return req.send().getCap().castAs<TestPowerboxCap>().readRequest().send()\n            .then([context](auto response) mutable -> void {\n          auto httpResponse = context.getResults().initContent();\n          httpResponse.setMimeType(\"text/plain\");\n          httpResponse.getBody().setBytes(response.getText().asBytes());\n        });\n      } else {\n        KJ_FAIL_REQUIRE(\"unknown post path\", path);\n      }\n    }\n}"
  },
  {
    "function_name": "get",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "74-89",
    "snippet": "kj::Promise<void> get(GetContext context) override {\n    // HTTP GET request.\n\n    auto path = context.getParams().getPath();\n\n    if (path == \"\") {\n      auto response = context.getResults().initContent();\n      response.setMimeType(\"text/html\");\n      response.initBody().setBytes(isPowerboxRequest ? *TEST_POWERBOX_HTML : *TEST_APP_HTML);\n      return kj::READY_NOW;\n    } else {\n      auto error = context.getResults().initClientError();\n      error.setStatusCode(sandstorm::WebSession::Response::ClientErrorCode::NOT_FOUND);\n      return kj::READY_NOW;\n    }\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error.setStatusCode",
          "args": [
            "sandstorm::WebSession::Response::ClientErrorCode::NOT_FOUND"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.initBody",
          "args": [
            "isPowerboxRequest ? *TEST_POWERBOX_HTML : *TEST_APP_HTML"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.initBody",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.setMimeType",
          "args": [
            "\"text/html\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  kj::Promise<void> get(GetContext context) override {\n      // HTTP GET request.\n  \n      auto path = context.getParams().getPath();\n  \n      if (path == \"\") {\n        auto response = context.getResults().initContent();\n        response.setMimeType(\"text/html\");\n        response.initBody().setBytes(isPowerboxRequest ? *TEST_POWERBOX_HTML : *TEST_APP_HTML);\n        return kj::READY_NOW;\n      } else {\n        auto error = context.getResults().initClientError();\n        error.setStatusCode(sandstorm::WebSession::Response::ClientErrorCode::NOT_FOUND);\n        return kj::READY_NOW;\n      }\n    }\n}"
  },
  {
    "function_name": "WebSessionImpl",
    "container": "WebSessionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "67-72",
    "snippet": "WebSessionImpl(sandstorm::UserInfo::Reader userInfo,\n                 sandstorm::SessionContext::Client context,\n                 sandstorm::WebSession::Params::Reader params,\n                 bool isPowerboxRequest = false)\n      : isPowerboxRequest(isPowerboxRequest),\n        sessionContext(kj::mv(context)) {}",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nWebSessionImpl {\n  WebSessionImpl(sandstorm::UserInfo::Reader userInfo,\n                   sandstorm::SessionContext::Client context,\n                   sandstorm::WebSession::Params::Reader params,\n                   bool isPowerboxRequest = false)\n        : isPowerboxRequest(isPowerboxRequest),\n          sessionContext(kj::mv(context)) {}\n}"
  },
  {
    "function_name": "read",
    "container": "TestPowerboxCapImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "54-57",
    "snippet": "kj::Promise<void> read(ReadContext context) override {\n    context.getResults().setText(text);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "text"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nTestPowerboxCapImpl {\n  kj::Promise<void> read(ReadContext context) override {\n      context.getResults().setText(text);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "save",
    "container": "TestPowerboxCapImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "47-52",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    auto results = context.getResults();\n    results.setObjectId(text);\n    results.initLabel().setDefaultText(\"some label\");\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.initLabel",
          "args": [
            "\"some label\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.initLabel",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "results.setObjectId",
          "args": [
            "text"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nTestPowerboxCapImpl {\n  kj::Promise<void> save(SaveContext context) override {\n      auto results = context.getResults();\n      results.setObjectId(text);\n      results.initLabel().setDefaultText(\"some label\");\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "TestPowerboxCapImpl",
    "container": "TestPowerboxCapImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/test-app/test-app.c++",
    "lines": "45-45",
    "snippet": "explicit TestPowerboxCapImpl(kj::String text): text(kj::mv(text)) {}",
    "includes": [
      "#include <sandstorm/test-app/test-app.capnp.h>",
      "#include <sandstorm/hack-session.capnp.h>",
      "#include <sandstorm/web-session.capnp.h>",
      "#include <sandstorm/grain.capnp.h>",
      "#include <capnp/serialize.h>",
      "#include <capnp/rpc-twoparty.h>",
      "#include <kj/async-io.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/main.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "text"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sandstorm/test-app/test-app.capnp.h>\n#include <sandstorm/hack-session.capnp.h>\n#include <sandstorm/web-session.capnp.h>\n#include <sandstorm/grain.capnp.h>\n#include <capnp/serialize.h>\n#include <capnp/rpc-twoparty.h>\n#include <kj/async-io.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/main.h>\n\nTestPowerboxCapImpl {\n  explicit TestPowerboxCapImpl(kj::String text): text(kj::mv(text)) {}\n}"
  }
]