[
  {
    "function_name": "write",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "110-119",
    "snippet": "uint32 MemIOCallback::write(IOCallback & IOToRead, size_t Size)\n{\n  if (dataBufferMemorySize < dataBufferPos + Size) {\n    //We need more memory!\n    dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n  }\n  IOToRead.readFully(&dataBuffer[dataBufferPos], Size);\n  dataBufferTotalSize = Size;\n  return Size;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IOToRead.readFully",
          "args": [
            "&dataBuffer[dataBufferPos]",
            "Size"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "readFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
          "lines": "67-79",
          "snippet": "void IOCallback::readFully(void*Buffer,size_t Size)\n{\n  if(Buffer == NULL)\n    throw;\n\n  if(read(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  void IOCallback::readFully(void*Buffer,size_t Size)\n  {\n    if(Buffer == NULL)\n      throw;\n  \n    if(read(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "(void *)dataBuffer",
            "dataBufferPos + Size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  uint32 MemIOCallback::write(IOCallback & IOToRead, size_t Size)\n  {\n    if (dataBufferMemorySize < dataBufferPos + Size) {\n      //We need more memory!\n      dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n    }\n    IOToRead.readFully(&dataBuffer[dataBufferPos], Size);\n    dataBufferTotalSize = Size;\n    return Size;\n  }\n}"
  },
  {
    "function_name": "write",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "96-108",
    "snippet": "size_t MemIOCallback::write(const void *Buffer, size_t Size)\n{\n  if (dataBufferMemorySize < dataBufferPos + Size) {\n    //We need more memory!\n    dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n  }\n  memcpy(dataBuffer+dataBufferPos, Buffer, Size);\n  dataBufferPos += Size;\n  if (dataBufferPos > dataBufferTotalSize)\n    dataBufferTotalSize = dataBufferPos;\n\n  return Size;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dataBuffer+dataBufferPos",
            "Buffer",
            "Size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "(void *)dataBuffer",
            "dataBufferPos + Size"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  size_t MemIOCallback::write(const void *Buffer, size_t Size)\n  {\n    if (dataBufferMemorySize < dataBufferPos + Size) {\n      //We need more memory!\n      dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n    }\n    memcpy(dataBuffer+dataBufferPos, Buffer, Size);\n    dataBufferPos += Size;\n    if (dataBufferPos > dataBufferTotalSize)\n      dataBufferTotalSize = dataBufferPos;\n  \n    return Size;\n  }\n}"
  },
  {
    "function_name": "setFilePointer",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "86-94",
    "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n  {\n    if (Mode == seek_beginning)\n      dataBufferPos = Offset;\n    else if (Mode == seek_current)\n      dataBufferPos = dataBufferPos + Offset;\n    else if (Mode == seek_end)\n      dataBufferPos = dataBufferTotalSize + Offset;\n  }\n}"
  },
  {
    "function_name": "read",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "66-84",
    "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBufferPos += Size;\n\n  return Size;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "Buffer",
            "dataBuffer+dataBufferPos",
            "Size"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "Buffer",
            "dataBuffer + dataBufferPos",
            "dataBufferTotalSize - dataBufferPos"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  uint32 MemIOCallback::read(void *Buffer, size_t Size)\n  {\n    if (Buffer == NULL || Size < 1)\n      return 0;\n    //If the size is larger than than the amount left in the buffer\n    if (Size + dataBufferPos > dataBufferTotalSize) {\n      //We will only return the remaining data\n      memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n      uint64 oldDataPos = dataBufferPos;\n      dataBufferPos = dataBufferTotalSize;\n      return dataBufferTotalSize - oldDataPos;\n    }\n  \n    //Well... We made it here, so do a quick and simple copy\n    memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n    dataBufferPos += Size;\n  \n    return Size;\n  }\n}"
  },
  {
    "function_name": "~MemIOCallback",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "60-64",
    "snippet": "MemIOCallback::~MemIOCallback()\n{\n  if (dataBuffer != NULL)\n    free(dataBuffer);\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dataBuffer"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  MemIOCallback::~MemIOCallback()\n  {\n    if (dataBuffer != NULL)\n      free(dataBuffer);\n  }\n}"
  },
  {
    "function_name": "MemIOCallback",
    "container": "MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "39-58",
    "snippet": "START_LIBEBML_NAMESPACE\n\nMemIOCallback::MemIOCallback(uint64 DefaultSize)\n{\n  //The default size of the buffer is 128 bytes\n  dataBuffer = (binary *)malloc(DefaultSize);\n  if (dataBuffer == NULL) {\n    mOk = false;\n    std::stringstream Msg;\n    Msg << \"Failed to alloc memory block of size \";\n    // not working with VC6    Msg << DefaultSize;\n    mLastErrorStr = Msg.str();\n    return;\n  }\n\n  dataBufferMemorySize = DefaultSize;\n  dataBufferPos = 0;\n  dataBufferTotalSize = 0;\n  mOk = true;\n}",
    "includes": [
      "#include \"ebml/EbmlConfig.h\"",
      "#include \"ebml/Debug.h\"",
      "#include \"ebml/MemIOCallback.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Msg.str",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "DefaultSize"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/MemIOCallback.h\"\n\nMemIOCallback {\n  START_LIBEBML_NAMESPACE\n  \n  MemIOCallback::MemIOCallback(uint64 DefaultSize)\n  {\n    //The default size of the buffer is 128 bytes\n    dataBuffer = (binary *)malloc(DefaultSize);\n    if (dataBuffer == NULL) {\n      mOk = false;\n      std::stringstream Msg;\n      Msg << \"Failed to alloc memory block of size \";\n      // not working with VC6    Msg << DefaultSize;\n      mLastErrorStr = Msg.str();\n      return;\n    }\n  \n    dataBufferMemorySize = DefaultSize;\n    dataBufferPos = 0;\n    dataBufferTotalSize = 0;\n    mOk = true;\n  }\n}"
  }
]