[
  {
    "function_name": "EbmlCrc32::Finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "338-348",
    "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::ResetCRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}"
  },
  {
    "function_name": "EbmlCrc32::Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "315-336",
    "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<uint32>",
          "args": [
            "input"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nvoid EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}"
  },
  {
    "function_name": "EbmlCrc32::FillCRC32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "281-313",
    "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n\n  //Now we finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //for (unsigned int i = 0; i < 4; i++)\n  //  (&last_crc32)[i] = GetCrcByte(i);*/\n\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Finalize",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::Finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "338-348",
          "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}"
        }
      },
      {
        "call_info": {
          "callee": "Update",
          "args": [
            "s",
            "n"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "315-336",
          "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nvoid EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::ResetCRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n\n  //Now we finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //for (unsigned int i = 0; i < 4; i++)\n  //  (&last_crc32)[i] = GetCrcByte(i);*/\n\n}"
  },
  {
    "function_name": "EbmlCrc32::CheckCRC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "252-279",
    "snippet": "bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<uint32>",
          "args": [
            "input"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nbool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}"
  },
  {
    "function_name": "EbmlCrc32::ReadData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "233-250",
    "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "SafeReadIOCallback::GetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nsize_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)&m_crc_final",
            "Buffer",
            "4"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.readFully",
          "args": [
            "Buffer",
            "GetSize()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.setFilePointer",
          "args": [
            "GetSize()",
            "seek_current"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nfilepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}"
  },
  {
    "function_name": "EbmlCrc32::RenderData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "210-231",
    "snippet": "filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Pad",
            "GetDefaultSize() - Result"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Pad",
            "0x00",
            "GetDefaultSize() - Result"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "&m_crc_final",
            "Result"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nfilepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}"
  },
  {
    "function_name": "EbmlCrc32::CheckElementCRC32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "202-208",
    "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckCRC",
          "args": [
            "m_crc_final",
            "memoryBuffer.GetDataBuffer()",
            "memoryBuffer.GetDataBufferSize()"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::CheckCRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "252-279",
          "snippet": "bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nbool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBufferSize",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBuffer",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementToCRC.Render",
          "args": [
            "memoryBuffer"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nbool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}"
  },
  {
    "function_name": "EbmlCrc32::AddElementCRC32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "192-200",
    "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Update",
          "args": [
            "memoryBuffer.GetDataBuffer()",
            "memoryBuffer.GetDataBufferSize()"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "315-336",
          "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nvoid EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBufferSize",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBuffer",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementToCRC.Render",
          "args": [
            "memoryBuffer",
            "true",
            "true"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nvoid EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}"
  },
  {
    "function_name": "EbmlCrc32::UpdateByte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "187-190",
    "snippet": "void EbmlCrc32::UpdateByte(binary b)\n{\n  m_crc = m_tab[CRC32_INDEX(m_crc) ^ b] ^ CRC32_SHIFTED(m_crc);\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "m_crc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "m_crc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nvoid EbmlCrc32::UpdateByte(binary b)\n{\n  m_crc = m_tab[CRC32_INDEX(m_crc) ^ b] ^ CRC32_SHIFTED(m_crc);\n}"
  },
  {
    "function_name": "EbmlCrc32::ResetCRC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "182-185",
    "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}"
  },
  {
    "function_name": "EbmlCrc32::EbmlCrc32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "175-180",
    "snippet": "EbmlCrc32::EbmlCrc32(const EbmlCrc32 & ElementToClone)\n  :EbmlBinary(ElementToClone)\n{\n  m_crc       = ElementToClone.m_crc;\n  m_crc_final = ElementToClone.m_crc_final;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32::EbmlCrc32(const EbmlCrc32 & ElementToClone)\n  :EbmlBinary(ElementToClone)\n{\n  m_crc       = ElementToClone.m_crc;\n  m_crc_final = ElementToClone.m_crc_final;\n}"
  },
  {
    "function_name": "EbmlCrc32::EbmlCrc32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "165-173",
    "snippet": "EbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "4"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "4"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "EbmlCrc32::ResetCRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nvoid EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}"
  }
]