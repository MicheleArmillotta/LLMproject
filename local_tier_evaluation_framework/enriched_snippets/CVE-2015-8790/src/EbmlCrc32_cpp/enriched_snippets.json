[
  {
    "function_name": "Finalize",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "338-348",
    "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCRC",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::ResetCRC()\n  {\n    m_crc = CRC32_NEGL;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::Finalize()\n  {\n    //Finalize the CRC32\n    m_crc ^= CRC32_NEGL;\n    //Copy it over to completed CRC32 memeber\n    m_crc_final = m_crc;\n    //Reset the holding CRC member (m_crc)\n    ResetCRC();\n    //This EbmlElement has been set\n    SetValueIsSet();\n  }\n}"
  },
  {
    "function_name": "Update",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "315-336",
    "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<uint32>",
          "args": [
            "input"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  void EbmlCrc32::Update(const binary *input, uint32 length)\n  {\n    uint32 crc = m_crc;\n  \n    for(; !IsAligned<uint32>(input) && length > 0; length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    while (length >= 4) {\n      crc ^= *(const uint32 *)input;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      length -= 4;\n      input += 4;\n    }\n  \n    while (length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    m_crc = crc;\n  }\n}"
  },
  {
    "function_name": "FillCRC32",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "281-313",
    "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n\n  //Now we finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //for (unsigned int i = 0; i < 4; i++)\n  //  (&last_crc32)[i] = GetCrcByte(i);*/\n\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Finalize",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "Finalize",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "338-348",
          "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::Finalize()\n  {\n    //Finalize the CRC32\n    m_crc ^= CRC32_NEGL;\n    //Copy it over to completed CRC32 memeber\n    m_crc_final = m_crc;\n    //Reset the holding CRC member (m_crc)\n    ResetCRC();\n    //This EbmlElement has been set\n    SetValueIsSet();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Update",
          "args": [
            "s",
            "n"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "315-336",
          "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  void EbmlCrc32::Update(const binary *input, uint32 length)\n  {\n    uint32 crc = m_crc;\n  \n    for(; !IsAligned<uint32>(input) && length > 0; length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    while (length >= 4) {\n      crc ^= *(const uint32 *)input;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      length -= 4;\n      input += 4;\n    }\n  \n    while (length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    m_crc = crc;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCRC",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::ResetCRC()\n  {\n    m_crc = CRC32_NEGL;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n  {\n    ResetCRC();\n    Update(s, n);\n    Finalize();\n  \n    /*uint32 crc = CRC32_NEGL;\n  \n    for(; !IsAligned<uint32>(s) && n > 0; n--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n  \n    while (n >= 4)\n    {\n      crc ^= *(const uint32 *)s;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      n -= 4;\n      s += 4;\n    }\n  \n    while (n--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n  \n    m_crc = crc;\n  \n    //Now we finalize the CRC32\n    m_crc ^= CRC32_NEGL;\n    //for (unsigned int i = 0; i < 4; i++)\n    //  (&last_crc32)[i] = GetCrcByte(i);*/\n  \n  }\n}"
  },
  {
    "function_name": "CheckCRC",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "252-279",
    "snippet": "bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "crc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "crc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<uint32>",
          "args": [
            "input"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n  {\n    uint32 crc = CRC32_NEGL;\n  \n    for(; !IsAligned<uint32>(input) && length > 0; length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    while (length >= 4) {\n      crc ^= *(const uint32 *)input;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      length -= 4;\n      input += 4;\n    }\n  \n    while (length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    //Now we finalize the CRC32\n    crc ^= CRC32_NEGL;\n  \n    if (crc == inputCRC)\n      return true;\n  \n    return false;\n  }\n}"
  },
  {
    "function_name": "ReadData",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "233-250",
    "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "GetSize",
          "container": "SafeReadIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nSafeReadIOCallback {\n  size_t\n  SafeReadIOCallback::GetSize()\n    const {\n    return mSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)&m_crc_final",
            "Buffer",
            "4"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.readFully",
          "args": [
            "Buffer",
            "GetSize()"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "readFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
          "lines": "67-79",
          "snippet": "void IOCallback::readFully(void*Buffer,size_t Size)\n{\n  if(Buffer == NULL)\n    throw;\n\n  if(read(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  void IOCallback::readFully(void*Buffer,size_t Size)\n  {\n    if(Buffer == NULL)\n      throw;\n  \n    if(read(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.setFilePointer",
          "args": [
            "GetSize()",
            "seek_current"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "setFilePointer",
          "container": "StdIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
          "lines": "113-149",
          "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n    throw CRTError(Msg.str());\n#endif // GCC2\n    mCurrentPosition = ftell(File);\n  } else {\n    switch ( Mode ) {\n      case SEEK_CUR:\n        mCurrentPosition += Offset;\n        break;\n      case SEEK_END:\n        mCurrentPosition = ftell(File);\n        break;\n      case SEEK_SET:\n        mCurrentPosition = Offset;\n        break;\n    }\n  }\n}",
          "includes": [
            "#include \"ebml/EbmlConfig.h\"",
            "#include \"ebml/Debug.h\"",
            "#include \"ebml/StdIOCallback.h\"",
            "#include <sstream>",
            "#include <climits>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n  {\n    assert(File!=0);\n  \n    // There is a numeric cast in the boost library, which would be quite nice for this checking\n    /*\n      SL : replaced because unknown class in cygwin\n      assert(Offset <= numeric_limits<long>::max());\n      assert(Offset >= numeric_limits<long>::min());\n    */\n  \n    assert(Offset <= LONG_MAX);\n    assert(Offset >= LONG_MIN);\n  \n    assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n  \n    if(fseek(File,Offset,Mode)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      ostringstream Msg;\n      Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n      mCurrentPosition = ftell(File);\n    } else {\n      switch ( Mode ) {\n        case SEEK_CUR:\n          mCurrentPosition += Offset;\n          break;\n        case SEEK_END:\n          mCurrentPosition = ftell(File);\n          break;\n        case SEEK_SET:\n          mCurrentPosition = Offset;\n          break;\n      }\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n  {\n    if (ReadFully != SCOPE_NO_DATA) {\n      binary *Buffer = new (std::nothrow) binary[GetSize()];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n  \n        memcpy((void *)&m_crc_final, Buffer, 4);\n        delete [] Buffer;\n        SetValueIsSet();\n      }\n    }\n  \n    return GetSize();\n  }\n}"
  },
  {
    "function_name": "RenderData",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "210-231",
    "snippet": "filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Pad",
            "GetDefaultSize() - Result"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "writeFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
          "lines": "46-63",
          "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  START_LIBEBML_NAMESPACE\n  \n  void IOCallback::writeFully(const void*Buffer,size_t Size)\n  {\n    if (Size == 0)\n      return;\n  \n    if (Buffer == NULL)\n      throw;\n  \n    if(write(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Pad",
            "0x00",
            "GetDefaultSize() - Result"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n  {\n    filepos_t Result = 4;\n  \n    if (Result != 0) {\n      output.writeFully(&m_crc_final, Result);\n    }\n  \n    if (Result < GetDefaultSize()) {\n      // pad the rest with 0\n      binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n      if (Pad != NULL) {\n        memset(Pad, 0x00, GetDefaultSize() - Result);\n        output.writeFully(Pad, GetDefaultSize() - Result);\n  \n        Result = GetDefaultSize();\n        delete [] Pad;\n      }\n    }\n  \n    return Result;\n  }\n}"
  },
  {
    "function_name": "CheckElementCRC32",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "202-208",
    "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckCRC",
          "args": [
            "m_crc_final",
            "memoryBuffer.GetDataBuffer()",
            "memoryBuffer.GetDataBufferSize()"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "CheckCRC",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "252-279",
          "snippet": "bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  //Now we finalize the CRC32\n  crc ^= CRC32_NEGL;\n\n  if (crc == inputCRC)\n    return true;\n\n  return false;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n  {\n    uint32 crc = CRC32_NEGL;\n  \n    for(; !IsAligned<uint32>(input) && length > 0; length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    while (length >= 4) {\n      crc ^= *(const uint32 *)input;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      length -= 4;\n      input += 4;\n    }\n  \n    while (length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    //Now we finalize the CRC32\n    crc ^= CRC32_NEGL;\n  \n    if (crc == inputCRC)\n      return true;\n  \n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBufferSize",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBuffer",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementToCRC.Render",
          "args": [
            "memoryBuffer"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n  {\n    MemIOCallback memoryBuffer;\n    ElementToCRC.Render(memoryBuffer);\n  \n    return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  }\n}"
  },
  {
    "function_name": "AddElementCRC32",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "192-200",
    "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Update",
          "args": [
            "memoryBuffer.GetDataBuffer()",
            "memoryBuffer.GetDataBufferSize()"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "315-336",
          "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  m_crc = crc;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  void EbmlCrc32::Update(const binary *input, uint32 length)\n  {\n    uint32 crc = m_crc;\n  \n    for(; !IsAligned<uint32>(input) && length > 0; length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    while (length >= 4) {\n      crc ^= *(const uint32 *)input;\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n      length -= 4;\n      input += 4;\n    }\n  \n    while (length--)\n      crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n  \n    m_crc = crc;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBufferSize",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memoryBuffer.GetDataBuffer",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementToCRC.Render",
          "args": [
            "memoryBuffer",
            "true",
            "true"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n  {\n    // Use a special IOCallback class that Render's to memory instead of to disk\n    MemIOCallback memoryBuffer;\n    ElementToCRC.Render(memoryBuffer, true, true);\n  \n    Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n    //  Finalize();\n  }\n}"
  },
  {
    "function_name": "UpdateByte",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "187-190",
    "snippet": "void EbmlCrc32::UpdateByte(binary b)\n{\n  m_crc = m_tab[CRC32_INDEX(m_crc) ^ b] ^ CRC32_SHIFTED(m_crc);\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRC32_SHIFTED",
          "args": [
            "m_crc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRC32_INDEX",
          "args": [
            "m_crc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  void EbmlCrc32::UpdateByte(binary b)\n  {\n    m_crc = m_tab[CRC32_INDEX(m_crc) ^ b] ^ CRC32_SHIFTED(m_crc);\n  }\n}"
  },
  {
    "function_name": "ResetCRC",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "182-185",
    "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32 CRC32_NEGL = 0xffffffffL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::ResetCRC()\n  {\n    m_crc = CRC32_NEGL;\n  }\n}"
  },
  {
    "function_name": "EbmlCrc32",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "175-180",
    "snippet": "EbmlCrc32::EbmlCrc32(const EbmlCrc32 & ElementToClone)\n  :EbmlBinary(ElementToClone)\n{\n  m_crc       = ElementToClone.m_crc;\n  m_crc_final = ElementToClone.m_crc_final;\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  EbmlCrc32::EbmlCrc32(const EbmlCrc32 & ElementToClone)\n    :EbmlBinary(ElementToClone)\n  {\n    m_crc       = ElementToClone.m_crc;\n    m_crc_final = ElementToClone.m_crc_final;\n  }\n}"
  },
  {
    "function_name": "EbmlCrc32",
    "container": "EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "165-173",
    "snippet": "EbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}",
    "includes": [
      "#include \"ebml/MemIOCallback.h\"",
      "#include \"ebml/EbmlContexts.h\"",
      "#include \"ebml/EbmlCrc32.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "4"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "4"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetCRC",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCRC",
          "container": "EbmlCrc32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
          "lines": "182-185",
          "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
          "includes": [
            "#include \"ebml/MemIOCallback.h\"",
            "#include \"ebml/EbmlContexts.h\"",
            "#include \"ebml/EbmlCrc32.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32 CRC32_NEGL = 0xffffffffL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nconst uint32 CRC32_NEGL = 0xffffffffL;\n\nEbmlCrc32 {\n  void EbmlCrc32::ResetCRC()\n  {\n    m_crc = CRC32_NEGL;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/MemIOCallback.h\"\n#include \"ebml/EbmlContexts.h\"\n#include \"ebml/EbmlCrc32.h\"\n\nEbmlCrc32 {\n  EbmlCrc32::EbmlCrc32()\n  {\n    ResetCRC();\n    SetDefaultSize(4);\n    m_crc_final = 0;\n    SetSize_(4);\n    //This EbmlElement has been set\n    //  SetValueIsSet();\n  }\n}"
  }
]