[
  {
    "function_name": "ReadData",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "145-169",
    "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet();\n      }\n    }\n  }\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "GetSize",
          "container": "SafeReadIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nSafeReadIOCallback {\n  size_t\n  SafeReadIOCallback::GetSize()\n    const {\n    return mSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.readFully",
          "args": [
            "Buffer",
            "GetSize()"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "readFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
          "lines": "67-79",
          "snippet": "void IOCallback::readFully(void*Buffer,size_t Size)\n{\n  if(Buffer == NULL)\n    throw;\n\n  if(read(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  void IOCallback::readFully(void*Buffer,size_t Size)\n  {\n    if(Buffer == NULL)\n      throw;\n  \n    if(read(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in readFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.setFilePointer",
          "args": [
            "GetSize()",
            "seek_current"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "setFilePointer",
          "container": "StdIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
          "lines": "113-149",
          "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n    throw CRTError(Msg.str());\n#endif // GCC2\n    mCurrentPosition = ftell(File);\n  } else {\n    switch ( Mode ) {\n      case SEEK_CUR:\n        mCurrentPosition += Offset;\n        break;\n      case SEEK_END:\n        mCurrentPosition = ftell(File);\n        break;\n      case SEEK_SET:\n        mCurrentPosition = Offset;\n        break;\n    }\n  }\n}",
          "includes": [
            "#include \"ebml/EbmlConfig.h\"",
            "#include \"ebml/Debug.h\"",
            "#include \"ebml/StdIOCallback.h\"",
            "#include <sstream>",
            "#include <climits>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlConfig.h\"\n#include \"ebml/Debug.h\"\n#include \"ebml/StdIOCallback.h\"\n#include <sstream>\n#include <climits>\n#include <cassert>\n\nStdIOCallback {\n  void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n  {\n    assert(File!=0);\n  \n    // There is a numeric cast in the boost library, which would be quite nice for this checking\n    /*\n      SL : replaced because unknown class in cygwin\n      assert(Offset <= numeric_limits<long>::max());\n      assert(Offset >= numeric_limits<long>::min());\n    */\n  \n    assert(Offset <= LONG_MAX);\n    assert(Offset >= LONG_MIN);\n  \n    assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n  \n    if(fseek(File,Offset,Mode)!=0) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      ostringstream Msg;\n      Msg<<\"Failed to seek file \"<<File<<\" to offset \"<<(unsigned long)Offset<<\" in mode \"<<Mode;\n      throw CRTError(Msg.str());\n  #endif // GCC2\n      mCurrentPosition = ftell(File);\n    } else {\n      switch ( Mode ) {\n        case SEEK_CUR:\n          mCurrentPosition += Offset;\n          break;\n        case SEEK_END:\n          mCurrentPosition = ftell(File);\n          break;\n        case SEEK_SET:\n          mCurrentPosition = Offset;\n          break;\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n  {\n    if (ReadFully != SCOPE_NO_DATA) {\n      if (GetSize() == 0) {\n        Value = \"\";\n        SetValueIsSet();\n      } else {\n        char *Buffer = new (std::nothrow) char[GetSize() + 1];\n        if (Buffer == NULL) {\n          // unable to store the data, skip it\n          input.setFilePointer(GetSize(), seek_current);\n        } else {\n          input.readFully(Buffer, GetSize());\n          if (Buffer[GetSize()-1] != '\\0') {\n            Buffer[GetSize()] = '\\0';\n          }\n          Value = Buffer;\n          delete [] Buffer;\n          SetValueIsSet();\n        }\n      }\n    }\n  \n    return GetSize();\n  }\n}"
  },
  {
    "function_name": "UpdateSize",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "132-143",
    "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "GetSize",
          "container": "SafeReadIOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nSafeReadIOCallback {\n  size_t\n  SafeReadIOCallback::GetSize()\n    const {\n    return mSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "Value.length()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.length",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "GetDefaultSize()"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.length",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsDefaultValue",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n  {\n    if (!bWithDefault && IsDefaultValue())\n      return 0;\n  \n    if (Value.length() < GetDefaultSize()) {\n      SetSize_(GetDefaultSize());\n    } else {\n      SetSize_(Value.length());\n    }\n    return GetSize();\n  }\n}"
  },
  {
    "function_name": "GetValue",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "128-130",
    "snippet": "std::string EbmlString::GetValue() const {\n  return Value;\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  std::string EbmlString::GetValue() const {\n    return Value;\n  }\n}"
  },
  {
    "function_name": "RenderData",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "90-109",
    "snippet": "filepos_t EbmlString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result;\n  output.writeFully(Value.c_str(), Value.length());\n  Result = Value.length();\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad == NULL) {\n      return Result;\n    }\n    memset(Pad, 0x00, GetDefaultSize() - Result);\n    output.writeFully(Pad, GetDefaultSize() - Result);\n    Result = GetDefaultSize();\n    delete [] Pad;\n  }\n\n  return Result;\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Pad",
            "GetDefaultSize() - Result"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "writeFully",
          "container": "IOCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
          "lines": "46-63",
          "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
          "includes": [
            "#include \"ebml/IOCallback.h\"",
            "#include <stdexcept>",
            "#include <sstream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/IOCallback.h\"\n#include <stdexcept>\n#include <sstream>\n\nIOCallback {\n  START_LIBEBML_NAMESPACE\n  \n  void IOCallback::writeFully(const void*Buffer,size_t Size)\n  {\n    if (Size == 0)\n      return;\n  \n    if (Buffer == NULL)\n      throw;\n  \n    if(write(Buffer,Size) != Size) {\n  #if !defined(__GNUC__) || (__GNUC__ > 2)\n      stringstream Msg;\n      Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n      throw runtime_error(Msg.str());\n  #endif // GCC2\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Pad",
            "0x00",
            "GetDefaultSize() - Result"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.length",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.length",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.c_str",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  filepos_t EbmlString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n  {\n    filepos_t Result;\n    output.writeFully(Value.c_str(), Value.length());\n    Result = Value.length();\n  \n    if (Result < GetDefaultSize()) {\n      // pad the rest with 0\n      binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n      if (Pad == NULL) {\n        return Result;\n      }\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  \n    return Result;\n  }\n}"
  },
  {
    "function_name": "SetDefaultValue",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "73-78",
    "snippet": "void EbmlString::SetDefaultValue(std::string & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!DefaultISset()"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultISset",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  void EbmlString::SetDefaultValue(std::string & aValue)\n  {\n    assert(!DefaultISset());\n    DefaultValue = aValue;\n    SetDefaultIsSet();\n  }\n}"
  },
  {
    "function_name": "EbmlString",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "66-71",
    "snippet": "EbmlString::EbmlString(const EbmlString & ElementToClone)\n  :EbmlElement(ElementToClone)\n  ,Value(ElementToClone.Value)\n  ,DefaultValue(ElementToClone.DefaultValue)\n{\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nEbmlString {\n  EbmlString::EbmlString(const EbmlString & ElementToClone)\n    :EbmlElement(ElementToClone)\n    ,Value(ElementToClone.Value)\n    ,DefaultValue(ElementToClone.DefaultValue)\n  {\n  }\n}"
  },
  {
    "function_name": "EbmlString",
    "container": "EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "52-61",
    "snippet": "EbmlString::EbmlString(const std::string & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n/* done automatically\n  SetSize_(Value.length());\n  if (GetDefaultSize() > GetSize())\n    SetSize_(GetDefaultSize());*/\n}",
    "includes": [
      "#include \"ebml/EbmlString.h\"",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [
      "START_LIBEBML_NAMESPACE\n\nEbmlString::EbmlString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlString.h\"\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\nEbmlString::EbmlString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n\nEbmlString {\n  EbmlString::EbmlString(const std::string & aDefaultValue)\n    :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n  {\n    SetDefaultSize(0);\n    SetDefaultIsSet();\n  /* done automatically\n    SetSize_(Value.length());\n    if (GetDefaultSize() > GetSize())\n      SetSize_(GetDefaultSize());*/\n  }\n}"
  }
]