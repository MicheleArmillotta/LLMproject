[
  {
    "function_name": "EbmlUnicodeString::ReadData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "347-372",
    "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to std::string\n        delete [] Buffer;\n        SetValueIsSet();\n      }\n    }\n  }\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "SafeReadIOCallback::GetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nsize_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.SetUTF8",
          "args": [
            "Buffer"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.readFully",
          "args": [
            "Buffer",
            "GetSize()"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.setFilePointer",
          "args": [
            "GetSize()",
            "seek_current"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetValueIsSet",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTFstring::value_type",
          "args": [
            "0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nfilepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to std::string\n        delete [] Buffer;\n        SetValueIsSet();\n      }\n    }\n  }\n\n  return GetSize();\n}"
  },
  {
    "function_name": "EbmlUnicodeString::UpdateSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "332-342",
    "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSize",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "SafeReadIOCallback::GetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
          "lines": "88-92",
          "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
          "includes": [
            "#include \"ebml/SafeReadIOCallback.h\"",
            "#include \"ebml/MemReadIOCallback.h\"",
            "#include \"ebml/EbmlBinary.h\"",
            "#include <cstring>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/SafeReadIOCallback.h\"\n#include \"ebml/MemReadIOCallback.h\"\n#include \"ebml/EbmlBinary.h\"\n#include <cstring>\n\nsize_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "GetDefaultSize()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetSize_",
          "args": [
            "Value.GetUTF8().length()"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsDefaultValue",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nuint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}"
  },
  {
    "function_name": "EbmlUnicodeString::GetValueUTF8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "325-327",
    "snippet": "std::string EbmlUnicodeString::GetValueUTF8() const {\n  return Value.GetUTF8();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nstd::string EbmlUnicodeString::GetValueUTF8() const {\n  return Value.GetUTF8();\n}"
  },
  {
    "function_name": "EbmlUnicodeString::GetValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "321-323",
    "snippet": "UTFstring EbmlUnicodeString::GetValue() const {\n  return Value;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring EbmlUnicodeString::GetValue() const {\n  return Value;\n}"
  },
  {
    "function_name": "EbmlUnicodeString::RenderData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "279-300",
    "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Pad",
            "GetDefaultSize() - Result"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Pad",
            "0x00",
            "GetDefaultSize() - Result"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultSize",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.writeFully",
          "args": [
            "Value.GetUTF8().c_str()",
            "Result"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value.GetUTF8",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nfilepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}"
  },
  {
    "function_name": "EbmlUnicodeString::SetDefaultValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "261-266",
    "snippet": "void EbmlUnicodeString::SetDefaultValue(UTFstring & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!DefaultISset()"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultISset",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nvoid EbmlUnicodeString::SetDefaultValue(UTFstring & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}"
  },
  {
    "function_name": "EbmlUnicodeString::EbmlUnicodeString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "254-259",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString(const EbmlUnicodeString & ElementToClone)\n  :EbmlElement(ElementToClone)\n  ,Value(ElementToClone.Value)\n  ,DefaultValue(ElementToClone.DefaultValue)\n{\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString::EbmlUnicodeString(const EbmlUnicodeString & ElementToClone)\n  :EbmlElement(ElementToClone)\n  ,Value(ElementToClone.Value)\n  ,DefaultValue(ElementToClone.DefaultValue)\n{\n}"
  },
  {
    "function_name": "EbmlUnicodeString::EbmlUnicodeString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "247-252",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString(const UTFstring & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultIsSet",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString::EbmlUnicodeString(const UTFstring & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n}"
  },
  {
    "function_name": "EbmlUnicodeString::EbmlUnicodeString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "241-245",
    "snippet": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetDefaultSize",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nEbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}"
  },
  {
    "function_name": "UTFstring::wcscmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "230-237",
    "snippet": "bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nbool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}"
  },
  {
    "function_name": "UTFstring::UpdateFromUCS2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "198-228",
    "snippet": "void UTFstring::UpdateFromUCS2()\n{\n  // find the size of the final UTF-8 string\n  size_t i,Size=0;\n  for (i=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      Size++;\n    } else if (_Data[i] < 0x800) {\n      Size += 2;\n    } else {\n      Size += 3;\n    }\n  }\n  std::string::value_type *tmpStr = new std::string::value_type[Size+1];\n  for (i=0, Size=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      tmpStr[Size++] = _Data[i];\n    } else if (_Data[i] < 0x800) {\n      tmpStr[Size++] = 0xC0 | (_Data[i] >> 6);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    } else {\n      tmpStr[Size++] = 0xE0 | (_Data[i] >> 12);\n      tmpStr[Size++] = 0x80 | ((_Data[i] >> 6) & 0x3F);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    }\n  }\n  tmpStr[Size] = 0;\n  UTF8string = tmpStr; // implicit conversion\n  delete [] tmpStr;\n\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nvoid UTFstring::UpdateFromUCS2()\n{\n  // find the size of the final UTF-8 string\n  size_t i,Size=0;\n  for (i=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      Size++;\n    } else if (_Data[i] < 0x800) {\n      Size += 2;\n    } else {\n      Size += 3;\n    }\n  }\n  std::string::value_type *tmpStr = new std::string::value_type[Size+1];\n  for (i=0, Size=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      tmpStr[Size++] = _Data[i];\n    } else if (_Data[i] < 0x800) {\n      tmpStr[Size++] = 0xC0 | (_Data[i] >> 6);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    } else {\n      tmpStr[Size++] = 0xE0 | (_Data[i] >> 12);\n      tmpStr[Size++] = 0x80 | ((_Data[i] >> 6) & 0x3F);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    }\n  }\n  tmpStr[Size] = 0;\n  UTF8string = tmpStr; // implicit conversion\n  delete [] tmpStr;\n\n}"
  },
  {
    "function_name": "UTFstring::UpdateFromUTF8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "156-196",
    "snippet": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UTFCharLength",
          "args": [
            "lead"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "UTFCharLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
          "lines": "46-63",
          "snippet": "START_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8>",
          "args": [
            "UTF8string[i]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8>",
          "args": [
            "UTF8string[i]"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTF8string.length",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nvoid UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}"
  },
  {
    "function_name": "UTFstring::SetUTF8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "147-151",
    "snippet": "void UTFstring::SetUTF8(const std::string & _aStr)\n{\n  UTF8string = _aStr;\n  UpdateFromUTF8();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpdateFromUTF8",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "UTFstring::UpdateFromUTF8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
          "lines": "156-196",
          "snippet": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nvoid UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  // find the size of the final UCS-2 string\n  size_t i;\n  const size_t SrcLength = UTF8string.length();\n  for (_Length=0, i=0; i<SrcLength; _Length++) {\n    const unsigned int CharLength = UTFCharLength(static_cast<uint8>(UTF8string[i]));\n    if ((CharLength >= 1) && (CharLength <= 4))\n      i += CharLength;\n    else\n      // Invalid size?\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<SrcLength; j++) {\n    const uint8 lead              = static_cast<uint8>(UTF8string[i]);\n    const unsigned int CharLength = UTFCharLength(lead);\n    if ((CharLength < 1) || (CharLength > 4))\n      // Invalid char?\n      break;\n\n    if ((i + CharLength) > SrcLength)\n      // Guard against invalid memory access beyond the end of the\n      // source buffer.\n      break;\n\n    if (CharLength == 1)\n      _Data[j] = lead;\n    else if (CharLength == 2)\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n    else if (CharLength == 3)\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n    else if (CharLength == 4)\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n\n    i += CharLength;\n  }\n  _Data[j] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nvoid UTFstring::SetUTF8(const std::string & _aStr)\n{\n  UTF8string = _aStr;\n  UpdateFromUTF8();\n}"
  },
  {
    "function_name": "UTFstring::operator==",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "138-145",
    "snippet": "bool UTFstring::operator==(const UTFstring& _aStr) const\n{\n  if ((_Data == NULL) && (_aStr._Data == NULL))\n    return true;\n  if ((_Data == NULL) || (_aStr._Data == NULL))\n    return false;\n  return wcscmp_internal(_Data, _aStr._Data);\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wcscmp_internal",
          "args": [
            "_Data",
            "_aStr._Data"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "UTFstring::wcscmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
          "lines": "230-237",
          "snippet": "bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}",
          "includes": [
            "#include \"ebml/EbmlUnicodeString.h\"",
            "#include <wchar.h>",
            "#include <cassert>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nbool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nbool UTFstring::operator==(const UTFstring& _aStr) const\n{\n  if ((_Data == NULL) && (_aStr._Data == NULL))\n    return true;\n  if ((_Data == NULL) || (_aStr._Data == NULL))\n    return false;\n  return wcscmp_internal(_Data, _aStr._Data);\n}"
  },
  {
    "function_name": "UTFstring::UTFstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "89-94",
    "snippet": "UTFstring::UTFstring(const UTFstring & _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_aBuf.c_str",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring::UTFstring(const UTFstring & _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}"
  },
  {
    "function_name": "UTFstring::~UTFstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "84-87",
    "snippet": "UTFstring::~UTFstring()\n{\n  delete [] _Data;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring::~UTFstring()\n{\n  delete [] _Data;\n}"
  },
  {
    "function_name": "UTFstring::UTFstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "77-82",
    "snippet": "UTFstring::UTFstring(std::wstring const &_aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_aBuf.c_str",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring::UTFstring(std::wstring const &_aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf.c_str();\n}"
  },
  {
    "function_name": "UTFstring::UTFstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "70-75",
    "snippet": "UTFstring::UTFstring(const wchar_t * _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring::UTFstring(const wchar_t * _aBuf)\n  :_Length(0)\n  ,_Data(NULL)\n{\n  *this = _aBuf;\n}"
  },
  {
    "function_name": "UTFstring::UTFstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "65-68",
    "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nUTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}"
  },
  {
    "function_name": "UTFCharLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "46-63",
    "snippet": "START_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}",
    "includes": [
      "#include \"ebml/EbmlUnicodeString.h\"",
      "#include <wchar.h>",
      "#include <cassert>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ebml/EbmlUnicodeString.h\"\n#include <wchar.h>\n#include <cassert>\n\nSTART_LIBEBML_NAMESPACE\n\n// ===================== UTFstring class ===================\n\nstatic unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    // Invalid size?\n    return 0;\n}"
  }
]