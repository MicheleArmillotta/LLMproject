[
  {
    "function_name": "clear",
    "container": "Encoding",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
    "lines": "49-50",
    "snippet": "void clear()\n      { encodingMap.clear(); }",
    "includes": [
      "#include <map>",
      "#include <string>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodingMap.clear",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "Encoding",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
          "lines": "49-50",
          "snippet": "void clear()\n      { encodingMap.clear(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <string>\n\nEncoding {\n  void clear()\n        { encodingMap.clear(); }\n}"
  },
  {
    "function_name": "Encoding",
    "container": "Encoding",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
    "lines": "45-46",
    "snippet": "explicit Encoding(const char* header)\n      { parse(header); }",
    "includes": [
      "#include <map>",
      "#include <string>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse",
          "args": [
            "header"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "Encoding",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/encoding.cpp",
          "lines": "44-160",
          "snippet": "void Encoding::parse(const char* header)\n  {\n    encodingMap.clear();\n\n    if (header == 0)\n      return;\n\n    enum {\n      state_0,\n      state_encoding,\n      state_quality,\n      state_qualityq,\n      state_qualityeq,\n      state_qualitypoint,\n      state_qualitytenth,\n      state_qualityign\n    } state = state_0;\n\n    std::string encoding;\n    unsigned quality = 0;\n    for (const char* p = header; *p; ++p)\n    {\n      char ch = *p;\n      switch (state)\n      {\n        case state_0:\n          if (!std::isspace(ch))\n          {\n            encoding.clear();\n            encoding.reserve(16);\n            encoding += ch;\n            state = state_encoding;\n          }\n          break;\n\n        case state_encoding:\n          if (ch == ';')\n            state = state_qualityq;\n          else if (ch == ',')\n          {\n            encodingMap.insert(encodingMapType::value_type(encoding, 1));\n            state = state_0;\n          }\n          else\n            encoding += ch;\n          break;\n\n        case state_qualityq:\n          if (ch == 'q')\n            state = state_qualityeq;\n          else if (!std::isspace(ch))\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualityeq:\n          if (ch == '=')\n            state = state_quality;\n          else if (!std::isspace(ch))\n            throwInvalidHeader(header);\n          break;\n\n        case state_quality:\n          if (std::isdigit(ch))\n          {\n            quality = (ch - '0') * 10;\n            state = state_qualitypoint;\n          }\n          else\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualitypoint:\n          if (ch == '.')\n            state = state_qualitytenth;\n          else if (ch == ';')\n          {\n            encodingMap.insert(encodingMapType::value_type(encoding, quality));\n            state = state_0;\n          }\n          else\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualitytenth:\n          if (std::isdigit(ch))\n          {\n            quality += ch - '0';\n            encodingMap.insert(encodingMapType::value_type(encoding, quality));\n            state = state_qualityign;\n          }\n          else if (ch == ';')\n            state = state_0;\n          break;\n\n        case state_qualityign:\n          if (ch == ';')\n            state = state_0;\n          break;\n      }\n    }\n\n    switch (state)\n    {\n      case state_encoding:\n        encodingMap.insert(encodingMapType::value_type(encoding, 1));\n        break;\n\n      case state_quality:\n      case state_qualitypoint:\n      case state_qualitytenth:\n        encodingMap.insert(encodingMapType::value_type(encoding, quality));\n        break;\n\n      default:\n        break;\n    }\n  }",
          "includes": [
            "#include <cctype>",
            "#include \"tnt/util.h\"",
            "#include \"tnt/encoding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cctype>\n#include \"tnt/util.h\"\n#include \"tnt/encoding.h\"\n\nEncoding {\n  void Encoding::parse(const char* header)\n    {\n      encodingMap.clear();\n  \n      if (header == 0)\n        return;\n  \n      enum {\n        state_0,\n        state_encoding,\n        state_quality,\n        state_qualityq,\n        state_qualityeq,\n        state_qualitypoint,\n        state_qualitytenth,\n        state_qualityign\n      } state = state_0;\n  \n      std::string encoding;\n      unsigned quality = 0;\n      for (const char* p = header; *p; ++p)\n      {\n        char ch = *p;\n        switch (state)\n        {\n          case state_0:\n            if (!std::isspace(ch))\n            {\n              encoding.clear();\n              encoding.reserve(16);\n              encoding += ch;\n              state = state_encoding;\n            }\n            break;\n  \n          case state_encoding:\n            if (ch == ';')\n              state = state_qualityq;\n            else if (ch == ',')\n            {\n              encodingMap.insert(encodingMapType::value_type(encoding, 1));\n              state = state_0;\n            }\n            else\n              encoding += ch;\n            break;\n  \n          case state_qualityq:\n            if (ch == 'q')\n              state = state_qualityeq;\n            else if (!std::isspace(ch))\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualityeq:\n            if (ch == '=')\n              state = state_quality;\n            else if (!std::isspace(ch))\n              throwInvalidHeader(header);\n            break;\n  \n          case state_quality:\n            if (std::isdigit(ch))\n            {\n              quality = (ch - '0') * 10;\n              state = state_qualitypoint;\n            }\n            else\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualitypoint:\n            if (ch == '.')\n              state = state_qualitytenth;\n            else if (ch == ';')\n            {\n              encodingMap.insert(encodingMapType::value_type(encoding, quality));\n              state = state_0;\n            }\n            else\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualitytenth:\n            if (std::isdigit(ch))\n            {\n              quality += ch - '0';\n              encodingMap.insert(encodingMapType::value_type(encoding, quality));\n              state = state_qualityign;\n            }\n            else if (ch == ';')\n              state = state_0;\n            break;\n  \n          case state_qualityign:\n            if (ch == ';')\n              state = state_0;\n            break;\n        }\n      }\n  \n      switch (state)\n      {\n        case state_encoding:\n          encodingMap.insert(encodingMapType::value_type(encoding, 1));\n          break;\n  \n        case state_quality:\n        case state_qualitypoint:\n        case state_qualitytenth:\n          encodingMap.insert(encodingMapType::value_type(encoding, quality));\n          break;\n  \n        default:\n          break;\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <string>\n\nEncoding {\n  explicit Encoding(const char* header)\n        { parse(header); }\n}"
  },
  {
    "function_name": "Encoding",
    "container": "Encoding",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
    "lines": "44-44",
    "snippet": "Encoding()  { }",
    "includes": [
      "#include <map>",
      "#include <string>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <string>\n\nEncoding {\n  Encoding()  { }\n}"
  }
]