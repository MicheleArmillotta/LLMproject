[
  {
    "function_name": "accept",
    "container": "Encoding",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/encoding.cpp",
    "lines": "162-177",
    "snippet": "unsigned Encoding::accept(const std::string& encoding) const\n  {\n    // check, if encoding is specified\n\n    encodingMapType::const_iterator it =  encodingMap.find(encoding);\n    if (it != encodingMap.end())\n      return it->second;\n\n    // check, if a wildcard-rule is specified\n    it = encodingMap.find(\"*\");\n    if (it != encodingMap.end())\n      return it->second;\n\n    // return 10 (accept), if encoding is identity, 0 otherwise\n    return encoding == \"identity\" ? 10 : 0;\n  }",
    "includes": [
      "#include <cctype>",
      "#include \"tnt/util.h\"",
      "#include \"tnt/encoding.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodingMap.end",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "DeflateStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/deflatestream.cpp",
          "lines": "183-187",
          "snippet": "void DeflateStream::end()\n  {\n    if (streambuf.end() != 0)\n      setstate(failbit);\n  }",
          "includes": [
            "#include <string.h>",
            "#include <sstream>",
            "#include <cxxtools/log.h>",
            "#include \"tnt/deflatestream.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sstream>\n#include <cxxtools/log.h>\n#include \"tnt/deflatestream.h\"\n\nDeflateStream {\n  void DeflateStream::end()\n    {\n      if (streambuf.end() != 0)\n        setstate(failbit);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encodingMap.find",
          "args": [
            "\"*\""
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "Messageheader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheader.cpp",
          "lines": "81-90",
          "snippet": "Messageheader::const_iterator Messageheader::find(const char* key) const\n  {\n    for (const_iterator it = begin(); it != end(); ++it)\n    {\n      if (StringCompareIgnoreCase<const char*>(key, it->first) == 0)\n        return it;\n    }\n\n    return end();\n  }",
          "includes": [
            "#include <cstring>",
            "#include <tnt/stringlessignorecase.h>",
            "#include <stdexcept>",
            "#include <cxxtools/log.h>",
            "#include <tnt/messageheaderparser.h>",
            "#include <tnt/messageheader.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <tnt/stringlessignorecase.h>\n#include <stdexcept>\n#include <cxxtools/log.h>\n#include <tnt/messageheaderparser.h>\n#include <tnt/messageheader.h>\n\nMessageheader {\n  Messageheader::const_iterator Messageheader::find(const char* key) const\n    {\n      for (const_iterator it = begin(); it != end(); ++it)\n      {\n        if (StringCompareIgnoreCase<const char*>(key, it->first) == 0)\n          return it;\n      }\n  \n      return end();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cctype>\n#include \"tnt/util.h\"\n#include \"tnt/encoding.h\"\n\nEncoding {\n  unsigned Encoding::accept(const std::string& encoding) const\n    {\n      // check, if encoding is specified\n  \n      encodingMapType::const_iterator it =  encodingMap.find(encoding);\n      if (it != encodingMap.end())\n        return it->second;\n  \n      // check, if a wildcard-rule is specified\n      it = encodingMap.find(\"*\");\n      if (it != encodingMap.end())\n        return it->second;\n  \n      // return 10 (accept), if encoding is identity, 0 otherwise\n      return encoding == \"identity\" ? 10 : 0;\n    }\n}"
  },
  {
    "function_name": "parse",
    "container": "Encoding",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/encoding.cpp",
    "lines": "44-160",
    "snippet": "void Encoding::parse(const char* header)\n  {\n    encodingMap.clear();\n\n    if (header == 0)\n      return;\n\n    enum {\n      state_0,\n      state_encoding,\n      state_quality,\n      state_qualityq,\n      state_qualityeq,\n      state_qualitypoint,\n      state_qualitytenth,\n      state_qualityign\n    } state = state_0;\n\n    std::string encoding;\n    unsigned quality = 0;\n    for (const char* p = header; *p; ++p)\n    {\n      char ch = *p;\n      switch (state)\n      {\n        case state_0:\n          if (!std::isspace(ch))\n          {\n            encoding.clear();\n            encoding.reserve(16);\n            encoding += ch;\n            state = state_encoding;\n          }\n          break;\n\n        case state_encoding:\n          if (ch == ';')\n            state = state_qualityq;\n          else if (ch == ',')\n          {\n            encodingMap.insert(encodingMapType::value_type(encoding, 1));\n            state = state_0;\n          }\n          else\n            encoding += ch;\n          break;\n\n        case state_qualityq:\n          if (ch == 'q')\n            state = state_qualityeq;\n          else if (!std::isspace(ch))\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualityeq:\n          if (ch == '=')\n            state = state_quality;\n          else if (!std::isspace(ch))\n            throwInvalidHeader(header);\n          break;\n\n        case state_quality:\n          if (std::isdigit(ch))\n          {\n            quality = (ch - '0') * 10;\n            state = state_qualitypoint;\n          }\n          else\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualitypoint:\n          if (ch == '.')\n            state = state_qualitytenth;\n          else if (ch == ';')\n          {\n            encodingMap.insert(encodingMapType::value_type(encoding, quality));\n            state = state_0;\n          }\n          else\n            throwInvalidHeader(header);\n          break;\n\n        case state_qualitytenth:\n          if (std::isdigit(ch))\n          {\n            quality += ch - '0';\n            encodingMap.insert(encodingMapType::value_type(encoding, quality));\n            state = state_qualityign;\n          }\n          else if (ch == ';')\n            state = state_0;\n          break;\n\n        case state_qualityign:\n          if (ch == ';')\n            state = state_0;\n          break;\n      }\n    }\n\n    switch (state)\n    {\n      case state_encoding:\n        encodingMap.insert(encodingMapType::value_type(encoding, 1));\n        break;\n\n      case state_quality:\n      case state_qualitypoint:\n      case state_qualitytenth:\n        encodingMap.insert(encodingMapType::value_type(encoding, quality));\n        break;\n\n      default:\n        break;\n    }\n  }",
    "includes": [
      "#include <cctype>",
      "#include \"tnt/util.h\"",
      "#include \"tnt/encoding.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodingMap.insert",
          "args": [
            "encodingMapType::value_type(encoding, quality)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMapType::value_type",
          "args": [
            "encoding",
            "quality"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMap.insert",
          "args": [
            "encodingMapType::value_type(encoding, 1)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMapType::value_type",
          "args": [
            "encoding",
            "1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMap.insert",
          "args": [
            "encodingMapType::value_type(encoding, quality)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMapType::value_type",
          "args": [
            "encoding",
            "quality"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::isdigit",
          "args": [
            "ch"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "throwInvalidHeader",
          "args": [
            "header"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "throwInvalidHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/encoding.cpp",
          "lines": "38-41",
          "snippet": "void throwInvalidHeader(const char* header)\n    {\n      throwRuntimeError(std::string(\"invalid encoding-string \\\"\") + header + '\"');\n    }",
          "includes": [
            "#include <cctype>",
            "#include \"tnt/util.h\"",
            "#include \"tnt/encoding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cctype>\n#include \"tnt/util.h\"\n#include \"tnt/encoding.h\"\n\nvoid throwInvalidHeader(const char* header)\n    {\n      throwRuntimeError(std::string(\"invalid encoding-string \\\"\") + header + '\"');\n    }"
        }
      },
      {
        "call_info": {
          "callee": "encodingMap.insert",
          "args": [
            "encodingMapType::value_type(encoding, quality)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMapType::value_type",
          "args": [
            "encoding",
            "quality"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::isdigit",
          "args": [
            "ch"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::isspace",
          "args": [
            "ch"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::isspace",
          "args": [
            "ch"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMap.insert",
          "args": [
            "encodingMapType::value_type(encoding, 1)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodingMapType::value_type",
          "args": [
            "encoding",
            "1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.reserve",
          "args": [
            "16"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.clear",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "Encoding",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
          "lines": "49-50",
          "snippet": "void clear()\n      { encodingMap.clear(); }",
          "includes": [
            "#include <map>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <string>\n\nEncoding {\n  void clear()\n        { encodingMap.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::isspace",
          "args": [
            "ch"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cctype>\n#include \"tnt/util.h\"\n#include \"tnt/encoding.h\"\n\nEncoding {\n  void Encoding::parse(const char* header)\n    {\n      encodingMap.clear();\n  \n      if (header == 0)\n        return;\n  \n      enum {\n        state_0,\n        state_encoding,\n        state_quality,\n        state_qualityq,\n        state_qualityeq,\n        state_qualitypoint,\n        state_qualitytenth,\n        state_qualityign\n      } state = state_0;\n  \n      std::string encoding;\n      unsigned quality = 0;\n      for (const char* p = header; *p; ++p)\n      {\n        char ch = *p;\n        switch (state)\n        {\n          case state_0:\n            if (!std::isspace(ch))\n            {\n              encoding.clear();\n              encoding.reserve(16);\n              encoding += ch;\n              state = state_encoding;\n            }\n            break;\n  \n          case state_encoding:\n            if (ch == ';')\n              state = state_qualityq;\n            else if (ch == ',')\n            {\n              encodingMap.insert(encodingMapType::value_type(encoding, 1));\n              state = state_0;\n            }\n            else\n              encoding += ch;\n            break;\n  \n          case state_qualityq:\n            if (ch == 'q')\n              state = state_qualityeq;\n            else if (!std::isspace(ch))\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualityeq:\n            if (ch == '=')\n              state = state_quality;\n            else if (!std::isspace(ch))\n              throwInvalidHeader(header);\n            break;\n  \n          case state_quality:\n            if (std::isdigit(ch))\n            {\n              quality = (ch - '0') * 10;\n              state = state_qualitypoint;\n            }\n            else\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualitypoint:\n            if (ch == '.')\n              state = state_qualitytenth;\n            else if (ch == ';')\n            {\n              encodingMap.insert(encodingMapType::value_type(encoding, quality));\n              state = state_0;\n            }\n            else\n              throwInvalidHeader(header);\n            break;\n  \n          case state_qualitytenth:\n            if (std::isdigit(ch))\n            {\n              quality += ch - '0';\n              encodingMap.insert(encodingMapType::value_type(encoding, quality));\n              state = state_qualityign;\n            }\n            else if (ch == ';')\n              state = state_0;\n            break;\n  \n          case state_qualityign:\n            if (ch == ';')\n              state = state_0;\n            break;\n        }\n      }\n  \n      switch (state)\n      {\n        case state_encoding:\n          encodingMap.insert(encodingMapType::value_type(encoding, 1));\n          break;\n  \n        case state_quality:\n        case state_qualitypoint:\n        case state_qualitytenth:\n          encodingMap.insert(encodingMapType::value_type(encoding, quality));\n          break;\n  \n        default:\n          break;\n      }\n    }\n}"
  },
  {
    "function_name": "throwInvalidHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/encoding.cpp",
    "lines": "38-41",
    "snippet": "void throwInvalidHeader(const char* header)\n    {\n      throwRuntimeError(std::string(\"invalid encoding-string \\\"\") + header + '\"');\n    }",
    "includes": [
      "#include <cctype>",
      "#include \"tnt/util.h\"",
      "#include \"tnt/encoding.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "throwRuntimeError",
          "args": [
            "std::string(\"invalid encoding-string \\\"\") + header + '\"'"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "throwRuntimeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/util.cpp",
          "lines": "39-42",
          "snippet": "void throwRuntimeError(const char* msg)\n  {\n    throwRuntimeError(std::string(msg));\n  }",
          "includes": [
            "#include <stdexcept>",
            "#include <tnt/util.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdexcept>\n#include <tnt/util.h>\n\nvoid throwRuntimeError(const char* msg)\n  {\n    throwRuntimeError(std::string(msg));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "\"invalid encoding-string \\\"\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cctype>\n#include \"tnt/util.h\"\n#include \"tnt/encoding.h\"\n\nvoid throwInvalidHeader(const char* header)\n    {\n      throwRuntimeError(std::string(\"invalid encoding-string \\\"\") + header + '\"');\n    }"
  }
]