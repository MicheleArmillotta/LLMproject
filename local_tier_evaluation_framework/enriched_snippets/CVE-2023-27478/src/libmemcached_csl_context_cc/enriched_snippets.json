[
  {
    "function_name": "set_hash",
    "container": "Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.cc",
    "lines": "94-104",
    "snippet": "bool Context::set_hash(memcached_hash_t hash) {\n  if (_has_hash) {\n    return false;\n  }\n\n  if ((memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_HASH, hash)) != MEMCACHED_SUCCESS) {\n    return false;\n  }\n\n  return _has_hash = true;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/csl/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "memc",
            "MEMCACHED_BEHAVIOR_HASH",
            "hash"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  bool Context::set_hash(memcached_hash_t hash) {\n    if (_has_hash) {\n      return false;\n    }\n  \n    if ((memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_HASH, hash)) != MEMCACHED_SUCCESS) {\n      return false;\n    }\n  \n    return _has_hash = true;\n  }\n}"
  },
  {
    "function_name": "string_buffer",
    "container": "Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.cc",
    "lines": "83-92",
    "snippet": "bool Context::string_buffer(const char *str, size_t size, memcached_string_t &string_) {\n  if (memcached_string_set(_string_buffer, str, size)) {\n    string_.c_str = memcached_string_value(_string_buffer);\n    string_.size = memcached_string_length(_string_buffer);\n\n    return true;\n  }\n\n  return false;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/csl/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_string_length",
          "args": [
            "_string_buffer"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "207-209",
          "snippet": "size_t memcached_string_length(const memcached_string_st &self) {\n  return size_t(self.end - self.string);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nsize_t memcached_string_length(const memcached_string_st &self) {\n  return size_t(self.end - self.string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_value",
          "args": [
            "_string_buffer"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_set",
          "args": [
            "_string_buffer",
            "str",
            "size"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "161-169",
          "snippet": "bool memcached_string_set(memcached_string_st &string, const char *value, size_t length) {\n  memcached_string_reset(&string);\n  if (memcached_success(memcached_string_append(&string, value, length))) {\n    memcached_string_append_null(string);\n    return true;\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nbool memcached_string_set(memcached_string_st &string, const char *value, size_t length) {\n  memcached_string_reset(&string);\n  if (memcached_success(memcached_string_append(&string, value, length))) {\n    memcached_string_append_null(string);\n    return true;\n  }\n\n  return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  bool Context::string_buffer(const char *str, size_t size, memcached_string_t &string_) {\n    if (memcached_string_set(_string_buffer, str, size)) {\n      string_.c_str = memcached_string_value(_string_buffer);\n      string_.size = memcached_string_length(_string_buffer);\n  \n      return true;\n    }\n  \n    return false;\n  }\n}"
  },
  {
    "function_name": "hostname",
    "container": "Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.cc",
    "lines": "72-81",
    "snippet": "void Context::hostname(const char *str, size_t size, server_t &server_) {\n  size_t copy_length = size_t(NI_MAXHOST) > size ? size : size_t(NI_MAXHOST);\n  memcpy(_hostname, str, copy_length);\n  _hostname[copy_length] = 0;\n\n  server_.port = MEMCACHED_DEFAULT_PORT;\n  server_.weight = 1;\n  server_.c_str = _hostname;\n  server_.size = size;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/csl/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "_hostname",
            "str",
            "copy_length"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "NI_MAXHOST"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "NI_MAXHOST"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  void Context::hostname(const char *str, size_t size, server_t &server_) {\n    size_t copy_length = size_t(NI_MAXHOST) > size ? size : size_t(NI_MAXHOST);\n    memcpy(_hostname, str, copy_length);\n    _hostname[copy_length] = 0;\n  \n    server_.port = MEMCACHED_DEFAULT_PORT;\n    server_.weight = 1;\n    server_.c_str = _hostname;\n    server_.size = size;\n  }\n}"
  },
  {
    "function_name": "error",
    "container": "Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.cc",
    "lines": "37-70",
    "snippet": "void Context::error(const char *error_arg, config_tokentype last_token,\n                    const char *last_token_str) {\n  rc = MEMCACHED_PARSE_ERROR;\n  if (not error_arg) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"Unknown error occured during parsing (%s)\",\n                               last_token_str ? last_token_str : \" \");\n    return;\n  }\n\n  if (strcmp(error_arg, \"memory exhausted\") == 0) {\n    (void) memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(error_arg));\n    return;\n  }\n\n  // We now test if it is something other then a syntax error, if it  we\n  // return a generic message\n  if (strcmp(error_arg, \"syntax error\")) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT,\n                               \"Error occured during parsing (%s): last_token=%s(%d)\", error_arg,\n                               last_token_str, last_token);\n    return;\n  }\n\n  if (last_token == UNKNOWN_OPTION and begin) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"Unknown option: %s\", begin);\n  } else if (last_token == UNKNOWN) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT,\n                               \"Error occured durring parsing, an unknown token was found.\");\n  } else {\n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"Error occured while parsing (%s)\",\n                               last_token_str ? last_token_str : \" \");\n  }\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/csl/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"Error occured while parsing (%s)\"",
            "last_token_str ? last_token_str : \" \""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"Error occured durring parsing, an unknown token was found.\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_parser_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "205-215",
          "snippet": "memcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"Unknown option: %s\"",
            "begin"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"Error occured during parsing (%s): last_token=%s(%d)\"",
            "error_arg",
            "last_token_str",
            "last_token"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "error_arg",
            "\"syntax error\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*memc",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT",
            "memcached_string_make_from_cstr(error_arg)"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "error_arg"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "error_arg",
            "\"memory exhausted\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"Unknown error occured during parsing (%s)\"",
            "last_token_str ? last_token_str : \" \""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  void Context::error(const char *error_arg, config_tokentype last_token,\n                      const char *last_token_str) {\n    rc = MEMCACHED_PARSE_ERROR;\n    if (not error_arg) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT, \"Unknown error occured during parsing (%s)\",\n                                 last_token_str ? last_token_str : \" \");\n      return;\n    }\n  \n    if (strcmp(error_arg, \"memory exhausted\") == 0) {\n      (void) memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                 memcached_string_make_from_cstr(error_arg));\n      return;\n    }\n  \n    // We now test if it is something other then a syntax error, if it  we\n    // return a generic message\n    if (strcmp(error_arg, \"syntax error\")) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT,\n                                 \"Error occured during parsing (%s): last_token=%s(%d)\", error_arg,\n                                 last_token_str, last_token);\n      return;\n    }\n  \n    if (last_token == UNKNOWN_OPTION and begin) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT, \"Unknown option: %s\", begin);\n    } else if (last_token == UNKNOWN) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT,\n                                 \"Error occured durring parsing, an unknown token was found.\");\n    } else {\n      memcached_set_parser_error(*memc, MEMCACHED_AT, \"Error occured while parsing (%s)\",\n                                 last_token_str ? last_token_str : \" \");\n    }\n  }\n}"
  },
  {
    "function_name": "abort",
    "container": "Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.cc",
    "lines": "19-35",
    "snippet": "void Context::abort(const char *error_arg, config_tokentype last_token,\n                    const char *last_token_str) {\n  rc = MEMCACHED_PARSE_ERROR;\n  (void) last_token;\n\n  if (error_arg) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"%s\", error_arg);\n    return;\n  }\n\n  if (last_token_str) {\n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"%s\", last_token_str);\n    return;\n  }\n\n  memcached_set_parser_error(*memc, MEMCACHED_AT, \"unknown parsing error\");\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/csl/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"unknown parsing error\""
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_parser_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "205-215",
          "snippet": "memcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"%s\"",
            "last_token_str"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_parser_error",
          "args": [
            "*memc",
            "MEMCACHED_AT",
            "\"%s\"",
            "error_arg"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  void Context::abort(const char *error_arg, config_tokentype last_token,\n                      const char *last_token_str) {\n    rc = MEMCACHED_PARSE_ERROR;\n    (void) last_token;\n  \n    if (error_arg) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT, \"%s\", error_arg);\n      return;\n    }\n  \n    if (last_token_str) {\n      memcached_set_parser_error(*memc, MEMCACHED_AT, \"%s\", last_token_str);\n      return;\n    }\n  \n    memcached_set_parser_error(*memc, MEMCACHED_AT, \"unknown parsing error\");\n  }\n}"
  }
]