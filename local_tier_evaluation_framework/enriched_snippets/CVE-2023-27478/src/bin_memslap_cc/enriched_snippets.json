[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "232-398",
    "snippet": "int main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION};\n  auto concurrency = DEFAULT_CONCURRENCY;\n  auto load_count = DEFAULT_INITIAL_LOAD;\n  auto test_count = DEFAULT_EXECUTE_NUMBER;\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n\n  opt.add(\"noreply\", 'R', no_argument, \"Enable the NOREPLY behavior for storage commands.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NOREPLY, ext.set)) {\n      if(!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc);\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"udp\", 'U', no_argument, \"Use UDP.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP, ext.set)) {\n      if (!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc) << \"\\n\";\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"flush\", 'F', no_argument, \"Flush all servers prior test.\");\n  opt.add(\"test\", 't', required_argument, \"Test to perform (options: get,mget,set; default: get).\");\n  opt.add(\"concurrency\", 'c', required_argument, \"Concurrency (number of threads to start; default: 1).\")\n      .apply = wrap_stoul(concurrency);\n  opt.add(\"execute-number\", 'e', required_argument, \"Number of times to execute the tests (default: 10000).\")\n      .apply = wrap_stoul(test_count);\n  opt.add(\"initial-load\", 'l', required_argument, \"Number of keys to load before executing tests (default: 10000).\"\n                                                  \"\\n\\t\\tDEPRECATED: --execute-number takes precedence.\")\n      .apply = wrap_stoul(load_count);\n\n  char set[] = \"set\";\n  opt.set(\"test\", true, set);\n\n  if (!opt.parse(argc, argv)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto total_start = time_clock::now();\n  std::cout << std::fixed << std::setprecision(3);\n\n  if (opt.isset(\"flush\")) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"- Flushing servers ...\\n\";\n    }\n    auto flush_start = time_clock::now();\n    auto rc = memcached_flush(&memc, 0);\n    auto flush_elapsed = time_clock::now() - flush_start;\n    if (!memcached_success(rc)) {\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << \"Failed to FLUSH: \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n      memcached_free(&memc);\n      exit(EXIT_FAILURE);\n    }\n    if (!opt.isset(\"quiet\")) {\n      std::cout << \"Time to flush      \" << align\n                << memcached_server_count(&memc)\n                << \" servers:               \"\n                << align << time_format(flush_elapsed).count()\n                << \" seconds.\\n\";\n    }\n  }\n\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Generating random test data ...\\n\";\n  }\n  auto keyval_start = time_clock::now();\n  keyval_st kv{test_count};\n  auto keyval_elapsed = time_clock::now() - keyval_start;\n\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"Time to generate   \"\n              << align << test_count\n              << \" test keys:             \"\n              << align << time_format(keyval_elapsed).count()\n              << \" seconds.\\n\";\n  }\n\n  if (strcmp(opt.argof(\"test\"), \"set\")) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"- Feeding initial load to servers ...\\n\";\n    }\n    auto feed_start = time_clock::now();\n    auto count = execute_set(opt, memc, kv);\n    check_return(opt, memc, memcached_flush_buffers(&memc));\n    auto feed_elapsed = time_clock::now() - feed_start;\n\n    if (!opt.isset(\"quiet\")) {\n      std::cout << \"Time to set        \"\n                << align << count\n                << \" keys:                  \"\n                << align << time_format(feed_elapsed).count()\n                << \" seconds.\\n\";\n      }\n  }\n\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Starting \" << concurrency << \" threads ...\\n\";\n  }\n  auto thread_start = time_clock::now();\n  std::vector<thread_context *> threads{};\n  threads.reserve(concurrency);\n  for (auto i = 0ul; i < concurrency; ++i) {\n    threads.push_back(new thread_context(opt, memc, kv));\n  }\n  auto thread_elapsed = time_clock::now() - thread_start;\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"Time to start      \"\n              << align << concurrency\n              << \" threads:                  \"\n              << time_format(thread_elapsed).count()\n              << \" seconds.\\n\";\n  }\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Starting test: \" << test_count\n              << \" x \" << opt.argof(\"test\")\n              << \" x \" << concurrency\n              << \" ...\\n\";\n  }\n  auto count = 0ul;\n  auto test_start = time_clock::now();\n  wakeup.store(true, std::memory_order_release);\n  for (auto &thread : threads) {\n    count += thread->complete();\n    delete thread;\n  }\n  auto test_elapsed = time_clock::now() - test_start;\n\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"--------------------------------------------------------------------\\n\"\n              << \"Time to \" << std::left << std::setw(4)\n              << opt.argof(\"test\") << \"       \"\n              << align << count\n              << \" keys by \"\n              << std::setw(4)\n              << concurrency << \" threads:  \"\n              << align << time_format(test_elapsed).count()\n              << \" seconds.\\n\";\n\n    std::cout << \"--------------------------------------------------------------------\\n\"\n              << \"Time total:                                    \"\n              << align << std::setw(12)\n              << time_format(time_clock::now() - total_start).count()\n              << \" seconds.\\n\";\n  }\n  exit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CONCURRENCY    1ul",
      "#define DEFAULT_EXECUTE_NUMBER 10000ul",
      "#define DEFAULT_INITIAL_LOAD   10000ul",
      "#define PROGRAM_VERSION     \"1.1\"",
      "#define PROGRAM_DESCRIPTION \"Generate load against a cluster of memcached servers.\"",
      "#define PROGRAM_NAME        \"memslap\""
    ],
    "globals_used": [
      "static std::atomic_bool wakeup;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "time_clock::now() - total_start"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::setw",
          "args": [
            "12"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "test_elapsed"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::setw",
          "args": [
            "4"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::setw",
          "args": [
            "4"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->complete",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "complete",
          "container": "thread_context",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "179-182",
          "snippet": "size_t complete() {\n    thread.join();\n    return count;\n  }",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nthread_context {\n  size_t complete() {\n      thread.join();\n      return count;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup.store",
          "args": [
            "true",
            "std::memory_order_release"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "thread_elapsed"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threads.push_back",
          "args": [
            "new thread_context(opt, memc, kv)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threads.reserve",
          "args": [
            "concurrency"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "feed_elapsed"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_return",
          "args": [
            "opt",
            "memc",
            "memcached_flush_buffers(&memc)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "check_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "57-71",
          "snippet": "bool check_return(const client_options &opt, memcached_st &memc, memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (!memcached_fatal(rc)) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Failed: \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error: \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_return(const client_options &opt, memcached_st &memc, memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (!memcached_fatal(rc)) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Failed: \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error: \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_flush_buffers",
          "args": [
            "&memc"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flush_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush_buffers.cc",
          "lines": "18-43",
          "snippet": "memcached_return_t memcached_flush_buffers(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t ret = MEMCACHED_SUCCESS;\n\n    for (uint32_t x = 0; x < memcached_server_count(memc); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n      if (instance->write_buffer_offset) {\n        if (instance->fd == INVALID_SOCKET\n            and (ret = memcached_connect(instance)) != MEMCACHED_SUCCESS) {\n          WATCHPOINT_ERROR(ret);\n          return ret;\n        }\n\n        if (memcached_io_write(instance) == false) {\n          ret = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_flush_buffers(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t ret = MEMCACHED_SUCCESS;\n\n    for (uint32_t x = 0; x < memcached_server_count(memc); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n      if (instance->write_buffer_offset) {\n        if (instance->fd == INVALID_SOCKET\n            and (ret = memcached_connect(instance)) != MEMCACHED_SUCCESS) {\n          WATCHPOINT_ERROR(ret);\n          return ret;\n        }\n\n        if (memcached_io_write(instance) == false) {\n          ret = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute_set",
          "args": [
            "opt",
            "memc",
            "kv"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "execute_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "151-162",
          "snippet": "static size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opt.argof(\"test\")",
            "\"set\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "keyval_elapsed"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "flush_elapsed"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "&memc"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_flush",
          "args": [
            "&memc",
            "0"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
          "lines": "104-122",
          "snippet": "memcached_return_t memcached_flush(memcached_st *shell, time_t expiration) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  LIBMEMCACHED_MEMCACHED_FLUSH_START();\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_flush_binary(ptr, expiration, reply);\n  } else {\n    rc = memcached_flush_textual(ptr, expiration, reply);\n  }\n  LIBMEMCACHED_MEMCACHED_FLUSH_END();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_flush(memcached_st *shell, time_t expiration) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  LIBMEMCACHED_MEMCACHED_FLUSH_START();\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_flush_binary(ptr, expiration, reply);\n  } else {\n    rc = memcached_flush_textual(ptr, expiration, reply);\n  }\n  LIBMEMCACHED_MEMCACHED_FLUSH_END();\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::setprecision",
          "args": [
            "3"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.apply",
          "args": [
            "&memc"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "149-177",
          "snippet": "bool client_options::apply(memcached_st *memc) {\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    std::cerr << \"Socket Initialization Error.\\n\";\n    return false;\n  }\n#endif // _WIN32\n\n  extended_option *servers = nullptr;\n  for (auto &opt : options) {\n    if (opt.apply) {\n      // servers should be applied last, so they take up any behaviors previously set\n      if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n        servers = &opt;\n        continue;\n      }\n      if (!opt.apply(*this, opt, memc)) {\n        return false;\n      }\n    }\n  }\n  if (servers) {\n    if (!servers->apply(*this, *servers, memc)) {\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::apply(memcached_st *memc) {\n  #ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n      std::cerr << \"Socket Initialization Error.\\n\";\n      return false;\n    }\n  #endif // _WIN32\n  \n    extended_option *servers = nullptr;\n    for (auto &opt : options) {\n      if (opt.apply) {\n        // servers should be applied last, so they take up any behaviors previously set\n        if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n          servers = &opt;\n          continue;\n        }\n        if (!opt.apply(*this, opt, memc)) {\n          return false;\n        }\n      }\n    }\n    if (servers) {\n      if (!servers->apply(*this, *servers, memc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_memcached",
          "args": [
            "opt",
            "memc"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "check_memcached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "47-55",
          "snippet": "bool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.parse",
          "args": [
            "argc",
            "argv"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.set",
          "args": [
            "\"test\"",
            "true",
            "set"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrap_stoul",
          "args": [
            "load_count"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_stoul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "216-226",
          "snippet": "static opt_apply wrap_stoul(unsigned long &ul) {\n  return [&ul](const client_options &, const client_options::extended_option &ext, memcached_st *) {\n    if (ext.arg && *ext.arg) {\n      auto c = std::stoul(ext.arg);\n      if (c) {\n        ul = c;\n      }\n    }\n    return true;\n  };\n}",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic opt_apply wrap_stoul(unsigned long &ul) {\n  return [&ul](const client_options &, const client_options::extended_option &ext, memcached_st *) {\n    if (ext.arg && *ext.arg) {\n      auto c = std::stoul(ext.arg);\n      if (c) {\n        ul = c;\n      }\n    }\n    return true;\n  };\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"initial-load\"",
            "'l'",
            "required_argument",
            "\"Number of keys to load before executing tests (default: 10000).\"\n                                                  \"\\n\\t\\tDEPRECATED: --execute-number takes precedence.\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"execute-number\"",
            "'e'",
            "required_argument",
            "\"Number of times to execute the tests (default: 10000).\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"concurrency\"",
            "'c'",
            "required_argument",
            "\"Concurrency (number of threads to start; default: 1).\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"test\"",
            "'t'",
            "required_argument",
            "\"Test to perform (options: get,mget,set; default: get).\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"flush\"",
            "'F'",
            "no_argument",
            "\"Flush all servers prior test.\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "memc",
            "MEMCACHED_BEHAVIOR_USE_UDP",
            "ext.set"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"udp\"",
            "'U'",
            "no_argument",
            "\"Use UDP.\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"noreply\"",
            "'R'",
            "no_argument",
            "\"Enable the NOREPLY behavior for storage commands.\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "def"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define DEFAULT_CONCURRENCY    1ul\n#define DEFAULT_EXECUTE_NUMBER 10000ul\n#define DEFAULT_INITIAL_LOAD   10000ul\n#define PROGRAM_VERSION     \"1.1\"\n#define PROGRAM_DESCRIPTION \"Generate load against a cluster of memcached servers.\"\n#define PROGRAM_NAME        \"memslap\"\n\nstatic std::atomic_bool wakeup;\n\nint main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION};\n  auto concurrency = DEFAULT_CONCURRENCY;\n  auto load_count = DEFAULT_INITIAL_LOAD;\n  auto test_count = DEFAULT_EXECUTE_NUMBER;\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n\n  opt.add(\"noreply\", 'R', no_argument, \"Enable the NOREPLY behavior for storage commands.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NOREPLY, ext.set)) {\n      if(!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc);\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"udp\", 'U', no_argument, \"Use UDP.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP, ext.set)) {\n      if (!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc) << \"\\n\";\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"flush\", 'F', no_argument, \"Flush all servers prior test.\");\n  opt.add(\"test\", 't', required_argument, \"Test to perform (options: get,mget,set; default: get).\");\n  opt.add(\"concurrency\", 'c', required_argument, \"Concurrency (number of threads to start; default: 1).\")\n      .apply = wrap_stoul(concurrency);\n  opt.add(\"execute-number\", 'e', required_argument, \"Number of times to execute the tests (default: 10000).\")\n      .apply = wrap_stoul(test_count);\n  opt.add(\"initial-load\", 'l', required_argument, \"Number of keys to load before executing tests (default: 10000).\"\n                                                  \"\\n\\t\\tDEPRECATED: --execute-number takes precedence.\")\n      .apply = wrap_stoul(load_count);\n\n  char set[] = \"set\";\n  opt.set(\"test\", true, set);\n\n  if (!opt.parse(argc, argv)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto total_start = time_clock::now();\n  std::cout << std::fixed << std::setprecision(3);\n\n  if (opt.isset(\"flush\")) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"- Flushing servers ...\\n\";\n    }\n    auto flush_start = time_clock::now();\n    auto rc = memcached_flush(&memc, 0);\n    auto flush_elapsed = time_clock::now() - flush_start;\n    if (!memcached_success(rc)) {\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << \"Failed to FLUSH: \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n      memcached_free(&memc);\n      exit(EXIT_FAILURE);\n    }\n    if (!opt.isset(\"quiet\")) {\n      std::cout << \"Time to flush      \" << align\n                << memcached_server_count(&memc)\n                << \" servers:               \"\n                << align << time_format(flush_elapsed).count()\n                << \" seconds.\\n\";\n    }\n  }\n\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Generating random test data ...\\n\";\n  }\n  auto keyval_start = time_clock::now();\n  keyval_st kv{test_count};\n  auto keyval_elapsed = time_clock::now() - keyval_start;\n\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"Time to generate   \"\n              << align << test_count\n              << \" test keys:             \"\n              << align << time_format(keyval_elapsed).count()\n              << \" seconds.\\n\";\n  }\n\n  if (strcmp(opt.argof(\"test\"), \"set\")) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"- Feeding initial load to servers ...\\n\";\n    }\n    auto feed_start = time_clock::now();\n    auto count = execute_set(opt, memc, kv);\n    check_return(opt, memc, memcached_flush_buffers(&memc));\n    auto feed_elapsed = time_clock::now() - feed_start;\n\n    if (!opt.isset(\"quiet\")) {\n      std::cout << \"Time to set        \"\n                << align << count\n                << \" keys:                  \"\n                << align << time_format(feed_elapsed).count()\n                << \" seconds.\\n\";\n      }\n  }\n\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Starting \" << concurrency << \" threads ...\\n\";\n  }\n  auto thread_start = time_clock::now();\n  std::vector<thread_context *> threads{};\n  threads.reserve(concurrency);\n  for (auto i = 0ul; i < concurrency; ++i) {\n    threads.push_back(new thread_context(opt, memc, kv));\n  }\n  auto thread_elapsed = time_clock::now() - thread_start;\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"Time to start      \"\n              << align << concurrency\n              << \" threads:                  \"\n              << time_format(thread_elapsed).count()\n              << \" seconds.\\n\";\n  }\n  if (opt.isset(\"verbose\")) {\n    std::cout << \"- Starting test: \" << test_count\n              << \" x \" << opt.argof(\"test\")\n              << \" x \" << concurrency\n              << \" ...\\n\";\n  }\n  auto count = 0ul;\n  auto test_start = time_clock::now();\n  wakeup.store(true, std::memory_order_release);\n  for (auto &thread : threads) {\n    count += thread->complete();\n    delete thread;\n  }\n  auto test_elapsed = time_clock::now() - test_start;\n\n  if (!opt.isset(\"quiet\")) {\n    std::cout << \"--------------------------------------------------------------------\\n\"\n              << \"Time to \" << std::left << std::setw(4)\n              << opt.argof(\"test\") << \"       \"\n              << align << count\n              << \" keys by \"\n              << std::setw(4)\n              << concurrency << \" threads:  \"\n              << align << time_format(test_elapsed).count()\n              << \" seconds.\\n\";\n\n    std::cout << \"--------------------------------------------------------------------\\n\"\n              << \"Time total:                                    \"\n              << align << std::setw(12)\n              << time_format(time_clock::now() - total_start).count()\n              << \" seconds.\\n\";\n  }\n  exit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "wrap_stoul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "216-226",
    "snippet": "static opt_apply wrap_stoul(unsigned long &ul) {\n  return [&ul](const client_options &, const client_options::extended_option &ext, memcached_st *) {\n    if (ext.arg && *ext.arg) {\n      auto c = std::stoul(ext.arg);\n      if (c) {\n        ul = c;\n      }\n    }\n    return true;\n  };\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::stoul",
          "args": [
            "ext.arg"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic opt_apply wrap_stoul(unsigned long &ul) {\n  return [&ul](const client_options &, const client_options::extended_option &ext, memcached_st *) {\n    if (ext.arg && *ext.arg) {\n      auto c = std::stoul(ext.arg);\n      if (c) {\n        ul = c;\n      }\n    }\n    return true;\n  };\n}"
  },
  {
    "function_name": "execute",
    "container": "thread_context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "192-211",
    "snippet": "void execute() {\n    memcached_clone(&memc, &root);\n\n    while (!wakeup.load(std::memory_order_acquire)) {\n      std::this_thread::yield();\n    }\n\n    if (!strcmp(\"set\", opt.argof(\"test\"))) {\n      count = execute_set(opt, memc, kv);\n    } else if (!strcmp(\"mget\", opt.argof(\"test\"))) {\n      count = execute_mget(opt, memc, kv);\n    } else {\n      if (strcmp(\"get\", opt.argof(\"test\"))) {\n        if (!opt.isset(\"quiet\")) {\n          std::cerr << \"Unknown --test: '\" << opt.argof(\"test\") << \"'.\\n\";\n        }\n      }\n      count = execute_get(opt, memc, kv);\n    }\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static std::atomic_bool wakeup;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute_get",
          "args": [
            "opt",
            "memc",
            "kv"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "execute_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "100-115",
          "snippet": "static size_t execute_get(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  random64 rnd{};\n\n  for (auto i = 0u; i < kv.num; ++i) {\n    memcached_return_t rc;\n    auto r = rnd(0, kv.num);\n    free(memcached_get(&memc, kv.key.chr[r], kv.key.len[r], nullptr, nullptr, &rc));\n\n    if (check_return(opt, memc, kv.key.chr[r], rc)) {\n      ++retrieved;\n    }\n  }\n\n  return retrieved;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_get(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  random64 rnd{};\n\n  for (auto i = 0u; i < kv.num; ++i) {\n    memcached_return_t rc;\n    auto r = rnd(0, kv.num);\n    free(memcached_get(&memc, kv.key.chr[r], kv.key.len[r], nullptr, nullptr, &rc));\n\n    if (check_return(opt, memc, kv.key.chr[r], rc)) {\n      ++retrieved;\n    }\n  }\n\n  return retrieved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"get\"",
            "opt.argof(\"test\")"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute_mget",
          "args": [
            "opt",
            "memc",
            "kv"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "execute_mget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "117-149",
          "snippet": "static size_t execute_mget(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  memcached_execute_fn cb[] = {&counter};\n  memcached_return_t rc;\n\n  if (memcached_is_binary(&memc)) {\n    rc = memcached_mget_execute(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num, cb,\n                                     &retrieved, 1);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      rc = memcached_fetch_execute(&memc, cb, &retrieved, 1);\n    }\n  } else {\n    memcached_result_st res;\n    memcached_result_create(&memc, &res);\n\n    rc = memcached_mget(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      if (memcached_fetch_result(&memc, &res, &rc)) {\n        ++retrieved;\n      }\n    }\n    memcached_result_free(&res);\n  }\n  if (memcached_fatal(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed mget: \" << memcached_strerror(&memc, rc) << \": \"\n                << memcached_last_error_message(&memc);\n    }\n  }\n  return retrieved;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_mget(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  memcached_execute_fn cb[] = {&counter};\n  memcached_return_t rc;\n\n  if (memcached_is_binary(&memc)) {\n    rc = memcached_mget_execute(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num, cb,\n                                     &retrieved, 1);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      rc = memcached_fetch_execute(&memc, cb, &retrieved, 1);\n    }\n  } else {\n    memcached_result_st res;\n    memcached_result_create(&memc, &res);\n\n    rc = memcached_mget(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      if (memcached_fetch_result(&memc, &res, &rc)) {\n        ++retrieved;\n      }\n    }\n    memcached_result_free(&res);\n  }\n  if (memcached_fatal(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed mget: \" << memcached_strerror(&memc, rc) << \": \"\n                << memcached_last_error_message(&memc);\n    }\n  }\n  return retrieved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"mget\"",
            "opt.argof(\"test\")"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute_set",
          "args": [
            "opt",
            "memc",
            "kv"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "execute_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "151-162",
          "snippet": "static size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"set\"",
            "opt.argof(\"test\")"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"test\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::this_thread::yield",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup.load",
          "args": [
            "std::memory_order_acquire"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_clone",
          "args": [
            "&memc",
            "&root"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_clone_sasl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "470-472",
          "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic std::atomic_bool wakeup;\n\nthread_context {\n  void execute() {\n      memcached_clone(&memc, &root);\n  \n      while (!wakeup.load(std::memory_order_acquire)) {\n        std::this_thread::yield();\n      }\n  \n      if (!strcmp(\"set\", opt.argof(\"test\"))) {\n        count = execute_set(opt, memc, kv);\n      } else if (!strcmp(\"mget\", opt.argof(\"test\"))) {\n        count = execute_mget(opt, memc, kv);\n      } else {\n        if (strcmp(\"get\", opt.argof(\"test\"))) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << \"Unknown --test: '\" << opt.argof(\"test\") << \"'.\\n\";\n          }\n        }\n        count = execute_get(opt, memc, kv);\n      }\n    }\n}"
  },
  {
    "function_name": "complete",
    "container": "thread_context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "179-182",
    "snippet": "size_t complete() {\n    thread.join();\n    return count;\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread.join",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nthread_context {\n  size_t complete() {\n      thread.join();\n      return count;\n    }\n}"
  },
  {
    "function_name": "thread_context",
    "container": "thread_context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "166-173",
    "snippet": "thread_context(const client_options &opt_, const memcached_st &memc_, const keyval_st &kv_)\n  : opt{opt_}\n  , kv{kv_}\n  , count{}\n  , root(memc_)\n  , memc{}\n  , thread([this]{ execute(); })\n  {}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "execute",
          "container": "thread_context",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "192-211",
          "snippet": "void execute() {\n    memcached_clone(&memc, &root);\n\n    while (!wakeup.load(std::memory_order_acquire)) {\n      std::this_thread::yield();\n    }\n\n    if (!strcmp(\"set\", opt.argof(\"test\"))) {\n      count = execute_set(opt, memc, kv);\n    } else if (!strcmp(\"mget\", opt.argof(\"test\"))) {\n      count = execute_mget(opt, memc, kv);\n    } else {\n      if (strcmp(\"get\", opt.argof(\"test\"))) {\n        if (!opt.isset(\"quiet\")) {\n          std::cerr << \"Unknown --test: '\" << opt.argof(\"test\") << \"'.\\n\";\n        }\n      }\n      count = execute_get(opt, memc, kv);\n    }\n  }",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static std::atomic_bool wakeup;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic std::atomic_bool wakeup;\n\nthread_context {\n  void execute() {\n      memcached_clone(&memc, &root);\n  \n      while (!wakeup.load(std::memory_order_acquire)) {\n        std::this_thread::yield();\n      }\n  \n      if (!strcmp(\"set\", opt.argof(\"test\"))) {\n        count = execute_set(opt, memc, kv);\n      } else if (!strcmp(\"mget\", opt.argof(\"test\"))) {\n        count = execute_mget(opt, memc, kv);\n      } else {\n        if (strcmp(\"get\", opt.argof(\"test\"))) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << \"Unknown --test: '\" << opt.argof(\"test\") << \"'.\\n\";\n          }\n        }\n        count = execute_get(opt, memc, kv);\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nthread_context {\n  thread_context(const client_options &opt_, const memcached_st &memc_, const keyval_st &kv_)\n    : opt{opt_}\n    , kv{kv_}\n    , count{}\n    , root(memc_)\n    , memc{}\n    , thread([this]{ execute(); })\n    {}\n}"
  },
  {
    "function_name": "execute_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "151-162",
    "snippet": "static size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_quit",
          "args": [
            "&memc"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "109-117",
          "snippet": "void memcached_quit(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return;\n  }\n\n  send_quit(memc);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return;\n  }\n\n  send_quit(memc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_return",
          "args": [
            "opt",
            "memc",
            "kv.key.chr[i]",
            "rc"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "check_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "73-90",
          "snippet": "bool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set",
          "args": [
            "&memc",
            "kv.key.chr[i]",
            "kv.key.len[i]",
            "kv.val.chr[i]",
            "kv.val.len[i]",
            "0",
            "0"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "325-334",
          "snippet": "memcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_set(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  for (auto i = 0u; i < kv.num; ++i) {\n    auto rc = memcached_set(&memc, kv.key.chr[i], kv.key.len[i], kv.val.chr[i], kv.val.len[i], 0, 0);\n\n    if (!check_return(opt, memc, kv.key.chr[i], rc)) {\n      memcached_quit(&memc);\n      return i;\n    }\n  }\n\n  return kv.num;\n}"
  },
  {
    "function_name": "execute_mget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "117-149",
    "snippet": "static size_t execute_mget(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  memcached_execute_fn cb[] = {&counter};\n  memcached_return_t rc;\n\n  if (memcached_is_binary(&memc)) {\n    rc = memcached_mget_execute(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num, cb,\n                                     &retrieved, 1);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      rc = memcached_fetch_execute(&memc, cb, &retrieved, 1);\n    }\n  } else {\n    memcached_result_st res;\n    memcached_result_create(&memc, &res);\n\n    rc = memcached_mget(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      if (memcached_fetch_result(&memc, &res, &rc)) {\n        ++retrieved;\n      }\n    }\n    memcached_result_free(&res);\n  }\n  if (memcached_fatal(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed mget: \" << memcached_strerror(&memc, rc) << \": \"\n                << memcached_last_error_message(&memc);\n    }\n  }\n  return retrieved;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_free",
          "args": [
            "&res"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "66-82",
          "snippet": "void memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fetch_result",
          "args": [
            "&memc",
            "&res",
            "&rc"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_mget",
          "args": [
            "&memc",
            "kv.key.chr.data()",
            "kv.key.len.data()",
            "kv.num"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "126-129",
          "snippet": "memcached_return_t memcached_mget(memcached_st *ptr, const char *const *keys,\n                                  const size_t *key_length, size_t number_of_keys) {\n  return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget(memcached_st *ptr, const char *const *keys,\n                                  const size_t *key_length, size_t number_of_keys) {\n  return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kv.key.len.data",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kv.key.chr.data",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_create",
          "args": [
            "&memc",
            "&res"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fetch_execute",
          "args": [
            "&memc",
            "cb",
            "&retrieved",
            "1"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_fetch_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/fetch.cc",
          "lines": "200-237",
          "snippet": "memcached_return_t memcached_fetch_execute(memcached_st *shell, memcached_execute_fn *callback,\n                                           void *context, uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_result_st *result = &ptr->result;\n  memcached_return_t rc;\n  bool some_errors = false;\n\n  while ((result = memcached_fetch_result(ptr, result, &rc))) {\n    if (memcached_failed(rc) and rc == MEMCACHED_NOTFOUND) {\n      continue;\n    } else if (memcached_failed(rc)) {\n      memcached_set_error(*ptr, rc, MEMCACHED_AT);\n      some_errors = true;\n      continue;\n    }\n\n    for (uint32_t x = 0; x < number_of_callbacks; x++) {\n      memcached_return_t ret = (*callback[x])(ptr, result, context);\n      if (memcached_failed(ret)) {\n        some_errors = true;\n        memcached_set_error(*ptr, ret, MEMCACHED_AT);\n        break;\n      }\n    }\n  }\n\n  if (some_errors) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  // If we were able to run all keys without issue we return\n  // MEMCACHED_SUCCESS\n  if (memcached_success(rc)) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_fetch_execute(memcached_st *shell, memcached_execute_fn *callback,\n                                           void *context, uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_result_st *result = &ptr->result;\n  memcached_return_t rc;\n  bool some_errors = false;\n\n  while ((result = memcached_fetch_result(ptr, result, &rc))) {\n    if (memcached_failed(rc) and rc == MEMCACHED_NOTFOUND) {\n      continue;\n    } else if (memcached_failed(rc)) {\n      memcached_set_error(*ptr, rc, MEMCACHED_AT);\n      some_errors = true;\n      continue;\n    }\n\n    for (uint32_t x = 0; x < number_of_callbacks; x++) {\n      memcached_return_t ret = (*callback[x])(ptr, result, context);\n      if (memcached_failed(ret)) {\n        some_errors = true;\n        memcached_set_error(*ptr, ret, MEMCACHED_AT);\n        break;\n      }\n    }\n  }\n\n  if (some_errors) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  // If we were able to run all keys without issue we return\n  // MEMCACHED_SUCCESS\n  if (memcached_success(rc)) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_mget_execute",
          "args": [
            "&memc",
            "kv.key.chr.data()",
            "kv.key.len.data()",
            "kv.num",
            "cb",
            "&retrieved",
            "1"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mget_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "303-309",
          "snippet": "memcached_return_t memcached_mget_execute(memcached_st *ptr, const char *const *keys,\n                                          const size_t *key_length, size_t number_of_keys,\n                                          memcached_execute_fn *callback, void *context,\n                                          unsigned int number_of_callbacks) {\n  return memcached_mget_execute_by_key(ptr, NULL, 0, keys, key_length, number_of_keys, callback,\n                                       context, number_of_callbacks);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_execute(memcached_st *ptr, const char *const *keys,\n                                          const size_t *key_length, size_t number_of_keys,\n                                          memcached_execute_fn *callback, void *context,\n                                          unsigned int number_of_callbacks) {\n  return memcached_mget_execute_by_key(ptr, NULL, 0, keys, key_length, number_of_keys, callback,\n                                       context, number_of_callbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kv.key.len.data",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kv.key.chr.data",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "&memc"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_mget(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  memcached_execute_fn cb[] = {&counter};\n  memcached_return_t rc;\n\n  if (memcached_is_binary(&memc)) {\n    rc = memcached_mget_execute(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num, cb,\n                                     &retrieved, 1);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      rc = memcached_fetch_execute(&memc, cb, &retrieved, 1);\n    }\n  } else {\n    memcached_result_st res;\n    memcached_result_create(&memc, &res);\n\n    rc = memcached_mget(&memc, kv.key.chr.data(), kv.key.len.data(), kv.num);\n\n    while (rc != MEMCACHED_END && memcached_success(rc)) {\n      if (memcached_fetch_result(&memc, &res, &rc)) {\n        ++retrieved;\n      }\n    }\n    memcached_result_free(&res);\n  }\n  if (memcached_fatal(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed mget: \" << memcached_strerror(&memc, rc) << \": \"\n                << memcached_last_error_message(&memc);\n    }\n  }\n  return retrieved;\n}"
  },
  {
    "function_name": "execute_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "100-115",
    "snippet": "static size_t execute_get(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  random64 rnd{};\n\n  for (auto i = 0u; i < kv.num; ++i) {\n    memcached_return_t rc;\n    auto r = rnd(0, kv.num);\n    free(memcached_get(&memc, kv.key.chr[r], kv.key.len[r], nullptr, nullptr, &rc));\n\n    if (check_return(opt, memc, kv.key.chr[r], rc)) {\n      ++retrieved;\n    }\n  }\n\n  return retrieved;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_return",
          "args": [
            "opt",
            "memc",
            "kv.key.chr[r]",
            "rc"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "check_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "73-90",
          "snippet": "bool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "memcached_get(&memc, kv.key.chr[r], kv.key.len[r], nullptr, nullptr, &rc)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "aes_free_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/aes.cc",
          "lines": "286-290",
          "snippet": "void aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}",
          "includes": [
            "#  include \"libhashkit/rijndael.hpp\"",
            "#include <openssl/evp.h>",
            "#include <cstring>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"libhashkit/rijndael.hpp\"\n#include <openssl/evp.h>\n#include <cstring>\n#include \"libhashkit/common.h\"\n\nvoid aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_get",
          "args": [
            "&memc",
            "kv.key.chr[r]",
            "kv.key.len[r]",
            "nullptr",
            "nullptr",
            "&rc"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnd",
          "args": [
            "0",
            "kv.num"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic size_t execute_get(const client_options &opt, memcached_st &memc, const keyval_st &kv) {\n  size_t retrieved = 0;\n  random64 rnd{};\n\n  for (auto i = 0u; i < kv.num; ++i) {\n    memcached_return_t rc;\n    auto r = rnd(0, kv.num);\n    free(memcached_get(&memc, kv.key.chr[r], kv.key.len[r], nullptr, nullptr, &rc));\n\n    if (check_return(opt, memc, kv.key.chr[r], rc)) {\n      ++retrieved;\n    }\n  }\n\n  return retrieved;\n}"
  },
  {
    "function_name": "gen",
    "container": "keyval_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "94-97",
    "snippet": "void gen(char *&key_chr, size_t &key_len, char *&val_chr, size_t &val_len) {\n    gen_key(key_chr, key_len);\n    gen_val(key_chr, key_len, val_chr, val_len);\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gen_val",
          "args": [
            "key_chr",
            "key_len",
            "val_chr",
            "val_len"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "gen_val",
          "container": "keyval_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "84-93",
          "snippet": "void gen_val(const char *key_chr, const size_t key_len, char *&val_chr, size_t &val_len) {\n    val_len = rnd(50, 5000);\n    val_chr = new char[val_len];\n\n    for (auto len = 0u; len < val_len; len += key_len) {\n      auto val_pos = val_chr + len;\n      auto rem_len = len + key_len > val_len ? val_len % key_len : key_len;\n      memcpy(val_pos, key_chr, rem_len);\n    }\n  }",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen_val(const char *key_chr, const size_t key_len, char *&val_chr, size_t &val_len) {\n      val_len = rnd(50, 5000);\n      val_chr = new char[val_len];\n  \n      for (auto len = 0u; len < val_len; len += key_len) {\n        auto val_pos = val_chr + len;\n        auto rem_len = len + key_len > val_len ? val_len % key_len : key_len;\n        memcpy(val_pos, key_chr, rem_len);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_key",
          "args": [
            "key_chr",
            "key_len"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "gen_key",
          "container": "keyval_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "78-83",
          "snippet": "void gen_key(char *&key_chr, size_t &key_len) {\n    key_len = rnd(20,60);\n    key_chr = new char[key_len + 1];\n    rnd.fill(key_chr, key_len);\n    key_chr[key_len] = 0;\n  }",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen_key(char *&key_chr, size_t &key_len) {\n      key_len = rnd(20,60);\n      key_chr = new char[key_len + 1];\n      rnd.fill(key_chr, key_len);\n      key_chr[key_len] = 0;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen(char *&key_chr, size_t &key_len, char *&val_chr, size_t &val_len) {\n      gen_key(key_chr, key_len);\n      gen_val(key_chr, key_len, val_chr, val_len);\n    }\n}"
  },
  {
    "function_name": "gen_val",
    "container": "keyval_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "84-93",
    "snippet": "void gen_val(const char *key_chr, const size_t key_len, char *&val_chr, size_t &val_len) {\n    val_len = rnd(50, 5000);\n    val_chr = new char[val_len];\n\n    for (auto len = 0u; len < val_len; len += key_len) {\n      auto val_pos = val_chr + len;\n      auto rem_len = len + key_len > val_len ? val_len % key_len : key_len;\n      memcpy(val_pos, key_chr, rem_len);\n    }\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val_pos",
            "key_chr",
            "rem_len"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnd",
          "args": [
            "50",
            "5000"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen_val(const char *key_chr, const size_t key_len, char *&val_chr, size_t &val_len) {\n      val_len = rnd(50, 5000);\n      val_chr = new char[val_len];\n  \n      for (auto len = 0u; len < val_len; len += key_len) {\n        auto val_pos = val_chr + len;\n        auto rem_len = len + key_len > val_len ? val_len % key_len : key_len;\n        memcpy(val_pos, key_chr, rem_len);\n      }\n    }\n}"
  },
  {
    "function_name": "gen_key",
    "container": "keyval_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "78-83",
    "snippet": "void gen_key(char *&key_chr, size_t &key_len) {\n    key_len = rnd(20,60);\n    key_chr = new char[key_len + 1];\n    rnd.fill(key_chr, key_len);\n    key_chr[key_len] = 0;\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd.fill",
          "args": [
            "key_chr",
            "key_len"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "fill",
          "container": "random64",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/random.hpp",
          "lines": "35-40",
          "snippet": "void fill(char *buf, size_t len,\n      const std::string &set = \"0123456789ABCDEFGHIJKLMNOPQRSTWXYZabcdefghijklmnopqrstuvwxyz\") {\n    for (auto i = 0ul; i < len; ++i) {\n      buf[i] = set[(*this)(0, set.length()-1)];\n    }\n  }",
          "includes": [
            "#include <random>",
            "#include \"time.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <random>\n#include \"time.hpp\"\n\nrandom64 {\n  void fill(char *buf, size_t len,\n        const std::string &set = \"0123456789ABCDEFGHIJKLMNOPQRSTWXYZabcdefghijklmnopqrstuvwxyz\") {\n      for (auto i = 0ul; i < len; ++i) {\n        buf[i] = set[(*this)(0, set.length()-1)];\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rnd",
          "args": [
            "20",
            "60"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen_key(char *&key_chr, size_t &key_len) {\n      key_len = rnd(20,60);\n      key_chr = new char[key_len + 1];\n      rnd.fill(key_chr, key_len);\n      key_chr[key_len] = 0;\n    }\n}"
  },
  {
    "function_name": "keyval_st",
    "container": "keyval_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "59-68",
    "snippet": "explicit keyval_st(size_t num_)\n  : key{num_}\n  , val{num_}\n  , num{num_}\n  , rnd{}\n  {\n    for (auto i = 0u; i < num; ++i) {\n      gen(key.chr[i], key.len[i], val.chr[i], val.len[i]);\n    }\n  }",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gen",
          "args": [
            "key.chr[i]",
            "key.len[i]",
            "val.chr[i]",
            "val.len[i]"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "gen",
          "container": "keyval_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
          "lines": "94-97",
          "snippet": "void gen(char *&key_chr, size_t &key_len, char *&val_chr, size_t &val_len) {\n    gen_key(key_chr, key_len);\n    gen_val(key_chr, key_len, val_chr, val_len);\n  }",
          "includes": [
            "#include <iomanip>",
            "#include <thread>",
            "#include <atomic>",
            "#include \"common/random.hpp\"",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  void gen(char *&key_chr, size_t &key_len, char *&val_chr, size_t &val_len) {\n      gen_key(key_chr, key_len);\n      gen_val(key_chr, key_len, val_chr, val_len);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  explicit keyval_st(size_t num_)\n    : key{num_}\n    , val{num_}\n    , num{num_}\n    , rnd{}\n    {\n      for (auto i = 0u; i < num; ++i) {\n        gen(key.chr[i], key.len[i], val.chr[i], val.len[i]);\n      }\n    }\n}"
  },
  {
    "function_name": "data",
    "container": "keyval_st::data",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "47-50",
    "snippet": "explicit data(size_t num)\n        : chr(num)\n        , len(num)\n    {}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nkeyval_st {\n  data {\n    explicit data(size_t num)\n            : chr(num)\n            , len(num)\n        {}\n  }\n}"
  },
  {
    "function_name": "counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memslap.cc",
    "lines": "37-41",
    "snippet": "static memcached_return_t counter(const memcached_st *, memcached_result_st *, void *ctx) {\n  auto c = static_cast<size_t *>(ctx);\n  ++(*c);\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <thread>",
      "#include <atomic>",
      "#include \"common/random.hpp\"",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<size_t *>",
          "args": [
            "ctx"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <thread>\n#include <atomic>\n#include \"common/random.hpp\"\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic memcached_return_t counter(const memcached_st *, memcached_result_st *, void *ctx) {\n  auto c = static_cast<size_t *>(ctx);\n  ++(*c);\n  return MEMCACHED_SUCCESS;\n}"
  }
]