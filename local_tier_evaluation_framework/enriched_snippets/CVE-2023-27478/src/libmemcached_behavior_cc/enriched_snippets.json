[
  {
    "function_name": "memcached_bucket_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "688-717",
    "snippet": "memcached_return_t memcached_bucket_set(memcached_st *shell, const uint32_t *host_map,\n                                        const uint32_t *forward_map, const uint32_t buckets,\n                                        const uint32_t replicas) {\n  Memcached *self = memcached2Memcached(shell);\n  memcached_return_t rc;\n\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (host_map == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_server_distribution_t old = memcached_behavior_get_distribution(self);\n\n  if (memcached_failed(\n          rc = memcached_behavior_set_distribution(self, MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET)))\n  {\n    return rc;\n  }\n\n  if (memcached_failed(\n          rc = memcached_virtual_bucket_create(self, host_map, forward_map, buckets, replicas)))\n  {\n    memcached_behavior_set_distribution(self, old);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_behavior_set_distribution",
          "args": [
            "self",
            "old"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set_distribution_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "556-571",
          "snippet": "memcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_virtual_bucket_create(self, host_map, forward_map, buckets, replicas)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_virtual_bucket_create",
          "args": [
            "self",
            "host_map",
            "forward_map",
            "buckets",
            "replicas"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_virtual_bucket_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/virtual_bucket.cc",
          "lines": "31-63",
          "snippet": "memcached_return_t memcached_virtual_bucket_create(memcached_st *self, const uint32_t *host_map,\n                                                   const uint32_t *forward_map,\n                                                   const uint32_t buckets,\n                                                   const uint32_t replicas) {\n  if (self == NULL || host_map == NULL || buckets == 0U) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_virtual_bucket_free(self);\n\n  struct memcached_virtual_bucket_t *virtual_bucket = (struct memcached_virtual_bucket_t *) malloc(\n      sizeof(struct memcached_virtual_bucket_t) + sizeof(struct bucket_t) * buckets);\n\n  if (virtual_bucket == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  virtual_bucket->size = buckets;\n  virtual_bucket->replicas = replicas;\n  self->virtual_bucket = virtual_bucket;\n\n  uint32_t x = 0;\n  for (; x < buckets; x++) {\n    virtual_bucket->buckets[x].master = host_map[x];\n    if (forward_map) {\n      virtual_bucket->buckets[x].forward = forward_map[x];\n    } else {\n      virtual_bucket->buckets[x].forward = 0;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_virtual_bucket_create(memcached_st *self, const uint32_t *host_map,\n                                                   const uint32_t *forward_map,\n                                                   const uint32_t buckets,\n                                                   const uint32_t replicas) {\n  if (self == NULL || host_map == NULL || buckets == 0U) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_virtual_bucket_free(self);\n\n  struct memcached_virtual_bucket_t *virtual_bucket = (struct memcached_virtual_bucket_t *) malloc(\n      sizeof(struct memcached_virtual_bucket_t) + sizeof(struct bucket_t) * buckets);\n\n  if (virtual_bucket == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  virtual_bucket->size = buckets;\n  virtual_bucket->replicas = replicas;\n  self->virtual_bucket = virtual_bucket;\n\n  uint32_t x = 0;\n  for (; x < buckets; x++) {\n    virtual_bucket->buckets[x].master = host_map[x];\n    if (forward_map) {\n      virtual_bucket->buckets[x].forward = forward_map[x];\n    } else {\n      virtual_bucket->buckets[x].forward = 0;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_behavior_set_distribution(self, MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_get_distribution",
          "args": [
            "self"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_get_distribution_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "573-580",
          "snippet": "memcached_hash_t memcached_behavior_get_distribution_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_hash_t memcached_behavior_get_distribution_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_bucket_set(memcached_st *shell, const uint32_t *host_map,\n                                        const uint32_t *forward_map, const uint32_t buckets,\n                                        const uint32_t replicas) {\n  Memcached *self = memcached2Memcached(shell);\n  memcached_return_t rc;\n\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (host_map == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_server_distribution_t old = memcached_behavior_get_distribution(self);\n\n  if (memcached_failed(\n          rc = memcached_behavior_set_distribution(self, MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET)))\n  {\n    return rc;\n  }\n\n  if (memcached_failed(\n          rc = memcached_virtual_bucket_create(self, host_map, forward_map, buckets, replicas)))\n  {\n    memcached_behavior_set_distribution(self, old);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_behavior_get_distribution_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "573-580",
    "snippet": "memcached_hash_t memcached_behavior_get_distribution_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashkit_get_function",
          "args": [
            "&ptr->hashkit"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "167-173",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_hash_t memcached_behavior_get_distribution_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}"
  },
  {
    "function_name": "memcached_behavior_set_distribution_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "556-571",
    "snippet": "memcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid memcached_hash_t()\")"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid memcached_hash_t()\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_success",
          "args": [
            "hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_set_distribution_function",
          "args": [
            "&ptr->hashkit",
            "(hashkit_hash_algorithm_t) type"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_set_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "100-103",
          "snippet": "hashkit_return_t hashkit_set_distribution_function(hashkit_st *self,\n                                                   hashkit_hash_algorithm_t hash_algorithm) {\n  return _set_function(&self->distribution_hash, hash_algorithm);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_return_t hashkit_set_distribution_function(hashkit_st *self,\n                                                   hashkit_hash_algorithm_t hash_algorithm) {\n  return _set_function(&self->distribution_hash, hash_algorithm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_behavior_get_key_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "547-554",
    "snippet": "memcached_hash_t memcached_behavior_get_key_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashkit_get_function",
          "args": [
            "&ptr->hashkit"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "167-173",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_hash_t memcached_behavior_get_key_hash(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return (memcached_hash_t) hashkit_get_function(&ptr->hashkit);\n  }\n\n  return MEMCACHED_HASH_MAX;\n}"
  },
  {
    "function_name": "memcached_behavior_set_key_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "533-545",
    "snippet": "memcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid memcached_hash_t()\")"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid memcached_hash_t()\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_success",
          "args": [
            "hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_set_function",
          "args": [
            "&ptr->hashkit",
            "(hashkit_hash_algorithm_t) type"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_set_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "96-98",
          "snippet": "hashkit_return_t hashkit_set_function(hashkit_st *self, hashkit_hash_algorithm_t hash_algorithm) {\n  return _set_function(&self->base_hash, hash_algorithm);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_return_t hashkit_set_function(hashkit_st *self, hashkit_hash_algorithm_t hash_algorithm) {\n  return _set_function(&self->base_hash, hash_algorithm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_behavior_get_distribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "524-531",
    "snippet": "memcached_server_distribution_t memcached_behavior_get_distribution(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return ptr->distribution;\n  }\n\n  return MEMCACHED_DISTRIBUTION_CONSISTENT_MAX;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_server_distribution_t memcached_behavior_get_distribution(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return ptr->distribution;\n  }\n\n  return MEMCACHED_DISTRIBUTION_CONSISTENT_MAX;\n}"
  },
  {
    "function_name": "memcached_behavior_set_distribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "484-522",
    "snippet": "memcached_return_t memcached_behavior_set_distribution(memcached_st *shell,\n                                                       memcached_server_distribution_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    switch (type) {\n    case MEMCACHED_DISTRIBUTION_MODULA:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT:\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n      memcached_set_weighted_ketama(ptr, false);\n      break;\n\n    case MEMCACHED_DISTRIBUTION_RANDOM:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n      memcached_set_weighted_ketama(ptr, true);\n      break;\n\n    case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n      break;\n\n    default:\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"Invalid memcached_server_distribution_t\"));\n    }\n    ptr->distribution = type;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "ptr"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid memcached_server_distribution_t\")"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid memcached_server_distribution_t\""
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_weighted_ketama",
          "args": [
            "ptr",
            "true"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_weighted_ketama",
          "args": [
            "ptr",
            "false"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_distribution(memcached_st *shell,\n                                                       memcached_server_distribution_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    switch (type) {\n    case MEMCACHED_DISTRIBUTION_MODULA:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT:\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n      memcached_set_weighted_ketama(ptr, false);\n      break;\n\n    case MEMCACHED_DISTRIBUTION_RANDOM:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n      break;\n\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n      memcached_set_weighted_ketama(ptr, true);\n      break;\n\n    case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n      break;\n\n    default:\n    case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"Invalid memcached_server_distribution_t\"));\n    }\n    ptr->distribution = type;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_behavior_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "288-482",
    "snippet": "uint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "0",
            "\"Invalid behavior passed to memcached_behavior_get()\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "memcached_parse_filename(ptr)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_parse_filename",
          "args": [
            "ptr"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_filename_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "26-28",
          "snippet": "size_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nsize_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_DEPRECATED",
            "MEMCACHED_AT",
            "memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\")"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*ptr",
            "get_socket_errno()",
            "MEMCACHED_AT"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "instance->fd",
            "SOL_SOCKET",
            "SO_RCVBUF",
            "(char *) &sock_size",
            "&sock_length"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_io_wait_for_write(instance)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_wait_for_write",
          "args": [
            "instance"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_wait_for_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "364-366",
          "snippet": "memcached_return_t memcached_io_wait_for_write(memcached_instance_st *instance) {\n  return io_wait(instance, POLLOUT);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_wait_for_write(memcached_instance_st *instance) {\n  return io_wait(instance, POLLOUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_connect(instance)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_connect",
          "args": [
            "instance"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "598-600",
          "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "0"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "instance->fd",
            "SOL_SOCKET",
            "SO_SNDBUF",
            "(char *) &sock_size",
            "&sock_length"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_io_wait_for_write(instance)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_connect(instance)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "0"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint64_t",
          "args": [
            "ptr->dead_timeout"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_get_distribution_function",
          "args": [
            "&ptr->hashkit"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "175-181",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashkit_get_function",
          "args": [
            "&ptr->hashkit"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "167-173",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->base_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_consistent_distribution",
          "args": [
            "ptr"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_is_consistent_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "24-40",
          "snippet": "bool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "ptr"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}"
  },
  {
    "function_name": "_is_auto_eject_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "284-286",
    "snippet": "bool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}"
  },
  {
    "function_name": "memcached_behavior_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "48-282",
    "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\")"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid behavior passed to memcached_behavior_set()\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "0",
            "\"Invalid behavior passed to memcached_behavior_set()\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srandom",
          "args": [
            "(uint32_t) time(NULL)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mark_server_for_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "44-67",
          "snippet": "static inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [
            "void memcached_instance_free(memcached_instance_st *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nvoid memcached_instance_free(memcached_instance_st *);\n\nstatic inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "ptr"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_quit",
          "args": [
            "ptr"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "send_quit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "101-107",
          "snippet": "void send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "int32_t",
          "args": [
            "data"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int32_t",
          "args": [
            "data"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "ptr"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set_distribution_hash",
          "args": [
            "ptr",
            "(memcached_hash_t)(data)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set_distribution_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "556-571",
          "snippet": "memcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_distribution_hash(memcached_st *shell,\n                                                            memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(\n            hashkit_set_distribution_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type)))\n    {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set_key_hash",
          "args": [
            "ptr",
            "(memcached_hash_t)(data)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set_key_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "533-545",
          "snippet": "memcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "ptr",
            "MEMCACHED_BEHAVIOR_KETAMA",
            "true"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "ptr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "data"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "data"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "data"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_is_consistent_distribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
    "lines": "24-40",
    "snippet": "bool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <ctime>",
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}"
  }
]