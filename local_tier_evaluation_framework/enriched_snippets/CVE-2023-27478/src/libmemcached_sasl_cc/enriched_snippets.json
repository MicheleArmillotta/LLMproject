[
  {
    "function_name": "memcached_sasl_authenticate_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "478-480",
    "snippet": "memcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "memcached_destroy_sasl_auth_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "474-476",
    "snippet": "memcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "memcached_clone_sasl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "470-472",
    "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "memcached_set_sasl_auth_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "466-468",
    "snippet": "memcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
  },
  {
    "function_name": "memcached_set_sasl_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "460-460",
    "snippet": "void memcached_set_sasl_callbacks(memcached_st *, const sasl_callback_t *) {}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nvoid memcached_set_sasl_callbacks(memcached_st *, const sasl_callback_t *) {}"
  },
  {
    "function_name": "memcached_clone_sasl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "364-456",
    "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *clone, const memcached_st *source) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (clone == NULL or source == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (source->sasl.callbacks == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  /* Hopefully we are using our own callback mechanisms.. */\n  if (source->sasl.callbacks[0].id == SASL_CB_USER\n      && source->sasl.callbacks[0].proc == CAST_SASL_CB(get_username)\n      && source->sasl.callbacks[1].id == SASL_CB_AUTHNAME\n      && source->sasl.callbacks[1].proc == CAST_SASL_CB(get_username)\n      && source->sasl.callbacks[2].id == SASL_CB_PASS\n      && source->sasl.callbacks[2].proc == CAST_SASL_CB(get_password)\n      && source->sasl.callbacks[3].id == SASL_CB_LIST_END)\n  {\n    sasl_secret_t *secret = (sasl_secret_t *) source->sasl.callbacks[2].context;\n    return memcached_set_sasl_auth_data(clone, (const char *) source->sasl.callbacks[0].context,\n                                        (const char *) secret->data);\n  }\n\n  /*\n   * But we're not. It may work if we know what the user tries to pass\n   * into the list, but if we don't know the ID we don't know how to handle\n   * the context...\n   */\n  ptrdiff_t total = 0;\n\n  while (source->sasl.callbacks[total].id != SASL_CB_LIST_END) {\n    switch (source->sasl.callbacks[total].id) {\n    case SASL_CB_USER:\n    case SASL_CB_AUTHNAME:\n    case SASL_CB_PASS:\n      break;\n    default:\n      /* I don't know how to deal with this... */\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    ++total;\n  }\n\n  sasl_callback_t *callbacks = libmemcached_xcalloc(clone, total + 1, sasl_callback_t);\n  if (callbacks == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n  memcpy(callbacks, source->sasl.callbacks, (total + 1) * sizeof(sasl_callback_t));\n\n  /* Now update the context... */\n  for (ptrdiff_t x = 0; x < total; ++x) {\n    if (callbacks[x].id == SASL_CB_USER || callbacks[x].id == SASL_CB_AUTHNAME) {\n      callbacks[x].context = (sasl_callback_t *) libmemcached_malloc(\n          clone, strlen((const char *) source->sasl.callbacks[x].context));\n\n      if (callbacks[x].context == NULL) {\n        /* Failed to allocate memory, clean up previously allocated memory */\n        for (ptrdiff_t y = 0; y < x; ++y) {\n          libmemcached_free(clone, clone->sasl.callbacks[y].context);\n        }\n\n        libmemcached_free(clone, callbacks);\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n      strncpy((char *) callbacks[x].context, (const char *) source->sasl.callbacks[x].context,\n              sizeof(callbacks[x].context));\n    } else {\n      sasl_secret_t *src = (sasl_secret_t *) source->sasl.callbacks[x].context;\n      sasl_secret_t *n = (sasl_secret_t *) libmemcached_malloc(clone, src->len + 1 + sizeof(*n));\n      if (n == NULL) {\n        /* Failed to allocate memory, clean up previously allocated memory */\n        for (ptrdiff_t y = 0; y < x; ++y) {\n          libmemcached_free(clone, clone->sasl.callbacks[y].context);\n        }\n\n        libmemcached_free(clone, callbacks);\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n      memcpy(n, src, src->len + 1 + sizeof(*n));\n      callbacks[x].context = n;\n    }\n  }\n\n  clone->sasl.callbacks = callbacks;\n  clone->sasl.is_allocated = true;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n",
            "src",
            "src->len + 1 + sizeof(*n)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "clone",
            "callbacks"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_malloc",
          "args": [
            "clone",
            "src->len + 1 + sizeof(*n)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "(char *) callbacks[x].context",
            "(const char *) source->sasl.callbacks[x].context",
            "sizeof(callbacks[x].context)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_malloc",
          "args": [
            "clone",
            "strlen((const char *) source->sasl.callbacks[x].context)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(const char *) source->sasl.callbacks[x].context"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "callbacks",
            "source->sasl.callbacks",
            "(total + 1) * sizeof(sasl_callback_t)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_xcalloc",
          "args": [
            "clone",
            "total + 1",
            "sasl_callback_t"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_sasl_auth_data",
          "args": [
            "clone",
            "(const char *) source->sasl.callbacks[0].context",
            "(const char *) secret->data"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_sasl_auth_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "466-468",
          "snippet": "memcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_password"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_username"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_username"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *clone, const memcached_st *source) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (clone == NULL or source == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (source->sasl.callbacks == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  /* Hopefully we are using our own callback mechanisms.. */\n  if (source->sasl.callbacks[0].id == SASL_CB_USER\n      && source->sasl.callbacks[0].proc == CAST_SASL_CB(get_username)\n      && source->sasl.callbacks[1].id == SASL_CB_AUTHNAME\n      && source->sasl.callbacks[1].proc == CAST_SASL_CB(get_username)\n      && source->sasl.callbacks[2].id == SASL_CB_PASS\n      && source->sasl.callbacks[2].proc == CAST_SASL_CB(get_password)\n      && source->sasl.callbacks[3].id == SASL_CB_LIST_END)\n  {\n    sasl_secret_t *secret = (sasl_secret_t *) source->sasl.callbacks[2].context;\n    return memcached_set_sasl_auth_data(clone, (const char *) source->sasl.callbacks[0].context,\n                                        (const char *) secret->data);\n  }\n\n  /*\n   * But we're not. It may work if we know what the user tries to pass\n   * into the list, but if we don't know the ID we don't know how to handle\n   * the context...\n   */\n  ptrdiff_t total = 0;\n\n  while (source->sasl.callbacks[total].id != SASL_CB_LIST_END) {\n    switch (source->sasl.callbacks[total].id) {\n    case SASL_CB_USER:\n    case SASL_CB_AUTHNAME:\n    case SASL_CB_PASS:\n      break;\n    default:\n      /* I don't know how to deal with this... */\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    ++total;\n  }\n\n  sasl_callback_t *callbacks = libmemcached_xcalloc(clone, total + 1, sasl_callback_t);\n  if (callbacks == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n  memcpy(callbacks, source->sasl.callbacks, (total + 1) * sizeof(sasl_callback_t));\n\n  /* Now update the context... */\n  for (ptrdiff_t x = 0; x < total; ++x) {\n    if (callbacks[x].id == SASL_CB_USER || callbacks[x].id == SASL_CB_AUTHNAME) {\n      callbacks[x].context = (sasl_callback_t *) libmemcached_malloc(\n          clone, strlen((const char *) source->sasl.callbacks[x].context));\n\n      if (callbacks[x].context == NULL) {\n        /* Failed to allocate memory, clean up previously allocated memory */\n        for (ptrdiff_t y = 0; y < x; ++y) {\n          libmemcached_free(clone, clone->sasl.callbacks[y].context);\n        }\n\n        libmemcached_free(clone, callbacks);\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n      strncpy((char *) callbacks[x].context, (const char *) source->sasl.callbacks[x].context,\n              sizeof(callbacks[x].context));\n    } else {\n      sasl_secret_t *src = (sasl_secret_t *) source->sasl.callbacks[x].context;\n      sasl_secret_t *n = (sasl_secret_t *) libmemcached_malloc(clone, src->len + 1 + sizeof(*n));\n      if (n == NULL) {\n        /* Failed to allocate memory, clean up previously allocated memory */\n        for (ptrdiff_t y = 0; y < x; ++y) {\n          libmemcached_free(clone, clone->sasl.callbacks[y].context);\n        }\n\n        libmemcached_free(clone, callbacks);\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n      memcpy(n, src, src->len + 1 + sizeof(*n));\n      callbacks[x].context = n;\n    }\n  }\n\n  clone->sasl.callbacks = callbacks;\n  clone->sasl.is_allocated = true;\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_destroy_sasl_auth_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "338-362",
    "snippet": "memcached_return_t memcached_destroy_sasl_auth_data(memcached_st *shell) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->sasl.callbacks == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  if (ptr->sasl.is_allocated) {\n    libmemcached_free(ptr, ptr->sasl.callbacks[0].context);\n    libmemcached_free(ptr, ptr->sasl.callbacks[2].context);\n    libmemcached_free(ptr, (void *) ptr->sasl.callbacks);\n    ptr->sasl.is_allocated = false;\n  }\n\n  ptr->sasl.callbacks = NULL;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "ptr",
            "(void *) ptr->sasl.callbacks"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_destroy_sasl_auth_data(memcached_st *shell) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->sasl.callbacks == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  if (ptr->sasl.is_allocated) {\n    libmemcached_free(ptr, ptr->sasl.callbacks[0].context);\n    libmemcached_free(ptr, ptr->sasl.callbacks[2].context);\n    libmemcached_free(ptr, (void *) ptr->sasl.callbacks);\n    ptr->sasl.is_allocated = false;\n  }\n\n  ptr->sasl.callbacks = NULL;\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_set_sasl_auth_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "283-336",
    "snippet": "memcached_return_t memcached_set_sasl_auth_data(memcached_st *shell, const char *username,\n                                                const char *password) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (ptr == NULL or username == NULL or password == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t ret;\n  if (memcached_failed(ret = memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, 1))) {\n    return memcached_set_error(\n        *ptr, ret, MEMCACHED_AT,\n        memcached_literal_param(\"Unable change to binary protocol which is required for SASL.\"));\n  }\n\n  memcached_destroy_sasl_auth_data(ptr);\n\n  sasl_callback_t *callbacks = libmemcached_xcalloc(ptr, 4, sasl_callback_t);\n  size_t password_length = strlen(password);\n  size_t username_length = strlen(username);\n  char *name = (char *) libmemcached_malloc(ptr, username_length + 1);\n  sasl_secret_t *secret =\n      (sasl_secret_t *) libmemcached_malloc(ptr, password_length + 1 + sizeof(sasl_secret_t));\n\n  if (callbacks == NULL or name == NULL or secret == NULL) {\n    libmemcached_free(ptr, callbacks);\n    libmemcached_free(ptr, name);\n    libmemcached_free(ptr, secret);\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  secret->len = password_length;\n  memcpy(secret->data, password, password_length);\n  secret->data[password_length] = 0;\n\n  callbacks[0].id = SASL_CB_USER;\n  callbacks[0].proc = CAST_SASL_CB(get_username);\n  callbacks[0].context = strncpy(name, username, username_length + 1);\n  callbacks[1].id = SASL_CB_AUTHNAME;\n  callbacks[1].proc = CAST_SASL_CB(get_username);\n  callbacks[1].context = name;\n  callbacks[2].id = SASL_CB_PASS;\n  callbacks[2].proc = CAST_SASL_CB(get_password);\n  callbacks[2].context = secret;\n  callbacks[3].id = SASL_CB_LIST_END;\n\n  ptr->sasl.callbacks = callbacks;\n  ptr->sasl.is_allocated = true;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_password"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_username"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "name",
            "username",
            "username_length + 1"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAST_SASL_CB",
          "args": [
            "get_username"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "secret->data",
            "password",
            "password_length"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "ptr",
            "secret"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_malloc",
          "args": [
            "ptr",
            "password_length + 1 + sizeof(sasl_secret_t)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_malloc",
          "args": [
            "ptr",
            "username_length + 1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "username"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_xcalloc",
          "args": [
            "ptr",
            "4",
            "sasl_callback_t"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_destroy_sasl_auth_data",
          "args": [
            "ptr"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_destroy_sasl_auth_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "474-476",
          "snippet": "memcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Unable change to binary protocol which is required for SASL.\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "ret = memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, 1)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "ptr",
            "MEMCACHED_BEHAVIOR_BINARY_PROTOCOL",
            "1"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_sasl_auth_data(memcached_st *shell, const char *username,\n                                                const char *password) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (ptr == NULL or username == NULL or password == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t ret;\n  if (memcached_failed(ret = memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, 1))) {\n    return memcached_set_error(\n        *ptr, ret, MEMCACHED_AT,\n        memcached_literal_param(\"Unable change to binary protocol which is required for SASL.\"));\n  }\n\n  memcached_destroy_sasl_auth_data(ptr);\n\n  sasl_callback_t *callbacks = libmemcached_xcalloc(ptr, 4, sasl_callback_t);\n  size_t password_length = strlen(password);\n  size_t username_length = strlen(username);\n  char *name = (char *) libmemcached_malloc(ptr, username_length + 1);\n  sasl_secret_t *secret =\n      (sasl_secret_t *) libmemcached_malloc(ptr, password_length + 1 + sizeof(sasl_secret_t));\n\n  if (callbacks == NULL or name == NULL or secret == NULL) {\n    libmemcached_free(ptr, callbacks);\n    libmemcached_free(ptr, name);\n    libmemcached_free(ptr, secret);\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  secret->len = password_length;\n  memcpy(secret->data, password, password_length);\n  secret->data[password_length] = 0;\n\n  callbacks[0].id = SASL_CB_USER;\n  callbacks[0].proc = CAST_SASL_CB(get_username);\n  callbacks[0].context = strncpy(name, username, username_length + 1);\n  callbacks[1].id = SASL_CB_AUTHNAME;\n  callbacks[1].proc = CAST_SASL_CB(get_username);\n  callbacks[1].context = name;\n  callbacks[2].id = SASL_CB_PASS;\n  callbacks[2].proc = CAST_SASL_CB(get_password);\n  callbacks[2].context = secret;\n  callbacks[3].id = SASL_CB_LIST_END;\n\n  ptr->sasl.callbacks = callbacks;\n  ptr->sasl.is_allocated = true;\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "get_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "273-281",
    "snippet": "static int get_password(sasl_conn_t *conn, void *context, int id, sasl_secret_t **psecret) {\n  if (!conn || !psecret || id != SASL_CB_PASS) {\n    return SASL_BADPARAM;\n  }\n\n  *psecret = (sasl_secret_t *) context;\n\n  return SASL_OK;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic int get_password(sasl_conn_t *conn, void *context, int id, sasl_secret_t **psecret) {\n  if (!conn || !psecret || id != SASL_CB_PASS) {\n    return SASL_BADPARAM;\n  }\n\n  *psecret = (sasl_secret_t *) context;\n\n  return SASL_OK;\n}"
  },
  {
    "function_name": "get_username",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "260-271",
    "snippet": "static int get_username(void *context, int id, const char **result, unsigned int *len) {\n  if (!context || !result || (id != SASL_CB_USER && id != SASL_CB_AUTHNAME)) {\n    return SASL_BADPARAM;\n  }\n\n  *result = (char *) context;\n  if (len) {\n    *len = (unsigned int) strlen(*result);\n  }\n\n  return SASL_OK;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*result"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic int get_username(void *context, int id, const char **result, unsigned int *len) {\n  if (!context || !result || (id != SASL_CB_USER && id != SASL_CB_AUTHNAME)) {\n    return SASL_BADPARAM;\n  }\n\n  *result = (char *) context;\n  if (len) {\n    *len = (unsigned int) strlen(*result);\n  }\n\n  return SASL_OK;\n}"
  },
  {
    "function_name": "memcached_sasl_authenticate_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "115-258",
    "snippet": "memcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *server) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (server == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  /* SANITY CHECK: SASL can only be used with the binary protocol */\n  if (memcached_is_binary(server->root) == false) {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_sasl_authenticate_connection() is not supported via the ASCII protocol\"));\n  }\n\n  /* Try to get the supported mech from the server. Servers without SASL\n   * support will return UNKNOWN COMMAND, so we can just treat that\n   * as authenticated\n   */\n  protocol_binary_request_no_extras request = {};\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_LIST_MECHS;\n\n  if (memcached_io_write(server, request.bytes, sizeof(request.bytes), true)\n      != sizeof(request.bytes)) {\n    return MEMCACHED_WRITE_FAILURE;\n  }\n  assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n  memcached_server_response_increment(server);\n\n  char mech[MEMCACHED_MAX_BUFFER] = {0};\n  memcached_return_t rc = memcached_response(server, mech, sizeof(mech) - 1, NULL);\n  if (memcached_failed(rc)) {\n    if (rc == MEMCACHED_PROTOCOL_ERROR) {\n      /* If the server doesn't support SASL it will return PROTOCOL_ERROR.\n       * This error may also be returned for other errors, but let's assume\n       * that the server don't support SASL and treat it as success and\n       * let the client fail with the next operation if the error was\n       * caused by another problem....\n       */\n      rc = MEMCACHED_SUCCESS;\n    }\n\n    return rc;\n  }\n  assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n  /* set ip addresses */\n  char laddr[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV];\n  char raddr[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV];\n\n  if (memcached_failed(rc = resolve_names(*server, laddr, sizeof(laddr), raddr, sizeof(raddr)))) {\n    return rc;\n  }\n\n  int pthread_error;\n  if ((pthread_error = pthread_once(&sasl_startup_once, sasl_startup_function))) {\n    return memcached_set_errno(*server, pthread_error, MEMCACHED_AT);\n  }\n\n  (void) pthread_mutex_lock(&sasl_startup_state_LOCK);\n  if (sasl_startup_state != SASL_OK) {\n    const char *sasl_error_msg = sasl_errstring(sasl_startup_state, NULL, NULL);\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n  (void) pthread_mutex_unlock(&sasl_startup_state_LOCK);\n\n  sasl_conn_t *conn;\n  int ret;\n  if ((ret = sasl_client_new(\"memcached\", server->_hostname, laddr, raddr,\n                             server->root->sasl.callbacks, 0, &conn))\n      != SASL_OK)\n  {\n    const char *sasl_error_msg = sasl_errstring(ret, NULL, NULL);\n\n    sasl_dispose(&conn);\n\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n\n  const char *data;\n  const char *chosenmech;\n  unsigned int len;\n  ret = sasl_client_start(conn, mech, NULL, &data, &len, &chosenmech);\n  if (ret != SASL_OK and ret != SASL_CONTINUE) {\n    const char *sasl_error_msg = sasl_errstring(ret, NULL, NULL);\n\n    sasl_dispose(&conn);\n\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n  uint16_t keylen = (uint16_t) strlen(chosenmech);\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_AUTH;\n  request.message.header.request.keylen = htons(keylen);\n  request.message.header.request.bodylen = htonl(len + keylen);\n\n  do {\n    /* send the packet */\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)}, {chosenmech, keylen}, {data, len}};\n\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    if (memcached_io_writev(server, vector, 3, true) == false) {\n      rc = MEMCACHED_WRITE_FAILURE;\n      break;\n    }\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    memcached_server_response_increment(server);\n\n    /* read the response */\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    rc = memcached_response(server, NULL, 0, NULL);\n    if (rc != MEMCACHED_AUTH_CONTINUE) {\n      break;\n    }\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n    ret = sasl_client_step(conn, memcached_result_value(&server->root->result),\n                           (unsigned int) memcached_result_length(&server->root->result), NULL,\n                           &data, &len);\n\n    if (ret != SASL_OK && ret != SASL_CONTINUE) {\n      rc = MEMCACHED_AUTH_PROBLEM;\n      break;\n    }\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_STEP;\n    request.message.header.request.bodylen = htonl(len + keylen);\n  } while (true);\n\n  /* Release resources */\n  sasl_dispose(&conn);\n\n  return memcached_set_error(*server, rc, MEMCACHED_AT);\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "rc",
            "MEMCACHED_AT"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sasl_dispose",
          "args": [
            "&conn"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "len + keylen"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sasl_client_step",
          "args": [
            "conn",
            "memcached_result_value(&server->root->result)",
            "(unsigned int) memcached_result_length(&server->root->result)",
            "NULL",
            "&data",
            "&len"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_length",
          "args": [
            "&server->root->result"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "110-113",
          "snippet": "size_t memcached_result_length(const memcached_result_st *self) {\n  const memcached_string_st *sptr = &self->value;\n  return memcached_string_length(sptr);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nsize_t memcached_result_length(const memcached_result_st *self) {\n  const memcached_string_st *sptr = &self->value;\n  return memcached_string_length(sptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_value",
          "args": [
            "&server->root->result"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "server",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "server"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_writev",
          "args": [
            "server",
            "vector",
            "3",
            "true"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "608-631",
          "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "keylen"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chosenmech"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "sasl_error_msg"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_dispose",
          "args": [
            "&conn"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_errstring",
          "args": [
            "ret",
            "NULL",
            "NULL"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_client_start",
          "args": [
            "conn",
            "mech",
            "NULL",
            "&data",
            "&len",
            "&chosenmech"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "sasl_error_msg"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_dispose",
          "args": [
            "&conn"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_errstring",
          "args": [
            "ret",
            "NULL",
            "NULL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_client_new",
          "args": [
            "\"memcached\"",
            "server->_hostname",
            "laddr",
            "raddr",
            "server->root->sasl.callbacks",
            "0",
            "&conn"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&sasl_startup_state_LOCK"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "sasl_error_msg"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_errstring",
          "args": [
            "sasl_startup_state",
            "NULL",
            "NULL"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&sasl_startup_state_LOCK"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*server",
            "pthread_error",
            "MEMCACHED_AT"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_once",
          "args": [
            "&sasl_startup_once",
            "sasl_startup_function"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = resolve_names(*server, laddr, sizeof(laddr), raddr, sizeof(raddr))"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_names",
          "args": [
            "*server",
            "laddr",
            "sizeof(laddr)",
            "raddr",
            "sizeof(raddr)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "55-90",
          "snippet": "static memcached_return_t resolve_names(memcached_instance_st &server, char *laddr,\n                                        size_t laddr_length, char *raddr, size_t raddr_length) {\n  char host[MEMCACHED_NI_MAXHOST];\n  char port[MEMCACHED_NI_MAXSERV];\n  struct sockaddr_storage saddr;\n  socklen_t salen = sizeof(saddr);\n\n  if (getsockname(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(laddr, laddr_length, \"%s;%s\", host, port);\n  salen = sizeof(saddr);\n\n  if (getpeername(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(raddr, raddr_length, \"%s;%s\", host, port);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t resolve_names(memcached_instance_st &server, char *laddr,\n                                        size_t laddr_length, char *raddr, size_t raddr_length) {\n  char host[MEMCACHED_NI_MAXHOST];\n  char port[MEMCACHED_NI_MAXSERV];\n  struct sockaddr_storage saddr;\n  socklen_t salen = sizeof(saddr);\n\n  if (getsockname(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(laddr, laddr_length, \"%s;%s\", host, port);\n  salen = sizeof(saddr);\n\n  if (getpeername(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(raddr, raddr_length, \"%s;%s\", host, port);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "server",
            "request.message.header"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"memcached_sasl_authenticate_connection() is not supported via the ASCII protocol\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "server->root"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *server) {\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    return MEMCACHED_NOT_SUPPORTED;\n  }\n\n  if (server == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  /* SANITY CHECK: SASL can only be used with the binary protocol */\n  if (memcached_is_binary(server->root) == false) {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_sasl_authenticate_connection() is not supported via the ASCII protocol\"));\n  }\n\n  /* Try to get the supported mech from the server. Servers without SASL\n   * support will return UNKNOWN COMMAND, so we can just treat that\n   * as authenticated\n   */\n  protocol_binary_request_no_extras request = {};\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_LIST_MECHS;\n\n  if (memcached_io_write(server, request.bytes, sizeof(request.bytes), true)\n      != sizeof(request.bytes)) {\n    return MEMCACHED_WRITE_FAILURE;\n  }\n  assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n  memcached_server_response_increment(server);\n\n  char mech[MEMCACHED_MAX_BUFFER] = {0};\n  memcached_return_t rc = memcached_response(server, mech, sizeof(mech) - 1, NULL);\n  if (memcached_failed(rc)) {\n    if (rc == MEMCACHED_PROTOCOL_ERROR) {\n      /* If the server doesn't support SASL it will return PROTOCOL_ERROR.\n       * This error may also be returned for other errors, but let's assume\n       * that the server don't support SASL and treat it as success and\n       * let the client fail with the next operation if the error was\n       * caused by another problem....\n       */\n      rc = MEMCACHED_SUCCESS;\n    }\n\n    return rc;\n  }\n  assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n  /* set ip addresses */\n  char laddr[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV];\n  char raddr[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV];\n\n  if (memcached_failed(rc = resolve_names(*server, laddr, sizeof(laddr), raddr, sizeof(raddr)))) {\n    return rc;\n  }\n\n  int pthread_error;\n  if ((pthread_error = pthread_once(&sasl_startup_once, sasl_startup_function))) {\n    return memcached_set_errno(*server, pthread_error, MEMCACHED_AT);\n  }\n\n  (void) pthread_mutex_lock(&sasl_startup_state_LOCK);\n  if (sasl_startup_state != SASL_OK) {\n    const char *sasl_error_msg = sasl_errstring(sasl_startup_state, NULL, NULL);\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n  (void) pthread_mutex_unlock(&sasl_startup_state_LOCK);\n\n  sasl_conn_t *conn;\n  int ret;\n  if ((ret = sasl_client_new(\"memcached\", server->_hostname, laddr, raddr,\n                             server->root->sasl.callbacks, 0, &conn))\n      != SASL_OK)\n  {\n    const char *sasl_error_msg = sasl_errstring(ret, NULL, NULL);\n\n    sasl_dispose(&conn);\n\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n\n  const char *data;\n  const char *chosenmech;\n  unsigned int len;\n  ret = sasl_client_start(conn, mech, NULL, &data, &len, &chosenmech);\n  if (ret != SASL_OK and ret != SASL_CONTINUE) {\n    const char *sasl_error_msg = sasl_errstring(ret, NULL, NULL);\n\n    sasl_dispose(&conn);\n\n    return memcached_set_error(*server, MEMCACHED_AUTH_PROBLEM, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(sasl_error_msg));\n  }\n  uint16_t keylen = (uint16_t) strlen(chosenmech);\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_AUTH;\n  request.message.header.request.keylen = htons(keylen);\n  request.message.header.request.bodylen = htonl(len + keylen);\n\n  do {\n    /* send the packet */\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)}, {chosenmech, keylen}, {data, len}};\n\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    if (memcached_io_writev(server, vector, 3, true) == false) {\n      rc = MEMCACHED_WRITE_FAILURE;\n      break;\n    }\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    memcached_server_response_increment(server);\n\n    /* read the response */\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n    rc = memcached_response(server, NULL, 0, NULL);\n    if (rc != MEMCACHED_AUTH_CONTINUE) {\n      break;\n    }\n    assert_msg(server->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n\n    ret = sasl_client_step(conn, memcached_result_value(&server->root->result),\n                           (unsigned int) memcached_result_length(&server->root->result), NULL,\n                           &data, &len);\n\n    if (ret != SASL_OK && ret != SASL_CONTINUE) {\n      rc = MEMCACHED_AUTH_PROBLEM;\n      break;\n    }\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SASL_STEP;\n    request.message.header.request.bodylen = htonl(len + keylen);\n  } while (true);\n\n  /* Release resources */\n  sasl_dispose(&conn);\n\n  return memcached_set_error(*server, rc, MEMCACHED_AT);\n}"
  },
  {
    "function_name": "sasl_startup_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "105-111",
    "snippet": "static void sasl_startup_function(void) {\n  sasl_startup_state = sasl_client_init(NULL);\n\n  if (sasl_startup_state == SASL_OK) {\n    (void) atexit(sasl_shutdown_function);\n  }\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atexit",
          "args": [
            "sasl_shutdown_function"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_client_init",
          "args": [
            "NULL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic void sasl_startup_function(void) {\n  sasl_startup_state = sasl_client_init(NULL);\n\n  if (sasl_startup_state == SASL_OK) {\n    (void) atexit(sasl_shutdown_function);\n  }\n}"
  },
  {
    "function_name": "sasl_shutdown_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "94-100",
    "snippet": "static void sasl_shutdown_function() {\n#if HAVE_SASL_CLIENT_DONE\n  (void) sasl_client_done();\n#else\n  sasl_done();\n#endif\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sasl_done",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sasl_client_done",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic void sasl_shutdown_function() {\n#if HAVE_SASL_CLIENT_DONE\n  (void) sasl_client_done();\n#else\n  sasl_done();\n#endif\n}"
  },
  {
    "function_name": "resolve_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "55-90",
    "snippet": "static memcached_return_t resolve_names(memcached_instance_st &server, char *laddr,\n                                        size_t laddr_length, char *raddr, size_t raddr_length) {\n  char host[MEMCACHED_NI_MAXHOST];\n  char port[MEMCACHED_NI_MAXSERV];\n  struct sockaddr_storage saddr;\n  socklen_t salen = sizeof(saddr);\n\n  if (getsockname(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(laddr, laddr_length, \"%s;%s\", host, port);\n  salen = sizeof(saddr);\n\n  if (getpeername(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(raddr, raddr_length, \"%s;%s\", host, port);\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "raddr",
            "raddr_length",
            "\"%s;%s\"",
            "host",
            "port"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "server",
            "MEMCACHED_HOST_LOOKUP_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(struct sockaddr *) &saddr",
            "salen",
            "host",
            "sizeof(host)",
            "port",
            "sizeof(port)",
            "NI_NUMERICHOST | NI_NUMERICSERV"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "server.fd",
            "(struct sockaddr *) &saddr",
            "&salen"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "laddr",
            "laddr_length",
            "\"%s;%s\"",
            "host",
            "port"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(struct sockaddr *) &saddr",
            "salen",
            "host",
            "sizeof(host)",
            "port",
            "sizeof(port)",
            "NI_NUMERICHOST | NI_NUMERICSERV"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "server.fd",
            "(struct sockaddr *) &saddr",
            "&salen"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t resolve_names(memcached_instance_st &server, char *laddr,\n                                        size_t laddr_length, char *raddr, size_t raddr_length) {\n  char host[MEMCACHED_NI_MAXHOST];\n  char port[MEMCACHED_NI_MAXSERV];\n  struct sockaddr_storage saddr;\n  socklen_t salen = sizeof(saddr);\n\n  if (getsockname(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(laddr, laddr_length, \"%s;%s\", host, port);\n  salen = sizeof(saddr);\n\n  if (getpeername(server.fd, (struct sockaddr *) &saddr, &salen) < 0) {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  if (getnameinfo((struct sockaddr *) &saddr, salen, host, sizeof(host), port, sizeof(port),\n                  NI_NUMERICHOST | NI_NUMERICSERV)\n      < 0)\n  {\n    return memcached_set_error(server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT);\n  }\n\n  (void) snprintf(raddr, raddr_length, \"%s;%s\", host, port);\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_set_sasl_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
    "lines": "31-37",
    "snippet": "void memcached_set_sasl_callbacks(memcached_st *shell, const sasl_callback_t *callbacks) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    self->sasl.callbacks = const_cast<sasl_callback_t *>(callbacks);\n    self->sasl.is_allocated = false;\n  }\n}",
    "includes": [
      "#  include <pthread.h>",
      "#    include <sasl/sasl.h>",
      "#include <atomic>",
      "#include <cassert>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "const_cast<sasl_callback_t *>",
          "args": [
            "callbacks"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nvoid memcached_set_sasl_callbacks(memcached_st *shell, const sasl_callback_t *callbacks) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    self->sasl.callbacks = const_cast<sasl_callback_t *>(callbacks);\n    self->sasl.is_allocated = false;\n  }\n}"
  }
]