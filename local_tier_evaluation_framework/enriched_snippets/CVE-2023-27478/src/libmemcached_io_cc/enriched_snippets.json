[
  {
    "function_name": "memcached_io_readline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "771-818",
    "snippet": "memcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "rc",
            "MEMCACHED_AT"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "true"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_read",
          "args": [
            "instance",
            "buffer_ptr",
            "1",
            "nread"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "771-818",
          "snippet": "memcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_safe_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "748-769",
    "snippet": "memcached_return_t memcached_safe_read(memcached_instance_st *instance, void *dta,\n                                       const size_t size) {\n  size_t offset = 0;\n  char *data = static_cast<char *>(dta);\n\n  while (offset < size) {\n    ssize_t nread;\n    memcached_return_t rc;\n\n    while (\n        memcached_continue(rc = memcached_io_read(instance, data + offset, size - offset, nread))) {\n    };\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    offset += size_t(nread);\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "nread"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_continue",
          "args": [
            "rc = memcached_io_read(instance, data + offset, size - offset, nread)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_read",
          "args": [
            "instance",
            "data + offset",
            "size - offset",
            "nread"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "771-818",
          "snippet": "memcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<char *>",
          "args": [
            "dta"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_safe_read(memcached_instance_st *instance, void *dta,\n                                       const size_t size) {\n  size_t offset = 0;\n  char *data = static_cast<char *>(dta);\n\n  while (offset < size) {\n    ssize_t nread;\n    memcached_return_t rc;\n\n    while (\n        memcached_continue(rc = memcached_io_read(instance, data + offset, size - offset, nread))) {\n    };\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    offset += size_t(nread);\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_io_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "740-742",
    "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "true"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
  },
  {
    "function_name": "close_socket",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "647-677",
    "snippet": "void memcached_instance_st::close_socket() {\n  if (fd != INVALID_SOCKET) {\n    int shutdown_options = SHUT_RD;\n    if (options.is_shutting_down == false) {\n      shutdown_options = SHUT_RDWR;\n    }\n\n    /* in case of death shutdown to avoid blocking at close() */\n    if (shutdown(fd, shutdown_options) == SOCKET_ERROR and get_socket_errno() != ENOTCONN) {\n      WATCHPOINT_NUMBER(fd);\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_ASSERT(get_socket_errno());\n    }\n\n    reset_socket();\n    state = MEMCACHED_SERVER_STATE_NEW;\n  }\n\n  state = MEMCACHED_SERVER_STATE_NEW;\n  cursor_active_ = 0;\n  io_bytes_sent = 0;\n  write_buffer_offset = size_t(root and memcached_is_udp(root) ? UDP_DATAGRAM_HEADER_LENGTH : 0);\n  read_buffer_length = 0;\n  read_ptr = read_buffer;\n  options.is_shutting_down = false;\n  memcached_server_response_reset(this);\n\n  // We reset the version so that if we end up talking to a different server\n  // we don't have stale server version information.\n  major_version = minor_version = micro_version = UINT8_MAX;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_response_reset",
          "args": [
            "this"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "root and memcached_is_udp(root) ? UDP_DATAGRAM_HEADER_LENGTH : 0"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "root"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_socket",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "reset_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "640-645",
          "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "get_socket_errno()"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERRNO",
          "args": [
            "get_socket_errno()"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_NUMBER",
          "args": [
            "fd"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "fd",
            "shutdown_options"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::close_socket() {\n    if (fd != INVALID_SOCKET) {\n      int shutdown_options = SHUT_RD;\n      if (options.is_shutting_down == false) {\n        shutdown_options = SHUT_RDWR;\n      }\n  \n      /* in case of death shutdown to avoid blocking at close() */\n      if (shutdown(fd, shutdown_options) == SOCKET_ERROR and get_socket_errno() != ENOTCONN) {\n        WATCHPOINT_NUMBER(fd);\n        WATCHPOINT_ERRNO(get_socket_errno());\n        WATCHPOINT_ASSERT(get_socket_errno());\n      }\n  \n      reset_socket();\n      state = MEMCACHED_SERVER_STATE_NEW;\n    }\n  \n    state = MEMCACHED_SERVER_STATE_NEW;\n    cursor_active_ = 0;\n    io_bytes_sent = 0;\n    write_buffer_offset = size_t(root and memcached_is_udp(root) ? UDP_DATAGRAM_HEADER_LENGTH : 0);\n    read_buffer_length = 0;\n    read_ptr = read_buffer;\n    options.is_shutting_down = false;\n    memcached_server_response_reset(this);\n  \n    // We reset the version so that if we end up talking to a different server\n    // we don't have stale server version information.\n    major_version = minor_version = micro_version = UINT8_MAX;\n  }\n}"
  },
  {
    "function_name": "reset_socket",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "640-645",
    "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
  },
  {
    "function_name": "start_close_socket",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "633-638",
    "snippet": "void memcached_instance_st::start_close_socket() {\n  if (fd != INVALID_SOCKET) {\n    shutdown(fd, SHUT_WR);\n    options.is_shutting_down = true;\n  }\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "fd",
            "SHUT_WR"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::start_close_socket() {\n    if (fd != INVALID_SOCKET) {\n      shutdown(fd, SHUT_WR);\n      options.is_shutting_down = true;\n    }\n  }\n}"
  },
  {
    "function_name": "memcached_io_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "608-631",
    "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "592-595",
          "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_io_write",
          "args": [
            "instance",
            "vector->buffer",
            "vector->length",
            "false",
            "written"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "546-590",
          "snippet": "static bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
  },
  {
    "function_name": "memcached_io_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "597-606",
    "snippet": "ssize_t memcached_io_write(memcached_instance_st *instance, const void *buffer, const size_t length,\n                           const bool with_flush) {\n  size_t written;\n\n  if (_io_write(instance, buffer, length, with_flush, written) == false) {\n    return -1;\n  }\n\n  return ssize_t(written);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssize_t",
          "args": [
            "written"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_io_write",
          "args": [
            "instance",
            "buffer",
            "length",
            "with_flush",
            "written"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "546-590",
          "snippet": "static bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nssize_t memcached_io_write(memcached_instance_st *instance, const void *buffer, const size_t length,\n                           const bool with_flush) {\n  size_t written;\n\n  if (_io_write(instance, buffer, length, with_flush, written) == false) {\n    return -1;\n  }\n\n  return ssize_t(written);\n}"
  },
  {
    "function_name": "memcached_io_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "592-595",
    "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_io_write",
          "args": [
            "instance",
            "NULL",
            "0",
            "true",
            "written"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "546-590",
          "snippet": "static bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
  },
  {
    "function_name": "_io_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "546-590",
    "snippet": "static bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_flush",
          "args": [
            "instance",
            "with_flush",
            "rc"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "io_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "265-362",
          "snippet": "static bool io_flush(memcached_instance_st *instance, const bool with_flush,\n                     memcached_return_t &error) {\n  /*\n   ** We might want to purge the input buffer if we haven't consumed\n   ** any output yet... The test for the limits is the purge is inline\n   ** in the purge function to avoid duplicating the logic..\n   */\n  {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n    if (memcached_purge(instance) == false) {\n      return false;\n    }\n  }\n  char *local_write_ptr = instance->write_buffer;\n  size_t write_length = instance->write_buffer_offset;\n\n  error = MEMCACHED_SUCCESS;\n\n  WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n  /* Looking for memory overflows */\n#if defined(DEBUG)\n  if (write_length == MEMCACHED_MAX_BUFFER)\n    WATCHPOINT_ASSERT(instance->write_buffer == local_write_ptr);\n  WATCHPOINT_ASSERT((instance->write_buffer + MEMCACHED_MAX_BUFFER)\n                    >= (local_write_ptr + write_length));\n#endif\n\n  while (write_length) {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    WATCHPOINT_ASSERT(write_length > 0);\n\n    int flags;\n    if (with_flush) {\n      flags = MSG_NOSIGNAL;\n    } else {\n      flags = MSG_NOSIGNAL | MSG_MORE;\n    }\n\n    ssize_t sent_length = ::send(instance->fd, local_write_ptr, write_length, flags);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (sent_length == SOCKET_ERROR) {\n#if 0 // @todo I should look at why we hit this bit of code hard frequently\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_NUMBER(get_socket_errno());\n#endif\n      switch (get_socket_errno()) {\n      case ENOBUFS:\n        continue;\n\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN: {\n        /*\n         * We may be blocked on write because the input buffer\n         * is full. Let's check if we have room in our input\n         * buffer for more data and retry the write before\n         * waiting..\n         */\n        if (repack_input_buffer(instance) or process_input_buffer(instance)) {\n          continue;\n        }\n\n        memcached_return_t rc = io_wait(instance, POLLOUT);\n        if (memcached_success(rc)) {\n          continue;\n        } else if (rc == MEMCACHED_TIMEOUT) {\n          return false;\n        }\n\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        return false;\n      }\n      case ENOTCONN:\n      case EPIPE:\n      default:\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        WATCHPOINT_ASSERT(instance->fd == INVALID_SOCKET);\n        return false;\n      }\n    }\n\n    instance->io_bytes_sent += uint32_t(sent_length);\n\n    local_write_ptr += sent_length;\n    write_length -= uint32_t(sent_length);\n  }\n\n  WATCHPOINT_ASSERT(write_length == 0);\n  instance->write_buffer_offset = 0;\n\n  return true;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool io_flush(memcached_instance_st *instance, const bool with_flush,\n                     memcached_return_t &error) {\n  /*\n   ** We might want to purge the input buffer if we haven't consumed\n   ** any output yet... The test for the limits is the purge is inline\n   ** in the purge function to avoid duplicating the logic..\n   */\n  {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n    if (memcached_purge(instance) == false) {\n      return false;\n    }\n  }\n  char *local_write_ptr = instance->write_buffer;\n  size_t write_length = instance->write_buffer_offset;\n\n  error = MEMCACHED_SUCCESS;\n\n  WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n  /* Looking for memory overflows */\n#if defined(DEBUG)\n  if (write_length == MEMCACHED_MAX_BUFFER)\n    WATCHPOINT_ASSERT(instance->write_buffer == local_write_ptr);\n  WATCHPOINT_ASSERT((instance->write_buffer + MEMCACHED_MAX_BUFFER)\n                    >= (local_write_ptr + write_length));\n#endif\n\n  while (write_length) {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    WATCHPOINT_ASSERT(write_length > 0);\n\n    int flags;\n    if (with_flush) {\n      flags = MSG_NOSIGNAL;\n    } else {\n      flags = MSG_NOSIGNAL | MSG_MORE;\n    }\n\n    ssize_t sent_length = ::send(instance->fd, local_write_ptr, write_length, flags);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (sent_length == SOCKET_ERROR) {\n#if 0 // @todo I should look at why we hit this bit of code hard frequently\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_NUMBER(get_socket_errno());\n#endif\n      switch (get_socket_errno()) {\n      case ENOBUFS:\n        continue;\n\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN: {\n        /*\n         * We may be blocked on write because the input buffer\n         * is full. Let's check if we have room in our input\n         * buffer for more data and retry the write before\n         * waiting..\n         */\n        if (repack_input_buffer(instance) or process_input_buffer(instance)) {\n          continue;\n        }\n\n        memcached_return_t rc = io_wait(instance, POLLOUT);\n        if (memcached_success(rc)) {\n          continue;\n        } else if (rc == MEMCACHED_TIMEOUT) {\n          return false;\n        }\n\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        return false;\n      }\n      case ENOTCONN:\n      case EPIPE:\n      default:\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        WATCHPOINT_ASSERT(instance->fd == INVALID_SOCKET);\n        return false;\n      }\n    }\n\n    instance->io_bytes_sent += uint32_t(sent_length);\n\n    local_write_ptr += sent_length;\n    write_length -= uint32_t(sent_length);\n  }\n\n  WATCHPOINT_ASSERT(write_length == 0);\n  instance->write_buffer_offset = 0;\n\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "write_ptr",
            "buffer_ptr",
            "should_write"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const char *>",
          "args": [
            "buffer"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_is_udp(instance->root) == false"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool _io_write(memcached_instance_st *instance, const void *buffer, size_t length,\n                      bool with_flush, size_t &written) {\n  assert(instance->fd != INVALID_SOCKET);\n  assert(memcached_is_udp(instance->root) == false);\n\n  const char *buffer_ptr = static_cast<const char *>(buffer);\n\n  const size_t original_length = length;\n\n  while (length) {\n    char *write_ptr;\n    size_t buffer_end = MEMCACHED_MAX_BUFFER;\n    size_t should_write = buffer_end - instance->write_buffer_offset;\n    should_write = (should_write < length) ? should_write : length;\n\n    write_ptr = instance->write_buffer + instance->write_buffer_offset;\n    memcpy(write_ptr, buffer_ptr, should_write);\n    instance->write_buffer_offset += should_write;\n    buffer_ptr += should_write;\n    length -= should_write;\n\n    if (instance->write_buffer_offset == buffer_end) {\n      WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n      memcached_return_t rc;\n      if (io_flush(instance, with_flush, rc) == false) {\n        written = original_length - length;\n        return false;\n      }\n    }\n  }\n\n  if (with_flush) {\n    memcached_return_t rc;\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    if (io_flush(instance, with_flush, rc) == false) {\n      written = original_length - length;\n      return false;\n    }\n  }\n\n  written = original_length - length;\n\n  return true;\n}"
  },
  {
    "function_name": "memcached_io_slurp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "493-544",
    "snippet": "memcached_return_t memcached_io_slurp(memcached_instance_st *instance) {\n  assert_msg(instance, \"Programmer error, invalid Instance\");\n  assert(memcached_is_udp(instance->root) == false);\n\n  if (instance->fd == INVALID_SOCKET) {\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO),\n               \"Invalid socket state\");\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  ssize_t data_read;\n  char buffer[MEMCACHED_MAX_BUFFER];\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, sizeof(buffer), MSG_NOSIGNAL);\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef ERESTART\n      case ERESTART:\n#endif\n        if (memcached_success(io_wait(instance, POLLIN))) {\n          continue;\n        }\n        return MEMCACHED_IN_PROGRESS;\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n      case ENOTSOCK:\n        assert(0);\n        /* fall through */\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Invalid socket state\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        return MEMCACHED_CONNECTION_FAILURE; // We want this!\n      }\n    }\n  } while (data_read > 0);\n\n  return MEMCACHED_CONNECTION_FAILURE;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance->fd != INVALID_SOCKET",
            "\"Invalid socket state\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "io_wait(instance, POLLIN)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_wait",
          "args": [
            "instance",
            "POLLIN"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "io_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "244-263",
          "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::recv",
          "args": [
            "instance->fd",
            "instance->read_buffer",
            "sizeof(buffer)",
            "MSG_NOSIGNAL"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO)",
            "\"Invalid socket state\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "MEMCACHED_SERVER_STATE_ADDRINFO"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_is_udp(instance->root) == false"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance",
            "\"Programmer error, invalid Instance\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_slurp(memcached_instance_st *instance) {\n  assert_msg(instance, \"Programmer error, invalid Instance\");\n  assert(memcached_is_udp(instance->root) == false);\n\n  if (instance->fd == INVALID_SOCKET) {\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO),\n               \"Invalid socket state\");\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  ssize_t data_read;\n  char buffer[MEMCACHED_MAX_BUFFER];\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, sizeof(buffer), MSG_NOSIGNAL);\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef ERESTART\n      case ERESTART:\n#endif\n        if (memcached_success(io_wait(instance, POLLIN))) {\n          continue;\n        }\n        return MEMCACHED_IN_PROGRESS;\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n      case ENOTSOCK:\n        assert(0);\n        /* fall through */\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Invalid socket state\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        return MEMCACHED_CONNECTION_FAILURE; // We want this!\n      }\n    }\n  } while (data_read > 0);\n\n  return MEMCACHED_CONNECTION_FAILURE;\n}"
  },
  {
    "function_name": "memcached_io_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "446-491",
    "snippet": "memcached_return_t memcached_io_read(memcached_instance_st *instance, void *buffer, size_t length,\n                                     ssize_t &nread) {\n  assert(memcached_is_udp(instance->root) == false);\n  assert_msg(\n      instance,\n      \"Programmer error, memcached_io_read() recieved an invalid Instance\"); // Programmer error\n  char *buffer_ptr = static_cast<char *>(buffer);\n\n  if (instance->fd == INVALID_SOCKET) {\n#if 0\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO), \"Programmer error, invalid socket state\");\n#endif\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  while (length) {\n    if (instance->read_buffer_length == 0) {\n      memcached_return_t io_fill_ret;\n      if (memcached_fatal(io_fill_ret = _io_fill(instance))) {\n        nread = -1;\n        return io_fill_ret;\n      }\n    }\n\n    if (length > 1) {\n      size_t difference =\n          (length > instance->read_buffer_length) ? instance->read_buffer_length : length;\n\n      memcpy(buffer_ptr, instance->read_ptr, difference);\n      length -= difference;\n      instance->read_ptr += difference;\n      instance->read_buffer_length -= difference;\n      buffer_ptr += difference;\n    } else {\n      *buffer_ptr = *instance->read_ptr;\n      instance->read_ptr++;\n      instance->read_buffer_length--;\n      buffer_ptr++;\n      break;\n    }\n  }\n\n  nread = ssize_t(buffer_ptr - (char *) buffer);\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssize_t",
          "args": [
            "buffer_ptr - (char *) buffer"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer_ptr",
            "instance->read_ptr",
            "difference"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "io_fill_ret = _io_fill(instance)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_io_fill",
          "args": [
            "instance"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "_io_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "372-444",
          "snippet": "static memcached_return_t _io_fill(memcached_instance_st *instance) {\n  ssize_t data_read;\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, MEMCACHED_MAX_BUFFER, MSG_NOSIGNAL);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef HAVE_ERESTART\n      case ERESTART:\n#endif\n      {\n        memcached_return_t io_wait_ret;\n        if (memcached_success(io_wait_ret = io_wait(instance, POLLIN))) {\n          continue;\n        }\n\n        return io_wait_ret;\n      }\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case ENOTSOCK:\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        memcached_quit_server(instance, true);\n        memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        break;\n      }\n\n      return memcached_instance_error_return(instance);\n    } else if (data_read == 0) {\n      /*\n        EOF. Any data received so far is incomplete\n        so discard it. This always reads by byte in case of TCP\n        and protocol enforcement happens at memcached_response()\n        looking for '\\n'. We do not care for UDB which requests 8 bytes\n        at once. Generally, this means that connection went away. Since\n        for blocking I/O we do not return 0 and for non-blocking case\n        it will return EGAIN if data is not immediatly available.\n      */\n      memcached_quit_server(instance, true);\n      return memcached_set_error(\n          *instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"::rec() returned zero, server has disconnected\"));\n    }\n    instance->io_wait_count._bytes_read += data_read;\n  } while (data_read <= 0);\n\n  instance->io_bytes_sent = 0;\n  instance->read_buffer_length = (size_t) data_read;\n  instance->read_ptr = instance->read_buffer;\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _io_fill(memcached_instance_st *instance) {\n  ssize_t data_read;\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, MEMCACHED_MAX_BUFFER, MSG_NOSIGNAL);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef HAVE_ERESTART\n      case ERESTART:\n#endif\n      {\n        memcached_return_t io_wait_ret;\n        if (memcached_success(io_wait_ret = io_wait(instance, POLLIN))) {\n          continue;\n        }\n\n        return io_wait_ret;\n      }\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case ENOTSOCK:\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        memcached_quit_server(instance, true);\n        memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        break;\n      }\n\n      return memcached_instance_error_return(instance);\n    } else if (data_read == 0) {\n      /*\n        EOF. Any data received so far is incomplete\n        so discard it. This always reads by byte in case of TCP\n        and protocol enforcement happens at memcached_response()\n        looking for '\\n'. We do not care for UDB which requests 8 bytes\n        at once. Generally, this means that connection went away. Since\n        for blocking I/O we do not return 0 and for non-blocking case\n        it will return EGAIN if data is not immediatly available.\n      */\n      memcached_quit_server(instance, true);\n      return memcached_set_error(\n          *instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"::rec() returned zero, server has disconnected\"));\n    }\n    instance->io_wait_count._bytes_read += data_read;\n  } while (data_read <= 0);\n\n  instance->io_bytes_sent = 0;\n  instance->read_buffer_length = (size_t) data_read;\n  instance->read_ptr = instance->read_buffer;\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO)",
            "\"Programmer error, invalid socket state\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "MEMCACHED_SERVER_STATE_ADDRINFO"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<char *>",
          "args": [
            "buffer"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance",
            "\"Programmer error, memcached_io_read() recieved an invalid Instance\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_is_udp(instance->root) == false"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_read(memcached_instance_st *instance, void *buffer, size_t length,\n                                     ssize_t &nread) {\n  assert(memcached_is_udp(instance->root) == false);\n  assert_msg(\n      instance,\n      \"Programmer error, memcached_io_read() recieved an invalid Instance\"); // Programmer error\n  char *buffer_ptr = static_cast<char *>(buffer);\n\n  if (instance->fd == INVALID_SOCKET) {\n#if 0\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO), \"Programmer error, invalid socket state\");\n#endif\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  while (length) {\n    if (instance->read_buffer_length == 0) {\n      memcached_return_t io_fill_ret;\n      if (memcached_fatal(io_fill_ret = _io_fill(instance))) {\n        nread = -1;\n        return io_fill_ret;\n      }\n    }\n\n    if (length > 1) {\n      size_t difference =\n          (length > instance->read_buffer_length) ? instance->read_buffer_length : length;\n\n      memcpy(buffer_ptr, instance->read_ptr, difference);\n      length -= difference;\n      instance->read_ptr += difference;\n      instance->read_buffer_length -= difference;\n      buffer_ptr += difference;\n    } else {\n      *buffer_ptr = *instance->read_ptr;\n      instance->read_ptr++;\n      instance->read_buffer_length--;\n      buffer_ptr++;\n      break;\n    }\n  }\n\n  nread = ssize_t(buffer_ptr - (char *) buffer);\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "_io_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "372-444",
    "snippet": "static memcached_return_t _io_fill(memcached_instance_st *instance) {\n  ssize_t data_read;\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, MEMCACHED_MAX_BUFFER, MSG_NOSIGNAL);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef HAVE_ERESTART\n      case ERESTART:\n#endif\n      {\n        memcached_return_t io_wait_ret;\n        if (memcached_success(io_wait_ret = io_wait(instance, POLLIN))) {\n          continue;\n        }\n\n        return io_wait_ret;\n      }\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case ENOTSOCK:\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        memcached_quit_server(instance, true);\n        memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        break;\n      }\n\n      return memcached_instance_error_return(instance);\n    } else if (data_read == 0) {\n      /*\n        EOF. Any data received so far is incomplete\n        so discard it. This always reads by byte in case of TCP\n        and protocol enforcement happens at memcached_response()\n        looking for '\\n'. We do not care for UDB which requests 8 bytes\n        at once. Generally, this means that connection went away. Since\n        for blocking I/O we do not return 0 and for non-blocking case\n        it will return EGAIN if data is not immediatly available.\n      */\n      memcached_quit_server(instance, true);\n      return memcached_set_error(\n          *instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"::rec() returned zero, server has disconnected\"));\n    }\n    instance->io_wait_count._bytes_read += data_read;\n  } while (data_read <= 0);\n\n  instance->io_bytes_sent = 0;\n  instance->read_buffer_length = (size_t) data_read;\n  instance->read_ptr = instance->read_buffer;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_CONNECTION_FAILURE",
            "MEMCACHED_AT",
            "memcached_literal_param(\"::rec() returned zero, server has disconnected\")"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"::rec() returned zero, server has disconnected\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "true"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_error_return",
          "args": [
            "instance"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "553-563",
          "snippet": "memcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*instance",
            "local_errno",
            "MEMCACHED_AT"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance->fd != INVALID_SOCKET",
            "\"Programmer error, invalid socket\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "io_wait_ret = io_wait(instance, POLLIN)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_wait",
          "args": [
            "instance",
            "POLLIN"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "io_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "244-263",
          "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::recv",
          "args": [
            "instance->fd",
            "instance->read_buffer",
            "MEMCACHED_MAX_BUFFER",
            "MSG_NOSIGNAL"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _io_fill(memcached_instance_st *instance) {\n  ssize_t data_read;\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, MEMCACHED_MAX_BUFFER, MSG_NOSIGNAL);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef HAVE_ERESTART\n      case ERESTART:\n#endif\n      {\n        memcached_return_t io_wait_ret;\n        if (memcached_success(io_wait_ret = io_wait(instance, POLLIN))) {\n          continue;\n        }\n\n        return io_wait_ret;\n      }\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case ENOTSOCK:\n        WATCHPOINT_ASSERT(0);\n        // fall through\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Programmer error, invalid socket\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        memcached_quit_server(instance, true);\n        memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        break;\n      }\n\n      return memcached_instance_error_return(instance);\n    } else if (data_read == 0) {\n      /*\n        EOF. Any data received so far is incomplete\n        so discard it. This always reads by byte in case of TCP\n        and protocol enforcement happens at memcached_response()\n        looking for '\\n'. We do not care for UDB which requests 8 bytes\n        at once. Generally, this means that connection went away. Since\n        for blocking I/O we do not return 0 and for non-blocking case\n        it will return EGAIN if data is not immediatly available.\n      */\n      memcached_quit_server(instance, true);\n      return memcached_set_error(\n          *instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"::rec() returned zero, server has disconnected\"));\n    }\n    instance->io_wait_count._bytes_read += data_read;\n  } while (data_read <= 0);\n\n  instance->io_bytes_sent = 0;\n  instance->read_buffer_length = (size_t) data_read;\n  instance->read_ptr = instance->read_buffer;\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_io_wait_for_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "368-370",
    "snippet": "memcached_return_t memcached_io_wait_for_read(memcached_instance_st *instance) {\n  return io_wait(instance, POLLIN);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_wait",
          "args": [
            "instance",
            "POLLIN"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "io_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "244-263",
          "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_wait_for_read(memcached_instance_st *instance) {\n  return io_wait(instance, POLLIN);\n}"
  },
  {
    "function_name": "memcached_io_wait_for_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "364-366",
    "snippet": "memcached_return_t memcached_io_wait_for_write(memcached_instance_st *instance) {\n  return io_wait(instance, POLLOUT);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_wait",
          "args": [
            "instance",
            "POLLOUT"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "io_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "244-263",
          "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_wait_for_write(memcached_instance_st *instance) {\n  return io_wait(instance, POLLOUT);\n}"
  },
  {
    "function_name": "io_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "265-362",
    "snippet": "static bool io_flush(memcached_instance_st *instance, const bool with_flush,\n                     memcached_return_t &error) {\n  /*\n   ** We might want to purge the input buffer if we haven't consumed\n   ** any output yet... The test for the limits is the purge is inline\n   ** in the purge function to avoid duplicating the logic..\n   */\n  {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n    if (memcached_purge(instance) == false) {\n      return false;\n    }\n  }\n  char *local_write_ptr = instance->write_buffer;\n  size_t write_length = instance->write_buffer_offset;\n\n  error = MEMCACHED_SUCCESS;\n\n  WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n  /* Looking for memory overflows */\n#if defined(DEBUG)\n  if (write_length == MEMCACHED_MAX_BUFFER)\n    WATCHPOINT_ASSERT(instance->write_buffer == local_write_ptr);\n  WATCHPOINT_ASSERT((instance->write_buffer + MEMCACHED_MAX_BUFFER)\n                    >= (local_write_ptr + write_length));\n#endif\n\n  while (write_length) {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    WATCHPOINT_ASSERT(write_length > 0);\n\n    int flags;\n    if (with_flush) {\n      flags = MSG_NOSIGNAL;\n    } else {\n      flags = MSG_NOSIGNAL | MSG_MORE;\n    }\n\n    ssize_t sent_length = ::send(instance->fd, local_write_ptr, write_length, flags);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (sent_length == SOCKET_ERROR) {\n#if 0 // @todo I should look at why we hit this bit of code hard frequently\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_NUMBER(get_socket_errno());\n#endif\n      switch (get_socket_errno()) {\n      case ENOBUFS:\n        continue;\n\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN: {\n        /*\n         * We may be blocked on write because the input buffer\n         * is full. Let's check if we have room in our input\n         * buffer for more data and retry the write before\n         * waiting..\n         */\n        if (repack_input_buffer(instance) or process_input_buffer(instance)) {\n          continue;\n        }\n\n        memcached_return_t rc = io_wait(instance, POLLOUT);\n        if (memcached_success(rc)) {\n          continue;\n        } else if (rc == MEMCACHED_TIMEOUT) {\n          return false;\n        }\n\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        return false;\n      }\n      case ENOTCONN:\n      case EPIPE:\n      default:\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        WATCHPOINT_ASSERT(instance->fd == INVALID_SOCKET);\n        return false;\n      }\n    }\n\n    instance->io_bytes_sent += uint32_t(sent_length);\n\n    local_write_ptr += sent_length;\n    write_length -= uint32_t(sent_length);\n  }\n\n  WATCHPOINT_ASSERT(write_length == 0);\n  instance->write_buffer_offset = 0;\n\n  return true;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "write_length == 0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "sent_length"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "sent_length"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd == INVALID_SOCKET"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*instance",
            "local_errno",
            "MEMCACHED_AT"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "true"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_wait",
          "args": [
            "instance",
            "POLLOUT"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "io_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "244-263",
          "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_input_buffer",
          "args": [
            "instance"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "process_input_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "97-132",
          "snippet": "static bool process_input_buffer(memcached_instance_st *instance) {\n  /*\n   ** We might be able to process some of the response messages if we\n   ** have a callback set up\n   */\n  if (instance->root->callbacks) {\n    /*\n     * We might have responses... try to read them out and fire\n     * callbacks\n     */\n    memcached_callback_st cb = *instance->root->callbacks;\n\n    memcached_set_processing_input((Memcached *) instance->root, true);\n\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    Memcached *root = (Memcached *) instance->root;\n    memcached_return_t error = memcached_response(instance, buffer, sizeof(buffer), &root->result);\n\n    memcached_set_processing_input(root, false);\n\n    if (error == MEMCACHED_SUCCESS) {\n      for (unsigned int x = 0; x < cb.number_of_callback; x++) {\n        error = (*cb.callback[x])(instance->root, &root->result, cb.context);\n        if (error != MEMCACHED_SUCCESS) {\n          break;\n        }\n      }\n\n      /* @todo what should I do with the error message??? */\n    }\n    /* @todo what should I do with other error messages?? */\n    return true;\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool process_input_buffer(memcached_instance_st *instance) {\n  /*\n   ** We might be able to process some of the response messages if we\n   ** have a callback set up\n   */\n  if (instance->root->callbacks) {\n    /*\n     * We might have responses... try to read them out and fire\n     * callbacks\n     */\n    memcached_callback_st cb = *instance->root->callbacks;\n\n    memcached_set_processing_input((Memcached *) instance->root, true);\n\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    Memcached *root = (Memcached *) instance->root;\n    memcached_return_t error = memcached_response(instance, buffer, sizeof(buffer), &root->result);\n\n    memcached_set_processing_input(root, false);\n\n    if (error == MEMCACHED_SUCCESS) {\n      for (unsigned int x = 0; x < cb.number_of_callback; x++) {\n        error = (*cb.callback[x])(instance->root, &root->result, cb.context);\n        if (error != MEMCACHED_SUCCESS) {\n          break;\n        }\n      }\n\n      /* @todo what should I do with the error message??? */\n    }\n    /* @todo what should I do with other error messages?? */\n    return true;\n  }\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repack_input_buffer",
          "args": [
            "instance"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "repack_input_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "35-85",
          "snippet": "static bool repack_input_buffer(memcached_instance_st *instance) {\n  if (instance->read_ptr != instance->read_buffer) {\n    /* Move all of the data to the beginning of the buffer so\n     ** that we can fit more data into the buffer...\n     */\n    memmove(instance->read_buffer, instance->read_ptr, instance->read_buffer_length);\n    instance->read_ptr = instance->read_buffer;\n  }\n\n  /* There is room in the buffer, try to fill it! */\n  if (instance->read_buffer_length != MEMCACHED_MAX_BUFFER) {\n    do {\n      /* Just try a single read to grab what's available */\n      ssize_t nr;\n      if ((nr = ::recv(instance->fd, instance->read_ptr + instance->read_buffer_length,\n                       MEMCACHED_MAX_BUFFER - instance->read_buffer_length, MSG_NOSIGNAL))\n          <= 0)\n      {\n        if (nr == 0) {\n          memcached_set_error(*instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT);\n        } else {\n          switch (get_socket_errno()) {\n          case EINTR:\n            continue;\n\n#if EWOULDBLOCK != EAGAIN\n          case EWOULDBLOCK:\n#endif\n          case EAGAIN:\n#ifdef HAVE_ERESTART\n          case ERESTART:\n#endif\n            break; // No IO is fine, we can just move on\n\n          default:\n            memcached_set_errno(*instance, get_socket_errno(), MEMCACHED_AT);\n          }\n        }\n\n        break;\n      } else // We read data, append to our read buffer\n      {\n        instance->read_buffer_length += size_t(nr);\n\n        return true;\n      }\n    } while (false);\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool repack_input_buffer(memcached_instance_st *instance) {\n  if (instance->read_ptr != instance->read_buffer) {\n    /* Move all of the data to the beginning of the buffer so\n     ** that we can fit more data into the buffer...\n     */\n    memmove(instance->read_buffer, instance->read_ptr, instance->read_buffer_length);\n    instance->read_ptr = instance->read_buffer;\n  }\n\n  /* There is room in the buffer, try to fill it! */\n  if (instance->read_buffer_length != MEMCACHED_MAX_BUFFER) {\n    do {\n      /* Just try a single read to grab what's available */\n      ssize_t nr;\n      if ((nr = ::recv(instance->fd, instance->read_ptr + instance->read_buffer_length,\n                       MEMCACHED_MAX_BUFFER - instance->read_buffer_length, MSG_NOSIGNAL))\n          <= 0)\n      {\n        if (nr == 0) {\n          memcached_set_error(*instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT);\n        } else {\n          switch (get_socket_errno()) {\n          case EINTR:\n            continue;\n\n#if EWOULDBLOCK != EAGAIN\n          case EWOULDBLOCK:\n#endif\n          case EAGAIN:\n#ifdef HAVE_ERESTART\n          case ERESTART:\n#endif\n            break; // No IO is fine, we can just move on\n\n          default:\n            memcached_set_errno(*instance, get_socket_errno(), MEMCACHED_AT);\n          }\n        }\n\n        break;\n      } else // We read data, append to our read buffer\n      {\n        instance->read_buffer_length += size_t(nr);\n\n        return true;\n      }\n    } while (false);\n  }\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_NUMBER",
          "args": [
            "get_socket_errno()"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERRNO",
          "args": [
            "get_socket_errno()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::send",
          "args": [
            "instance->fd",
            "local_write_ptr",
            "write_length",
            "flags"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "write_length > 0"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "(instance->write_buffer + MEMCACHED_MAX_BUFFER)\n                    >= (local_write_ptr + write_length)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->write_buffer == local_write_ptr"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_purge",
          "args": [
            "instance"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
          "lines": "52-131",
          "snippet": "bool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nbool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->fd != INVALID_SOCKET"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool io_flush(memcached_instance_st *instance, const bool with_flush,\n                     memcached_return_t &error) {\n  /*\n   ** We might want to purge the input buffer if we haven't consumed\n   ** any output yet... The test for the limits is the purge is inline\n   ** in the purge function to avoid duplicating the logic..\n   */\n  {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n    if (memcached_purge(instance) == false) {\n      return false;\n    }\n  }\n  char *local_write_ptr = instance->write_buffer;\n  size_t write_length = instance->write_buffer_offset;\n\n  error = MEMCACHED_SUCCESS;\n\n  WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n\n  /* Looking for memory overflows */\n#if defined(DEBUG)\n  if (write_length == MEMCACHED_MAX_BUFFER)\n    WATCHPOINT_ASSERT(instance->write_buffer == local_write_ptr);\n  WATCHPOINT_ASSERT((instance->write_buffer + MEMCACHED_MAX_BUFFER)\n                    >= (local_write_ptr + write_length));\n#endif\n\n  while (write_length) {\n    WATCHPOINT_ASSERT(instance->fd != INVALID_SOCKET);\n    WATCHPOINT_ASSERT(write_length > 0);\n\n    int flags;\n    if (with_flush) {\n      flags = MSG_NOSIGNAL;\n    } else {\n      flags = MSG_NOSIGNAL | MSG_MORE;\n    }\n\n    ssize_t sent_length = ::send(instance->fd, local_write_ptr, write_length, flags);\n    int local_errno = get_socket_errno(); // We cache in case memcached_quit_server() modifies errno\n\n    if (sent_length == SOCKET_ERROR) {\n#if 0 // @todo I should look at why we hit this bit of code hard frequently\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_NUMBER(get_socket_errno());\n#endif\n      switch (get_socket_errno()) {\n      case ENOBUFS:\n        continue;\n\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN: {\n        /*\n         * We may be blocked on write because the input buffer\n         * is full. Let's check if we have room in our input\n         * buffer for more data and retry the write before\n         * waiting..\n         */\n        if (repack_input_buffer(instance) or process_input_buffer(instance)) {\n          continue;\n        }\n\n        memcached_return_t rc = io_wait(instance, POLLOUT);\n        if (memcached_success(rc)) {\n          continue;\n        } else if (rc == MEMCACHED_TIMEOUT) {\n          return false;\n        }\n\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        return false;\n      }\n      case ENOTCONN:\n      case EPIPE:\n      default:\n        memcached_quit_server(instance, true);\n        error = memcached_set_errno(*instance, local_errno, MEMCACHED_AT);\n        WATCHPOINT_ASSERT(instance->fd == INVALID_SOCKET);\n        return false;\n      }\n    }\n\n    instance->io_bytes_sent += uint32_t(sent_length);\n\n    local_write_ptr += sent_length;\n    write_length -= uint32_t(sent_length);\n  }\n\n  WATCHPOINT_ASSERT(write_length == 0);\n  instance->write_buffer_offset = 0;\n\n  return true;\n}"
  },
  {
    "function_name": "io_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "244-263",
    "snippet": "static memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_poll",
          "args": [
            "instance",
            "events"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_purge",
          "args": [
            "instance"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
          "lines": "52-131",
          "snippet": "bool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nbool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_wait(memcached_instance_st *instance, const short events) {\n  if (events & POLLOUT) {\n    /*\n     ** We are going to block on write, but at least on Solaris we might block\n     ** on write if we haven't read anything from our input buffer..\n     ** Try to purge the input buffer if we don't do any flow control in the\n     ** application layer (just sending a lot of data etc)\n     ** The test is moved down in the purge function to avoid duplication of\n     ** the test.\n     */\n    if (memcached_purge(instance) == false) {\n      return MEMCACHED_FAILURE;\n    }\n    instance->io_wait_count.write++;\n  } else {\n    instance->io_wait_count.read++;\n  }\n\n  return memcached_io_poll(instance, events);\n}"
  },
  {
    "function_name": "memcached_io_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "150-242",
    "snippet": "memcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "STDERR_FILENO",
            "\"io_poll() looped!\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "inst",
            "true"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_sock_err",
          "args": [
            "inst",
            "memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"poll(POLLERR|POLLHUP|POLLNVAL)\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "active == 1",
            "\"poll() returned an unexpected number of active file descriptors\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*inst",
            "MEMCACHED_TIMEOUT",
            "MEMCACHED_AT",
            "memcached_literal_param(\"time out\")"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"time out\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_sock_err",
          "args": [
            "inst",
            "memcached_literal_param(\"getsockopt() after poll() timed out\")"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"getsockopt() after poll() timed out\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*inst",
            "local_errno",
            "MEMCACHED_AT",
            "memcached_literal_param(\"poll()\")"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"poll()\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inst->reset_socket",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "reset_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "640-645",
          "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"RLIMIT_NOFILE exceeded, or invalid timeout\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"timeout on interrupt or restart\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_MONOTONIC",
            "&tspec"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "clock_gettime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "159-171",
          "snippet": "int clock_gettime(int, struct timespec *spec)\n{\n  __int64 wintime, unixtime;\n\n  GetSystemTimeAsFileTime((FILETIME*) &wintime);\n  unixtime = wintime2unixtime(wintime);\n\n\n  spec->tv_sec = unixtime / 10000000i64;\n  spec->tv_nsec = unixtime % 10000000i64 * 100;\n\n  return 0;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint clock_gettime(int, struct timespec *spec)\n{\n  __int64 wintime, unixtime;\n\n  GetSystemTimeAsFileTime((FILETIME*) &wintime);\n  unixtime = wintime2unixtime(wintime);\n\n\n  spec->tv_sec = unixtime / 10000000i64;\n  spec->tv_nsec = unixtime % 10000000i64 * 100;\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "poll_timeout"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "150-242",
          "snippet": "memcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"clock_gettime()\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"timeout was set to zero\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inst->events",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}"
  },
  {
    "function_name": "io_sock_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "134-148",
    "snippet": "static memcached_return_t io_sock_err(memcached_instance_st *inst,\n                                      const char *reason_str, size_t reason_len) {\n  int err;\n  socklen_t len = sizeof(err);\n\n  if (getsockopt(inst->fd, SOL_SOCKET, SO_ERROR, (char *) &err, &len) == -1) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getsockopt()\"));\n  }\n\n  if (err) {\n    return memcached_set_errno(*inst, err, MEMCACHED_AT, reason_str, reason_len);\n  }\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*inst",
            "err",
            "MEMCACHED_AT",
            "reason_str",
            "reason_len"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "311-315",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"getsockopt()\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "inst->fd",
            "SOL_SOCKET",
            "SO_ERROR",
            "(char *) &err",
            "&len"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t io_sock_err(memcached_instance_st *inst,\n                                      const char *reason_str, size_t reason_len) {\n  int err;\n  socklen_t len = sizeof(err);\n\n  if (getsockopt(inst->fd, SOL_SOCKET, SO_ERROR, (char *) &err, &len) == -1) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getsockopt()\"));\n  }\n\n  if (err) {\n    return memcached_set_errno(*inst, err, MEMCACHED_AT, reason_str, reason_len);\n  }\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "process_input_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "97-132",
    "snippet": "static bool process_input_buffer(memcached_instance_st *instance) {\n  /*\n   ** We might be able to process some of the response messages if we\n   ** have a callback set up\n   */\n  if (instance->root->callbacks) {\n    /*\n     * We might have responses... try to read them out and fire\n     * callbacks\n     */\n    memcached_callback_st cb = *instance->root->callbacks;\n\n    memcached_set_processing_input((Memcached *) instance->root, true);\n\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    Memcached *root = (Memcached *) instance->root;\n    memcached_return_t error = memcached_response(instance, buffer, sizeof(buffer), &root->result);\n\n    memcached_set_processing_input(root, false);\n\n    if (error == MEMCACHED_SUCCESS) {\n      for (unsigned int x = 0; x < cb.number_of_callback; x++) {\n        error = (*cb.callback[x])(instance->root, &root->result, cb.context);\n        if (error != MEMCACHED_SUCCESS) {\n          break;\n        }\n      }\n\n      /* @todo what should I do with the error message??? */\n    }\n    /* @todo what should I do with other error messages?? */\n    return true;\n  }\n\n  return false;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "instance->root",
            "&root->result",
            "cb.context"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_processing_input",
          "args": [
            "root",
            "false"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "&root->result"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_processing_input",
          "args": [
            "(Memcached *) instance->root",
            "true"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool process_input_buffer(memcached_instance_st *instance) {\n  /*\n   ** We might be able to process some of the response messages if we\n   ** have a callback set up\n   */\n  if (instance->root->callbacks) {\n    /*\n     * We might have responses... try to read them out and fire\n     * callbacks\n     */\n    memcached_callback_st cb = *instance->root->callbacks;\n\n    memcached_set_processing_input((Memcached *) instance->root, true);\n\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    Memcached *root = (Memcached *) instance->root;\n    memcached_return_t error = memcached_response(instance, buffer, sizeof(buffer), &root->result);\n\n    memcached_set_processing_input(root, false);\n\n    if (error == MEMCACHED_SUCCESS) {\n      for (unsigned int x = 0; x < cb.number_of_callback; x++) {\n        error = (*cb.callback[x])(instance->root, &root->result, cb.context);\n        if (error != MEMCACHED_SUCCESS) {\n          break;\n        }\n      }\n\n      /* @todo what should I do with the error message??? */\n    }\n    /* @todo what should I do with other error messages?? */\n    return true;\n  }\n\n  return false;\n}"
  },
  {
    "function_name": "repack_input_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "35-85",
    "snippet": "static bool repack_input_buffer(memcached_instance_st *instance) {\n  if (instance->read_ptr != instance->read_buffer) {\n    /* Move all of the data to the beginning of the buffer so\n     ** that we can fit more data into the buffer...\n     */\n    memmove(instance->read_buffer, instance->read_ptr, instance->read_buffer_length);\n    instance->read_ptr = instance->read_buffer;\n  }\n\n  /* There is room in the buffer, try to fill it! */\n  if (instance->read_buffer_length != MEMCACHED_MAX_BUFFER) {\n    do {\n      /* Just try a single read to grab what's available */\n      ssize_t nr;\n      if ((nr = ::recv(instance->fd, instance->read_ptr + instance->read_buffer_length,\n                       MEMCACHED_MAX_BUFFER - instance->read_buffer_length, MSG_NOSIGNAL))\n          <= 0)\n      {\n        if (nr == 0) {\n          memcached_set_error(*instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT);\n        } else {\n          switch (get_socket_errno()) {\n          case EINTR:\n            continue;\n\n#if EWOULDBLOCK != EAGAIN\n          case EWOULDBLOCK:\n#endif\n          case EAGAIN:\n#ifdef HAVE_ERESTART\n          case ERESTART:\n#endif\n            break; // No IO is fine, we can just move on\n\n          default:\n            memcached_set_errno(*instance, get_socket_errno(), MEMCACHED_AT);\n          }\n        }\n\n        break;\n      } else // We read data, append to our read buffer\n      {\n        instance->read_buffer_length += size_t(nr);\n\n        return true;\n      }\n    } while (false);\n  }\n\n  return false;\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "nr"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*instance",
            "get_socket_errno()",
            "MEMCACHED_AT"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_CONNECTION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::recv",
          "args": [
            "instance->fd",
            "instance->read_ptr + instance->read_buffer_length",
            "MEMCACHED_MAX_BUFFER - instance->read_buffer_length",
            "MSG_NOSIGNAL"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "instance->read_buffer",
            "instance->read_ptr",
            "instance->read_buffer_length"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool repack_input_buffer(memcached_instance_st *instance) {\n  if (instance->read_ptr != instance->read_buffer) {\n    /* Move all of the data to the beginning of the buffer so\n     ** that we can fit more data into the buffer...\n     */\n    memmove(instance->read_buffer, instance->read_ptr, instance->read_buffer_length);\n    instance->read_ptr = instance->read_buffer;\n  }\n\n  /* There is room in the buffer, try to fill it! */\n  if (instance->read_buffer_length != MEMCACHED_MAX_BUFFER) {\n    do {\n      /* Just try a single read to grab what's available */\n      ssize_t nr;\n      if ((nr = ::recv(instance->fd, instance->read_ptr + instance->read_buffer_length,\n                       MEMCACHED_MAX_BUFFER - instance->read_buffer_length, MSG_NOSIGNAL))\n          <= 0)\n      {\n        if (nr == 0) {\n          memcached_set_error(*instance, MEMCACHED_CONNECTION_FAILURE, MEMCACHED_AT);\n        } else {\n          switch (get_socket_errno()) {\n          case EINTR:\n            continue;\n\n#if EWOULDBLOCK != EAGAIN\n          case EWOULDBLOCK:\n#endif\n          case EAGAIN:\n#ifdef HAVE_ERESTART\n          case ERESTART:\n#endif\n            break; // No IO is fine, we can just move on\n\n          default:\n            memcached_set_errno(*instance, get_socket_errno(), MEMCACHED_AT);\n          }\n        }\n\n        break;\n      } else // We read data, append to our read buffer\n      {\n        instance->read_buffer_length += size_t(nr);\n\n        return true;\n      }\n    } while (false);\n  }\n\n  return false;\n}"
  },
  {
    "function_name": "initialize_binary_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
    "lines": "20-25",
    "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
    "includes": [
      "#include \"p9y/clock_gettime.hpp\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "server->request_id"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
  }
]