[
  {
    "function_name": "memcached_key_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
    "lines": "43-81",
    "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "memc",
            "MEMCACHED_BAD_KEY_PROVIDED",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Key provided had invalid character.\")"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Key provided had invalid character.\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isgraph",
          "args": [
            "keys[x][y]"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Key provided was too long.\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_validate_key_length",
          "args": [
            "*(key_length + x)",
            "false/* memc.flags.binary_protocol */"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_validate_key_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "18-41",
          "snippet": "static inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_flag",
          "args": [
            "memc",
            "MEMCACHED_FLAG_BINARY_PROTOCOL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flag.cc",
          "lines": "18-67",
          "snippet": "bool memcached_flag(const memcached_st &memc, const memcached_flag_t flag) {\n  switch (flag) {\n  case MEMCACHED_FLAG_AUTO_EJECT_HOSTS:\n    return memcached_is_auto_eject_hosts(&memc);\n\n  case MEMCACHED_FLAG_BINARY_PROTOCOL:\n    return memcached_is_binary(&memc);\n\n  case MEMCACHED_FLAG_BUFFER_REQUESTS:\n    return memcached_is_buffering(&memc);\n\n  case MEMCACHED_FLAG_HASH_WITH_NAMESPACE:\n    return memcached_is_hash_with_namespace(&memc);\n\n  case MEMCACHED_FLAG_NO_BLOCK:\n    return memcached_is_no_block(&memc);\n\n  case MEMCACHED_FLAG_REPLY:\n    return memcached_is_replying(&memc);\n\n  case MEMCACHED_FLAG_RANDOMIZE_REPLICA_READ:\n    return memcached_is_randomize_replica_read(&memc);\n\n  case MEMCACHED_FLAG_SUPPORT_CAS:\n    return memcached_is_cas(&memc);\n\n  case MEMCACHED_FLAG_TCP_NODELAY:\n    return memcached_is_tcp_nodelay(&memc);\n\n  case MEMCACHED_FLAG_USE_SORT_HOSTS:\n    return memcached_is_use_sort_hosts(&memc);\n\n  case MEMCACHED_FLAG_USE_UDP:\n    return memcached_is_udp(&memc);\n\n  case MEMCACHED_FLAG_VERIFY_KEY:\n    return memcached_is_verify_key(&memc);\n\n  case MEMCACHED_FLAG_TCP_KEEPALIVE:\n    return memcached_is_use_sort_hosts(&memc);\n\n  case MEMCACHED_FLAG_IS_AES:\n    return memcached_is_aes(&memc);\n\n  case MEMCACHED_FLAG_IS_FETCHING_VERSION:\n    return memcached_is_fetching_version(&memc);\n  }\n\n  abort();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nbool memcached_flag(const memcached_st &memc, const memcached_flag_t flag) {\n  switch (flag) {\n  case MEMCACHED_FLAG_AUTO_EJECT_HOSTS:\n    return memcached_is_auto_eject_hosts(&memc);\n\n  case MEMCACHED_FLAG_BINARY_PROTOCOL:\n    return memcached_is_binary(&memc);\n\n  case MEMCACHED_FLAG_BUFFER_REQUESTS:\n    return memcached_is_buffering(&memc);\n\n  case MEMCACHED_FLAG_HASH_WITH_NAMESPACE:\n    return memcached_is_hash_with_namespace(&memc);\n\n  case MEMCACHED_FLAG_NO_BLOCK:\n    return memcached_is_no_block(&memc);\n\n  case MEMCACHED_FLAG_REPLY:\n    return memcached_is_replying(&memc);\n\n  case MEMCACHED_FLAG_RANDOMIZE_REPLICA_READ:\n    return memcached_is_randomize_replica_read(&memc);\n\n  case MEMCACHED_FLAG_SUPPORT_CAS:\n    return memcached_is_cas(&memc);\n\n  case MEMCACHED_FLAG_TCP_NODELAY:\n    return memcached_is_tcp_nodelay(&memc);\n\n  case MEMCACHED_FLAG_USE_SORT_HOSTS:\n    return memcached_is_use_sort_hosts(&memc);\n\n  case MEMCACHED_FLAG_USE_UDP:\n    return memcached_is_udp(&memc);\n\n  case MEMCACHED_FLAG_VERIFY_KEY:\n    return memcached_is_verify_key(&memc);\n\n  case MEMCACHED_FLAG_TCP_KEEPALIVE:\n    return memcached_is_use_sort_hosts(&memc);\n\n  case MEMCACHED_FLAG_IS_AES:\n    return memcached_is_aes(&memc);\n\n  case MEMCACHED_FLAG_IS_FETCHING_VERSION:\n    return memcached_is_fetching_version(&memc);\n  }\n\n  abort();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Key was NULL or length of key was zero.\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Numbers of keys provided was zero\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_validate_key_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
    "lines": "18-41",
    "snippet": "static inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  }
]