[
  {
    "function_name": "memcached_instance_error_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "553-563",
    "snippet": "memcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_server_error_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "541-551",
    "snippet": "memcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_last_error_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "500-511",
    "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
  },
  {
    "function_name": "memcached_last_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "487-498",
    "snippet": "memcached_return_t memcached_last_error(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    if (memc->error_messages) {\n      return memc->error_messages->rc;\n    }\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_last_error(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    if (memc->error_messages) {\n      return memc->error_messages->rc;\n    }\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_has_current_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "483-485",
    "snippet": "bool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_has_current_error",
          "args": [
            "*(server.root)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_has_current_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "483-485",
          "snippet": "bool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}"
  },
  {
    "function_name": "memcached_has_current_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "473-481",
    "snippet": "bool memcached_has_current_error(Memcached &memc) {\n  if (memc.error_messages and memc.error_messages->query_id == memc.query_id\n      and memcached_failed(memc.error_messages->rc))\n  {\n    return true;\n  }\n\n  return false;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memc.error_messages->rc"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_has_current_error(Memcached &memc) {\n  if (memc.error_messages and memc.error_messages->query_id == memc.query_id\n      and memcached_failed(memc.error_messages->rc))\n  {\n    return true;\n  }\n\n  return false;\n}"
  },
  {
    "function_name": "memcached_error_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "447-450",
    "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_error_free",
          "args": [
            "self.error_messages"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
  },
  {
    "function_name": "memcached_error_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "442-445",
    "snippet": "void memcached_error_free(memcached_instance_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_error_free",
          "args": [
            "self.error_messages"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_instance_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
  },
  {
    "function_name": "memcached_error_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "437-440",
    "snippet": "void memcached_error_free(Memcached &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_error_free",
          "args": [
            "self.error_messages"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(Memcached &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
  },
  {
    "function_name": "_error_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "429-435",
    "snippet": "static void _error_free(memcached_error_t *error) {\n  if (error) {\n    _error_free(error->next);\n\n    libmemcached_free(error->root, error);\n  }\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "error->root",
            "error"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_error_free",
          "args": [
            "error->next"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _error_free(memcached_error_t *error) {\n  if (error) {\n    _error_free(error->next);\n\n    libmemcached_free(error->root, error);\n  }\n}"
  },
  {
    "function_name": "memcached_error_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "414-427",
    "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_error_print",
          "args": [
            "instance->error_messages"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_by_position",
          "args": [
            "self",
            "x"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "self"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
  },
  {
    "function_name": "_error_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "400-412",
    "snippet": "static void _error_print(const memcached_error_t *error) {\n  if (error == NULL) {\n    return;\n  }\n\n  if (error->size == 0) {\n    fprintf(stderr, \"\\t%s\\n\", memcached_strerror(NULL, error->rc));\n  } else {\n    fprintf(stderr, \"\\t%s %s\\n\", memcached_strerror(NULL, error->rc), error->message);\n  }\n\n  _error_print(error->next);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_error_print",
          "args": [
            "error->next"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t%s %s\\n\"",
            "memcached_strerror(NULL, error->rc)",
            "error->message"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "NULL",
            "error->rc"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t%s\\n\"",
            "memcached_strerror(NULL, error->rc)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "NULL",
            "error->rc"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _error_print(const memcached_error_t *error) {\n  if (error == NULL) {\n    return;\n  }\n\n  if (error->size == 0) {\n    fprintf(stderr, \"\\t%s\\n\", memcached_strerror(NULL, error->rc));\n  } else {\n    fprintf(stderr, \"\\t%s %s\\n\", memcached_strerror(NULL, error->rc), error->message);\n  }\n\n  _error_print(error->next);\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "378-398",
    "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [
      "#define MAX_ERROR_LENGTH 2048"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "(*self.root)"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "35-52",
          "snippet": "static void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "*self.root",
            "&error_host",
            "rc",
            "at",
            "local_errno"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "311-315",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "append_host_to_string",
          "args": [
            "self",
            "hostname_port_message",
            "sizeof(hostname_port_message)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "append_host_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "217-232",
          "snippet": "static inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "340-376",
    "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [
      "#define MAX_ERROR_LENGTH 2048"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:%d %s != %s\\n\"",
            "__FILE__",
            "__LINE__",
            "memcached_strerror(NULL, self.root->error_messages->rc)",
            "memcached_strerror(NULL, self.error_messages->rc)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "NULL",
            "self.error_messages->rc"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "NULL",
            "self.root->error_messages->rc"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "(*self.root)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "35-52",
          "snippet": "static void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "*self.root",
            "&error_host",
            "rc",
            "at",
            "local_errno"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "311-315",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "append_host_to_string",
          "args": [
            "self",
            "hostname_port_message_ptr",
            "sizeof(hostname_port_message) - size"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "append_host_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "217-232",
          "snippet": "static inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hostname_port_message_ptr",
            "sizeof(hostname_port_message)",
            "\"%.*s, \"",
            "memcached_string_printf(str)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_printf",
          "args": [
            "str"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "328-338",
    "snippet": "memcached_return_t memcached_set_errno(Memcached &memc, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  _set(memc, &str, rc, at, local_errno);\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "memc",
            "&str",
            "rc",
            "at",
            "local_errno"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "311-315",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_errno(Memcached &memc, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  _set(memc, &str, rc, at, local_errno);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "317-326",
    "snippet": "memcached_return_t memcached_set_errno(Memcached &self, int local_errno, const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  _set(self, NULL, rc, at, local_errno);\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "NULL",
            "rc",
            "at",
            "local_errno"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "311-315",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_errno(Memcached &self, int local_errno, const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  _set(self, NULL, rc, at, local_errno);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "311-315",
    "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "self",
            "local_errno",
            "at",
            "tmp"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}"
  },
  {
    "function_name": "memcached_set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "305-309",
    "snippet": "memcached_return_t memcached_set_errno(Memcached &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "self",
            "local_errno",
            "at",
            "tmp"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_errno(Memcached &self, int local_errno, const char *at,\n                                       const char *str, size_t length) {\n  memcached_string_t tmp = {str, length};\n  return memcached_set_errno(self, local_errno, at, tmp);\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "293-303",
    "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "NULL",
            "rc",
            "at"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_ERRNO",
            "\"Programmer error, MEMCACHED_ERRNO was set to be returned to client\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "271-291",
    "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at) {\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  char hostname_port[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV + sizeof(\"host : \")];\n  size_t size = append_host_to_string(self, hostname_port, sizeof(hostname_port));\n\n  memcached_string_t error_host = {hostname_port, size};\n\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, *self.root);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "*self.root"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "35-52",
          "snippet": "static void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "*self.root",
            "&error_host",
            "rc",
            "at"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_host_to_string",
          "args": [
            "self",
            "hostname_port",
            "sizeof(hostname_port)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "append_host_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "217-232",
          "snippet": "static inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_SOME_ERRORS",
            "\"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at) {\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  char hostname_port[MEMCACHED_NI_MAXHOST + MEMCACHED_NI_MAXSERV + sizeof(\"host : \")];\n  size_t size = append_host_to_string(self, hostname_port, sizeof(hostname_port));\n\n  memcached_string_t error_host = {hostname_port, size};\n\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, *self.root);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "234-269",
    "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [
      "#define MAX_ERROR_LENGTH 2048"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "self.error_messages->rc == self.root->error_messages->rc"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "self.root->error_messages"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "self.error_messages"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "self",
            "(*self.root)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "35-52",
          "snippet": "static void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "*self.root",
            "&error_host",
            "rc",
            "at"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "self.root",
            "\"Programmer error, root was not set on instance\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "size"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_host_to_string",
          "args": [
            "self",
            "hostname_port_message_ptr",
            "sizeof(hostname_port_message) - size"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "append_host_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "217-232",
          "snippet": "static inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hostname_port_message_ptr",
            "sizeof(hostname_port_message)",
            "\"%.*s, \"",
            "memcached_string_printf(str)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_printf",
          "args": [
            "str"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_SOME_ERRORS",
            "\"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_ERRNO",
            "\"Programmer error, MEMCACHED_ERRNO was set to be returned to client\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "append_host_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "217-232",
    "snippet": "static inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buffer_length",
            "\" socket: %s\"",
            "self.hostname()"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self.hostname",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buffer_length",
            "\" host: %s:%d\"",
            "self.hostname()",
            "int(self.port())"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "self.port()"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "self.port",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "self.hostname",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline size_t append_host_to_string(memcached_instance_st &self, char *buffer,\n                                           const size_t buffer_length) {\n  size_t size = 0;\n  switch (self.type) {\n  case MEMCACHED_CONNECTION_TCP:\n  case MEMCACHED_CONNECTION_UDP:\n    size += snprintf(buffer, buffer_length, \" host: %s:%d\", self.hostname(), int(self.port()));\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    size += snprintf(buffer, buffer_length, \" socket: %s\", self.hostname());\n    break;\n  }\n\n  return size;\n}"
  },
  {
    "function_name": "memcached_set_parser_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "205-215",
    "snippet": "memcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "memc",
            "MEMCACHED_PARSE_ERROR",
            "at",
            "buffer",
            "length"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "183-192",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "format",
            "args"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "format"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_parser_error(Memcached &memc, const char *at, const char *format,\n                                              ...) {\n  va_list args;\n\n  char buffer[BUFSIZ];\n  va_start(args, format);\n  int length = vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n\n  return memcached_set_error(memc, MEMCACHED_PARSE_ERROR, at, buffer, length);\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "194-203",
    "snippet": "memcached_return_t memcached_set_error(Memcached &memc, memcached_return_t rc, const char *at,\n                                       memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc)) {\n    _set(memc, &str, rc, at);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set",
          "args": [
            "memc",
            "&str",
            "rc",
            "at"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_ERRNO",
            "\"Programmer error, MEMCACHED_ERRNO was set to be returned to client\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &memc, memcached_return_t rc, const char *at,\n                                       memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc)) {\n    _set(memc, &str, rc, at);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "183-192",
    "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "self",
            "rc",
            "at",
            "tmp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_SOME_ERRORS",
            "\"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_ERRNO",
            "\"Programmer error, MEMCACHED_ERRNO was set to be returned to client\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}"
  },
  {
    "function_name": "memcached_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "175-181",
    "snippet": "memcached_return_t memcached_set_error(Memcached &memc, memcached_return_t rc, const char *at,\n                                       const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(memc, rc, at, tmp);\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "memc",
            "rc",
            "at",
            "tmp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "rc != MEMCACHED_ERRNO",
            "\"Programmer error, MEMCACHED_ERRNO was set to be returned to client\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &memc, memcached_return_t rc, const char *at,\n                                       const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(memc, rc, at, tmp);\n}"
  },
  {
    "function_name": "_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "58-173",
    "snippet": "static void _set(Memcached &memc, memcached_string_t *str, memcached_return_t &rc, const char *at,\n                 int local_errno = 0) {\n  if (memc.error_messages && memc.error_messages->query_id != memc.query_id) {\n    memcached_error_free(memc);\n  }\n\n  if (memcached_fatal(rc) or rc == MEMCACHED_CLIENT_ERROR) {\n    // For memory allocation we use our error since it is a bit more specific\n    if (local_errno == ENOMEM and rc == MEMCACHED_ERRNO) {\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_MEMORY_ALLOCATION_FAILURE) {\n      local_errno = ENOMEM;\n    }\n\n    if (rc == MEMCACHED_ERRNO and not local_errno) {\n      local_errno = errno;\n      rc = MEMCACHED_ERRNO;\n    }\n\n    if (rc == MEMCACHED_ERRNO and local_errno == ENOTCONN) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_ERRNO and local_errno == ECONNRESET) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (local_errno == EINVAL) {\n      rc = MEMCACHED_INVALID_ARGUMENTS;\n    }\n\n    if (local_errno == ECONNREFUSED) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_TIMEOUT) {\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error == NULL) // Bad business if this happens\n    {\n      assert_msg(error, \"libmemcached_xmalloc() failed to allocate a memcached_error_t\");\n      return;\n    }\n\n    error->root = &memc;\n    error->query_id = memc.query_id;\n    error->rc = rc;\n    error->local_errno = local_errno;\n\n    // MEMCACHED_CLIENT_ERROR is a special case because it is an error coming from the server\n    if (rc == MEMCACHED_CLIENT_ERROR) {\n      assert(str);\n      assert(str->size);\n      if (str and str->size) {\n        assert(error->local_errno == 0);\n        error->local_errno = 0;\n\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %.*s\", error->root,\n                                     int(str->size), str->c_str);\n      }\n    } else if (local_errno) {\n      const char *errmsg_ptr;\n      char errmsg[MAX_ERROR_LENGTH];\n      errmsg[0] = 0;\n      errmsg_ptr = errmsg;\n\n#if defined(HAVE_STRERROR_R_CHAR_P) && HAVE_STRERROR_R_CHAR_P\n      errmsg_ptr = strerror_r(local_errno, errmsg, sizeof(errmsg));\n#elif defined(HAVE_STRERROR_R) && HAVE_STRERROR_R\n      strerror_r(local_errno, errmsg, sizeof(errmsg));\n      errmsg_ptr = errmsg;\n#else\n      snprintf(errmsg, sizeof(errmsg), \"%s\", strerror(local_errno));\n      errmsg_ptr = errmsg;\n#endif\n\n      if (str and str->size and local_errno) {\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s(%s), %.*s -> %s\",\n                                     error->root, memcached_strerror(&memc, rc), errmsg_ptr,\n                                     memcached_string_printf(*str), at);\n      } else {\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s(%s) -> %s\",\n                                     error->root, memcached_strerror(&memc, rc), errmsg_ptr, at);\n      }\n    } else if (rc == MEMCACHED_PARSE_ERROR and str and str->size) {\n      error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %.*s -> %s\", error->root,\n                                   int(str->size), str->c_str, at);\n    } else if (str and str->size) {\n      error->size =\n          (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s, %.*s -> %s\", error->root,\n                         memcached_strerror(&memc, rc), int(str->size), str->c_str, at);\n    } else {\n      error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s -> %s\", error->root,\n                                   memcached_strerror(&memc, rc), at);\n    }\n\n    error->next = memc.error_messages;\n    memc.error_messages = error;\n#if 0\n    if (error_log_fd == -1)\n    {\n  //    unlink(\"/tmp/libmemcachd.log\");\n      if ((error_log_fd= open(\"/tmp/libmemcachd.log\", O_CREAT | O_WRONLY | O_APPEND, 0644)) < 0)\n      {\n        perror(\"open\");\n        error_log_fd= -1;\n      }\n    }\n    ::write(error_log_fd, error->message, error->size);\n    ::write(error_log_fd, \"\\n\", 1);\n#endif\n  }\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [
      "#define MAX_ERROR_LENGTH 2048"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "::write",
          "args": [
            "error_log_fd",
            "\"\\n\"",
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::write",
          "args": [
            "error_log_fd",
            "error->message",
            "error->size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/tmp/libmemcachd.log\"",
            "O_CREAT | O_WRONLY | O_APPEND",
            "0644"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %s -> %s\"",
            "error->root",
            "memcached_strerror(&memc, rc)",
            "at"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %s, %.*s -> %s\"",
            "error->root",
            "memcached_strerror(&memc, rc)",
            "int(str->size)",
            "str->c_str",
            "at"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "str->size"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %.*s -> %s\"",
            "error->root",
            "int(str->size)",
            "str->c_str",
            "at"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %s(%s) -> %s\"",
            "error->root",
            "memcached_strerror(&memc, rc)",
            "errmsg_ptr",
            "at"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %s(%s), %.*s -> %s\"",
            "error->root",
            "memcached_strerror(&memc, rc)",
            "errmsg_ptr",
            "memcached_string_printf(*str)",
            "at"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_printf",
          "args": [
            "*str"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "errmsg",
            "sizeof(errmsg)",
            "\"%s\"",
            "strerror(local_errno)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "local_errno"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "local_errno",
            "errmsg",
            "sizeof(errmsg)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "local_errno",
            "errmsg",
            "sizeof(errmsg)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "error->message",
            "MAX_ERROR_LENGTH",
            "\"(%p) %.*s\"",
            "error->root",
            "int(str->size)",
            "str->c_str"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error->local_errno == 0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str->size"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "error",
            "\"libmemcached_xmalloc() failed to allocate a memcached_error_t\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_xmalloc",
          "args": [
            "&memc",
            "memcached_error_t"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_error_free",
          "args": [
            "memc"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nstatic void _set(Memcached &memc, memcached_string_t *str, memcached_return_t &rc, const char *at,\n                 int local_errno = 0) {\n  if (memc.error_messages && memc.error_messages->query_id != memc.query_id) {\n    memcached_error_free(memc);\n  }\n\n  if (memcached_fatal(rc) or rc == MEMCACHED_CLIENT_ERROR) {\n    // For memory allocation we use our error since it is a bit more specific\n    if (local_errno == ENOMEM and rc == MEMCACHED_ERRNO) {\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_MEMORY_ALLOCATION_FAILURE) {\n      local_errno = ENOMEM;\n    }\n\n    if (rc == MEMCACHED_ERRNO and not local_errno) {\n      local_errno = errno;\n      rc = MEMCACHED_ERRNO;\n    }\n\n    if (rc == MEMCACHED_ERRNO and local_errno == ENOTCONN) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_ERRNO and local_errno == ECONNRESET) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (local_errno == EINVAL) {\n      rc = MEMCACHED_INVALID_ARGUMENTS;\n    }\n\n    if (local_errno == ECONNREFUSED) {\n      rc = MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    if (rc == MEMCACHED_TIMEOUT) {\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error == NULL) // Bad business if this happens\n    {\n      assert_msg(error, \"libmemcached_xmalloc() failed to allocate a memcached_error_t\");\n      return;\n    }\n\n    error->root = &memc;\n    error->query_id = memc.query_id;\n    error->rc = rc;\n    error->local_errno = local_errno;\n\n    // MEMCACHED_CLIENT_ERROR is a special case because it is an error coming from the server\n    if (rc == MEMCACHED_CLIENT_ERROR) {\n      assert(str);\n      assert(str->size);\n      if (str and str->size) {\n        assert(error->local_errno == 0);\n        error->local_errno = 0;\n\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %.*s\", error->root,\n                                     int(str->size), str->c_str);\n      }\n    } else if (local_errno) {\n      const char *errmsg_ptr;\n      char errmsg[MAX_ERROR_LENGTH];\n      errmsg[0] = 0;\n      errmsg_ptr = errmsg;\n\n#if defined(HAVE_STRERROR_R_CHAR_P) && HAVE_STRERROR_R_CHAR_P\n      errmsg_ptr = strerror_r(local_errno, errmsg, sizeof(errmsg));\n#elif defined(HAVE_STRERROR_R) && HAVE_STRERROR_R\n      strerror_r(local_errno, errmsg, sizeof(errmsg));\n      errmsg_ptr = errmsg;\n#else\n      snprintf(errmsg, sizeof(errmsg), \"%s\", strerror(local_errno));\n      errmsg_ptr = errmsg;\n#endif\n\n      if (str and str->size and local_errno) {\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s(%s), %.*s -> %s\",\n                                     error->root, memcached_strerror(&memc, rc), errmsg_ptr,\n                                     memcached_string_printf(*str), at);\n      } else {\n        error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s(%s) -> %s\",\n                                     error->root, memcached_strerror(&memc, rc), errmsg_ptr, at);\n      }\n    } else if (rc == MEMCACHED_PARSE_ERROR and str and str->size) {\n      error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %.*s -> %s\", error->root,\n                                   int(str->size), str->c_str, at);\n    } else if (str and str->size) {\n      error->size =\n          (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s, %.*s -> %s\", error->root,\n                         memcached_strerror(&memc, rc), int(str->size), str->c_str, at);\n    } else {\n      error->size = (int) snprintf(error->message, MAX_ERROR_LENGTH, \"(%p) %s -> %s\", error->root,\n                                   memcached_strerror(&memc, rc), at);\n    }\n\n    error->next = memc.error_messages;\n    memc.error_messages = error;\n#if 0\n    if (error_log_fd == -1)\n    {\n  //    unlink(\"/tmp/libmemcachd.log\");\n      if ((error_log_fd= open(\"/tmp/libmemcachd.log\", O_CREAT | O_WRONLY | O_APPEND, 0644)) < 0)\n      {\n        perror(\"open\");\n        error_log_fd= -1;\n      }\n    }\n    ::write(error_log_fd, error->message, error->size);\n    ::write(error_log_fd, \"\\n\", 1);\n#endif\n  }\n}"
  },
  {
    "function_name": "_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
    "lines": "35-52",
    "snippet": "static void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}",
    "includes": [
      "#include <cstdio>",
      "#include <cstdarg>",
      "#include <cerrno>",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "error",
            "memc.error_messages",
            "sizeof(memcached_error_t)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_xmalloc",
          "args": [
            "&memc",
            "memcached_error_t"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_error_free",
          "args": [
            "server"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void _set(memcached_instance_st &server, Memcached &memc) {\n  if (server.error_messages and server.error_messages->query_id != server.root->query_id) {\n    memcached_error_free(server);\n  }\n\n  if (memc.error_messages) {\n    if (memc.error_messages->rc == MEMCACHED_TIMEOUT) {\n      server.io_wait_count.timeouts++;\n    }\n\n    memcached_error_t *error = libmemcached_xmalloc(&memc, memcached_error_t);\n    if (error) {\n      memcpy(error, memc.error_messages, sizeof(memcached_error_t));\n      error->next = server.error_messages;\n      server.error_messages = error;\n    }\n  }\n}"
  }
]