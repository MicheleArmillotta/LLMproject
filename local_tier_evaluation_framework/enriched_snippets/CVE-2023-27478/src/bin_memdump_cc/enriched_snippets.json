[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memdump.cc",
    "lines": "33-89",
    "snippet": "int main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION};\n\n  for (const auto &def : opt.defaults) {\n    switch (def.opt.val) {\n    case 'H': // no need for --hash\n    case 'b': // binary proto not available\n      break;\n    default:\n      opt.add(def);\n    }\n  }\n\n  opt.add(\"file\", 'f', required_argument, \"Output to file instead of standard output.\");\n\n  if (!opt.parse(argc, argv)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (opt.isset(\"quiet\") && !opt.isset(\"file\")) {\n    std::cerr << \"--quiet operation was requested, but --file was not set.\\n\";\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_dump_fn cb[1] = {&print};\n  std::ofstream outfile{};\n  std::ostream *outstream = check_ostream(opt, opt.argof(\"file\"), outfile);\n\n  auto rc = memcached_dump(&memc, cb, outstream, 1);\n\n  if (outfile) {\n    if (opt.isset(\"debug\")) {\n      std::cerr << \"Flushing \" << opt.argof(\"file\") << \".\\n\";\n    }\n    outfile.flush();\n  }\n\n  if (MEMCACHED_SUCCESS != rc) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to dump keys:\" << memcached_last_error_message(&memc) << \"\\n\";\n    }\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_free(&memc);\n  exit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\"",
      "#include <fstream>"
    ],
    "macros_used": [
      "#define PROGRAM_VERSION     \"1.1\"",
      "#define PROGRAM_DESCRIPTION \"Dump all values from one or many servers.\"",
      "#define PROGRAM_NAME        \"memdump\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "outfile.flush",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"file\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_dump",
          "args": [
            "&memc",
            "cb",
            "outstream",
            "1"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/dump.cc",
          "lines": "112-131",
          "snippet": "memcached_return_t memcached_dump(memcached_st *shell, memcached_dump_fn *callback, void *context,\n                                  uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  /*\n    No support for Binary protocol yet\n    @todo Fix this so that we just flush, switch to ascii, and then go back to binary.\n  */\n  if (memcached_is_binary(ptr)) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Binary protocol is not supported for memcached_dump()\"));\n  }\n\n  return ascii_dump(ptr, callback, context, number_of_callbacks);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_dump(memcached_st *shell, memcached_dump_fn *callback, void *context,\n                                  uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  /*\n    No support for Binary protocol yet\n    @todo Fix this so that we just flush, switch to ascii, and then go back to binary.\n  */\n  if (memcached_is_binary(ptr)) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Binary protocol is not supported for memcached_dump()\"));\n  }\n\n  return ascii_dump(ptr, callback, context, number_of_callbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ostream",
          "args": [
            "opt",
            "opt.argof(\"file\")",
            "outfile"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"file\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.apply",
          "args": [
            "&memc"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "149-177",
          "snippet": "bool client_options::apply(memcached_st *memc) {\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    std::cerr << \"Socket Initialization Error.\\n\";\n    return false;\n  }\n#endif // _WIN32\n\n  extended_option *servers = nullptr;\n  for (auto &opt : options) {\n    if (opt.apply) {\n      // servers should be applied last, so they take up any behaviors previously set\n      if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n        servers = &opt;\n        continue;\n      }\n      if (!opt.apply(*this, opt, memc)) {\n        return false;\n      }\n    }\n  }\n  if (servers) {\n    if (!servers->apply(*this, *servers, memc)) {\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::apply(memcached_st *memc) {\n  #ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n      std::cerr << \"Socket Initialization Error.\\n\";\n      return false;\n    }\n  #endif // _WIN32\n  \n    extended_option *servers = nullptr;\n    for (auto &opt : options) {\n      if (opt.apply) {\n        // servers should be applied last, so they take up any behaviors previously set\n        if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n          servers = &opt;\n          continue;\n        }\n        if (!opt.apply(*this, opt, memc)) {\n          return false;\n        }\n      }\n    }\n    if (servers) {\n      if (!servers->apply(*this, *servers, memc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_memcached",
          "args": [
            "opt",
            "memc"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "check_memcached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "47-55",
          "snippet": "bool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.parse",
          "args": [
            "argc",
            "argv"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"file\"",
            "'f'",
            "required_argument",
            "\"Output to file instead of standard output.\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "def"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n#include <fstream>\n\n#define PROGRAM_VERSION     \"1.1\"\n#define PROGRAM_DESCRIPTION \"Dump all values from one or many servers.\"\n#define PROGRAM_NAME        \"memdump\"\n\nint main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION};\n\n  for (const auto &def : opt.defaults) {\n    switch (def.opt.val) {\n    case 'H': // no need for --hash\n    case 'b': // binary proto not available\n      break;\n    default:\n      opt.add(def);\n    }\n  }\n\n  opt.add(\"file\", 'f', required_argument, \"Output to file instead of standard output.\");\n\n  if (!opt.parse(argc, argv)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (opt.isset(\"quiet\") && !opt.isset(\"file\")) {\n    std::cerr << \"--quiet operation was requested, but --file was not set.\\n\";\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_dump_fn cb[1] = {&print};\n  std::ofstream outfile{};\n  std::ostream *outstream = check_ostream(opt, opt.argof(\"file\"), outfile);\n\n  auto rc = memcached_dump(&memc, cb, outstream, 1);\n\n  if (outfile) {\n    if (opt.isset(\"debug\")) {\n      std::cerr << \"Flushing \" << opt.argof(\"file\") << \".\\n\";\n    }\n    outfile.flush();\n  }\n\n  if (MEMCACHED_SUCCESS != rc) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to dump keys:\" << memcached_last_error_message(&memc) << \"\\n\";\n    }\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_free(&memc);\n  exit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memdump.cc",
    "lines": "26-31",
    "snippet": "static memcached_return_t print(const memcached_st *, const char *k, size_t l, void *ctx) {\n  auto out = static_cast<std::ostream *>(ctx);\n  out->write(k, l);\n  out->put('\\n');\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\"",
      "#include <fstream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out->put",
          "args": [
            "'\\n'"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out->write",
          "args": [
            "k",
            "l"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<std::ostream *>",
          "args": [
            "ctx"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n#include <fstream>\n\nstatic memcached_return_t print(const memcached_st *, const char *k, size_t l, void *ctx) {\n  auto out = static_cast<std::ostream *>(ctx);\n  out->write(k, l);\n  out->put('\\n');\n  return MEMCACHED_SUCCESS;\n}"
  }
]