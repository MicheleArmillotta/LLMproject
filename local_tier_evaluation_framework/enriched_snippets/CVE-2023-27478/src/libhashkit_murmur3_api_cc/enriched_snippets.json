[
  {
    "function_name": "hashkit_murmur3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/murmur3_api.cc",
    "lines": "19-26",
    "snippet": "uint32_t hashkit_murmur3(const char *key, size_t length, void *) {\n  const uint32_t seed = (0xdeadbeef * (uint32_t) length);\n\n  uint32_t ret;\n  MurmurHash3_x86_32(key, int(length), seed, &ret);\n\n  return ret;\n}",
    "includes": [
      "#include \"libhashkit/murmur3.h\"",
      "#include \"libhashkit/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MurmurHash3_x86_32",
          "args": [
            "key",
            "int(length)",
            "seed",
            "&ret"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "MurmurHash3_x86_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/murmur3.cc",
          "lines": "63-117",
          "snippet": "void MurmurHash3_x86_32(const void *key, int len, uint32_t seed, void *out) {\n  const uint8_t *data = (const uint8_t *) key;\n  const int nblocks = len / 4;\n  int i;\n\n  uint32_t h1 = seed;\n\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n\n  //----------\n  // body\n\n  const uint32_t *blocks = (const uint32_t *) (data + nblocks * 4);\n\n  for (i = -nblocks; i; i++) {\n    uint32_t k1 = getblock(blocks, i);\n#if WORDS_BIGENDIAN\n    k1 = BYTESWAP_32(k1);\n#endif\n\n    k1 *= c1;\n    k1 = ROTL32(k1, 15);\n    k1 *= c2;\n\n    h1 ^= k1;\n    h1 = ROTL32(h1, 13);\n    h1 = h1 * 5 + 0xe6546b64;\n  }\n\n  //----------\n  // tail\n\n  const uint8_t *tail = (const uint8_t *) (data + nblocks * 4);\n\n  uint32_t k1 = 0;\n  memcpy(&k1, tail, len & 3);\n#if WORDS_BIGENDIAN\n  k1 = BYTESWAP_32(k1);\n#endif\n\n  k1 *= c1;\n  k1 = ROTL32(k1, 15);\n  k1 *= c2;\n  h1 ^= k1;\n\n  //----------\n  // finalization\n\n  h1 ^= len;\n\n  h1 = fmix32(h1);\n\n  *(uint32_t *) out = h1;\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/murmur3.h\"",
            "#include \"libhashkit/hashkitcon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/murmur3.h\"\n#include \"libhashkit/hashkitcon.h\"\n\nvoid MurmurHash3_x86_32(const void *key, int len, uint32_t seed, void *out) {\n  const uint8_t *data = (const uint8_t *) key;\n  const int nblocks = len / 4;\n  int i;\n\n  uint32_t h1 = seed;\n\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n\n  //----------\n  // body\n\n  const uint32_t *blocks = (const uint32_t *) (data + nblocks * 4);\n\n  for (i = -nblocks; i; i++) {\n    uint32_t k1 = getblock(blocks, i);\n#if WORDS_BIGENDIAN\n    k1 = BYTESWAP_32(k1);\n#endif\n\n    k1 *= c1;\n    k1 = ROTL32(k1, 15);\n    k1 *= c2;\n\n    h1 ^= k1;\n    h1 = ROTL32(h1, 13);\n    h1 = h1 * 5 + 0xe6546b64;\n  }\n\n  //----------\n  // tail\n\n  const uint8_t *tail = (const uint8_t *) (data + nblocks * 4);\n\n  uint32_t k1 = 0;\n  memcpy(&k1, tail, len & 3);\n#if WORDS_BIGENDIAN\n  k1 = BYTESWAP_32(k1);\n#endif\n\n  k1 *= c1;\n  k1 = ROTL32(k1, 15);\n  k1 *= c2;\n  h1 ^= k1;\n\n  //----------\n  // finalization\n\n  h1 ^= len;\n\n  h1 = fmix32(h1);\n\n  *(uint32_t *) out = h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "length"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libhashkit/murmur3.h\"\n#include \"libhashkit/common.h\"\n\nuint32_t hashkit_murmur3(const char *key, size_t length, void *) {\n  const uint32_t seed = (0xdeadbeef * (uint32_t) length);\n\n  uint32_t ret;\n  MurmurHash3_x86_32(key, int(length), seed, &ret);\n\n  return ret;\n}"
  }
]