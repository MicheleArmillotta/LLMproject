[
  {
    "function_name": "memcached_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
    "lines": "52-131",
    "snippet": "bool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_result_free",
          "args": [
            "result_ptr"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "66-82",
          "snippet": "void memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "(*cb.callback[y])(ptr->root, result_ptr, cb.context)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ptr->root",
            "result_ptr",
            "cb.context"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_read_one_response",
          "args": [
            "ptr",
            "result_ptr"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_read_one_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "771-780",
          "snippet": "memcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_reset",
          "args": [
            "result_ptr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_reset_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "84-86",
          "snippet": "void memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "result_ptr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_create",
          "args": [
            "root",
            "&result"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_count",
          "args": [
            "ptr"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "179-186",
          "snippet": "uint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ptr->fd != INVALID_SOCKET"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_WRITE_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "ptr"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "ptr"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "592-595",
          "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ptr->fd != INVALID_SOCKET"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_purging",
          "args": [
            "ptr->root"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nbool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}"
  },
  {
    "function_name": "PollTimeout",
    "container": "PollTimeout",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
    "lines": "37-41",
    "snippet": "PollTimeout(Memcached *arg, int32_t ms = 50)\n  : _timeout(arg->poll_timeout)\n  , _origin(arg->poll_timeout) {\n    _origin = ms;\n  }",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nPollTimeout {\n  PollTimeout(Memcached *arg, int32_t ms = 50)\n    : _timeout(arg->poll_timeout)\n    , _origin(arg->poll_timeout) {\n      _origin = ms;\n    }\n}"
  },
  {
    "function_name": "Purge",
    "container": "Purge",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
    "lines": "22-25",
    "snippet": "Purge(Memcached *arg)\n  : _memc(arg) {\n    memcached_set_purging(_memc, true);\n  }",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_purging",
          "args": [
            "_memc",
            "true"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nPurge {\n  Purge(Memcached *arg)\n    : _memc(arg) {\n      memcached_set_purging(_memc, true);\n    }\n}"
  }
]