[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1800-1971",
    "snippet": "int main(int argc, char **argv) {\n  static const char *const status_msg[] = {\"[skip]\", \"[pass]\", \"[pass]\", \"[FAIL]\"};\n  struct test_type_st tests = {true, true};\n  int total = 0;\n  int failed = 0;\n  const char *hostname = NULL;\n  const char *port = MEMCACHED_DEFAULT_PORT_STRING;\n  int cmd;\n  bool prompt = false;\n  const char *testname = NULL;\n\n  while ((cmd = getopt(argc, argv, \"qt:vch:p:PT:?ab\")) != EOF) {\n    switch (cmd) {\n    case 'a':\n      tests.ascii = true;\n      tests.binary = false;\n      break;\n\n    case 'b':\n      tests.ascii = false;\n      tests.binary = true;\n      break;\n\n    case 't':\n      timeout = atoi(optarg);\n      if (timeout == 0) {\n        fprintf(stderr, \"Invalid timeout. Please specify a number for -t\\n\");\n        return EXIT_FAILURE;\n      }\n      break;\n\n    case 'v':\n      verbose = true;\n      break;\n\n    case 'c':\n      do_core = true;\n      break;\n\n    case 'h':\n      hostname = optarg;\n      break;\n\n    case 'p':\n      port = optarg;\n      break;\n\n    case 'q':\n      //close_stdio();\n      break;\n\n    case 'P':\n      prompt = true;\n      break;\n\n    case 'T':\n      testname = optarg;\n      break;\n\n    default:\n      fprintf(stderr,\n              \"Usage: %s [-h hostname] [-p port] [-c] [-v] [-t n] [-P] [-T testname]'\\n\"\n              \"\\t-c\\tGenerate coredump if a test fails\\n\"\n              \"\\t-v\\tVerbose test output (print out the assertion)\\n\"\n              \"\\t-t n\\tSet the timeout for io-operations to n seconds\\n\"\n              \"\\t-P\\tPrompt the user before starting a test.\\n\"\n              \"\\t\\t\\t\\\"skip\\\" will skip the test\\n\"\n              \"\\t\\t\\t\\\"quit\\\" will terminate memcapable\\n\"\n              \"\\t\\t\\tEverything else will start the test\\n\"\n              \"\\t-T n\\tJust run the test named n\\n\"\n              \"\\t-a\\tOnly test the ascii protocol\\n\"\n              \"\\t-b\\tOnly test the binary protocol\\n\\n\"\n              \"WARNING: This will FLUSH your server!\\n\\n\",\n              argv[0]);\n      return EXIT_SUCCESS;\n    }\n  }\n\n  if (!hostname) {\n    fprintf(stderr, \"No hostname was provided.\\n\");\n    return EXIT_FAILURE;\n  }\n\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    fprintf(stderr, \"Socket Initialization Error.\\n\");\n    return EXIT_FAILURE;\n  }\n#endif // _WIN32\n\n  sock = connect_server(hostname, port);\n  if (sock == INVALID_SOCKET) {\n    fprintf(stderr, \"Failed to connect to <%s:%s>: %s\\n\", hostname, port,\n            strerror(get_socket_errno()));\n    return EXIT_FAILURE;\n  }\n\n  for (int ii = 0; testcases[ii].description; ++ii) {\n    if (testname && strcmp(testcases[ii].description, testname)) {\n      continue;\n    }\n\n    if ((testcases[ii].description[0] == 'a' && (tests.ascii) == 0)\n        || (testcases[ii].description[0] == 'b' && (tests.binary) == 0))\n    {\n      continue;\n    }\n    ++total;\n    fprintf(stdout, \"%-40s\", testcases[ii].description);\n    fflush(stdout);\n\n    if (prompt) {\n      fprintf(stdout, \"\\nPress <return> when you are ready? \");\n      char buffer[80] = {0};\n      if (fgets(buffer, sizeof(buffer), stdin)) {\n        if (strncmp(buffer, \"skip\", 4) == 0) {\n          fprintf(stdout, \"%-40s%s\\n\", testcases[ii].description, status_msg[TEST_SKIP]);\n          fflush(stdout);\n          continue;\n        }\n        if (strncmp(buffer, \"quit\", 4) == 0) {\n          exit(EXIT_SUCCESS);\n        }\n      }\n\n      fprintf(stdout, \"%-40s\", testcases[ii].description);\n      fflush(stdout);\n    }\n\n    bool reconnect = false;\n    enum test_return ret = testcases[ii].function();\n    if (ret == TEST_FAIL) {\n      reconnect = true;\n      ++failed;\n      if (verbose) {\n        fprintf(stderr, \"\\n\");\n      }\n    } else if (ret == TEST_PASS_RECONNECT) {\n      reconnect = true;\n    }\n\n    if (ret == TEST_FAIL) {\n      fprintf(stderr, \"%s\\n\", status_msg[ret]);\n    } else {\n      fprintf(stdout, \"%s\\n\", status_msg[ret]);\n    }\n\n    if (reconnect) {\n      closesocket(sock);\n      if ((sock = connect_server(hostname, port)) == INVALID_SOCKET) {\n        fprintf(stderr, \"Failed to connect to <%s:%s>: %s\\n\", hostname,\n                port, strerror(get_socket_errno()));\n        fprintf(stderr, \"%d of %d tests failed\\n\", failed, total);\n        return EXIT_FAILURE;\n      }\n    }\n  }\n\n  closesocket(sock);\n  if (failed == 0) {\n    fprintf(stdout, \"All tests passed\\n\");\n  } else {\n    fprintf(stderr, \"%d of %d tests failed\\n\", failed, total);\n  }\n\n#ifdef _WIN32\n  WSACleanup();\n#endif\n\n  return (failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_core = false;",
      "static memcached_socket_t sock;",
      "static bool verbose = false;",
      "static int timeout = 2;",
      "struct testcase testcases[] = {{\"ascii version\", test_ascii_version},\n                               {\"ascii quit\", test_ascii_quit},\n                               {\"ascii verbosity\", test_ascii_verbosity},\n                               {\"ascii set\", test_ascii_set},\n                               {\"ascii set noreply\", test_ascii_set_noreply},\n                               {\"ascii get\", test_ascii_get},\n                               {\"ascii gets\", test_ascii_gets},\n                               {\"ascii mget\", test_ascii_mget},\n                               {\"ascii flush\", test_ascii_flush},\n                               {\"ascii flush noreply\", test_ascii_flush_noreply},\n                               {\"ascii add\", test_ascii_add},\n                               {\"ascii add noreply\", test_ascii_add_noreply},\n                               {\"ascii replace\", test_ascii_replace},\n                               {\"ascii replace noreply\", test_ascii_replace_noreply},\n                               {\"ascii cas\", test_ascii_cas},\n                               {\"ascii cas noreply\", test_ascii_cas_noreply},\n                               {\"ascii delete\", test_ascii_delete},\n                               {\"ascii delete noreply\", test_ascii_delete_noreply},\n                               {\"ascii incr\", test_ascii_incr},\n                               {\"ascii incr noreply\", test_ascii_incr_noreply},\n                               {\"ascii decr\", test_ascii_decr},\n                               {\"ascii decr noreply\", test_ascii_decr_noreply},\n                               {\"ascii append\", test_ascii_append},\n                               {\"ascii append noreply\", test_ascii_append_noreply},\n                               {\"ascii prepend\", test_ascii_prepend},\n                               {\"ascii prepend noreply\", test_ascii_prepend_noreply},\n                               {\"ascii stat\", test_ascii_stat},\n                               {\"binary noop\", test_binary_noop},\n                               {\"binary quit\", test_binary_quit},\n                               {\"binary quitq\", test_binary_quitq},\n                               {\"binary set\", test_binary_set},\n                               {\"binary setq\", test_binary_setq},\n                               {\"binary flush\", test_binary_flush},\n                               {\"binary flushq\", test_binary_flushq},\n                               {\"binary add\", test_binary_add},\n                               {\"binary addq\", test_binary_addq},\n                               {\"binary replace\", test_binary_replace},\n                               {\"binary replaceq\", test_binary_replaceq},\n                               {\"binary delete\", test_binary_delete},\n                               {\"binary deleteq\", test_binary_deleteq},\n                               {\"binary get\", test_binary_get},\n                               {\"binary getq\", test_binary_getq},\n                               {\"binary getk\", test_binary_getk},\n                               {\"binary getkq\", test_binary_getkq},\n                               {\"binary incr\", test_binary_incr},\n                               {\"binary incrq\", test_binary_incrq},\n                               {\"binary decr\", test_binary_decr},\n                               {\"binary decrq\", test_binary_decrq},\n                               {\"binary version\", test_binary_version},\n                               {\"binary append\", test_binary_append},\n                               {\"binary appendq\", test_binary_appendq},\n                               {\"binary prepend\", test_binary_prepend},\n                               {\"binary prependq\", test_binary_prependq},\n                               {\"binary stat\", test_binary_stat},\n                               {NULL, NULL}};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSACleanup",
          "args": [],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d of %d tests failed\\n\"",
            "failed",
            "total"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"All tests passed\\n\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d of %d tests failed\\n\"",
            "failed",
            "total"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to connect to <%s:%s>: %s\\n\"",
            "hostname",
            "port",
            "strerror(get_socket_errno())"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "get_socket_errno()"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_server",
          "args": [
            "hostname",
            "port"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "connect_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "154-174",
          "snippet": "static memcached_socket_t connect_server(const char *hostname, const char *port) {\n  struct addrinfo *ai = lookuphost(hostname, port);\n  sock = INVALID_SOCKET;\n  if (ai) {\n    if ((sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) != INVALID_SOCKET) {\n      if (connect(sock, ai->ai_addr, ai->ai_addrlen) == SOCKET_ERROR) {\n        fprintf(stderr, \"Failed to connect socket: %s\\n\", strerror(get_socket_errno()));\n        closesocket(sock);\n        sock = INVALID_SOCKET;\n      } else {\n        sock = set_noblock();\n      }\n    } else {\n      fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(get_socket_errno()));\n    }\n\n    freeaddrinfo(ai);\n  }\n\n  return sock;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic memcached_socket_t connect_server(const char *hostname, const char *port) {\n  struct addrinfo *ai = lookuphost(hostname, port);\n  sock = INVALID_SOCKET;\n  if (ai) {\n    if ((sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) != INVALID_SOCKET) {\n      if (connect(sock, ai->ai_addr, ai->ai_addrlen) == SOCKET_ERROR) {\n        fprintf(stderr, \"Failed to connect socket: %s\\n\", strerror(get_socket_errno()));\n        closesocket(sock);\n        sock = INVALID_SOCKET;\n      } else {\n        sock = set_noblock();\n      }\n    } else {\n      fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(get_socket_errno()));\n    }\n\n    freeaddrinfo(ai);\n  }\n\n  return sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "status_msg[ret]"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "status_msg[ret]"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "testcases[ii].function",
          "args": [],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-40s\"",
            "testcases[ii].description"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"quit\"",
            "4"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-40s%s\\n\"",
            "testcases[ii].description",
            "status_msg[TEST_SKIP]"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"skip\"",
            "4"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "stdin"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\nPress <return> when you are ready? \""
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-40s\"",
            "testcases[ii].description"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "testcases[ii].description",
            "testname"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to connect to <%s:%s>: %s\\n\"",
            "hostname",
            "port",
            "strerror(get_socket_errno())"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "get_socket_errno()"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Socket Initialization Error.\\n\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "MAKEWORD(2, 2)",
            "&wsaData"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEWORD",
          "args": [
            "2",
            "2"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No hostname was provided.\\n\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: %s [-h hostname] [-p port] [-c] [-v] [-t n] [-P] [-T testname]'\\n\"\n              \"\\t-c\\tGenerate coredump if a test fails\\n\"\n              \"\\t-v\\tVerbose test output (print out the assertion)\\n\"\n              \"\\t-t n\\tSet the timeout for io-operations to n seconds\\n\"\n              \"\\t-P\\tPrompt the user before starting a test.\\n\"\n              \"\\t\\t\\t\\\"skip\\\" will skip the test\\n\"\n              \"\\t\\t\\t\\\"quit\\\" will terminate memcapable\\n\"\n              \"\\t\\t\\tEverything else will start the test\\n\"\n              \"\\t-T n\\tJust run the test named n\\n\"\n              \"\\t-a\\tOnly test the ascii protocol\\n\"\n              \"\\t-b\\tOnly test the binary protocol\\n\\n\"\n              \"WARNING: This will FLUSH your server!\\n\\n\"",
            "argv[0]"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid timeout. Please specify a number for -t\\n\""
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "optarg"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"qt:vch:p:PT:?ab\""
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic bool do_core = false;\nstatic memcached_socket_t sock;\nstatic bool verbose = false;\nstatic int timeout = 2;\nstruct testcase testcases[] = {{\"ascii version\", test_ascii_version},\n                               {\"ascii quit\", test_ascii_quit},\n                               {\"ascii verbosity\", test_ascii_verbosity},\n                               {\"ascii set\", test_ascii_set},\n                               {\"ascii set noreply\", test_ascii_set_noreply},\n                               {\"ascii get\", test_ascii_get},\n                               {\"ascii gets\", test_ascii_gets},\n                               {\"ascii mget\", test_ascii_mget},\n                               {\"ascii flush\", test_ascii_flush},\n                               {\"ascii flush noreply\", test_ascii_flush_noreply},\n                               {\"ascii add\", test_ascii_add},\n                               {\"ascii add noreply\", test_ascii_add_noreply},\n                               {\"ascii replace\", test_ascii_replace},\n                               {\"ascii replace noreply\", test_ascii_replace_noreply},\n                               {\"ascii cas\", test_ascii_cas},\n                               {\"ascii cas noreply\", test_ascii_cas_noreply},\n                               {\"ascii delete\", test_ascii_delete},\n                               {\"ascii delete noreply\", test_ascii_delete_noreply},\n                               {\"ascii incr\", test_ascii_incr},\n                               {\"ascii incr noreply\", test_ascii_incr_noreply},\n                               {\"ascii decr\", test_ascii_decr},\n                               {\"ascii decr noreply\", test_ascii_decr_noreply},\n                               {\"ascii append\", test_ascii_append},\n                               {\"ascii append noreply\", test_ascii_append_noreply},\n                               {\"ascii prepend\", test_ascii_prepend},\n                               {\"ascii prepend noreply\", test_ascii_prepend_noreply},\n                               {\"ascii stat\", test_ascii_stat},\n                               {\"binary noop\", test_binary_noop},\n                               {\"binary quit\", test_binary_quit},\n                               {\"binary quitq\", test_binary_quitq},\n                               {\"binary set\", test_binary_set},\n                               {\"binary setq\", test_binary_setq},\n                               {\"binary flush\", test_binary_flush},\n                               {\"binary flushq\", test_binary_flushq},\n                               {\"binary add\", test_binary_add},\n                               {\"binary addq\", test_binary_addq},\n                               {\"binary replace\", test_binary_replace},\n                               {\"binary replaceq\", test_binary_replaceq},\n                               {\"binary delete\", test_binary_delete},\n                               {\"binary deleteq\", test_binary_deleteq},\n                               {\"binary get\", test_binary_get},\n                               {\"binary getq\", test_binary_getq},\n                               {\"binary getk\", test_binary_getk},\n                               {\"binary getkq\", test_binary_getkq},\n                               {\"binary incr\", test_binary_incr},\n                               {\"binary incrq\", test_binary_incrq},\n                               {\"binary decr\", test_binary_decr},\n                               {\"binary decrq\", test_binary_decrq},\n                               {\"binary version\", test_binary_version},\n                               {\"binary append\", test_binary_append},\n                               {\"binary appendq\", test_binary_appendq},\n                               {\"binary prepend\", test_binary_prepend},\n                               {\"binary prependq\", test_binary_prependq},\n                               {\"binary stat\", test_binary_stat},\n                               {NULL, NULL}};\n\nint main(int argc, char **argv) {\n  static const char *const status_msg[] = {\"[skip]\", \"[pass]\", \"[pass]\", \"[FAIL]\"};\n  struct test_type_st tests = {true, true};\n  int total = 0;\n  int failed = 0;\n  const char *hostname = NULL;\n  const char *port = MEMCACHED_DEFAULT_PORT_STRING;\n  int cmd;\n  bool prompt = false;\n  const char *testname = NULL;\n\n  while ((cmd = getopt(argc, argv, \"qt:vch:p:PT:?ab\")) != EOF) {\n    switch (cmd) {\n    case 'a':\n      tests.ascii = true;\n      tests.binary = false;\n      break;\n\n    case 'b':\n      tests.ascii = false;\n      tests.binary = true;\n      break;\n\n    case 't':\n      timeout = atoi(optarg);\n      if (timeout == 0) {\n        fprintf(stderr, \"Invalid timeout. Please specify a number for -t\\n\");\n        return EXIT_FAILURE;\n      }\n      break;\n\n    case 'v':\n      verbose = true;\n      break;\n\n    case 'c':\n      do_core = true;\n      break;\n\n    case 'h':\n      hostname = optarg;\n      break;\n\n    case 'p':\n      port = optarg;\n      break;\n\n    case 'q':\n      //close_stdio();\n      break;\n\n    case 'P':\n      prompt = true;\n      break;\n\n    case 'T':\n      testname = optarg;\n      break;\n\n    default:\n      fprintf(stderr,\n              \"Usage: %s [-h hostname] [-p port] [-c] [-v] [-t n] [-P] [-T testname]'\\n\"\n              \"\\t-c\\tGenerate coredump if a test fails\\n\"\n              \"\\t-v\\tVerbose test output (print out the assertion)\\n\"\n              \"\\t-t n\\tSet the timeout for io-operations to n seconds\\n\"\n              \"\\t-P\\tPrompt the user before starting a test.\\n\"\n              \"\\t\\t\\t\\\"skip\\\" will skip the test\\n\"\n              \"\\t\\t\\t\\\"quit\\\" will terminate memcapable\\n\"\n              \"\\t\\t\\tEverything else will start the test\\n\"\n              \"\\t-T n\\tJust run the test named n\\n\"\n              \"\\t-a\\tOnly test the ascii protocol\\n\"\n              \"\\t-b\\tOnly test the binary protocol\\n\\n\"\n              \"WARNING: This will FLUSH your server!\\n\\n\",\n              argv[0]);\n      return EXIT_SUCCESS;\n    }\n  }\n\n  if (!hostname) {\n    fprintf(stderr, \"No hostname was provided.\\n\");\n    return EXIT_FAILURE;\n  }\n\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    fprintf(stderr, \"Socket Initialization Error.\\n\");\n    return EXIT_FAILURE;\n  }\n#endif // _WIN32\n\n  sock = connect_server(hostname, port);\n  if (sock == INVALID_SOCKET) {\n    fprintf(stderr, \"Failed to connect to <%s:%s>: %s\\n\", hostname, port,\n            strerror(get_socket_errno()));\n    return EXIT_FAILURE;\n  }\n\n  for (int ii = 0; testcases[ii].description; ++ii) {\n    if (testname && strcmp(testcases[ii].description, testname)) {\n      continue;\n    }\n\n    if ((testcases[ii].description[0] == 'a' && (tests.ascii) == 0)\n        || (testcases[ii].description[0] == 'b' && (tests.binary) == 0))\n    {\n      continue;\n    }\n    ++total;\n    fprintf(stdout, \"%-40s\", testcases[ii].description);\n    fflush(stdout);\n\n    if (prompt) {\n      fprintf(stdout, \"\\nPress <return> when you are ready? \");\n      char buffer[80] = {0};\n      if (fgets(buffer, sizeof(buffer), stdin)) {\n        if (strncmp(buffer, \"skip\", 4) == 0) {\n          fprintf(stdout, \"%-40s%s\\n\", testcases[ii].description, status_msg[TEST_SKIP]);\n          fflush(stdout);\n          continue;\n        }\n        if (strncmp(buffer, \"quit\", 4) == 0) {\n          exit(EXIT_SUCCESS);\n        }\n      }\n\n      fprintf(stdout, \"%-40s\", testcases[ii].description);\n      fflush(stdout);\n    }\n\n    bool reconnect = false;\n    enum test_return ret = testcases[ii].function();\n    if (ret == TEST_FAIL) {\n      reconnect = true;\n      ++failed;\n      if (verbose) {\n        fprintf(stderr, \"\\n\");\n      }\n    } else if (ret == TEST_PASS_RECONNECT) {\n      reconnect = true;\n    }\n\n    if (ret == TEST_FAIL) {\n      fprintf(stderr, \"%s\\n\", status_msg[ret]);\n    } else {\n      fprintf(stdout, \"%s\\n\", status_msg[ret]);\n    }\n\n    if (reconnect) {\n      closesocket(sock);\n      if ((sock = connect_server(hostname, port)) == INVALID_SOCKET) {\n        fprintf(stderr, \"Failed to connect to <%s:%s>: %s\\n\", hostname,\n                port, strerror(get_socket_errno()));\n        fprintf(stderr, \"%d of %d tests failed\\n\", failed, total);\n        return EXIT_FAILURE;\n      }\n    }\n  }\n\n  closesocket(sock);\n  if (failed == 0) {\n    fprintf(stdout, \"All tests passed\\n\");\n  } else {\n    fprintf(stderr, \"%d of %d tests failed\\n\", failed, total);\n  }\n\n#ifdef _WIN32\n  WSACleanup();\n#endif\n\n  return (failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
  },
  {
    "function_name": "test_ascii_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1720-1730",
    "snippet": "static enum test_return test_ascii_stat(void) {\n  execute(send_string(\"stats noreply\\r\\n\"));\n  execute(receive_error_response());\n  execute(send_string(\"stats\\r\\n\"));\n  char buffer[1024];\n  do {\n    execute(receive_line(buffer, sizeof(buffer)));\n  } while (strcmp(buffer, \"END\\r\\n\"));\n\n  return TEST_PASS_RECONNECT;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buffer",
            "\"END\\r\\n\""
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"stats\\r\\n\")"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"stats\\r\\n\""
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"stats noreply\\r\\n\")"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_stat(void) {\n  execute(send_string(\"stats noreply\\r\\n\"));\n  execute(receive_error_response());\n  execute(send_string(\"stats\\r\\n\"));\n  char buffer[1024];\n  do {\n    execute(receive_line(buffer, sizeof(buffer)));\n  } while (strcmp(buffer, \"END\\r\\n\"));\n\n  return TEST_PASS_RECONNECT;\n}"
  },
  {
    "function_name": "test_ascii_prepend_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1716-1718",
    "snippet": "static enum test_return test_ascii_prepend_noreply(void) {\n  return test_ascii_concat_impl(\"test_ascii_prepend_noreply\", false, true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_concat_impl",
          "args": [
            "\"test_ascii_prepend_noreply\"",
            "false",
            "true"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1662-1702",
          "snippet": "static enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_prepend_noreply(void) {\n  return test_ascii_concat_impl(\"test_ascii_prepend_noreply\", false, true);\n}"
  },
  {
    "function_name": "test_ascii_append_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1712-1714",
    "snippet": "static enum test_return test_ascii_append_noreply(void) {\n  return test_ascii_concat_impl(\"test_ascii_append_noreply\", true, true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_concat_impl",
          "args": [
            "\"test_ascii_append_noreply\"",
            "true",
            "true"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1662-1702",
          "snippet": "static enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_append_noreply(void) {\n  return test_ascii_concat_impl(\"test_ascii_append_noreply\", true, true);\n}"
  },
  {
    "function_name": "test_ascii_prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1708-1710",
    "snippet": "static enum test_return test_ascii_prepend(void) {\n  return test_ascii_concat_impl(\"test_ascii_prepend\", false, false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_concat_impl",
          "args": [
            "\"test_ascii_prepend\"",
            "false",
            "false"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1662-1702",
          "snippet": "static enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_prepend(void) {\n  return test_ascii_concat_impl(\"test_ascii_prepend\", false, false);\n}"
  },
  {
    "function_name": "test_ascii_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1704-1706",
    "snippet": "static enum test_return test_ascii_append(void) {\n  return test_ascii_concat_impl(\"test_ascii_append\", true, false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_concat_impl",
          "args": [
            "\"test_ascii_append\"",
            "true",
            "false"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1662-1702",
          "snippet": "static enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_append(void) {\n  return test_ascii_concat_impl(\"test_ascii_append\", true, false);\n}"
  },
  {
    "function_name": "test_ascii_concat_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1662-1702",
    "snippet": "static enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"NOT_STORED\\r\\n\")"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"NOT_STORED\\r\\n\""
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(cmd)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "cmd"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof(cmd)",
            "\"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\"",
            "append ? \"append\" : \"prepend\"",
            "key",
            "(unsigned int) strlen(value)",
            "noreply ? \" noreply\" : \"\"",
            "value"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"hello world\", true)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "\"hello world\"",
            "true"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(cmd)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof(cmd)",
            "\"%s %s 0 0 %u%s\\r\\n%s\\r\\n\"",
            "append ? \"append\" : \"prepend\"",
            "key",
            "(unsigned int) strlen(value)",
            "noreply ? \" noreply\" : \"\"",
            "value"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, value)"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "value"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_concat_impl(const char *key, bool append, bool noreply) {\n  const char *value;\n\n  if (append)\n    value = \"hello\";\n  else\n    value = \" world\";\n\n  execute(ascii_set_item(key, value));\n\n  if (append) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  char cmd[400];\n  snprintf(cmd, sizeof(cmd), \"%s %s 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\", key,\n           (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, \"hello world\", true));\n\n  snprintf(cmd, sizeof(cmd), \"%s %s_notfound 0 0 %u%s\\r\\n%s\\r\\n\", append ? \"append\" : \"prepend\",\n           key, (unsigned int) strlen(value), noreply ? \" noreply\" : \"\", value);\n  execute(send_string(cmd));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_flush_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1658-1660",
    "snippet": "static enum test_return test_ascii_flush_noreply(void) {\n  return test_ascii_flush_impl(\"test_ascii_flush_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_flush_impl",
          "args": [
            "\"test_ascii_flush_noreply\"",
            "true"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_flush_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1630-1652",
          "snippet": "static enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_flush_noreply(void) {\n  return test_ascii_flush_impl(\"test_ascii_flush_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1654-1656",
    "snippet": "static enum test_return test_ascii_flush(void) {\n  return test_ascii_flush_impl(\"test_ascii_flush\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_flush_impl",
          "args": [
            "\"test_ascii_flush\"",
            "false"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_flush_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1630-1652",
          "snippet": "static enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_flush(void) {\n  return test_ascii_flush_impl(\"test_ascii_flush\", false);\n}"
  },
  {
    "function_name": "test_ascii_flush_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1630-1652",
    "snippet": "static enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, key, false)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "key",
            "false"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"OK\\r\\n\")"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"OK\\r\\n\""
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"flush_all\\r\\n\")"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"flush_all\\r\\n\""
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"flush_all noreply\\r\\n\")"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, key, true)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, key)"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "key"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"flush_all foo bar\\r\\n\")"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_flush_impl(const char *key, bool noreply) {\n#if 0\n  /* Verify that the flush_all command handles unknown options */\n  /* Bug in the current memcached server! */\n  execute(send_string(\"flush_all foo bar\\r\\n\"));\n  execute(receive_error_response());\n#endif\n\n  execute(ascii_set_item(key, key));\n  execute(ascii_get_item(key, key, true));\n\n  if (noreply) {\n    execute(send_string(\"flush_all noreply\\r\\n\"));\n    execute(test_ascii_version());\n  } else {\n    execute(send_string(\"flush_all\\r\\n\"));\n    execute(receive_response(\"OK\\r\\n\"));\n  }\n\n  execute(ascii_get_item(key, key, false));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_decr_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1626-1628",
    "snippet": "static enum test_return test_ascii_decr_noreply(void) {\n  return test_ascii_decr_impl(\"test_ascii_decr_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_decr_impl",
          "args": [
            "\"test_ascii_decr_noreply\"",
            "true"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_decr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1589-1620",
          "snippet": "static enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_decr_noreply(void) {\n  return test_ascii_decr_impl(\"test_ascii_decr_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_decr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1622-1624",
    "snippet": "static enum test_return test_ascii_decr(void) {\n  return test_ascii_decr_impl(\"test_ascii_decr\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_decr_impl",
          "args": [
            "\"test_ascii_decr\"",
            "false"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_decr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1589-1620",
          "snippet": "static enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_decr(void) {\n  return test_ascii_decr_impl(\"test_ascii_decr\", false);\n}"
  },
  {
    "function_name": "test_ascii_decr_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1589-1620",
    "snippet": "static enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"0\", true)"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "\"0\"",
            "true"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(cmd)"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "cmd"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"0\", true)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == x"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "buffer"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(cmd)"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, \"9\")"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "\"9\""
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof(cmd)",
            "\"decr %s 1%s\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_decr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"decr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"9\"));\n  for (int x = 8; x > -1; --x) {\n    execute(send_string(cmd));\n\n    if (noreply) {\n      execute(test_ascii_version());\n    } else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"0\", true));\n\n  /* verify that it doesn't wrap */\n  execute(send_string(cmd));\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    char buffer[80];\n    execute(receive_line(buffer, sizeof(buffer)));\n  }\n  execute(ascii_get_item(key, \"0\", true));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_incr_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1585-1587",
    "snippet": "static enum test_return test_ascii_incr_noreply(void) {\n  return test_ascii_incr_impl(\"test_ascii_incr_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_incr_impl",
          "args": [
            "\"test_ascii_incr_noreply\"",
            "true"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_incr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1558-1579",
          "snippet": "static enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_incr_noreply(void) {\n  return test_ascii_incr_impl(\"test_ascii_incr_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_incr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1581-1583",
    "snippet": "static enum test_return test_ascii_incr(void) {\n  return test_ascii_incr_impl(\"test_ascii_incr\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_incr_impl",
          "args": [
            "\"test_ascii_incr\"",
            "false"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_incr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1558-1579",
          "snippet": "static enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_incr(void) {\n  return test_ascii_incr_impl(\"test_ascii_incr\", false);\n}"
  },
  {
    "function_name": "test_ascii_incr_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1558-1579",
    "snippet": "static enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"10\", true)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "\"10\"",
            "true"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == x"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "buffer"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(cmd)"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "cmd"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, \"0\")"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "\"0\""
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof(cmd)",
            "\"incr %s 1%s\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_incr_impl(const char *key, bool noreply) {\n  char cmd[300];\n  snprintf(cmd, sizeof(cmd), \"incr %s 1%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n\n  execute(ascii_set_item(key, \"0\"));\n  for (int x = 1; x < 11; ++x) {\n    execute(send_string(cmd));\n\n    if (noreply)\n      execute(test_ascii_version());\n    else {\n      char buffer[80];\n      execute(receive_line(buffer, sizeof(buffer)));\n      int val = atoi(buffer);\n      verify(val == x);\n    }\n  }\n\n  execute(ascii_get_item(key, \"10\", true));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_mget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1508-1556",
    "snippet": "static enum test_return test_ascii_mget(void) {\n  const uint32_t nkeys = 5;\n  const char *const keys[] = {\"test_ascii_mget1\", \"test_ascii_mget2\",\n                              /* test_ascii_mget_3 does not exist :) */\n                              \"test_ascii_mget4\", \"test_ascii_mget5\", \"test_ascii_mget6\"};\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    execute(ascii_set_item(keys[x], \"value\"));\n  }\n\n  /* Ask for a key that doesn't exist as well */\n  execute(send_string(\"get test_ascii_mget1 test_ascii_mget2 test_ascii_mget3 \"\n                      \"test_ascii_mget4 test_ascii_mget5 \"\n                      \"test_ascii_mget6\\r\\n\"));\n\n  std::vector<char *> returned;\n  returned.resize(nkeys);\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    ssize_t nbytes = 0;\n    char *v = NULL;\n    execute(ascii_get_unknown_value(&returned[x], &v, &nbytes));\n    verify(nbytes == 5);\n    verify(memcmp(v, \"value\", 5) == 0);\n    free(v);\n  }\n\n  char buffer[5];\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  /* verify that we got all the keys we expected */\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    bool found = false;\n    for (uint32_t y = 0; y < nkeys; ++y) {\n      if (strcmp(keys[x], returned[y]) == 0) {\n        found = true;\n        break;\n      }\n    }\n    verify(found);\n  }\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    free(returned[x]);\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "returned[x]"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "aes_free_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/aes.cc",
          "lines": "286-290",
          "snippet": "void aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}",
          "includes": [
            "#  include \"libhashkit/rijndael.hpp\"",
            "#include <openssl/evp.h>",
            "#include <cstring>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"libhashkit/rijndael.hpp\"\n#include <openssl/evp.h>\n#include <cstring>\n#include \"libhashkit/common.h\"\n\nvoid aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "found"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "keys[x]",
            "returned[y]"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"END\\r\\n\", 5) == 0"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"END\\r\\n\"",
            "5"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 5)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "5"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(v, \"value\", 5) == 0"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "v",
            "\"value\"",
            "5"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "nbytes == 5"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_unknown_value(&returned[x], &v, &nbytes)"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_unknown_value",
          "args": [
            "&returned[x]",
            "&v",
            "&nbytes"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_unknown_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1203-1240",
          "snippet": "static enum test_return ascii_get_unknown_value(char **key, char **value, ssize_t *ndata) {\n  char buffer[1024];\n\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  char *end = strchr(buffer + 6, ' ');\n  verify(end);\n  if (end) {\n    *end = '\\0';\n  }\n  *key = strdup(buffer + 6);\n  verify(*key);\n  char *ptr = end + 1;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n  errno = 0;\n  *ndata = (ssize_t) strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) ++end;\n  verify(end and *end == '\\n');\n\n  *value = static_cast<char *>(malloc((size_t) *ndata));\n  verify(*value);\n\n  execute(retry_read(*value, (size_t) *ndata));\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_unknown_value(char **key, char **value, ssize_t *ndata) {\n  char buffer[1024];\n\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  char *end = strchr(buffer + 6, ' ');\n  verify(end);\n  if (end) {\n    *end = '\\0';\n  }\n  *key = strdup(buffer + 6);\n  verify(*key);\n  char *ptr = end + 1;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n  errno = 0;\n  *ndata = (ssize_t) strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) ++end;\n  verify(end and *end == '\\n');\n\n  *value = static_cast<char *>(malloc((size_t) *ndata));\n  verify(*value);\n\n  execute(retry_read(*value, (size_t) *ndata));\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "returned.resize",
          "args": [
            "nkeys"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"get test_ascii_mget1 test_ascii_mget2 test_ascii_mget3 \"\n                      \"test_ascii_mget4 test_ascii_mget5 \"\n                      \"test_ascii_mget6\\r\\n\")"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"get test_ascii_mget1 test_ascii_mget2 test_ascii_mget3 \"\n                      \"test_ascii_mget4 test_ascii_mget5 \"\n                      \"test_ascii_mget6\\r\\n\""
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(keys[x], \"value\")"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "keys[x]",
            "\"value\""
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_mget(void) {\n  const uint32_t nkeys = 5;\n  const char *const keys[] = {\"test_ascii_mget1\", \"test_ascii_mget2\",\n                              /* test_ascii_mget_3 does not exist :) */\n                              \"test_ascii_mget4\", \"test_ascii_mget5\", \"test_ascii_mget6\"};\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    execute(ascii_set_item(keys[x], \"value\"));\n  }\n\n  /* Ask for a key that doesn't exist as well */\n  execute(send_string(\"get test_ascii_mget1 test_ascii_mget2 test_ascii_mget3 \"\n                      \"test_ascii_mget4 test_ascii_mget5 \"\n                      \"test_ascii_mget6\\r\\n\"));\n\n  std::vector<char *> returned;\n  returned.resize(nkeys);\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    ssize_t nbytes = 0;\n    char *v = NULL;\n    execute(ascii_get_unknown_value(&returned[x], &v, &nbytes));\n    verify(nbytes == 5);\n    verify(memcmp(v, \"value\", 5) == 0);\n    free(v);\n  }\n\n  char buffer[5];\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  /* verify that we got all the keys we expected */\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    bool found = false;\n    for (uint32_t y = 0; y < nkeys; ++y) {\n      if (strcmp(keys[x], returned[y]) == 0) {\n        found = true;\n        break;\n      }\n    }\n    verify(found);\n  }\n\n  for (uint32_t x = 0; x < nkeys; ++x) {\n    free(returned[x]);\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_gets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1496-1506",
    "snippet": "static enum test_return test_ascii_gets(void) {\n  execute(ascii_set_item(\"test_ascii_gets\", \"value\"));\n\n  execute(send_string(\"gets\\r\\n\"));\n  execute(receive_error_response());\n  unsigned long cas;\n  execute(ascii_gets_item(\"test_ascii_gets\", \"value\", true, &cas));\n  execute(ascii_gets_item(\"test_ascii_gets_notfound\", \"value\", false, &cas));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_gets_item(\"test_ascii_gets_notfound\", \"value\", false, &cas)"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_gets_item",
          "args": [
            "\"test_ascii_gets_notfound\"",
            "\"value\"",
            "false",
            "&cas"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_gets_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1347-1366",
          "snippet": "static enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_gets_item(\"test_ascii_gets\", \"value\", true, &cas)"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"gets\\r\\n\")"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"gets\\r\\n\""
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(\"test_ascii_gets\", \"value\")"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "\"test_ascii_gets\"",
            "\"value\""
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_gets(void) {\n  execute(ascii_set_item(\"test_ascii_gets\", \"value\"));\n\n  execute(send_string(\"gets\\r\\n\"));\n  execute(receive_error_response());\n  unsigned long cas;\n  execute(ascii_gets_item(\"test_ascii_gets\", \"value\", true, &cas));\n  execute(ascii_gets_item(\"test_ascii_gets_notfound\", \"value\", false, &cas));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1485-1494",
    "snippet": "static enum test_return test_ascii_get(void) {\n  execute(ascii_set_item(\"test_ascii_get\", \"value\"));\n\n  execute(send_string(\"get\\r\\n\"));\n  execute(receive_error_response());\n  execute(ascii_get_item(\"test_ascii_get\", \"value\", true));\n  execute(ascii_get_item(\"test_ascii_get_notfound\", \"value\", false));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(\"test_ascii_get_notfound\", \"value\", false)"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "\"test_ascii_get_notfound\"",
            "\"value\"",
            "false"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(\"test_ascii_get\", \"value\", true)"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"get\\r\\n\")"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"get\\r\\n\""
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(\"test_ascii_get\", \"value\")"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "\"test_ascii_get\"",
            "\"value\""
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_get(void) {\n  execute(ascii_set_item(\"test_ascii_get\", \"value\"));\n\n  execute(send_string(\"get\\r\\n\"));\n  execute(receive_error_response());\n  execute(ascii_get_item(\"test_ascii_get\", \"value\", true));\n  execute(ascii_get_item(\"test_ascii_get_notfound\", \"value\", false));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_delete_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1481-1483",
    "snippet": "static enum test_return test_ascii_delete_noreply(void) {\n  return test_ascii_delete_impl(\"test_ascii_delete_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_delete_impl",
          "args": [
            "\"test_ascii_delete_noreply\"",
            "true"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_delete_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1449-1475",
          "snippet": "static enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_delete_noreply(void) {\n  return test_ascii_delete_impl(\"test_ascii_delete_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1477-1479",
    "snippet": "static enum test_return test_ascii_delete(void) {\n  return test_ascii_delete_impl(\"test_ascii_delete\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_delete_impl",
          "args": [
            "\"test_ascii_delete\"",
            "false"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_delete_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1449-1475",
          "snippet": "static enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_delete(void) {\n  return test_ascii_delete_impl(\"test_ascii_delete\", false);\n}"
  },
  {
    "function_name": "test_ascii_delete_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1449-1475",
    "snippet": "static enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"NOT_FOUND\\r\\n\")"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"NOT_FOUND\\r\\n\""
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"value\", false)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "\"value\"",
            "false"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"DELETED\\r\\n\")"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"delete %s%s\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"delete a b c d e\\r\\n\")"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"delete\\r\\n\")"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, \"value\")"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "\"value\""
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_delete_impl(const char *key, bool noreply) {\n  execute(ascii_set_item(key, \"value\"));\n\n  execute(send_string(\"delete\\r\\n\"));\n  execute(receive_error_response());\n  /* BUG: the server accepts delete a b */\n  execute(send_string(\"delete a b c d e\\r\\n\"));\n  execute(receive_error_response());\n\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"delete %s%s\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"DELETED\\r\\n\"));\n\n  execute(ascii_get_item(key, \"value\", false));\n  execute(send_string(buffer));\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"NOT_FOUND\\r\\n\"));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_cas_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1445-1447",
    "snippet": "static enum test_return test_ascii_cas_noreply(void) {\n  return test_ascii_cas_impl(\"test_ascii_cas_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_cas_impl",
          "args": [
            "\"test_ascii_cas_noreply\"",
            "true"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_cas_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1412-1439",
          "snippet": "static enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_cas_noreply(void) {\n  return test_ascii_cas_impl(\"test_ascii_cas_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_cas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1441-1443",
    "snippet": "static enum test_return test_ascii_cas(void) {\n  return test_ascii_cas_impl(\"test_ascii_cas\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_cas_impl",
          "args": [
            "\"test_ascii_cas\"",
            "false"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_cas_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1412-1439",
          "snippet": "static enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_cas(void) {\n  return test_ascii_cas_impl(\"test_ascii_cas\", false);\n}"
  },
  {
    "function_name": "test_ascii_cas_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1412-1439",
    "snippet": "static enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"EXISTS\\r\\n\")"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"EXISTS\\r\\n\""
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\"",
            "key",
            "cas",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_gets_item(key, \"value\", true, &cas)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_gets_item",
          "args": [
            "key",
            "\"value\"",
            "true",
            "&cas"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_gets_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1347-1366",
          "snippet": "static enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, \"value\")"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "\"value\""
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_cas_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  unsigned long cas;\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_gets_item(key, \"value\", true, &cas));\n\n  snprintf(buffer, sizeof(buffer), \"cas %s 0 0 6 %lu%s\\r\\nvalue2\\r\\n\", key, cas,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  /* reexecute the same command should fail due to illegal cas */\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"EXISTS\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
  },
  {
    "function_name": "test_ascii_replace_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1408-1410",
    "snippet": "static enum test_return test_ascii_replace_noreply(void) {\n  return test_ascii_replace_impl(\"test_ascii_replace_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_replace_impl",
          "args": [
            "\"test_ascii_replace_noreply\"",
            "true"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_replace_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1379-1402",
          "snippet": "static enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_replace_noreply(void) {\n  return test_ascii_replace_impl(\"test_ascii_replace_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1404-1406",
    "snippet": "static enum test_return test_ascii_replace(void) {\n  return test_ascii_replace_impl(\"test_ascii_replace\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_replace_impl",
          "args": [
            "\"test_ascii_replace\"",
            "false"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_replace_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1379-1402",
          "snippet": "static enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_replace(void) {\n  return test_ascii_replace_impl(\"test_ascii_replace\", false);\n}"
  },
  {
    "function_name": "test_ascii_replace_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1379-1402",
    "snippet": "static enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"STORED\\r\\n\""
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_item(key, \"value\", true)"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_item",
          "args": [
            "key",
            "\"value\"",
            "true"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1280-1299",
          "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_set_item(key, \"value\")"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_set_item",
          "args": [
            "key",
            "\"value\""
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1368-1377",
          "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"NOT_STORED\\r\\n\")"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"replace %s 0 0 5%s\\r\\nvalue\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_replace_impl(const char *key, bool noreply) {\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"replace %s 0 0 5%s\\r\\nvalue\\r\\n\", key,\n           noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (noreply) {\n    execute(test_ascii_version());\n  } else {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  execute(ascii_set_item(key, \"value\"));\n  execute(ascii_get_item(key, \"value\", true));\n\n  execute(send_string(buffer));\n\n  if (noreply)\n    execute(test_ascii_version());\n  else\n    execute(receive_response(\"STORED\\r\\n\"));\n\n  return test_ascii_version();\n}"
  },
  {
    "function_name": "ascii_set_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1368-1377",
    "snippet": "static enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"STORED\\r\\n\""
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"\\r\\n\")"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_write(value, len)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_write",
          "args": [
            "value",
            "len"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "retry_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "245-261",
          "snippet": "static enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"set %s 0 0 %u\\r\\n\"",
            "key",
            "(unsigned int) len"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_set_item(const char *key, const char *value) {\n  char buffer[300];\n  size_t len = strlen(value);\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 %u\\r\\n\", key, (unsigned int) len);\n  execute(send_string(buffer));\n  execute(retry_write(value, len));\n  execute(send_string(\"\\r\\n\"));\n  execute(receive_response(\"STORED\\r\\n\"));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ascii_gets_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1347-1366",
    "snippet": "static enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"END\\r\\n\", 5) == 0"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"END\\r\\n\"",
            "5"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 5)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "5"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_gets_value(key, value, cas)"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_gets_value",
          "args": [
            "key",
            "value",
            "cas"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_gets_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1301-1345",
          "snippet": "static enum test_return ascii_gets_value(const char *key, const char *value, unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  errno = 0;\n  *cas = strtoul(end, &end, 10); /* cas */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_gets_value(const char *key, const char *value, unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  errno = 0;\n  *cas = strtoul(end, &end, 10); /* cas */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"gets %s\\r\\n\"",
            "key"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "datasize < sizeof(buffer)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_gets_item(const char *key, const char *value, bool exist,\n                                        unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"gets %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist)\n    execute(ascii_gets_value(key, value, cas));\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ascii_gets_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1301-1345",
    "snippet": "static enum test_return ascii_gets_value(const char *key, const char *value, unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  errno = 0;\n  *cas = strtoul(end, &end, 10); /* cas */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"\\r\\n\", 2) == 0"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"\\r\\n\"",
            "2"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 2)"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "2"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, value, datasize) == 0"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "value",
            "datasize"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, datasize)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end and *end == '\\n'"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*end"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == datasize"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "end",
            "&end",
            "10"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == datasize"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "end",
            "&end",
            "10"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == 0"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "ptr",
            "&end",
            "10"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer + 6, key, strlen(key)) == 0"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer + 6",
            "key",
            "strlen(key)"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VALUE \", 6) == 0"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VALUE \"",
            "6"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "datasize < sizeof(buffer)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_gets_value(const char *key, const char *value, unsigned long *cas) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  errno = 0;\n  *cas = strtoul(end, &end, 10); /* cas */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ascii_get_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1280-1299",
    "snippet": "static enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"END\\r\\n\", 5) == 0"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"END\\r\\n\"",
            "5"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 5)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "5"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "ascii_get_value(key, value)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ascii_get_value",
          "args": [
            "key",
            "value"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1242-1278",
          "snippet": "static enum test_return ascii_get_value(const char *key, const char *value) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_value(const char *key, const char *value) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"get %s\\r\\n\"",
            "key"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "datasize < sizeof(buffer)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_item(const char *key, const char *value, bool exist) {\n  char buffer[1024];\n  size_t datasize = 0;\n  if (value) {\n    datasize = strlen(value);\n  }\n\n  verify(datasize < sizeof(buffer));\n  snprintf(buffer, sizeof(buffer), \"get %s\\r\\n\", key);\n  execute(send_string(buffer));\n\n  if (exist) {\n    execute(ascii_get_value(key, value));\n  }\n\n  execute(retry_read(buffer, 5));\n  verify(memcmp(buffer, \"END\\r\\n\", 5) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ascii_get_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1242-1278",
    "snippet": "static enum test_return ascii_get_value(const char *key, const char *value) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"\\r\\n\", 2) == 0"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"\\r\\n\"",
            "2"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 2)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "2"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, value, datasize) == 0"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "value",
            "datasize"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, datasize)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end and *end == '\\n'"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*end"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == datasize"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "end",
            "&end",
            "10"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == 0"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "ptr",
            "&end",
            "10"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer + 6, key, strlen(key)) == 0"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer + 6",
            "key",
            "strlen(key)"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VALUE \", 6) == 0"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VALUE \"",
            "6"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "datasize < sizeof(buffer)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_value(const char *key, const char *value) {\n  char buffer[1024];\n  size_t datasize = strlen(value);\n\n  verify(datasize < sizeof(buffer));\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  verify(strncmp(buffer + 6, key, strlen(key)) == 0);\n  char *ptr = buffer + 6 + strlen(key) + 1;\n  char *end;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n\n  errno = 0;\n  val = strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == datasize);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) {\n    ++end;\n  }\n  verify(end and *end == '\\n');\n\n  execute(retry_read(buffer, datasize));\n  verify(memcmp(buffer, value, datasize) == 0);\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ascii_get_unknown_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1203-1240",
    "snippet": "static enum test_return ascii_get_unknown_value(char **key, char **value, ssize_t *ndata) {\n  char buffer[1024];\n\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  char *end = strchr(buffer + 6, ' ');\n  verify(end);\n  if (end) {\n    *end = '\\0';\n  }\n  *key = strdup(buffer + 6);\n  verify(*key);\n  char *ptr = end + 1;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n  errno = 0;\n  *ndata = (ssize_t) strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) ++end;\n  verify(end and *end == '\\n');\n\n  *value = static_cast<char *>(malloc((size_t) *ndata));\n  verify(*value);\n\n  execute(retry_read(*value, (size_t) *ndata));\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(buffer, \"\\r\\n\", 2) == 0"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"\\r\\n\"",
            "2"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer, 2)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer",
            "2"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(*value, (size_t) *ndata)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "*value"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char *>",
          "args": [
            "malloc((size_t) *ndata)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) *ndata"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end and *end == '\\n'"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*end"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "end",
            "&end",
            "10"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "val == 0"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "ptr != end"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "errno == 0"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "ptr",
            "&end",
            "10"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "*key"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buffer + 6"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "end"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer + 6",
            "' '"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VALUE \", 6) == 0"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VALUE \"",
            "6"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return ascii_get_unknown_value(char **key, char **value, ssize_t *ndata) {\n  char buffer[1024];\n\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VALUE \", 6) == 0);\n  char *end = strchr(buffer + 6, ' ');\n  verify(end);\n  if (end) {\n    *end = '\\0';\n  }\n  *key = strdup(buffer + 6);\n  verify(*key);\n  char *ptr = end + 1;\n\n  errno = 0;\n  unsigned long val = strtoul(ptr, &end, 10); /* flags */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(val == 0);\n  verify(end);\n  errno = 0;\n  *ndata = (ssize_t) strtoul(end, &end, 10); /* size */\n  verify(errno == 0);\n  verify(ptr != end);\n  verify(end);\n  while (end and *end != '\\n' and isspace(*end)) ++end;\n  verify(end and *end == '\\n');\n\n  *value = static_cast<char *>(malloc((size_t) *ndata));\n  verify(*value);\n\n  execute(retry_read(*value, (size_t) *ndata));\n\n  execute(retry_read(buffer, 2));\n  verify(memcmp(buffer, \"\\r\\n\", 2) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_add_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1199-1201",
    "snippet": "static enum test_return test_ascii_add_noreply(void) {\n  return test_ascii_add_impl(\"test_ascii_add_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_add_impl",
          "args": [
            "\"test_ascii_add_noreply\"",
            "true"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_add_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1176-1193",
          "snippet": "static enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_add_noreply(void) {\n  return test_ascii_add_impl(\"test_ascii_add_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1195-1197",
    "snippet": "static enum test_return test_ascii_add(void) {\n  return test_ascii_add_impl(\"test_ascii_add\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_add_impl",
          "args": [
            "\"test_ascii_add\"",
            "false"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_add_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1176-1193",
          "snippet": "static enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_add(void) {\n  return test_ascii_add_impl(\"test_ascii_add\", false);\n}"
  },
  {
    "function_name": "test_ascii_add_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1176-1193",
    "snippet": "static enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"NOT_STORED\\r\\n\")"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"NOT_STORED\\r\\n\""
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"add %s 0 0 5%s\\r\\nvalue\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_add_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"add %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"NOT_STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
  },
  {
    "function_name": "test_ascii_set_noreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1172-1174",
    "snippet": "static enum test_return test_ascii_set_noreply(void) {\n  return test_ascii_set_impl(\"test_ascii_set_noreply\", true);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_set_impl",
          "args": [
            "\"test_ascii_set_noreply\"",
            "true"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_set_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1155-1166",
          "snippet": "static enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_set_noreply(void) {\n  return test_ascii_set_impl(\"test_ascii_set_noreply\", true);\n}"
  },
  {
    "function_name": "test_ascii_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1168-1170",
    "snippet": "static enum test_return test_ascii_set(void) {\n  return test_ascii_set_impl(\"test_ascii_set\", false);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_set_impl",
          "args": [
            "\"test_ascii_set\"",
            "false"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "test_ascii_set_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1155-1166",
          "snippet": "static enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_set(void) {\n  return test_ascii_set_impl(\"test_ascii_set\", false);\n}"
  },
  {
    "function_name": "test_ascii_set_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1155-1166",
    "snippet": "static enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"STORED\\r\\n\")"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"STORED\\r\\n\""
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(buffer)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "buffer"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"set %s 0 0 5%s\\r\\nvalue\\r\\n\"",
            "key",
            "noreply ? \" noreply\" : \"\""
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_set_impl(const char *key, bool noreply) {\n  /* @todo add tests for bogus format! */\n  char buffer[1024];\n  snprintf(buffer, sizeof(buffer), \"set %s 0 0 5%s\\r\\nvalue\\r\\n\", key, noreply ? \" noreply\" : \"\");\n  execute(send_string(buffer));\n\n  if (!noreply) {\n    execute(receive_response(\"STORED\\r\\n\"));\n  }\n\n  return test_ascii_version();\n}"
  },
  {
    "function_name": "test_ascii_verbosity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1132-1153",
    "snippet": "static enum test_return test_ascii_verbosity(void) {\n  /* This command does not adhere to the spec! */\n  execute(send_string(\"verbosity foo bar my\\r\\n\"));\n  execute(receive_error_response());\n\n  execute(send_string(\"verbosity noreply\\r\\n\"));\n  execute(test_ascii_version());\n\n  execute(send_string(\"verbosity 0 noreply\\r\\n\"));\n  execute(test_ascii_version());\n\n  execute(send_string(\"verbosity\\r\\n\"));\n  execute(receive_error_response());\n\n  execute(send_string(\"verbosity 1\\r\\n\"));\n  execute(receive_response(\"OK\\r\\n\"));\n\n  execute(send_string(\"verbosity 0\\r\\n\"));\n  execute(receive_response(\"OK\\r\\n\"));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"OK\\r\\n\")"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_response",
          "args": [
            "\"OK\\r\\n\""
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "receive_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1063-1071",
          "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity 0\\r\\n\")"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"verbosity 0\\r\\n\""
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_response(\"OK\\r\\n\")"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity 1\\r\\n\")"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity\\r\\n\")"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity 0 noreply\\r\\n\")"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_ascii_version()"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ascii_version",
          "args": [],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity noreply\\r\\n\")"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"verbosity foo bar my\\r\\n\")"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_ascii_verbosity(void) {\n  /* This command does not adhere to the spec! */\n  execute(send_string(\"verbosity foo bar my\\r\\n\"));\n  execute(receive_error_response());\n\n  execute(send_string(\"verbosity noreply\\r\\n\"));\n  execute(test_ascii_version());\n\n  execute(send_string(\"verbosity 0 noreply\\r\\n\"));\n  execute(test_ascii_version());\n\n  execute(send_string(\"verbosity\\r\\n\"));\n  execute(receive_error_response());\n\n  execute(send_string(\"verbosity 1\\r\\n\"));\n  execute(receive_response(\"OK\\r\\n\"));\n\n  execute(send_string(\"verbosity 0\\r\\n\"));\n  execute(receive_response(\"OK\\r\\n\"));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1101-1130",
    "snippet": "static enum test_return test_ascii_version(void) {\n  /* Verify that version works */\n  execute(send_string(\"version\\r\\n\"));\n  char buffer[256];\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VERSION \", 8) == 0);\n\n  char *version = &buffer[sizeof(\"VERSION\")];\n  if (version[0] > '1' || (version[0] == '1' && version[2] >= '6')) {\n    v16x_or_greater = true;\n  }\n\n  /* Verify that version command handles unknown options */\n  execute(send_string(\"version foo bar\\r\\n\"));\n  if (v16x_or_greater) {\n    execute(receive_line(buffer, sizeof(buffer)));\n    verify(strncmp(buffer, \"VERSION \", 8) == 0);\n  } else {\n    execute(receive_error_response());\n  }\n  /* version doesn't support noreply */\n  execute(send_string(\"version noreply\\r\\n\"));\n  if (v16x_or_greater) {\n    execute(receive_line(buffer, sizeof(buffer)));\n    verify(strncmp(buffer, \"VERSION \", 8) == 0);\n  } else {\n    execute(receive_error_response());\n  }\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool v16x_or_greater = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VERSION \", 8) == 0"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VERSION \"",
            "8"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"version noreply\\r\\n\")"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"version noreply\\r\\n\""
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VERSION \", 8) == 0"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VERSION \"",
            "8"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"version foo bar\\r\\n\")"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"VERSION \", 8) == 0"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"VERSION \"",
            "8"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"version\\r\\n\")"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic bool v16x_or_greater = false;\n\nstatic enum test_return test_ascii_version(void) {\n  /* Verify that version works */\n  execute(send_string(\"version\\r\\n\"));\n  char buffer[256];\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"VERSION \", 8) == 0);\n\n  char *version = &buffer[sizeof(\"VERSION\")];\n  if (version[0] > '1' || (version[0] == '1' && version[2] >= '6')) {\n    v16x_or_greater = true;\n  }\n\n  /* Verify that version command handles unknown options */\n  execute(send_string(\"version foo bar\\r\\n\"));\n  if (v16x_or_greater) {\n    execute(receive_line(buffer, sizeof(buffer)));\n    verify(strncmp(buffer, \"VERSION \", 8) == 0);\n  } else {\n    execute(receive_error_response());\n  }\n  /* version doesn't support noreply */\n  execute(send_string(\"version noreply\\r\\n\"));\n  if (v16x_or_greater) {\n    execute(receive_line(buffer, sizeof(buffer)));\n    verify(strncmp(buffer, \"VERSION \", 8) == 0);\n  } else {\n    execute(receive_error_response());\n  }\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_ascii_quit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1081-1099",
    "snippet": "static enum test_return test_ascii_quit(void) {\n  if (!v16x_or_greater) {\n    /* Verify that quit handles unknown options */\n    execute(send_string(\"quit foo bar\\r\\n\"));\n    execute(receive_error_response());\n\n    /* quit doesn't support noreply */\n    execute(send_string(\"quit noreply\\r\\n\"));\n    execute(receive_error_response());\n  }\n\n  /* Verify that quit works */\n  execute(send_string(\"quit\\r\\n\"));\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  char buffer[80];\n  verify(timeout_io_op(sock, POLLIN, buffer, sizeof(buffer)) == 0);\n  return TEST_PASS_RECONNECT;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;",
      "static bool v16x_or_greater = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "timeout_io_op(sock, POLLIN, buffer, sizeof(buffer)) == 0"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_io_op",
          "args": [
            "sock",
            "POLLIN",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_io_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "176-207",
          "snippet": "static ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int timeout = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic int timeout = 2;\n\nstatic ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"quit\\r\\n\")"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_string",
          "args": [
            "\"quit\\r\\n\""
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "send_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1041-1044",
          "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"quit noreply\\r\\n\")"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_error_response()"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_error_response",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_string(\"quit foo bar\\r\\n\")"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\nstatic bool v16x_or_greater = false;\n\nstatic enum test_return test_ascii_quit(void) {\n  if (!v16x_or_greater) {\n    /* Verify that quit handles unknown options */\n    execute(send_string(\"quit foo bar\\r\\n\"));\n    execute(receive_error_response());\n\n    /* quit doesn't support noreply */\n    execute(send_string(\"quit noreply\\r\\n\"));\n    execute(receive_error_response());\n  }\n\n  /* Verify that quit works */\n  execute(send_string(\"quit\\r\\n\"));\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  char buffer[80];\n  verify(timeout_io_op(sock, POLLIN, buffer, sizeof(buffer)) == 0);\n  return TEST_PASS_RECONNECT;\n}"
  },
  {
    "function_name": "receive_error_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1073-1079",
    "snippet": "static enum test_return receive_error_response(void) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"ERROR\", 5) == 0 || strncmp(buffer, \"CLIENT_ERROR\", 12) == 0\n         || strncmp(buffer, \"SERVER_ERROR\", 12) == 0);\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strncmp(buffer, \"ERROR\", 5) == 0 || strncmp(buffer, \"CLIENT_ERROR\", 12) == 0\n         || strncmp(buffer, \"SERVER_ERROR\", 12) == 0"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"SERVER_ERROR\"",
            "12"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"CLIENT_ERROR\"",
            "12"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"ERROR\"",
            "5"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_error_response(void) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  verify(strncmp(buffer, \"ERROR\", 5) == 0 || strncmp(buffer, \"CLIENT_ERROR\", 12) == 0\n         || strncmp(buffer, \"SERVER_ERROR\", 12) == 0);\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "receive_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1063-1071",
    "snippet": "static enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "strcmp(msg, buffer) == 0"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "msg",
            "buffer"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"[%s]\\n\"",
            "buffer"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "msg",
            "buffer"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_line(buffer, sizeof(buffer))"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_line",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "receive_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "1046-1061",
          "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_response(const char *msg) {\n  char buffer[80];\n  execute(receive_line(buffer, sizeof(buffer)));\n  if (strcmp(msg, buffer)) {\n    fprintf(stderr, \"[%s]\\n\", buffer);\n  }\n  verify(strcmp(msg, buffer) == 0);\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "receive_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1046-1061",
    "snippet": "static enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(buffer + offset, 1)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "buffer + offset",
            "1"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_line(char *buffer, size_t size) {\n  size_t offset = 0;\n  while (offset < size) {\n    execute(retry_read(buffer + offset, 1));\n    if (buffer[offset] == '\\n') {\n      if (offset + 1 < size) {\n        buffer[offset + 1] = '\\0';\n        return TEST_PASS;\n      } else\n        return TEST_FAIL;\n    }\n    ++offset;\n  }\n\n  return TEST_FAIL;\n}"
  },
  {
    "function_name": "send_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1041-1044",
    "snippet": "static enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_write(cmd, strlen(cmd))"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_write",
          "args": [
            "cmd",
            "strlen(cmd)"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "retry_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "245-261",
          "snippet": "static enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_string(const char *cmd) {\n  execute(retry_write(cmd, strlen(cmd)));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1025-1039",
    "snippet": "static enum test_return test_binary_stat(void) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_STAT, NULL, 0, NULL, 0);\n  execute(send_packet(&cmd));\n\n  do {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_STAT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } while (rsp.plain.message.header.response.keylen);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_STAT, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_STAT",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_STAT",
            "NULL",
            "0",
            "NULL",
            "0"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_stat(void) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_STAT, NULL, 0, NULL, 0);\n  execute(send_packet(&cmd));\n\n  do {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_STAT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } while (rsp.plain.message.header.response.keylen);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_prependq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1021-1023",
    "snippet": "static enum test_return test_binary_prependq(void) {\n  return test_binary_concat_impl(\"test_binary_prependq\", PROTOCOL_BINARY_CMD_PREPENDQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_concat_impl",
          "args": [
            "\"test_binary_prependq\"",
            "PROTOCOL_BINARY_CMD_PREPENDQ"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "971-1007",
          "snippet": "static enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_prependq(void) {\n  return test_binary_concat_impl(\"test_binary_prependq\", PROTOCOL_BINARY_CMD_PREPENDQ);\n}"
  },
  {
    "function_name": "test_binary_appendq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1017-1019",
    "snippet": "static enum test_return test_binary_appendq(void) {\n  return test_binary_concat_impl(\"test_binary_appendq\", PROTOCOL_BINARY_CMD_APPENDQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_concat_impl",
          "args": [
            "\"test_binary_appendq\"",
            "PROTOCOL_BINARY_CMD_APPENDQ"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "971-1007",
          "snippet": "static enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_appendq(void) {\n  return test_binary_concat_impl(\"test_binary_appendq\", PROTOCOL_BINARY_CMD_APPENDQ);\n}"
  },
  {
    "function_name": "test_binary_prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1013-1015",
    "snippet": "static enum test_return test_binary_prepend(void) {\n  return test_binary_concat_impl(\"test_binary_prepend\", PROTOCOL_BINARY_CMD_PREPEND);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_concat_impl",
          "args": [
            "\"test_binary_prepend\"",
            "PROTOCOL_BINARY_CMD_PREPEND"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "971-1007",
          "snippet": "static enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_prepend(void) {\n  return test_binary_concat_impl(\"test_binary_prepend\", PROTOCOL_BINARY_CMD_PREPEND);\n}"
  },
  {
    "function_name": "test_binary_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "1009-1011",
    "snippet": "static enum test_return test_binary_append(void) {\n  return test_binary_concat_impl(\"test_binary_append\", PROTOCOL_BINARY_CMD_APPEND);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_concat_impl",
          "args": [
            "\"test_binary_append\"",
            "PROTOCOL_BINARY_CMD_APPEND"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_concat_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "971-1007",
          "snippet": "static enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_append(void) {\n  return test_binary_concat_impl(\"test_binary_append\", PROTOCOL_BINARY_CMD_APPEND);\n}"
  },
  {
    "function_name": "test_binary_concat_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "971-1007",
    "snippet": "static enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcmp(rsp.bytes + 28, \"hello world\", 11) == 0"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "rsp.bytes + 28",
            "\"hello world\"",
            "11"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp.plain.message.header.response.bodylen - 4 == 11"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_GET",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_GET",
            "key",
            "strlen(key)",
            "NULL",
            "0"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "binary_set_item(key, value)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_set_item",
          "args": [
            "key",
            "value"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "binary_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "700-708",
          "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  const char *value;\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \"hello\";\n  } else {\n    value = \" world\";\n  }\n\n  execute(binary_set_item(key, value));\n\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_APPENDQ) {\n    value = \" world\";\n  } else {\n    value = \"hello\";\n  }\n\n  raw_command(&cmd, cc, key, strlen(key), value, strlen(value));\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_APPEND || cc == PROTOCOL_BINARY_CMD_PREPEND) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else {\n    execute(test_binary_noop());\n  }\n\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  verify(rsp.plain.message.header.response.bodylen - 4 == 11);\n  verify(memcmp(rsp.bytes + 28, \"hello world\", 11) == 0);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_flushq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "967-969",
    "snippet": "static enum test_return test_binary_flushq(void) {\n  return test_binary_flush_impl(\"test_binary_flushq\", PROTOCOL_BINARY_CMD_FLUSHQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_flush_impl",
          "args": [
            "\"test_binary_flushq\"",
            "PROTOCOL_BINARY_CMD_FLUSHQ"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_flush_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "938-961",
          "snippet": "static enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_flushq(void) {\n  return test_binary_flush_impl(\"test_binary_flushq\", PROTOCOL_BINARY_CMD_FLUSHQ);\n}"
  },
  {
    "function_name": "test_binary_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "963-965",
    "snippet": "static enum test_return test_binary_flush(void) {\n  return test_binary_flush_impl(\"test_binary_flush\", PROTOCOL_BINARY_CMD_FLUSH);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_flush_impl",
          "args": [
            "\"test_binary_flush\"",
            "PROTOCOL_BINARY_CMD_FLUSH"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_flush_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "938-961",
          "snippet": "static enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_flush(void) {\n  return test_binary_flush_impl(\"test_binary_flush\", PROTOCOL_BINARY_CMD_FLUSH);\n}"
  },
  {
    "function_name": "test_binary_flush_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "938-961",
    "snippet": "static enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_GET",
            "PROTOCOL_BINARY_RESPONSE_KEY_ENOENT"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_GET",
            "key",
            "strlen(key)",
            "NULL",
            "0"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_command",
          "args": [
            "&cmd",
            "cc",
            "0",
            "ii == 0"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "flush_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "401-412",
          "snippet": "static void flush_command(command *cmd, uint8_t cc, uint32_t exptime, bool use_extra) {\n  memset(cmd, 0, sizeof(cmd->flush));\n  cmd->flush.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->flush.message.header.request.opcode = cc;\n  cmd->flush.message.header.request.opaque = 0xdeadbeef;\n\n  if (exptime || use_extra) {\n    cmd->flush.message.header.request.extlen = 4;\n    cmd->flush.message.body.expiration = htonl(exptime);\n    cmd->flush.message.header.request.bodylen = 4;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void flush_command(command *cmd, uint8_t cc, uint32_t exptime, bool use_extra) {\n  memset(cmd, 0, sizeof(cmd->flush));\n  cmd->flush.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->flush.message.header.request.opcode = cc;\n  cmd->flush.message.header.request.opaque = 0xdeadbeef;\n\n  if (exptime || use_extra) {\n    cmd->flush.message.header.request.extlen = 4;\n    cmd->flush.message.body.expiration = htonl(exptime);\n    cmd->flush.message.header.request.bodylen = 4;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "binary_set_item(key, key)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_set_item",
          "args": [
            "key",
            "key"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "binary_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "700-708",
          "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_flush_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  for (int ii = 0; ii < 2; ++ii) {\n    execute(binary_set_item(key, key));\n    flush_command(&cmd, cc, 0, ii == 0);\n    execute(send_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_FLUSH) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n\n    raw_command(&cmd, PROTOCOL_BINARY_CMD_GET, key, strlen(key), NULL, 0);\n    execute(send_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_GET,\n                                    PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "925-936",
    "snippet": "static enum test_return test_binary_version(void) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_VERSION, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_VERSION,\n                                  PROTOCOL_BINARY_RESPONSE_SUCCESS));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_VERSION,\n                                  PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_VERSION",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_VERSION",
            "NULL",
            "0",
            "NULL",
            "0"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_version(void) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_VERSION, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_VERSION,\n                                  PROTOCOL_BINARY_RESPONSE_SUCCESS));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_decrq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "921-923",
    "snippet": "static enum test_return test_binary_decrq(void) {\n  return test_binary_decr_impl(\"test_binary_decrq\", PROTOCOL_BINARY_CMD_DECREMENTQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_decr_impl",
          "args": [
            "\"test_binary_decrq\"",
            "PROTOCOL_BINARY_CMD_DECREMENTQ"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_decr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "882-915",
          "snippet": "static enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_decrq(void) {\n  return test_binary_decr_impl(\"test_binary_decrq\", PROTOCOL_BINARY_CMD_DECREMENTQ);\n}"
  },
  {
    "function_name": "test_binary_decr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "917-919",
    "snippet": "static enum test_return test_binary_decr(void) {\n  return test_binary_decr_impl(\"test_binary_decr\", PROTOCOL_BINARY_CMD_DECREMENT);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_decr_impl",
          "args": [
            "\"test_binary_decr\"",
            "PROTOCOL_BINARY_CMD_DECREMENT"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_decr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "882-915",
          "snippet": "static enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_decr(void) {\n  return test_binary_decr_impl(\"test_binary_decr\", PROTOCOL_BINARY_CMD_DECREMENT);\n}"
  },
  {
    "function_name": "test_binary_decr_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "882-915",
    "snippet": "static enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcached_ntohll(rsp.decr.message.body.value) == 0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_ntohll",
          "args": [
            "rsp.decr.message.body.value"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arithmetic_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "1",
            "9",
            "0"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "arithmetic_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "423-438",
          "snippet": "static void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_decr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 9, 0);\n\n  int ii;\n  for (ii = 9; ii > -1; --ii) {\n    if (ii == 9)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.decr.message.body.value) == (uint64_t) ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* decr 0 should not wrap */\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DECREMENT) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    verify(memcached_ntohll(rsp.decr.message.body.value) == 0);\n  } else {\n    /* @todo get the value and verify! */\n  }\n\n  /* @todo add incorrect cas */\n  execute(test_binary_noop());\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_incrq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "878-880",
    "snippet": "static enum test_return test_binary_incrq(void) {\n  return test_binary_incr_impl(\"test_binary_incrq\", PROTOCOL_BINARY_CMD_INCREMENTQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_incr_impl",
          "args": [
            "\"test_binary_incrq\"",
            "PROTOCOL_BINARY_CMD_INCREMENTQ"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_incr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "850-872",
          "snippet": "static enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_incrq(void) {\n  return test_binary_incr_impl(\"test_binary_incrq\", PROTOCOL_BINARY_CMD_INCREMENTQ);\n}"
  },
  {
    "function_name": "test_binary_incr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "874-876",
    "snippet": "static enum test_return test_binary_incr(void) {\n  return test_binary_incr_impl(\"test_binary_incr\", PROTOCOL_BINARY_CMD_INCREMENT);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_incr_impl",
          "args": [
            "\"test_binary_incr\"",
            "PROTOCOL_BINARY_CMD_INCREMENT"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_incr_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "850-872",
          "snippet": "static enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_incr(void) {\n  return test_binary_incr_impl(\"test_binary_incr\", PROTOCOL_BINARY_CMD_INCREMENT);\n}"
  },
  {
    "function_name": "test_binary_incr_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "850-872",
    "snippet": "static enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "memcached_ntohll(rsp.incr.message.body.value) == ii"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_ntohll",
          "args": [
            "rsp.incr.message.body.value"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arithmetic_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "1",
            "0",
            "0"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "arithmetic_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "423-438",
          "snippet": "static void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_incr_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  arithmetic_command(&cmd, cc, key, strlen(key), 1, 0, 0);\n\n  uint64_t ii;\n  for (ii = 0; ii < 10; ++ii) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_INCREMENT) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n      verify(memcached_ntohll(rsp.incr.message.body.value) == ii);\n    } else\n      execute(test_binary_noop());\n  }\n\n  /* @todo add incorrect CAS */\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_getkq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "846-848",
    "snippet": "static enum test_return test_binary_getkq(void) {\n  return test_binary_get_impl(\"test_binary_getkq\", PROTOCOL_BINARY_CMD_GETKQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_get_impl",
          "args": [
            "\"test_binary_getkq\"",
            "PROTOCOL_BINARY_CMD_GETKQ"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_get_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "808-832",
          "snippet": "static enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_getkq(void) {\n  return test_binary_get_impl(\"test_binary_getkq\", PROTOCOL_BINARY_CMD_GETKQ);\n}"
  },
  {
    "function_name": "test_binary_getq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "842-844",
    "snippet": "static enum test_return test_binary_getq(void) {\n  return test_binary_get_impl(\"test_binary_getq\", PROTOCOL_BINARY_CMD_GETQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_get_impl",
          "args": [
            "\"test_binary_getq\"",
            "PROTOCOL_BINARY_CMD_GETQ"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_get_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "808-832",
          "snippet": "static enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_getq(void) {\n  return test_binary_get_impl(\"test_binary_getq\", PROTOCOL_BINARY_CMD_GETQ);\n}"
  },
  {
    "function_name": "test_binary_getk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "838-840",
    "snippet": "static enum test_return test_binary_getk(void) {\n  return test_binary_get_impl(\"test_binary_getk\", PROTOCOL_BINARY_CMD_GETK);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_get_impl",
          "args": [
            "\"test_binary_getk\"",
            "PROTOCOL_BINARY_CMD_GETK"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_get_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "808-832",
          "snippet": "static enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_getk(void) {\n  return test_binary_get_impl(\"test_binary_getk\", PROTOCOL_BINARY_CMD_GETK);\n}"
  },
  {
    "function_name": "test_binary_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "834-836",
    "snippet": "static enum test_return test_binary_get(void) {\n  return test_binary_get_impl(\"test_binary_get\", PROTOCOL_BINARY_CMD_GET);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_get_impl",
          "args": [
            "\"test_binary_get\"",
            "PROTOCOL_BINARY_CMD_GET"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_get_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "808-832",
          "snippet": "static enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get(void) {\n  return test_binary_get_impl(\"test_binary_get\", PROTOCOL_BINARY_CMD_GET);\n}"
  },
  {
    "function_name": "test_binary_get_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "808-832",
    "snippet": "static enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "binary_set_item(key, key)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_set_item",
          "args": [
            "key",
            "key"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "binary_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "700-708",
          "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "NULL",
            "0"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n\n  if (cc == PROTOCOL_BINARY_CMD_GET || cc == PROTOCOL_BINARY_CMD_GETK) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  }\n\n  execute(receive_binary_noop());\n\n  execute(binary_set_item(key, key));\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_deleteq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "804-806",
    "snippet": "static enum test_return test_binary_deleteq(void) {\n  return test_binary_delete_impl(\"test_binary_deleteq\", PROTOCOL_BINARY_CMD_DELETEQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_delete_impl",
          "args": [
            "\"test_binary_deleteq\"",
            "PROTOCOL_BINARY_CMD_DELETEQ"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_delete_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "775-798",
          "snippet": "static enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_deleteq(void) {\n  return test_binary_delete_impl(\"test_binary_deleteq\", PROTOCOL_BINARY_CMD_DELETEQ);\n}"
  },
  {
    "function_name": "test_binary_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "800-802",
    "snippet": "static enum test_return test_binary_delete(void) {\n  return test_binary_delete_impl(\"test_binary_delete\", PROTOCOL_BINARY_CMD_DELETE);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_delete_impl",
          "args": [
            "\"test_binary_delete\"",
            "PROTOCOL_BINARY_CMD_DELETE"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_delete_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "775-798",
          "snippet": "static enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_delete(void) {\n  return test_binary_delete_impl(\"test_binary_delete\", PROTOCOL_BINARY_CMD_DELETE);\n}"
  },
  {
    "function_name": "test_binary_delete_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "775-798",
    "snippet": "static enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "binary_set_item(key, key)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_set_item",
          "args": [
            "key",
            "key"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "binary_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "700-708",
          "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "NULL",
            "0"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_delete_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, key, strlen(key), NULL, 0);\n\n  /* The delete shouldn't work the first time, because the item isn't there */\n  execute(send_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT));\n  execute(receive_binary_noop());\n  execute(binary_set_item(key, key));\n\n  /* The item should be present now, resend*/\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_DELETE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  execute(test_binary_noop());\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_replaceq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "771-773",
    "snippet": "static enum test_return test_binary_replaceq(void) {\n  return test_binary_replace_impl(\"test_binary_replaceq\", PROTOCOL_BINARY_CMD_REPLACEQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_replace_impl",
          "args": [
            "\"test_binary_replaceq\"",
            "PROTOCOL_BINARY_CMD_REPLACEQ"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_replace_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "710-765",
          "snippet": "static enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_replaceq(void) {\n  return test_binary_replace_impl(\"test_binary_replaceq\", PROTOCOL_BINARY_CMD_REPLACEQ);\n}"
  },
  {
    "function_name": "test_binary_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "767-769",
    "snippet": "static enum test_return test_binary_replace(void) {\n  return test_binary_replace_impl(\"test_binary_replace\", PROTOCOL_BINARY_CMD_REPLACE);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_replace_impl",
          "args": [
            "\"test_binary_replace\"",
            "PROTOCOL_BINARY_CMD_REPLACE"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_replace_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "710-765",
          "snippet": "static enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_replace(void) {\n  return test_binary_replace_impl(\"test_binary_replace\", PROTOCOL_BINARY_CMD_REPLACE);\n}"
  },
  {
    "function_name": "test_binary_replace_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "710-765",
    "snippet": "static enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_htonll",
          "args": [
            "rsp.plain.message.header.response.cas - 1"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "binary_set_item(key, key)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_set_item",
          "args": [
            "key",
            "key"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "binary_set_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "700-708",
          "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, expected_result)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "&value",
            "sizeof(value)",
            "0",
            "0"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "storage_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "345-364",
          "snippet": "static void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_replace_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first replace should fail, successive should succeed (when the\n     item is added! */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_REPLACE || ii == 0) {\n      uint16_t expected_result;\n      if (ii == 0) {\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n      } else {\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      }\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n\n      if (ii == 0)\n        execute(binary_set_item(key, key));\n    } else {\n      execute(test_binary_noop());\n    }\n  }\n\n  /* verify that replace with CAS value works! */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n\n  if (cc == PROTOCOL_BINARY_CMD_REPLACE) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  execute(receive_binary_noop());\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "binary_set_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "700-708",
    "snippet": "static enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_SET",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_SET",
            "key",
            "strlen(key)",
            "value",
            "strlen(value)",
            "0",
            "0"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "storage_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "345-364",
          "snippet": "static void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return binary_set_item(const char *key, const char *value) {\n  command cmd;\n  response rsp;\n  storage_command(&cmd, PROTOCOL_BINARY_CMD_SET, key, strlen(key), value, strlen(value), 0, 0);\n  execute(send_packet(&cmd));\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_addq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "696-698",
    "snippet": "static enum test_return test_binary_addq(void) {\n  return test_binary_add_impl(\"test_binary_addq\", PROTOCOL_BINARY_CMD_ADDQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_add_impl",
          "args": [
            "\"test_binary_addq\"",
            "PROTOCOL_BINARY_CMD_ADDQ"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_add_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "660-690",
          "snippet": "static enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_addq(void) {\n  return test_binary_add_impl(\"test_binary_addq\", PROTOCOL_BINARY_CMD_ADDQ);\n}"
  },
  {
    "function_name": "test_binary_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "692-694",
    "snippet": "static enum test_return test_binary_add(void) {\n  return test_binary_add_impl(\"test_binary_add\", PROTOCOL_BINARY_CMD_ADD);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_add_impl",
          "args": [
            "\"test_binary_add\"",
            "PROTOCOL_BINARY_CMD_ADD"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_add_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "660-690",
          "snippet": "static enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_add(void) {\n  return test_binary_add_impl(\"test_binary_add\", PROTOCOL_BINARY_CMD_ADD);\n}"
  },
  {
    "function_name": "test_binary_add_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "660-690",
    "snippet": "static enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, expected_result)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "expected_result"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "&value",
            "sizeof(value)",
            "0",
            "0"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "storage_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "345-364",
          "snippet": "static void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_add_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* first add should work, rest of them should fail (even with cas\n     as wildcard */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0)\n      execute(send_packet(&cmd));\n    else\n      execute(resend_packet(&cmd));\n\n    if (cc == PROTOCOL_BINARY_CMD_ADD || ii > 0) {\n      uint16_t expected_result;\n      if (ii == 0)\n        expected_result = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n      else\n        expected_result = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n\n      execute(send_binary_noop());\n      execute(recv_packet(&rsp));\n      execute(receive_binary_noop());\n      verify(validate_response_header(&rsp, cc, expected_result));\n    } else\n      execute(test_binary_noop());\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_setq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "656-658",
    "snippet": "static enum test_return test_binary_setq(void) {\n  return test_binary_set_impl(\"test_binary_setq\", PROTOCOL_BINARY_CMD_SETQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_set_impl",
          "args": [
            "\"test_binary_setq\"",
            "PROTOCOL_BINARY_CMD_SETQ"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_set_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "596-650",
          "snippet": "static enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_setq(void) {\n  return test_binary_set_impl(\"test_binary_setq\", PROTOCOL_BINARY_CMD_SETQ);\n}"
  },
  {
    "function_name": "test_binary_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "652-654",
    "snippet": "static enum test_return test_binary_set(void) {\n  return test_binary_set_impl(\"test_binary_set\", PROTOCOL_BINARY_CMD_SET);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_set_impl",
          "args": [
            "\"test_binary_set\"",
            "PROTOCOL_BINARY_CMD_SET"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_set_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "596-650",
          "snippet": "static enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_set(void) {\n  return test_binary_set_impl(\"test_binary_set\", PROTOCOL_BINARY_CMD_SET);\n}"
  },
  {
    "function_name": "test_binary_set_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "596-650",
    "snippet": "static enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "cc",
            "PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "&cmd"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_htonll",
          "args": [
            "rsp.plain.message.header.response.cas - 1"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "test_binary_noop()"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_binary_noop",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(&cmd)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_command",
          "args": [
            "&cmd",
            "cc",
            "key",
            "strlen(key)",
            "&value",
            "sizeof(value)",
            "0",
            "0"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "storage_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "345-364",
          "snippet": "static void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_set_impl(const char *key, uint8_t cc) {\n  command cmd;\n  response rsp;\n\n  uint64_t value = 0xdeadbeefdeadcafeULL;\n  storage_command(&cmd, cc, key, strlen(key), &value, sizeof(value), 0, 0);\n\n  /* set should always work */\n  for (int ii = 0; ii < 10; ii++) {\n    if (ii == 0) {\n      execute(send_packet(&cmd));\n    } else {\n      execute(resend_packet(&cmd));\n    }\n\n    if (cc == PROTOCOL_BINARY_CMD_SET) {\n      execute(recv_packet(&rsp));\n      verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    } else\n      execute(test_binary_noop());\n  }\n\n  /*\n   * We need to get the current CAS id, and at this time we haven't\n   * verified that we have a working get\n   */\n  if (cc == PROTOCOL_BINARY_CMD_SETQ) {\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SET;\n    execute(resend_packet(&cmd));\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_SET, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n    cmd.set.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n  }\n\n  /* try to set with the correct CAS value */\n  cmd.plain.message.header.request.cas = memcached_htonll(rsp.plain.message.header.response.cas);\n  execute(resend_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_SET) {\n    execute(recv_packet(&rsp));\n    verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  } else\n    execute(test_binary_noop());\n\n  /* try to set with an incorrect CAS value */\n  cmd.plain.message.header.request.cas =\n      memcached_htonll(rsp.plain.message.header.response.cas - 1);\n  execute(resend_packet(&cmd));\n  execute(send_binary_noop());\n  execute(recv_packet(&rsp));\n  verify(validate_response_header(&rsp, cc, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS));\n  execute(receive_binary_noop());\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "test_binary_quitq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "592-594",
    "snippet": "static enum test_return test_binary_quitq(void) {\n  return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_quit_impl",
          "args": [
            "PROTOCOL_BINARY_CMD_QUITQ"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_quit_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "570-586",
          "snippet": "static enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_quitq(void) {\n  return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);\n}"
  },
  {
    "function_name": "test_binary_quit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "588-590",
    "snippet": "static enum test_return test_binary_quit(void) {\n  return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_binary_quit_impl",
          "args": [
            "PROTOCOL_BINARY_CMD_QUIT"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "test_binary_quit_impl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "570-586",
          "snippet": "static enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_quit(void) {\n  return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);\n}"
  },
  {
    "function_name": "test_binary_quit_impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "570-586",
    "snippet": "static enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_io_op",
          "args": [
            "sock",
            "POLLIN",
            "rsp.bytes",
            "sizeof(rsp.bytes)"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_io_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "176-207",
          "snippet": "static ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int timeout = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic int timeout = 2;\n\nstatic ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_QUIT",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "cc",
            "NULL",
            "0",
            "NULL",
            "0"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return test_binary_quit_impl(uint8_t cc) {\n  command cmd;\n  response rsp;\n  raw_command(&cmd, cc, NULL, 0, NULL, 0);\n\n  execute(send_packet(&cmd));\n  if (cc == PROTOCOL_BINARY_CMD_QUIT) {\n    execute(recv_packet(&rsp));\n    verify(\n        validate_response_header(&rsp, PROTOCOL_BINARY_CMD_QUIT, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  }\n\n  /* Socket should be closed now, read should return EXIT_SUCCESS */\n  verify(timeout_io_op(sock, POLLIN, rsp.bytes, sizeof(rsp.bytes)) == 0);\n\n  return TEST_PASS_RECONNECT;\n}"
  },
  {
    "function_name": "test_binary_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "564-568",
    "snippet": "static enum test_return test_binary_noop(void) {\n  execute(send_binary_noop());\n  execute(receive_binary_noop());\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "receive_binary_noop()"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_binary_noop",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_binary_noop()"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_binary_noop",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return test_binary_noop(void) {\n  execute(send_binary_noop());\n  execute(receive_binary_noop());\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "receive_binary_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "556-562",
    "snippet": "static enum test_return receive_binary_noop(void) {\n  response rsp;\n  execute(recv_packet(&rsp));\n  verify(\n      validate_response_header(&rsp, PROTOCOL_BINARY_CMD_NOOP, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "validate_response_header(&rsp, PROTOCOL_BINARY_CMD_NOOP, PROTOCOL_BINARY_RESPONSE_SUCCESS)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_response_header",
          "args": [
            "&rsp",
            "PROTOCOL_BINARY_CMD_NOOP",
            "PROTOCOL_BINARY_RESPONSE_SUCCESS"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "do_validate_response_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "446-540",
          "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "recv_packet(&rsp)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv_packet",
          "args": [
            "&rsp"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "recv_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "317-331",
          "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return receive_binary_noop(void) {\n  response rsp;\n  execute(recv_packet(&rsp));\n  verify(\n      validate_response_header(&rsp, PROTOCOL_BINARY_CMD_NOOP, PROTOCOL_BINARY_RESPONSE_SUCCESS));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "send_binary_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "549-554",
    "snippet": "static enum test_return send_binary_noop(void) {\n  command cmd;\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_NOOP, NULL, 0, NULL, 0);\n  execute(send_packet(&cmd));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "send_packet(&cmd)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_packet",
          "args": [
            "&cmd"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "send_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "279-287",
          "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_command",
          "args": [
            "&cmd",
            "PROTOCOL_BINARY_CMD_NOOP",
            "NULL",
            "0",
            "NULL",
            "0"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "raw_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "375-392",
          "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_binary_noop(void) {\n  command cmd;\n  raw_command(&cmd, PROTOCOL_BINARY_CMD_NOOP, NULL, 0, NULL, 0);\n  execute(send_packet(&cmd));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "do_validate_response_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "446-540",
    "snippet": "static enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas == 0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 4"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 4"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas == 0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.bodylen"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas == 0"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.bodylen == 8"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas == 0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.bodylen == 0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.cas"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.bodylen == 0"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.extlen == 0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.keylen == 0"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "\"Quiet command shouldn't return on success\" == NULL"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.opaque == 0xdeadbeef"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.status == status"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.opcode == cc"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return do_validate_response_header(response *rsp, uint8_t cc, uint16_t status) {\n  verify(rsp->plain.message.header.response.magic == PROTOCOL_BINARY_RES);\n  verify(rsp->plain.message.header.response.opcode == cc);\n  verify(rsp->plain.message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n  verify(rsp->plain.message.header.response.status == status);\n  verify(rsp->plain.message.header.response.opaque == 0xdeadbeef);\n\n  if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n    case PROTOCOL_BINARY_CMD_QUITQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_SETQ:\n      verify(\"Quiet command shouldn't return on success\" == NULL);\n      /* fall through */\n    default:\n      break;\n    }\n\n    switch (cc) {\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_NOOP:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_DELETE:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 0);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_DECREMENT:\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen == 8);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_STAT:\n      verify(rsp->plain.message.header.response.extlen == 0);\n      /* key and value exists in all packets except in the terminating */\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_VERSION:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 0);\n      verify(rsp->plain.message.header.response.bodylen);\n      verify(rsp->plain.message.header.response.cas == 0);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GET:\n    case PROTOCOL_BINARY_CMD_GETQ:\n      verify(rsp->plain.message.header.response.keylen == 0);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    case PROTOCOL_BINARY_CMD_GETK:\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      verify(rsp->plain.message.header.response.keylen);\n      verify(rsp->plain.message.header.response.extlen == 4);\n      verify(rsp->plain.message.header.response.cas);\n      break;\n\n    default:\n      /* Undefined command code */\n      break;\n    }\n  } else {\n    verify(rsp->plain.message.header.response.cas == 0);\n    verify(rsp->plain.message.header.response.extlen == 0);\n    if (cc != PROTOCOL_BINARY_CMD_GETK) {\n      verify(rsp->plain.message.header.response.keylen == 0);\n    }\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "arithmetic_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "423-438",
    "snippet": "static void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cmd->bytes + key_offset",
            "key",
            "keylen"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "exptime"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmd",
            "0",
            "sizeof(cmd->incr)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void arithmetic_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                               uint64_t delta, uint64_t initial, uint32_t exptime) {\n  memset(cmd, 0, sizeof(cmd->incr));\n  cmd->incr.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->incr.message.header.request.opcode = cc;\n  cmd->incr.message.header.request.keylen = (uint16_t) keylen;\n  cmd->incr.message.header.request.extlen = 20;\n  cmd->incr.message.header.request.bodylen = (uint32_t)(keylen + 20);\n  cmd->incr.message.header.request.opaque = 0xdeadbeef;\n  cmd->incr.message.body.delta = memcached_htonll(delta);\n  cmd->incr.message.body.initial = memcached_htonll(initial);\n  cmd->incr.message.body.expiration = htonl(exptime);\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n}"
  },
  {
    "function_name": "flush_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "401-412",
    "snippet": "static void flush_command(command *cmd, uint8_t cc, uint32_t exptime, bool use_extra) {\n  memset(cmd, 0, sizeof(cmd->flush));\n  cmd->flush.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->flush.message.header.request.opcode = cc;\n  cmd->flush.message.header.request.opaque = 0xdeadbeef;\n\n  if (exptime || use_extra) {\n    cmd->flush.message.header.request.extlen = 4;\n    cmd->flush.message.body.expiration = htonl(exptime);\n    cmd->flush.message.header.request.bodylen = 4;\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "exptime"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmd",
            "0",
            "sizeof(cmd->flush)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void flush_command(command *cmd, uint8_t cc, uint32_t exptime, bool use_extra) {\n  memset(cmd, 0, sizeof(cmd->flush));\n  cmd->flush.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->flush.message.header.request.opcode = cc;\n  cmd->flush.message.header.request.opaque = 0xdeadbeef;\n\n  if (exptime || use_extra) {\n    cmd->flush.message.header.request.extlen = 4;\n    cmd->flush.message.body.expiration = htonl(exptime);\n    cmd->flush.message.header.request.bodylen = 4;\n  }\n}"
  },
  {
    "function_name": "raw_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "375-392",
    "snippet": "static void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cmd->bytes + key_offset + keylen",
            "dta",
            "dtalen"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cmd->bytes + key_offset",
            "key",
            "keylen"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmd",
            "0",
            "sizeof(*cmd)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void raw_command(command *cmd, uint8_t cc, const void *key, size_t keylen, const void *dta,\n                        size_t dtalen) {\n  /* all of the storage commands use the same command layout */\n  memset(cmd, 0, sizeof(*cmd));\n  cmd->plain.message.header.request.magic = PROTOCOL_BINARY_REQ;\n  cmd->plain.message.header.request.opcode = cc;\n  cmd->plain.message.header.request.keylen = (uint16_t) keylen;\n  cmd->plain.message.header.request.bodylen = (uint32_t)(keylen + dtalen);\n  cmd->plain.message.header.request.opaque = 0xdeadbeef;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n  if (key)\n    memcpy(cmd->bytes + key_offset, key, keylen);\n\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
  },
  {
    "function_name": "storage_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "345-364",
    "snippet": "static void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cmd->bytes + key_offset + keylen",
            "dta",
            "dtalen"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cmd->bytes + key_offset",
            "key",
            "keylen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "request",
            "0",
            "sizeof(*request)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic void storage_command(command *cmd, uint8_t cc, const void *key, size_t keylen,\n                            const void *dta, size_t dtalen, uint32_t flags, uint32_t exptime) {\n  /* all of the storage commands use the same command layout */\n  protocol_binary_request_set *request = &cmd->set;\n\n  memset(request, 0, sizeof(*request));\n  request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n  request->message.header.request.opcode = cc;\n  request->message.header.request.keylen = (uint16_t) keylen;\n  request->message.header.request.extlen = 8;\n  request->message.header.request.bodylen = (uint32_t)(keylen + 8 + dtalen);\n  request->message.header.request.opaque = 0xdeadbeef;\n  request->message.body.flags = flags;\n  request->message.body.expiration = exptime;\n\n  off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n  memcpy(cmd->bytes + key_offset, key, keylen);\n  if (dta)\n    memcpy(cmd->bytes + key_offset + keylen, dta, dtalen);\n}"
  },
  {
    "function_name": "recv_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "317-331",
    "snippet": "static enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_read",
          "args": [
            "rsp->bytes + sizeof(protocol_binary_response_no_extras)",
            "bodysz"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "retry_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "292-311",
          "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_ntohll",
          "args": [
            "rsp->plain.message.header.response.cas"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "rsp->plain.message.header.response.status"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "rsp->plain.message.header.response.keylen"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_read(rsp, sizeof(protocol_binary_response_no_extras))"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return recv_packet(response *rsp) {\n  execute(retry_read(rsp, sizeof(protocol_binary_response_no_extras)));\n\n  /* Fix the byte order in the packet header */\n  rsp->plain.message.header.response.keylen = ntohs(rsp->plain.message.header.response.keylen);\n  rsp->plain.message.header.response.status = ntohs(rsp->plain.message.header.response.status);\n  rsp->plain.message.header.response.bodylen = ntohl(rsp->plain.message.header.response.bodylen);\n  rsp->plain.message.header.response.cas = memcached_ntohll(rsp->plain.message.header.response.cas);\n\n  size_t bodysz = rsp->plain.message.header.response.bodylen;\n  if (bodysz > 0)\n    execute(retry_read(rsp->bytes + sizeof(protocol_binary_response_no_extras), bodysz));\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "retry_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "292-311",
    "snippet": "static enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "get_socket_errno() == EINTR || get_socket_errno() == EAGAIN"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Errno: %d %s\\n\"",
            "get_socket_errno()",
            "strerror(errno)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_io_op",
          "args": [
            "sock",
            "POLLIN",
            "((char *) buf) + offset",
            "len - offset"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_io_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "176-207",
          "snippet": "static ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int timeout = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic int timeout = 2;\n\nstatic ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_read(void *buf, size_t len) {\n  size_t offset = 0;\n  do {\n    ssize_t nr = timeout_io_op(sock, POLLIN, ((char *) buf) + offset, len - offset);\n    switch (nr) {\n    case -1:\n      fprintf(stderr, \"Errno: %d %s\\n\", get_socket_errno(), strerror(errno));\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n      break;\n\n    case 0:\n      return TEST_FAIL;\n\n    default:\n      offset += (size_t) nr;\n    }\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "send_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "279-287",
    "snippet": "static enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "resend_packet(cmd)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resend_packet",
          "args": [
            "cmd"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "resend_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "267-273",
          "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_ntohll",
          "args": [
            "cmd->plain.message.header.request.cas"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "cmd->plain.message.header.request.keylen"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return send_packet(command *cmd) {\n  /* Fix the byteorder of the header */\n  cmd->plain.message.header.request.keylen = ntohs(cmd->plain.message.header.request.keylen);\n  cmd->plain.message.header.request.bodylen = ntohl(cmd->plain.message.header.request.bodylen);\n  cmd->plain.message.header.request.cas = memcached_ntohll(cmd->plain.message.header.request.cas);\n\n  execute(resend_packet(cmd));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "resend_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "267-273",
    "snippet": "static enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "retry_write(cmd, length)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_write",
          "args": [
            "cmd",
            "length"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "retry_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "245-261",
          "snippet": "static enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_socket_t sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "cmd->plain.message.header.request.bodylen"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic enum test_return resend_packet(command *cmd) {\n  size_t length =\n      sizeof(protocol_binary_request_no_extras) + ntohl(cmd->plain.message.header.request.bodylen);\n\n  execute(retry_write(cmd, length));\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "retry_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "245-261",
    "snippet": "static enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify",
          "args": [
            "get_socket_errno() == EINTR || get_socket_errno() == EAGAIN"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_io_op",
          "args": [
            "sock",
            "POLLOUT",
            "(ptr + offset)",
            "num_bytes"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_io_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
          "lines": "176-207",
          "snippet": "static ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}",
          "includes": [
            "#include <vector>",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcachedprotocol-0.0/binary.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"p9y/socket.hpp\"",
            "#include \"p9y/getopt.hpp\"",
            "#  include <unistd.h>",
            "#include <sys/types.h>",
            "#include <csignal>",
            "#include <ciso646>",
            "#include <cinttypes>",
            "#include <fcntl.h>",
            "#include <cctype>",
            "#include <cstring>",
            "#include <cstdlib>",
            "#include <cstdio>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int timeout = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic int timeout = 2;\n\nstatic ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<const char *>",
          "args": [
            "buf"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic enum test_return retry_write(const void *buf, size_t len) {\n  size_t offset = 0;\n  const char *ptr = static_cast<const char *>(buf);\n\n  do {\n    size_t num_bytes = len - offset;\n    ssize_t nw = timeout_io_op(sock, POLLOUT, (ptr + offset), num_bytes);\n    if (nw == -1) {\n      verify(get_socket_errno() == EINTR || get_socket_errno() == EAGAIN);\n    } else {\n      offset += (size_t) nw;\n    }\n\n  } while (offset < len);\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "ensure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "215-229",
    "snippet": "static enum test_return ensure(bool val, const char *expression, const char *file, int line) {\n  if (!val) {\n    if (verbose) {\n      fprintf(stdout, \"\\n%s:%d: %s\", file, line, expression);\n    }\n\n    if (do_core) {\n      abort();\n    }\n\n    return TEST_FAIL;\n  }\n\n  return TEST_PASS;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool do_core = false;",
      "static bool verbose = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n%s:%d: %s\"",
            "file",
            "line",
            "expression"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic bool do_core = false;\nstatic bool verbose = false;\n\nstatic enum test_return ensure(bool val, const char *expression, const char *file, int line) {\n  if (!val) {\n    if (verbose) {\n      fprintf(stdout, \"\\n%s:%d: %s\", file, line, expression);\n    }\n\n    if (do_core) {\n      abort();\n    }\n\n    return TEST_FAIL;\n  }\n\n  return TEST_PASS;\n}"
  },
  {
    "function_name": "timeout_io_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "176-207",
    "snippet": "static ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int timeout = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Failed to poll\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "fd",
            "const_cast<char *>(buf)",
            "len",
            "0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<char *>",
          "args": [
            "buf"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "buf",
            "len",
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&fds",
            "1",
            "timeout * 1000"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "150-242",
          "snippet": "memcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fds",
            "0",
            "sizeof(struct pollfd)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "fd",
            "const_cast<char *>(buf)",
            "len",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<char *>",
          "args": [
            "buf"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "buf",
            "len",
            "0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic int timeout = 2;\n\nstatic ssize_t timeout_io_op(memcached_socket_t fd, short direction, const char *buf, size_t len) {\n  ssize_t ret;\n\n  if (direction == POLLOUT) {\n    ret = send(fd, buf, len, 0);\n  } else {\n    ret = recv(fd, const_cast<char *>(buf), len, 0);\n  }\n  int local_errno = get_socket_errno();\n  if (ret == SOCKET_ERROR && local_errno == EWOULDBLOCK || (EAGAIN != EWOULDBLOCK && local_errno == EAGAIN)) {\n    struct pollfd fds;\n    memset(&fds, 0, sizeof(struct pollfd));\n    fds.events = direction;\n    fds.fd = fd;\n\n    int err = poll(&fds, 1, timeout * 1000);\n    if (err == 1) {\n      if (direction == POLLOUT) {\n        ret = send(fd, buf, len, 0);\n      } else {\n        ret = recv(fd, const_cast<char *>(buf), len, 0);\n      }\n    } else if (err == 0) {\n      errno = ETIMEDOUT;\n    } else {\n      perror(\"Failed to poll\");\n      return -1;\n    }\n  }\n\n  return ret;\n}"
  },
  {
    "function_name": "connect_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "154-174",
    "snippet": "static memcached_socket_t connect_server(const char *hostname, const char *port) {\n  struct addrinfo *ai = lookuphost(hostname, port);\n  sock = INVALID_SOCKET;\n  if (ai) {\n    if ((sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) != INVALID_SOCKET) {\n      if (connect(sock, ai->ai_addr, ai->ai_addrlen) == SOCKET_ERROR) {\n        fprintf(stderr, \"Failed to connect socket: %s\\n\", strerror(get_socket_errno()));\n        closesocket(sock);\n        sock = INVALID_SOCKET;\n      } else {\n        sock = set_noblock();\n      }\n    } else {\n      fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(get_socket_errno()));\n    }\n\n    freeaddrinfo(ai);\n  }\n\n  return sock;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create socket: %s\\n\"",
            "strerror(get_socket_errno())"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "get_socket_errno()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_noblock",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to connect socket: %s\\n\"",
            "strerror(get_socket_errno())"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "get_socket_errno()"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "ai->ai_addr",
            "ai->ai_addrlen"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ai->ai_family",
            "ai->ai_socktype",
            "ai->ai_protocol"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_unix_socket_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "426-441",
          "snippet": "memcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookuphost",
          "args": [
            "hostname",
            "port"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic memcached_socket_t connect_server(const char *hostname, const char *port) {\n  struct addrinfo *ai = lookuphost(hostname, port);\n  sock = INVALID_SOCKET;\n  if (ai) {\n    if ((sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) != INVALID_SOCKET) {\n      if (connect(sock, ai->ai_addr, ai->ai_addrlen) == SOCKET_ERROR) {\n        fprintf(stderr, \"Failed to connect socket: %s\\n\", strerror(get_socket_errno()));\n        closesocket(sock);\n        sock = INVALID_SOCKET;\n      } else {\n        sock = set_noblock();\n      }\n    } else {\n      fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(get_socket_errno()));\n    }\n\n    freeaddrinfo(ai);\n  }\n\n  return sock;\n}"
  },
  {
    "function_name": "set_noblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcapable.cc",
    "lines": "121-146",
    "snippet": "static memcached_socket_t set_noblock(void) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(sock, FIONBIO, &arg) == SOCKET_ERROR) {\n    perror(\"Failed to set nonblocking io\");\n    closesocket(sock);\n    return INVALID_SOCKET;\n  }\n#else\n  int flags = fcntl(sock, F_GETFL, 0);\n  if (flags == -1) {\n    perror(\"Failed to get socket flags\");\n    closesocket(sock);\n    return INVALID_SOCKET;\n  }\n\n  if ((flags & O_NONBLOCK) != O_NONBLOCK) {\n    if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1) {\n      perror(\"Failed to set socket to nonblocking mode\");\n      closesocket(sock);\n      return INVALID_SOCKET;\n    }\n  }\n#endif\n  return sock;\n}",
    "includes": [
      "#include <vector>",
      "#include \"libmemcached/byteorder.h\"",
      "#include \"libmemcachedprotocol-0.0/binary.h\"",
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include \"p9y/poll.hpp\"",
      "#include \"p9y/socket.hpp\"",
      "#include \"p9y/getopt.hpp\"",
      "#  include <unistd.h>",
      "#include <sys/types.h>",
      "#include <csignal>",
      "#include <ciso646>",
      "#include <cinttypes>",
      "#include <fcntl.h>",
      "#include <cctype>",
      "#include <cstring>",
      "#include <cstdlib>",
      "#include <cstdio>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_socket_t sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Failed to set socket to nonblocking mode\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Failed to get socket flags\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock",
            "F_GETFL",
            "0"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Failed to set nonblocking io\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctlsocket",
          "args": [
            "sock",
            "FIONBIO",
            "&arg"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcachedprotocol-0.0/binary.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#include \"p9y/poll.hpp\"\n#include \"p9y/socket.hpp\"\n#include \"p9y/getopt.hpp\"\n#  include <unistd.h>\n#include <sys/types.h>\n#include <csignal>\n#include <ciso646>\n#include <cinttypes>\n#include <fcntl.h>\n#include <cctype>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cerrno>\n#include <cassert>\n#include \"mem_config.h\"\n\nstatic memcached_socket_t sock;\n\nstatic memcached_socket_t set_noblock(void) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(sock, FIONBIO, &arg) == SOCKET_ERROR) {\n    perror(\"Failed to set nonblocking io\");\n    closesocket(sock);\n    return INVALID_SOCKET;\n  }\n#else\n  int flags = fcntl(sock, F_GETFL, 0);\n  if (flags == -1) {\n    perror(\"Failed to get socket flags\");\n    closesocket(sock);\n    return INVALID_SOCKET;\n  }\n\n  if ((flags & O_NONBLOCK) != O_NONBLOCK) {\n    if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1) {\n      perror(\"Failed to set socket to nonblocking mode\");\n      closesocket(sock);\n      return INVALID_SOCKET;\n    }\n  }\n#endif\n  return sock;\n}"
  }
]