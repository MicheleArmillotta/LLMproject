[
  {
    "function_name": "is_shutting_down",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "280-282",
    "snippet": "bool memcached_instance_st::is_shutting_down() const {\n  return options.is_shutting_down;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  bool memcached_instance_st::is_shutting_down() const {\n    return options.is_shutting_down;\n  }\n}"
  },
  {
    "function_name": "valid",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "272-278",
    "snippet": "bool memcached_instance_st::valid() const {\n  if (fd == INVALID_SOCKET) {\n    return false;\n  }\n\n  return true;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  bool memcached_instance_st::valid() const {\n    if (fd == INVALID_SOCKET) {\n      return false;\n    }\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "memcached_instance_next_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "265-270",
    "snippet": "void memcached_instance_next_retry(const memcached_instance_st *self, const time_t absolute_time) {\n  WATCHPOINT_ASSERT(self);\n  if (self) {\n    ((memcached_instance_st *) self)->next_retry = absolute_time;\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "self"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_next_retry(const memcached_instance_st *self, const time_t absolute_time) {\n  WATCHPOINT_ASSERT(self);\n  if (self) {\n    ((memcached_instance_st *) self)->next_retry = absolute_time;\n  }\n}"
  },
  {
    "function_name": "set_last_disconnected_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "233-254",
    "snippet": "void set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_get_last_disconnect",
          "args": [
            "root"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_clone",
          "args": [
            "self"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_free",
          "args": [
            "(memcached_instance_st *) (root->last_disconnected_server)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "141-145",
          "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_get_last_disconnect",
          "args": [
            "self->root"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_get_last_disconnect",
          "args": [
            "self->root"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "self->root"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}"
  },
  {
    "function_name": "memcached_server_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "173-194",
    "snippet": "memcached_return_t memcached_server_execute(memcached_st *memc,\n                                            memcached_server_execute_fn callback, void *context) {\n  if (callback == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool some_errors = false;\n  ;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_return_t rc = (*callback)(memc, instance, context);\n    if (rc == MEMCACHED_INVALID_ARGUMENTS) {\n      return rc;\n    } else if (memcached_fatal(rc)) {\n      some_errors = true;\n    }\n  }\n\n  (void) some_errors;\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "memc",
            "instance",
            "context"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "x"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_list_count",
          "args": [
            "memc"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_execute(memcached_st *memc,\n                                            memcached_server_execute_fn callback, void *context) {\n  if (callback == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool some_errors = false;\n  ;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_return_t rc = (*callback)(memc, instance, context);\n    if (rc == MEMCACHED_INVALID_ARGUMENTS) {\n      return rc;\n    } else if (memcached_fatal(rc)) {\n      some_errors = true;\n    }\n  }\n\n  (void) some_errors;\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_server_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "147-171",
    "snippet": "memcached_return_t memcached_server_cursor(const memcached_st *shell,\n                                           const memcached_server_fn *callback, void *context,\n                                           uint32_t number_of_callbacks) {\n  const Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_const_query(memc))) {\n    return rc;\n  }\n\n  size_t errors = 0;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(memc, x);\n\n    for (uint32_t y = 0; y < number_of_callbacks; y++) {\n      memcached_return_t ret = (*callback[y])(memc, instance, context);\n\n      if (memcached_failed(ret)) {\n        errors++;\n        continue;\n      }\n    }\n  }\n\n  return errors ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "ret"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "memc",
            "instance",
            "context"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_by_position",
          "args": [
            "memc",
            "x"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_list_count",
          "args": [
            "memc"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_const_query(memc)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_const_query",
          "args": [
            "memc"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_const_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "41-51",
          "snippet": "memcached_return_t initialize_const_query(const Memcached *self) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return MEMCACHED_NO_SERVERS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_const_query(const Memcached *self) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return MEMCACHED_NO_SERVERS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_cursor(const memcached_st *shell,\n                                           const memcached_server_fn *callback, void *context,\n                                           uint32_t number_of_callbacks) {\n  const Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_const_query(memc))) {\n    return rc;\n  }\n\n  size_t errors = 0;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(memc, x);\n\n    for (uint32_t y = 0; y < number_of_callbacks; y++) {\n      memcached_return_t ret = (*callback[y])(memc, instance, context);\n\n      if (memcached_failed(ret)) {\n        errors++;\n        continue;\n      }\n    }\n  }\n\n  return errors ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_instance_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "141-145",
    "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instance_free",
          "args": [
            "self"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "141-145",
          "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}"
  },
  {
    "function_name": "instance_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "126-139",
    "snippet": "void instance_free(memcached_instance_st *self) {\n  memcached_quit_server(self, false);\n\n  self->clear_addrinfo();\n  assert(self->address_info_next == NULL);\n\n  memcached_error_free(*self);\n\n  if (memcached_is_allocated(self)) {\n    libmemcached_free(self->root, self);\n  } else {\n    self->options.is_initialized = false;\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "self->root",
            "self"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_allocated",
          "args": [
            "self"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_error_free",
          "args": [
            "*self"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "self->address_info_next == NULL"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->clear_addrinfo",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "clear_addrinfo",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "129-135",
          "snippet": "void clear_addrinfo() {\n    if (address_info) {\n      freeaddrinfo(address_info);\n      address_info = NULL;\n      address_info_next = NULL;\n    }\n  }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  void clear_addrinfo() {\n      if (address_info) {\n        freeaddrinfo(address_info);\n        address_info = NULL;\n        address_info_next = NULL;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "self",
            "false"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid instance_free(memcached_instance_st *self) {\n  memcached_quit_server(self, false);\n\n  self->clear_addrinfo();\n  assert(self->address_info_next == NULL);\n\n  memcached_error_free(*self);\n\n  if (memcached_is_allocated(self)) {\n    libmemcached_free(self->root, self);\n  } else {\n    self->options.is_initialized = false;\n  }\n}"
  },
  {
    "function_name": "revents",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "91-98",
    "snippet": "void memcached_instance_st::revents(short arg) {\n  if (arg) {\n    options.ready = true;\n  }\n\n  _revents = arg;\n  _events &= short(~arg);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "short",
          "args": [
            "~arg"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::revents(short arg) {\n    if (arg) {\n      options.ready = true;\n    }\n  \n    _revents = arg;\n    _events &= short(~arg);\n  }\n}"
  },
  {
    "function_name": "events",
    "container": "memcached_instance_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "83-89",
    "snippet": "void memcached_instance_st::events(short arg) {\n  if ((_events | arg) == _events) {\n    return;\n  }\n\n  _events |= arg;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::events(short arg) {\n    if ((_events | arg) == _events) {\n      return;\n    }\n  \n    _events |= arg;\n  }\n}"
  },
  {
    "function_name": "_server_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
    "lines": "18-62",
    "snippet": "static inline void _server_init(memcached_instance_st *self, Memcached *root,\n                                const memcached_string_t &hostname, in_port_t port, uint32_t weight,\n                                memcached_connection_t type) {\n  self->options.is_shutting_down = false;\n  self->options.is_dead = false;\n  self->options.ready = false;\n  self->_events = 0;\n  self->_revents = 0;\n  self->cursor_active_ = 0;\n  self->port_ = port;\n  self->fd = INVALID_SOCKET;\n  self->io_bytes_sent = 0;\n  self->request_id = 0;\n  self->server_failure_counter = 0;\n  self->server_failure_counter_query_id = 0;\n  self->server_timeout_counter = 0;\n  self->server_timeout_counter_query_id = 0;\n  self->weight = weight ? weight : 1; // 1 is the default weight value\n  self->io_wait_count.read = 0;\n  self->io_wait_count.write = 0;\n  self->io_wait_count.timeouts = 0;\n  self->io_wait_count._bytes_read = 0;\n  self->major_version = UINT8_MAX;\n  self->micro_version = UINT8_MAX;\n  self->minor_version = UINT8_MAX;\n  self->type = type;\n  self->error_messages = NULL;\n  self->read_ptr = self->read_buffer;\n  self->read_buffer_length = 0;\n  self->write_buffer_offset = 0;\n  self->address_info = NULL;\n  self->address_info_next = NULL;\n\n  self->state = MEMCACHED_SERVER_STATE_NEW;\n  self->next_retry = 0;\n\n  self->root = root;\n  if (root) {\n    self->version = ++root->server_info.version;\n  } else {\n    self->version = UINT_MAX;\n  }\n  self->limit_maxbytes = 0;\n  self->hostname(hostname);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "self->hostname",
          "args": [
            "hostname"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "hostname",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "81-89",
          "snippet": "void hostname(const memcached_string_t &hostname_) {\n    if (hostname_.size) {\n      memcpy(_hostname, hostname_.c_str, hostname_.size);\n      _hostname[hostname_.size] = 0;\n    } else {\n      memcpy(_hostname, memcached_literal_param(\"localhost\"));\n      _hostname[memcached_literal_param_size(\"localhost\")] = 0;\n    }\n  }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  void hostname(const memcached_string_t &hostname_) {\n      if (hostname_.size) {\n        memcpy(_hostname, hostname_.c_str, hostname_.size);\n        _hostname[hostname_.size] = 0;\n      } else {\n        memcpy(_hostname, memcached_literal_param(\"localhost\"));\n        _hostname[memcached_literal_param_size(\"localhost\")] = 0;\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline void _server_init(memcached_instance_st *self, Memcached *root,\n                                const memcached_string_t &hostname, in_port_t port, uint32_t weight,\n                                memcached_connection_t type) {\n  self->options.is_shutting_down = false;\n  self->options.is_dead = false;\n  self->options.ready = false;\n  self->_events = 0;\n  self->_revents = 0;\n  self->cursor_active_ = 0;\n  self->port_ = port;\n  self->fd = INVALID_SOCKET;\n  self->io_bytes_sent = 0;\n  self->request_id = 0;\n  self->server_failure_counter = 0;\n  self->server_failure_counter_query_id = 0;\n  self->server_timeout_counter = 0;\n  self->server_timeout_counter_query_id = 0;\n  self->weight = weight ? weight : 1; // 1 is the default weight value\n  self->io_wait_count.read = 0;\n  self->io_wait_count.write = 0;\n  self->io_wait_count.timeouts = 0;\n  self->io_wait_count._bytes_read = 0;\n  self->major_version = UINT8_MAX;\n  self->micro_version = UINT8_MAX;\n  self->minor_version = UINT8_MAX;\n  self->type = type;\n  self->error_messages = NULL;\n  self->read_ptr = self->read_buffer;\n  self->read_buffer_length = 0;\n  self->write_buffer_offset = 0;\n  self->address_info = NULL;\n  self->address_info_next = NULL;\n\n  self->state = MEMCACHED_SERVER_STATE_NEW;\n  self->next_retry = 0;\n\n  self->root = root;\n  if (root) {\n    self->version = ++root->server_info.version;\n  } else {\n    self->version = UINT_MAX;\n  }\n  self->limit_maxbytes = 0;\n  self->hostname(hostname);\n}"
  }
]