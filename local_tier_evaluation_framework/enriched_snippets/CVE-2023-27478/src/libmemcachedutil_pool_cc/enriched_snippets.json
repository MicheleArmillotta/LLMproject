[
  {
    "function_name": "memcached_pool_behavior_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "400-418",
    "snippet": "memcached_return_t memcached_pool_behavior_get(memcached_pool_st *pool, memcached_behavior_t flag,\n                                               uint64_t *value) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&pool->mutex))) {\n    return MEMCACHED_IN_PROGRESS;\n  }\n\n  *value = memcached_behavior_get(pool->master, flag);\n\n  if ((error = pthread_mutex_unlock(&pool->mutex))) {\n    assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_vmsg",
          "args": [
            "error",
            "\"pthread_mutex_unlock() %s\"",
            "strerror(error)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "error"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_get",
          "args": [
            "pool->master",
            "flag"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "288-482",
          "snippet": "uint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&pool->mutex"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_return_t memcached_pool_behavior_get(memcached_pool_st *pool, memcached_behavior_t flag,\n                                               uint64_t *value) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&pool->mutex))) {\n    return MEMCACHED_IN_PROGRESS;\n  }\n\n  *value = memcached_behavior_get(pool->master, flag);\n\n  if ((error = pthread_mutex_unlock(&pool->mutex))) {\n    assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_pool_behavior_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "353-398",
    "snippet": "memcached_return_t memcached_pool_behavior_set(memcached_pool_st *pool, memcached_behavior_t flag,\n                                               uint64_t data) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&pool->mutex))) {\n    return MEMCACHED_IN_PROGRESS;\n  }\n\n  /* update the master */\n  memcached_return_t rc = memcached_behavior_set(pool->master, flag, data);\n  if (memcached_failed(rc)) {\n    if ((error = pthread_mutex_unlock(&pool->mutex))) {\n      assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n    }\n    return rc;\n  }\n\n  pool->increment_version();\n  /* update the clones */\n  for (int xx = 0; xx <= pool->firstfree; ++xx) {\n    if (memcached_success(memcached_behavior_set(pool->server_pool[xx], flag, data))) {\n      pool->server_pool[xx]->configure.version = pool->version();\n    } else {\n      memcached_st *memc;\n      if ((memc = memcached_clone(NULL, pool->master))) {\n        memcached_free(pool->server_pool[xx]);\n        pool->server_pool[xx] = memc;\n        /* I'm not sure what to do in this case.. this would happen\n          if we fail to push the server list inside the client..\n          I should add a testcase for this, but I believe the following\n          would work, except that you would add a hole in the pool list..\n          in theory you could end up with an empty pool....\n        */\n      }\n    }\n  }\n\n  if ((error = pthread_mutex_unlock(&pool->mutex))) {\n    assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_vmsg",
          "args": [
            "error",
            "\"pthread_mutex_unlock() %s\"",
            "strerror(error)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "error"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "pool->server_pool[xx]"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_clone",
          "args": [
            "NULL",
            "pool->master"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_clone_sasl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "470-472",
          "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pool->version",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "version",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "89-91",
          "snippet": "int32_t version() const {\n    return master->configure.version;\n  }",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  int32_t version() const {\n      return master->configure.version;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "memcached_behavior_set(pool->server_pool[xx], flag, data)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "pool->server_pool[xx]",
            "flag",
            "data"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pool->increment_version",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "increment_version",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "81-83",
          "snippet": "void increment_version() {\n    ++master->configure.version;\n  }",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  void increment_version() {\n      ++master->configure.version;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_vmsg",
          "args": [
            "error",
            "\"pthread_mutex_unlock() %s\"",
            "strerror(error)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "error"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&pool->mutex"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_return_t memcached_pool_behavior_set(memcached_pool_st *pool, memcached_behavior_t flag,\n                                               uint64_t data) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&pool->mutex))) {\n    return MEMCACHED_IN_PROGRESS;\n  }\n\n  /* update the master */\n  memcached_return_t rc = memcached_behavior_set(pool->master, flag, data);\n  if (memcached_failed(rc)) {\n    if ((error = pthread_mutex_unlock(&pool->mutex))) {\n      assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n    }\n    return rc;\n  }\n\n  pool->increment_version();\n  /* update the clones */\n  for (int xx = 0; xx <= pool->firstfree; ++xx) {\n    if (memcached_success(memcached_behavior_set(pool->server_pool[xx], flag, data))) {\n      pool->server_pool[xx]->configure.version = pool->version();\n    } else {\n      memcached_st *memc;\n      if ((memc = memcached_clone(NULL, pool->master))) {\n        memcached_free(pool->server_pool[xx]);\n        pool->server_pool[xx] = memc;\n        /* I'm not sure what to do in this case.. this would happen\n          if we fail to push the server list inside the client..\n          I should add a testcase for this, but I believe the following\n          would work, except that you would add a hole in the pool list..\n          in theory you could end up with an empty pool....\n        */\n      }\n    }\n  }\n\n  if ((error = pthread_mutex_unlock(&pool->mutex))) {\n    assert_vmsg(error, \"pthread_mutex_unlock() %s\", strerror(error));\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_pool_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "349-351",
    "snippet": "memcached_return_t memcached_pool_push(memcached_pool_st *pool, memcached_st *released) {\n  return memcached_pool_release(pool, released);\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_pool_release",
          "args": [
            "pool",
            "released"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_pool_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "337-347",
          "snippet": "memcached_return_t memcached_pool_release(memcached_pool_st *pool, memcached_st *released) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n\n  (void) pool->release(released, rc);\n\n  return rc;\n}",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_return_t memcached_pool_release(memcached_pool_st *pool, memcached_st *released) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n\n  (void) pool->release(released, rc);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_return_t memcached_pool_push(memcached_pool_st *pool, memcached_st *released) {\n  return memcached_pool_release(pool, released);\n}"
  },
  {
    "function_name": "memcached_pool_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "337-347",
    "snippet": "memcached_return_t memcached_pool_release(memcached_pool_st *pool, memcached_st *released) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n\n  (void) pool->release(released, rc);\n\n  return rc;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pool->release",
          "args": [
            "released",
            "rc"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "release",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "259-297",
          "snippet": "bool memcached_pool_st::release(memcached_st *released, memcached_return_t &rc) {\n  rc = MEMCACHED_SUCCESS;\n  if (released == NULL) {\n    rc = MEMCACHED_INVALID_ARGUMENTS;\n    return false;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&mutex))) {\n    rc = MEMCACHED_IN_PROGRESS;\n    return false;\n  }\n\n  /*\n    Someone updated the behavior on the object, so we clone a new memcached_st with the new\n    settings. If we fail to clone, we keep the old one around.\n  */\n  if (compare_version(released) == false) {\n    memcached_st *memc;\n    if ((memc = memcached_clone(NULL, master))) {\n      memcached_free(released);\n      released = memc;\n    }\n  }\n\n  server_pool[++firstfree] = released;\n\n  if (firstfree == 0 and current_size == size) {\n    /* we might have people waiting for a connection.. wake them up :-) */\n    if ((error = pthread_cond_broadcast(&cond))) {\n      assert_vmsg(error, \"pthread_cond_broadcast() %s\", strerror(error));\n    }\n  }\n\n  if ((error = pthread_mutex_unlock(&mutex))) {\n  }\n\n  return true;\n}",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  bool memcached_pool_st::release(memcached_st *released, memcached_return_t &rc) {\n    rc = MEMCACHED_SUCCESS;\n    if (released == NULL) {\n      rc = MEMCACHED_INVALID_ARGUMENTS;\n      return false;\n    }\n  \n    int error;\n    if ((error = pthread_mutex_lock(&mutex))) {\n      rc = MEMCACHED_IN_PROGRESS;\n      return false;\n    }\n  \n    /*\n      Someone updated the behavior on the object, so we clone a new memcached_st with the new\n      settings. If we fail to clone, we keep the old one around.\n    */\n    if (compare_version(released) == false) {\n      memcached_st *memc;\n      if ((memc = memcached_clone(NULL, master))) {\n        memcached_free(released);\n        released = memc;\n      }\n    }\n  \n    server_pool[++firstfree] = released;\n  \n    if (firstfree == 0 and current_size == size) {\n      /* we might have people waiting for a connection.. wake them up :-) */\n      if ((error = pthread_cond_broadcast(&cond))) {\n        assert_vmsg(error, \"pthread_cond_broadcast() %s\", strerror(error));\n      }\n    }\n  \n    if ((error = pthread_mutex_unlock(&mutex))) {\n    }\n  \n    return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_return_t memcached_pool_release(memcached_pool_st *pool, memcached_st *released) {\n  if (pool == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n\n  (void) pool->release(released, rc);\n\n  return rc;\n}"
  },
  {
    "function_name": "release",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "259-297",
    "snippet": "bool memcached_pool_st::release(memcached_st *released, memcached_return_t &rc) {\n  rc = MEMCACHED_SUCCESS;\n  if (released == NULL) {\n    rc = MEMCACHED_INVALID_ARGUMENTS;\n    return false;\n  }\n\n  int error;\n  if ((error = pthread_mutex_lock(&mutex))) {\n    rc = MEMCACHED_IN_PROGRESS;\n    return false;\n  }\n\n  /*\n    Someone updated the behavior on the object, so we clone a new memcached_st with the new\n    settings. If we fail to clone, we keep the old one around.\n  */\n  if (compare_version(released) == false) {\n    memcached_st *memc;\n    if ((memc = memcached_clone(NULL, master))) {\n      memcached_free(released);\n      released = memc;\n    }\n  }\n\n  server_pool[++firstfree] = released;\n\n  if (firstfree == 0 and current_size == size) {\n    /* we might have people waiting for a connection.. wake them up :-) */\n    if ((error = pthread_cond_broadcast(&cond))) {\n      assert_vmsg(error, \"pthread_cond_broadcast() %s\", strerror(error));\n    }\n  }\n\n  if ((error = pthread_mutex_unlock(&mutex))) {\n  }\n\n  return true;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_vmsg",
          "args": [
            "error",
            "\"pthread_cond_broadcast() %s\"",
            "strerror(error)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "error"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_broadcast",
          "args": [
            "&cond"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "released"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_clone",
          "args": [
            "NULL",
            "master"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_clone_sasl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "470-472",
          "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_version",
          "args": [
            "released"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "compare_version",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "85-87",
          "snippet": "bool compare_version(const memcached_st *arg) const {\n    return (arg->configure.version == version());\n  }",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  bool compare_version(const memcached_st *arg) const {\n      return (arg->configure.version == version());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&mutex"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  bool memcached_pool_st::release(memcached_st *released, memcached_return_t &rc) {\n    rc = MEMCACHED_SUCCESS;\n    if (released == NULL) {\n      rc = MEMCACHED_INVALID_ARGUMENTS;\n      return false;\n    }\n  \n    int error;\n    if ((error = pthread_mutex_lock(&mutex))) {\n      rc = MEMCACHED_IN_PROGRESS;\n      return false;\n    }\n  \n    /*\n      Someone updated the behavior on the object, so we clone a new memcached_st with the new\n      settings. If we fail to clone, we keep the old one around.\n    */\n    if (compare_version(released) == false) {\n      memcached_st *memc;\n      if ((memc = memcached_clone(NULL, master))) {\n        memcached_free(released);\n        released = memc;\n      }\n    }\n  \n    server_pool[++firstfree] = released;\n  \n    if (firstfree == 0 and current_size == size) {\n      /* we might have people waiting for a connection.. wake them up :-) */\n      if ((error = pthread_cond_broadcast(&cond))) {\n        assert_vmsg(error, \"pthread_cond_broadcast() %s\", strerror(error));\n      }\n    }\n  \n    if ((error = pthread_mutex_unlock(&mutex))) {\n    }\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "init",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "113-130",
    "snippet": "bool memcached_pool_st::init(uint32_t initial) {\n  server_pool = new (std::nothrow) memcached_st *[size];\n  if (server_pool == NULL) {\n    return false;\n  }\n\n  /*\n    Try to create the initial size of the pool. An allocation failure at\n    this time is not fatal..\n  */\n  for (unsigned int x = 0; x < initial; ++x) {\n    if (grow_pool(this) == false) {\n      break;\n    }\n  }\n\n  return true;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow_pool",
          "args": [
            "this"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "grow_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "98-111",
          "snippet": "static bool grow_pool(memcached_pool_st *pool) {\n  assert(pool);\n\n  memcached_st *obj;\n  if (not(obj = memcached_clone(NULL, pool->master))) {\n    return false;\n  }\n\n  pool->server_pool[++pool->firstfree] = obj;\n  pool->current_size++;\n  obj->configure.version = pool->version();\n\n  return true;\n}",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nstatic bool grow_pool(memcached_pool_st *pool) {\n  assert(pool);\n\n  memcached_st *obj;\n  if (not(obj = memcached_clone(NULL, pool->master))) {\n    return false;\n  }\n\n  pool->server_pool[++pool->firstfree] = obj;\n  pool->current_size++;\n  obj->configure.version = pool->version();\n\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  bool memcached_pool_st::init(uint32_t initial) {\n    server_pool = new (std::nothrow) memcached_st *[size];\n    if (server_pool == NULL) {\n      return false;\n    }\n  \n    /*\n      Try to create the initial size of the pool. An allocation failure at\n      this time is not fatal..\n    */\n    for (unsigned int x = 0; x < initial; ++x) {\n      if (grow_pool(this) == false) {\n        break;\n      }\n    }\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "grow_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "98-111",
    "snippet": "static bool grow_pool(memcached_pool_st *pool) {\n  assert(pool);\n\n  memcached_st *obj;\n  if (not(obj = memcached_clone(NULL, pool->master))) {\n    return false;\n  }\n\n  pool->server_pool[++pool->firstfree] = obj;\n  pool->current_size++;\n  obj->configure.version = pool->version();\n\n  return true;\n}",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pool->version",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "version",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "89-91",
          "snippet": "int32_t version() const {\n    return master->configure.version;\n  }",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  int32_t version() const {\n      return master->configure.version;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_clone",
          "args": [
            "NULL",
            "pool->master"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_clone_sasl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "470-472",
          "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pool"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nstatic bool grow_pool(memcached_pool_st *pool) {\n  assert(pool);\n\n  memcached_st *obj;\n  if (not(obj = memcached_clone(NULL, pool->master))) {\n    return false;\n  }\n\n  pool->server_pool[++pool->firstfree] = obj;\n  pool->current_size++;\n  obj->configure.version = pool->version();\n\n  return true;\n}"
  },
  {
    "function_name": "version",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "89-91",
    "snippet": "int32_t version() const {\n    return master->configure.version;\n  }",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  int32_t version() const {\n      return master->configure.version;\n    }\n}"
  },
  {
    "function_name": "compare_version",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "85-87",
    "snippet": "bool compare_version(const memcached_st *arg) const {\n    return (arg->configure.version == version());\n  }",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "version",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "version",
          "container": "memcached_pool_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
          "lines": "89-91",
          "snippet": "int32_t version() const {\n    return master->configure.version;\n  }",
          "includes": [
            "#include <memory>",
            "#include <pthread.h>",
            "#include <ctime>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include <cassert>",
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  int32_t version() const {\n      return master->configure.version;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  bool compare_version(const memcached_st *arg) const {\n      return (arg->configure.version == version());\n    }\n}"
  },
  {
    "function_name": "increment_version",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "81-83",
    "snippet": "void increment_version() {\n    ++master->configure.version;\n  }",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  void increment_version() {\n      ++master->configure.version;\n    }\n}"
  },
  {
    "function_name": "memcached_pool_st",
    "container": "memcached_pool_st",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/pool.cc",
    "lines": "36-47",
    "snippet": "memcached_pool_st(memcached_st *master_arg, size_t max_arg)\n  : master(master_arg)\n  , server_pool(NULL)\n  , firstfree(-1)\n  , size(uint32_t(max_arg))\n  , current_size(0)\n  , _owns_master(false) {\n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond, NULL);\n    _timeout.tv_sec = 5;\n    _timeout.tv_nsec = 0;\n  }",
    "includes": [
      "#include <memory>",
      "#include <pthread.h>",
      "#include <ctime>",
      "#include <cstring>",
      "#include <cerrno>",
      "#include <cassert>",
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_cond_init",
          "args": [
            "&cond",
            "NULL"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&mutex",
            "NULL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "max_arg"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <pthread.h>\n#include <ctime>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include \"libmemcachedutil/common.h\"\n\nmemcached_pool_st {\n  memcached_pool_st(memcached_st *master_arg, size_t max_arg)\n    : master(master_arg)\n    , server_pool(NULL)\n    , firstfree(-1)\n    , size(uint32_t(max_arg))\n    , current_size(0)\n    , _owns_master(false) {\n      pthread_mutex_init(&mutex, NULL);\n      pthread_cond_init(&cond, NULL);\n      _timeout.tv_sec = 5;\n      _timeout.tv_nsec = 0;\n    }\n}"
  }
]